[
  {
    "url": "https://angular.dev/overview",
    "title": "What is Angular? • Angular",
    "chunk": "Introduction What is Angular? Angular is a web framework that empowers developers to build fast, reliable applications. Maintained by a dedicated team at Google, Angular provides a broad suite of tools, APIs, and libraries to simplify and streamline your development workflow. Angular gives you a solid platform on which to build fast, reliable applications that scale with both the size of your team and the size of your codebase. Want to see some code? Jump over to our Essentials for a quick overv",
    "id": "what-is-angular-*-angular-0"
  },
  {
    "url": "https://angular.dev/overview",
    "title": "What is Angular? • Angular",
    "chunk": "iew of what it's like to use Angular, or get started in the Tutorial if you prefer following step-by-step instructions. On this pagearrow_upward_alt Back to the top Features that power your development Keep your codebase organized with an opinionated component model and flexible dependency injection system Angular components make it easy to split your code into well-encapsulated parts. The versatile dependency injection helps you keep your code modular, loosely-coupled, and testable. Get started",
    "id": "what-is-angular-*-angular-1"
  },
  {
    "url": "https://angular.dev/overview",
    "title": "What is Angular? • Angular",
    "chunk": " with Components Get fast state updates with fine-grained reactivity based on Signals Our fine-grained reactivity model, combined with compile-time optimizations, simplifies development and helps build faster apps by default. Granularly track how and where state is used throughout an application, giving the framework the power to render fast updates via highly optimized instructions. Explore Angular Signals Meet your performance targets with SSR, SSG, hydration, and next-generation deferred load",
    "id": "what-is-angular-*-angular-2"
  },
  {
    "url": "https://angular.dev/overview",
    "title": "What is Angular? • Angular",
    "chunk": "ing Angular supports both server-side rendering (SSR) and static site generation (SSG) along with full DOM hydration. @defer blocks in templates make it simple to declaratively divide your templates into lazy-loadable parts. Read about SSR Guarantee everything works together with Angular's first-party modules for forms, routing, and more Angular's router provides a feature-rich navigation toolkit, including support for route guards, data resolution, lazy-loading, and much more. Angular's forms m",
    "id": "what-is-angular-*-angular-3"
  },
  {
    "url": "https://angular.dev/overview",
    "title": "What is Angular? • Angular",
    "chunk": "odule provides a standardized system for form participation and validation. Develop applications faster than ever Effortlessly build, serve, test, deploy with Angular CLI Angular CLI gets your project running in under a minute with the commands you need to grow into a deployed production application. Angular CLI Visually debug, analyze, and optimize your code with the Angular DevTools browser extension Angular DevTools sits alongside your browser's developer tools. It helps debug and analyze you",
    "id": "what-is-angular-*-angular-4"
  },
  {
    "url": "https://angular.dev/overview",
    "title": "What is Angular? • Angular",
    "chunk": "r app, including a component tree inspector, dependency injection tree view, and custom performance profiling flame chart. Angular DevTools Never miss a version with ng update Angular CLI's ng update runs automated code transformations that automatically handle routine breaking changes, dramatically simplifying major version updates. Keeping up with the latest version keeps your app as fast and secure as possible. ng update Stay productive with IDE integration in your favorite editor Angular's I",
    "id": "what-is-angular-*-angular-5"
  },
  {
    "url": "https://angular.dev/overview",
    "title": "What is Angular? • Angular",
    "chunk": "DE language services powers code completion, navigation, refactoring, and real-time diagnostics in your favorite editor. Language service Ship with confidence Verified commit-by-commit against Google's colossal monorepo Every Angular commit is checked against hundreds of thousands of tests in Google's internal code repository, representing countless real-world scenarios. Angular is committed to stability for some of Google’s largest products, including Google Cloud. This commitment ensures chang",
    "id": "what-is-angular-*-angular-6"
  },
  {
    "url": "https://angular.dev/overview",
    "title": "What is Angular? • Angular",
    "chunk": "es are well-tested, backwards compatible, and include migration tools whenever possible. Learn about Google's monorepo Clear support policies and predictable release schedule Angular's predictable, time-based release schedule gives your organization confidence in the stability and backwards compatibility of the framework. Long Term Support (LTS) windows make sure you get critical security fixes when you need them. First-party update tools, guides and automated migration schematics help keep your",
    "id": "what-is-angular-*-angular-7"
  },
  {
    "url": "https://angular.dev/overview",
    "title": "What is Angular? • Angular",
    "chunk": " apps up-to-date with the latest advancements to the framework and the web platform. Versioning & releasing Works at any scale Reach users everywhere with internationalization support Angular's internationalization features handle message translations and formatting, including support for unicode standard ICU syntax. Internationalization Protect your users with security by default In collaboration with Google's world-class security engineers, Angular aims to make development safe by default. Bui",
    "id": "what-is-angular-*-angular-8"
  },
  {
    "url": "https://angular.dev/overview",
    "title": "What is Angular? • Angular",
    "chunk": "lt-in security features, including HTML sanitization and trusted type support, help protect your users from common vulnerabilities like cross-site scripting and cross-site request forgery. Security Keep large teams productive with Vite and esbuild Angular CLI includes a fast, modern build pipeline using Vite and ESBuild. Developers report building projects with hundreds of thousands of lines of code in less than a minute. ESBuild and Vite Proven in some of Google's largest web apps Large Google ",
    "id": "what-is-angular-*-angular-9"
  },
  {
    "url": "https://angular.dev/overview",
    "title": "What is Angular? • Angular",
    "chunk": "products build on top of Angular's architecture and help develop new features that further improve Angular's scalability, from Google Fonts to Google Cloud. Open-source first Made in the open on GitHub Curious what we’re working on? Every PR and commit is available on our GitHub. Run into an issue or bug? We triage GitHub issues regularly to ensure we’re responsive and engaged with our community, and solving the real world problems you’re facing. Star our GitHub Built with transparency Our team ",
    "id": "what-is-angular-*-angular-10"
  },
  {
    "url": "https://angular.dev/overview",
    "title": "What is Angular? • Angular",
    "chunk": "publishes a public roadmap of our current and future work and values your feedback. We publish Request for Comments (RFCs) to collect feedback on larger feature changes and ensure the community voice is heard while shaping the future direction of Angular. Read our public roadmap A thriving community Courses, blogs and resources Our community is composed of talented developers, writers, instructors, podcasters, and more. The Google for Developers library is just a sample of the high quality resou",
    "id": "what-is-angular-*-angular-11"
  },
  {
    "url": "https://angular.dev/overview",
    "title": "What is Angular? • Angular",
    "chunk": "rces available for new and experienced developers to continue developing. Check out DevLibrary Open Source We are thankful for the open source contributors who make Angular a better framework for everyone. From fixing a typo in the docs, to adding major features, we encourage anyone interested to get started on our GitHub. Contribute to Angular Community partnerships Our team partners with individuals, educators, and enterprises to ensure we consistently are supporting developers. Angular Google",
    "id": "what-is-angular-*-angular-12"
  },
  {
    "url": "https://angular.dev/overview",
    "title": "What is Angular? • Angular",
    "chunk": " Developer Experts (GDEs) represent community leaders around the world educating, organizing, and developing with Angular. Enterprise partnerships help ensure that Angular scales well for technology industry leaders. Meet the Angular GDEs Partnering with other Google technologies Angular partners closely with other Google technologies and teams to improve the web. Our ongoing partnership with Chrome’s Aurora actively explores improvements to user experience across the web, developing built-in pe",
    "id": "what-is-angular-*-angular-13"
  },
  {
    "url": "https://angular.dev/overview",
    "title": "What is Angular? • Angular",
    "chunk": "rformance optimizations like NgOptimizedImage and improvements to Angular’s Core Web Vitals. We are also working with Firebase, Tensorflow, Flutter, Material Design, and Google Cloud to ensure we provide meaningful integrations across the developer workflow. Join the momentum! Read Angular's roadmap Try out our playground Learn with tutorials Watch our YouTube course Reference our APIs Social MediaBlogX (formerly Twitter)BlueskyYouTube Discord GitHub Stack Overflow Community Contribute Code of C",
    "id": "what-is-angular-*-angular-14"
  },
  {
    "url": "https://angular.dev/overview",
    "title": "What is Angular? • Angular",
    "chunk": "onduct Report Issues Google's DevLibrary Angular Google Developer Experts ResourcesPress KitRoadmapLanguages简体中文版正體中文版日本語版한국어 Ελληνικά Super-powered by Google ©2010-2025. Code licensed under an MIT-style License . Documentation licensed under CC BY 4.0 . Introduction What is Angular?",
    "id": "what-is-angular-*-angular-15"
  },
  {
    "url": "https://angular.dev/installation",
    "title": "Installation • Angular",
    "chunk": "Introduction Installation Get started with Angular quickly with online starters or locally with your terminal. On this pagearrow_upward_alt Back to the top Play Online If you just want to play around with Angular in your browser without setting up a project, you can use our online sandbox: The fastest way to play with an Angular app. No setup required. Open on Playground Set up a new project locally If you're starting a new project, you'll most likely want to create a local project so that you c",
    "id": "installation-*-angular-0"
  },
  {
    "url": "https://angular.dev/installation",
    "title": "Installation • Angular",
    "chunk": "an use tooling such as Git. Prerequisites Node.js - v20.11.1 or newer Text editor - We recommend Visual Studio Code Terminal - Required for running Angular CLI commands Development Tool - To improve your development workflow, we recommend the Angular Language Service Instructions The following guide will walk you through setting up a local Angular project. Install Angular CLI Open a terminal (if you're using Visual Studio Code, you can open an integrated terminal) and run the following command: ",
    "id": "installation-*-angular-1"
  },
  {
    "url": "https://angular.dev/installation",
    "title": "Installation • Angular",
    "chunk": "npm npm install -g @angular/cli pnpm pnpm install -g @angular/cli yarn yarn global add @angular/cli bun bun install -g @angular/cli If you are having issues running this command in Windows or Unix, check out the CLI docs for more info. Create a new project In your terminal, run the CLI command ng new with the desired project name. In the following examples, we'll be using the example project name of my-first-angular-app. ng new <project-name> You will be presented with some configuration options",
    "id": "installation-*-angular-2"
  },
  {
    "url": "https://angular.dev/installation",
    "title": "Installation • Angular",
    "chunk": " for your project. Use the arrow and enter keys to navigate and select which options you desire. If you don't have any preferences, just hit the enter key to take the default options and continue with the setup. After you select the configuration options and the CLI runs through the setup, you should see the following message: ✔ Packages installed successfully. Successfully initialized git. At this point, you're now ready to run your project locally! Running your new project locally In your term",
    "id": "installation-*-angular-3"
  },
  {
    "url": "https://angular.dev/installation",
    "title": "Installation • Angular",
    "chunk": "inal, switch to your new Angular project. cd my-first-angular-app All of your dependencies should be installed at this point (which you can verify by checking for the existent for a node_modules folder in your project), so you can start your project by running the command: npm start If everything is successful, you should see a similar confirmation message in your terminal: Watch mode enabled. Watching for file changes...NOTE: Raw file sizes do not reflect development server per-request transfor",
    "id": "installation-*-angular-4"
  },
  {
    "url": "https://angular.dev/installation",
    "title": "Installation • Angular",
    "chunk": "mations. ➜ Local: http://localhost:4200/ ➜ press h + enter to show help And now you can visit the path in Local (e.g., http://localhost:4200) to see your application. Happy coding! 🎉 Next steps Now that you've created your Angular project, you can learn more about Angular in our Essentials guide or choose a topic in our in-depth guides! Social MediaBlogX (formerly Twitter)BlueskyYouTube Discord GitHub Stack Overflow Community Contribute Code of Conduct Report Issues Google's DevLibrary Angular ",
    "id": "installation-*-angular-5"
  },
  {
    "url": "https://angular.dev/installation",
    "title": "Installation • Angular",
    "chunk": "Google Developer Experts ResourcesPress KitRoadmapLanguages简体中文版正體中文版日本語版한국어 Ελληνικά Super-powered by Google ©2010-2025. Code licensed under an MIT-style License . Documentation licensed under CC BY 4.0 . Introduction Installation",
    "id": "installation-*-angular-6"
  },
  {
    "url": "https://angular.dev/guide/components",
    "title": "Anatomy of components • Angular",
    "chunk": "In-depth GuidesComponents Anatomy of a component TIP: This guide assumes you've already read the Essentials Guide. Read that first if you're new to Angular. Every component must have: A TypeScript class with behaviors such as handling user input and fetching data from a server An HTML template that controls what renders into the DOM A CSS selector that defines how the component is used in HTML You provide Angular-specific information for a component by adding a @Component decorator on top of the",
    "id": "anatomy-of-components-*-angular-0"
  },
  {
    "url": "https://angular.dev/guide/components",
    "title": "Anatomy of components • Angular",
    "chunk": " TypeScript class: @Component({ selector: 'profile-photo', template: `<img src=\"profile-photo.jpg\" alt=\"Your profile photo\">`,})export class ProfilePhoto { } For full details on writing Angular templates, including data binding, event handling, and control flow, see the Templates guide. The object passed to the @Component decorator is called the component's metadata. This includes the selector, template, and other properties described throughout this guide. Components can optionally include a li",
    "id": "anatomy-of-components-*-angular-1"
  },
  {
    "url": "https://angular.dev/guide/components",
    "title": "Anatomy of components • Angular",
    "chunk": "st of CSS styles that apply to that component's DOM: @Component({ selector: 'profile-photo', template: `<img src=\"profile-photo.jpg\" alt=\"Your profile photo\">`, styles: `img { border-radius: 50%; }`,})export class ProfilePhoto { } By default, a component's styles only affect elements defined in that component's template. See Styling Components for details on Angular's approach to styling. You can alternatively choose to write your template and styles in separate files: @Component({ selector: 'pr",
    "id": "anatomy-of-components-*-angular-2"
  },
  {
    "url": "https://angular.dev/guide/components",
    "title": "Anatomy of components • Angular",
    "chunk": "ofile-photo', templateUrl: 'profile-photo.html', styleUrl: 'profile-photo.css',})export class ProfilePhoto { } This can help separate the concerns of presentation from behavior in your project. You can choose one approach for your entire project, or you decide which to use for each component. Both templateUrl and styleUrl are relative to the directory in which the component resides. On this pagearrow_upward_alt Back to the top Using components Imports in the @Component decorator To use a compone",
    "id": "anatomy-of-components-*-angular-3"
  },
  {
    "url": "https://angular.dev/guide/components",
    "title": "Anatomy of components • Angular",
    "chunk": "nt, directive, or pipe, you must add it to the imports array in the @Component decorator: import {ProfilePhoto} from './profile-photo';@Component({ // Import the `ProfilePhoto` component in // order to use it in this component's template. imports: [ProfilePhoto], /* ... */})export class UserProfile { } By default, Angular components are standalone, meaning that you can directly add them to the imports array of other components. Components created with an earlier version of Angular may instead sp",
    "id": "anatomy-of-components-*-angular-4"
  },
  {
    "url": "https://angular.dev/guide/components",
    "title": "Anatomy of components • Angular",
    "chunk": "ecify standalone: false in their @Component decorator. For these components, you instead import the NgModule in which the component is defined. See the full NgModule guide for details. Important: In Angular versions before 19.0.0, the standalone option defaults to false. Showing components in a template Every component defines a CSS selector: @Component({ selector: 'profile-photo', ...})export class ProfilePhoto { } See Component Selectors for details about which types of selectors Angular suppo",
    "id": "anatomy-of-components-*-angular-5"
  },
  {
    "url": "https://angular.dev/guide/components",
    "title": "Anatomy of components • Angular",
    "chunk": "rts and guidance on choosing a selector. You show a component by creating a matching HTML element in the template of other components: @Component({ selector: 'profile-photo',})export class ProfilePhoto { }@Component({ imports: [ProfilePhoto], template: `<profile-photo />`})export class UserProfile { } Angular creates an instance of the component for every matching HTML element it encounters. The DOM element that matches a component's selector is referred to as that component's host element. The ",
    "id": "anatomy-of-components-*-angular-6"
  },
  {
    "url": "https://angular.dev/guide/components",
    "title": "Anatomy of components • Angular",
    "chunk": "contents of a component's template are rendered inside its host element. The DOM rendered by a component, corresponding to that component's template, is called that component's view. In composing components in this way, you can think of your Angular application as a tree of components. #mermaid-generated-diagram{font-family:\"trebuchet ms\",verdana,arial,sans-serif;font-size:16px;fill:#333;}@keyframes edge-animation-frame{from{stroke-dashoffset:0;}}@keyframes dash{to{stroke-dashoffset:0;}}#mermaid",
    "id": "anatomy-of-components-*-angular-7"
  },
  {
    "url": "https://angular.dev/guide/components",
    "title": "Anatomy of components • Angular",
    "chunk": "-generated-diagram .edge-animation-slow{stroke-dasharray:9,5!important;stroke-dashoffset:900;animation:dash 50s linear infinite;stroke-linecap:round;}#mermaid-generated-diagram .edge-animation-fast{stroke-dasharray:9,5!important;stroke-dashoffset:900;animation:dash 20s linear infinite;stroke-linecap:round;}#mermaid-generated-diagram .error-icon{fill:hsl(220.5882352941, 100%, 98.3333333333%);}#mermaid-generated-diagram .error-text{fill:rgb(8.5000000002, 5.7500000001, 0);stroke:rgb(8.5000000002, 5",
    "id": "anatomy-of-components-*-angular-8"
  },
  {
    "url": "https://angular.dev/guide/components",
    "title": "Anatomy of components • Angular",
    "chunk": ".7500000001, 0);}#mermaid-generated-diagram .edge-thickness-normal{stroke-width:1px;}#mermaid-generated-diagram .edge-thickness-thick{stroke-width:3.5px;}#mermaid-generated-diagram .edge-pattern-solid{stroke-dasharray:0;}#mermaid-generated-diagram .edge-thickness-invisible{stroke-width:0;fill:none;}#mermaid-generated-diagram .edge-pattern-dashed{stroke-dasharray:3;}#mermaid-generated-diagram .edge-pattern-dotted{stroke-dasharray:2;}#mermaid-generated-diagram .marker{fill:#0b0b0b;stroke:#0b0b0b;}",
    "id": "anatomy-of-components-*-angular-9"
  },
  {
    "url": "https://angular.dev/guide/components",
    "title": "Anatomy of components • Angular",
    "chunk": "#mermaid-generated-diagram .marker.cross{stroke:#0b0b0b;}#mermaid-generated-diagram svg{font-family:\"trebuchet ms\",verdana,arial,sans-serif;font-size:16px;}#mermaid-generated-diagram p{margin:0;}#mermaid-generated-diagram .label{font-family:\"trebuchet ms\",verdana,arial,sans-serif;color:#333;}#mermaid-generated-diagram .cluster-label text{fill:rgb(8.5000000002, 5.7500000001, 0);}#mermaid-generated-diagram .cluster-label span{color:rgb(8.5000000002, 5.7500000001, 0);}#mermaid-generated-diagram .cl",
    "id": "anatomy-of-components-*-angular-10"
  },
  {
    "url": "https://angular.dev/guide/components",
    "title": "Anatomy of components • Angular",
    "chunk": "uster-label span p{background-color:transparent;}#mermaid-generated-diagram .label text,#mermaid-generated-diagram span{fill:#333;color:#333;}#mermaid-generated-diagram .node rect,#mermaid-generated-diagram .node circle,#mermaid-generated-diagram .node ellipse,#mermaid-generated-diagram .node polygon,#mermaid-generated-diagram .node path{fill:#fff4dd;stroke:hsl(40.5882352941, 60%, 83.3333333333%);stroke-width:1px;}#mermaid-generated-diagram .rough-node .label text,#mermaid-generated-diagram .nod",
    "id": "anatomy-of-components-*-angular-11"
  },
  {
    "url": "https://angular.dev/guide/components",
    "title": "Anatomy of components • Angular",
    "chunk": "e .label text,#mermaid-generated-diagram .image-shape .label,#mermaid-generated-diagram .icon-shape .label{text-anchor:middle;}#mermaid-generated-diagram .node .katex path{fill:#000;stroke:#000;stroke-width:1px;}#mermaid-generated-diagram .rough-node .label,#mermaid-generated-diagram .node .label,#mermaid-generated-diagram .image-shape .label,#mermaid-generated-diagram .icon-shape .label{text-align:center;}#mermaid-generated-diagram .node.clickable{cursor:pointer;}#mermaid-generated-diagram .roo",
    "id": "anatomy-of-components-*-angular-12"
  },
  {
    "url": "https://angular.dev/guide/components",
    "title": "Anatomy of components • Angular",
    "chunk": "t .anchor path{fill:#0b0b0b!important;stroke-width:0;stroke:#0b0b0b;}#mermaid-generated-diagram .arrowheadPath{fill:#0b0b0b;}#mermaid-generated-diagram .edgePath .path{stroke:#0b0b0b;stroke-width:2.0px;}#mermaid-generated-diagram .flowchart-link{stroke:#0b0b0b;fill:none;}#mermaid-generated-diagram .edgeLabel{background-color:hsl(-79.4117647059, 100%, 93.3333333333%);text-align:center;}#mermaid-generated-diagram .edgeLabel p{background-color:hsl(-79.4117647059, 100%, 93.3333333333%);}#mermaid-gen",
    "id": "anatomy-of-components-*-angular-13"
  },
  {
    "url": "https://angular.dev/guide/components",
    "title": "Anatomy of components • Angular",
    "chunk": "erated-diagram .edgeLabel rect{opacity:0.5;background-color:hsl(-79.4117647059, 100%, 93.3333333333%);fill:hsl(-79.4117647059, 100%, 93.3333333333%);}#mermaid-generated-diagram .labelBkg{background-color:rgba(243.9999999999, 220.9999999998, 255, 0.5);}#mermaid-generated-diagram .cluster rect{fill:hsl(220.5882352941, 100%, 98.3333333333%);stroke:hsl(220.5882352941, 60%, 88.3333333333%);stroke-width:1px;}#mermaid-generated-diagram .cluster text{fill:rgb(8.5000000002, 5.7500000001, 0);}#mermaid-gen",
    "id": "anatomy-of-components-*-angular-14"
  },
  {
    "url": "https://angular.dev/guide/components",
    "title": "Anatomy of components • Angular",
    "chunk": "erated-diagram .cluster span{color:rgb(8.5000000002, 5.7500000001, 0);}#mermaid-generated-diagram div.mermaidTooltip{position:absolute;text-align:center;max-width:200px;padding:2px;font-family:\"trebuchet ms\",verdana,arial,sans-serif;font-size:12px;background:hsl(220.5882352941, 100%, 98.3333333333%);border:1px solid hsl(220.5882352941, 60%, 88.3333333333%);border-radius:2px;pointer-events:none;z-index:100;}#mermaid-generated-diagram .flowchartTitleText{text-anchor:middle;font-size:18px;fill:#333",
    "id": "anatomy-of-components-*-angular-15"
  },
  {
    "url": "https://angular.dev/guide/components",
    "title": "Anatomy of components • Angular",
    "chunk": ";}#mermaid-generated-diagram rect.text{fill:none;stroke-width:0;}#mermaid-generated-diagram .icon-shape,#mermaid-generated-diagram .image-shape{background-color:hsl(-79.4117647059, 100%, 93.3333333333%);text-align:center;}#mermaid-generated-diagram .icon-shape p,#mermaid-generated-diagram .image-shape p{background-color:hsl(-79.4117647059, 100%, 93.3333333333%);padding:2px;}#mermaid-generated-diagram .icon-shape rect,#mermaid-generated-diagram .image-shape rect{opacity:0.5;background-color:hsl(-",
    "id": "anatomy-of-components-*-angular-16"
  },
  {
    "url": "https://angular.dev/guide/components",
    "title": "Anatomy of components • Angular",
    "chunk": "79.4117647059, 100%, 93.3333333333%);fill:hsl(-79.4117647059, 100%, 93.3333333333%);}#mermaid-generated-diagram :root{--mermaid-font-family:\"trebuchet ms\",verdana,arial,sans-serif;}AccountSettingsUserProfilePaymentInfoProfilePicUserBioThis tree structure is important to understanding several other Angular concepts, including dependency injection and child queries. Social MediaBlogX (formerly Twitter)BlueskyYouTube Discord GitHub Stack Overflow Community Contribute Code of Conduct Report Issues G",
    "id": "anatomy-of-components-*-angular-17"
  },
  {
    "url": "https://angular.dev/guide/components",
    "title": "Anatomy of components • Angular",
    "chunk": "oogle's DevLibrary Angular Google Developer Experts ResourcesPress KitRoadmapLanguages简体中文版正體中文版日本語版한국어 Ελληνικά Super-powered by Google ©2010-2025. Code licensed under an MIT-style License . Documentation licensed under CC BY 4.0 . In-depth GuidesComponents Anatomy of a component",
    "id": "anatomy-of-components-*-angular-18"
  },
  {
    "url": "https://angular.dev/guide/components/selectors",
    "title": "Selectors • Angular",
    "chunk": "In-depth GuidesComponents Component selectors TIP: This guide assumes you've already read the Essentials Guide. Read that first if you're new to Angular. Every component defines a CSS selector that determines how the component is used: @Component({ selector: 'profile-photo', ...})export class ProfilePhoto { } You use a component by creating a matching HTML element in the templates of other components: @Component({ template: ` <profile-photo /> <button>Upload a new profile photo</button>`, ...,})",
    "id": "selectors-*-angular-0"
  },
  {
    "url": "https://angular.dev/guide/components/selectors",
    "title": "Selectors • Angular",
    "chunk": "export class UserProfile { } Angular matches selectors statically at compile-time. Changing the DOM at run-time, either via Angular bindings or with DOM APIs, does not affect the components rendered. An element can match exactly one component selector. If multiple component selectors match a single element, Angular reports an error. Component selectors are case-sensitive. On this pagearrow_upward_alt Back to the top Types of selectors Angular supports a limited subset of basic CSS selector types",
    "id": "selectors-*-angular-1"
  },
  {
    "url": "https://angular.dev/guide/components/selectors",
    "title": "Selectors • Angular",
    "chunk": " in component selectors: Selector type Description Examples Type selector Matches elements based on their HTML tag name, or node name. profile-photo Attribute selector Matches elements based on the presence of an HTML attribute and, optionally, an exact value for that attribute. [dropzone] [type=\"reset\"] Class selector Matches elements based on the presence of a CSS class. .menu-item For attribute values, Angular supports matching an exact attribute value with the equals (=) operator. Angular do",
    "id": "selectors-*-angular-2"
  },
  {
    "url": "https://angular.dev/guide/components/selectors",
    "title": "Selectors • Angular",
    "chunk": "es not support other attribute value operators. Angular component selectors do not support combinators, including the descendant combinator or child combinator. Angular component selectors do not support specifying namespaces. The :not pseudo-class Angular supports the :not pseudo-class. You can append this pseudo-class to any other selector to narrow which elements a component's selector matches. For example, you could define a [dropzone] attribute selector and prevent matching textarea element",
    "id": "selectors-*-angular-3"
  },
  {
    "url": "https://angular.dev/guide/components/selectors",
    "title": "Selectors • Angular",
    "chunk": "s: @Component({ selector: '[dropzone]:not(textarea)', ...})export class DropZone { } Angular does not support any other pseudo-classes or pseudo-elements in component selectors. Combining selectors You can combine multiple selectors by concatenating them. For example, you can match <button> elements that specify type=\"reset\": @Component({ selector: 'button[type=\"reset\"]', ...})export class ResetButton { } You can also define multiple selectors with a comma-separated list: @Component({ selector: ",
    "id": "selectors-*-angular-4"
  },
  {
    "url": "https://angular.dev/guide/components/selectors",
    "title": "Selectors • Angular",
    "chunk": "'drop-zone, [dropzone]', ...})export class DropZone { } Angular creates a component for each element that matches any of the selectors in the list. Choosing a selector The vast majority of components should use a custom element name as their selector. All custom element names should include a hyphen as described by the HTML specification. By default, Angular reports an error if it encounters a custom tag name that does not match any available components, preventing bugs due to mistyped component",
    "id": "selectors-*-angular-5"
  },
  {
    "url": "https://angular.dev/guide/components/selectors",
    "title": "Selectors • Angular",
    "chunk": " names. See Advanced component configuration for details on using native custom elements in Angular templates. Selector prefixes The Angular team recommends using a short, consistent prefix for all the custom components defined inside your project. For example, if you were to build YouTube with Angular, you might prefix your components with yt-, with components like yt-menu, yt-player, etc. Namespacing your selectors like this makes it immediately clear where a particular component comes from. B",
    "id": "selectors-*-angular-6"
  },
  {
    "url": "https://angular.dev/guide/components/selectors",
    "title": "Selectors • Angular",
    "chunk": "y default, the Angular CLI uses app-. Angular uses the ng selector prefix for its own framework APIs. Never use ng as a selector prefix for your own custom components. When to use an attribute selector You should consider an attribute selector when you want to create a component on a standard native element. For example, if you want to create a custom button component, you can take advantage of the standard <button> element by using an attribute selector: @Component({ selector: 'button[yt-upload",
    "id": "selectors-*-angular-7"
  },
  {
    "url": "https://angular.dev/guide/components/selectors",
    "title": "Selectors • Angular",
    "chunk": "]', ...})export class YouTubeUploadButton { } This approach allows consumers of the component to directly use all the element's standard APIs without extra work. This is especially valuable for ARIA attributes such as aria-label. Angular does not report errors when it encounters custom attributes that don't match an available component. When using components with attribute selectors, consumers may forget to import the component or its NgModule, resulting in the component not rendering. See Impor",
    "id": "selectors-*-angular-8"
  },
  {
    "url": "https://angular.dev/guide/components/selectors",
    "title": "Selectors • Angular",
    "chunk": "ting and using components for more information. Components that define attribute selectors should use lowercase, dash-case attributes. You can follow the same prefixing recommendation described above. Social MediaBlogX (formerly Twitter)BlueskyYouTube Discord GitHub Stack Overflow Community Contribute Code of Conduct Report Issues Google's DevLibrary Angular Google Developer Experts ResourcesPress KitRoadmapLanguages简体中文版正體中文版日本語版한국어 Ελληνικά Super-powered by Google ©2010-2025. Code licensed und",
    "id": "selectors-*-angular-9"
  },
  {
    "url": "https://angular.dev/guide/components/selectors",
    "title": "Selectors • Angular",
    "chunk": "er an MIT-style License . Documentation licensed under CC BY 4.0 .",
    "id": "selectors-*-angular-10"
  },
  {
    "url": "https://angular.dev/guide/components/styling",
    "title": "Styling • Angular",
    "chunk": "In-depth GuidesComponents Styling components TIP: This guide assumes you've already read the Essentials Guide. Read that first if you're new to Angular. Components can optionally include CSS styles that apply to that component's DOM: @Component({ selector: 'profile-photo', template: `<img src=\"profile-photo.jpg\" alt=\"Your profile photo\">`, styles: ` img { border-radius: 50%; } `,})export class ProfilePhoto { } You can also choose to write your styles in separate files: @Component({ selector: 'pr",
    "id": "styling-*-angular-0"
  },
  {
    "url": "https://angular.dev/guide/components/styling",
    "title": "Styling • Angular",
    "chunk": "ofile-photo', templateUrl: 'profile-photo.html', styleUrl: 'profile-photo.css',})export class ProfilePhoto { } When Angular compiles your component, these styles are emitted with your component's JavaScript output. This means that component styles participate in the JavaScript module system. When you render an Angular component, the framework automatically includes its associated styles, even when lazy-loading a component. Angular works with any tool that outputs CSS, including Sass, less, and s",
    "id": "styling-*-angular-1"
  },
  {
    "url": "https://angular.dev/guide/components/styling",
    "title": "Styling • Angular",
    "chunk": "tylus. On this pagearrow_upward_alt Back to the top Style scoping Every component has a view encapsulation setting that determines how the framework scopes a component's styles. There are three view encapsulation modes: Emulated, ShadowDom, and None. You can specify the mode in the @Component decorator: @Component({ ..., encapsulation: ViewEncapsulation.None,})export class ProfilePhoto { } ViewEncapsulation.Emulated By default, Angular uses emulated encapsulation so that a component's styles onl",
    "id": "styling-*-angular-2"
  },
  {
    "url": "https://angular.dev/guide/components/styling",
    "title": "Styling • Angular",
    "chunk": "y apply to elements defined in that component's template. In this mode, the framework generates a unique HTML attribute for each component instance, adds that attribute to elements in the component's template, and inserts that attribute into the CSS selectors defined in your component's styles. This mode ensures that a component's styles do not leak out and affect other components. However, global styles defined outside of a component may still affect elements inside a component with emulated en",
    "id": "styling-*-angular-3"
  },
  {
    "url": "https://angular.dev/guide/components/styling",
    "title": "Styling • Angular",
    "chunk": "capsulation. In emulated mode, Angular supports the :host and :host-context() pseudo classes without using Shadow DOM. During compilation, the framework transforms these pseudo classes into attributes so it doesn't comply with these native pseudo classes' rules at runtime (e.g. browser compatibility, specificity). Angular's emulated encapsulation mode does not support any other pseudo classes related to Shadow DOM, such as ::shadow or ::part. ::ng-deep Angular's emulated encapsulation mode suppo",
    "id": "styling-*-angular-4"
  },
  {
    "url": "https://angular.dev/guide/components/styling",
    "title": "Styling • Angular",
    "chunk": "rts a custom pseudo class, ::ng-deep. Applying this pseudo class to a CSS rule disables encapsulation for that rule, effectively turning it into a global style. The Angular team strongly discourages new use of ::ng-deep. These APIs remain exclusively for backwards compatibility. ViewEncapsulation.ShadowDom This mode scopes styles within a component by using the web standard Shadow DOM API. When enabling this mode, Angular attaches a shadow root to the component's host element and renders the com",
    "id": "styling-*-angular-5"
  },
  {
    "url": "https://angular.dev/guide/components/styling",
    "title": "Styling • Angular",
    "chunk": "ponent's template and styles into the corresponding shadow tree. This mode strictly guarantees that only that component's styles apply to elements in the component's template. Global styles cannot affect elements in a shadow tree and styles inside the shadow tree cannot affect elements outside of that shadow tree. Enabling ShadowDom encapsulation, however, impacts more than style scoping. Rendering the component in a shadow tree affects event propagation, interaction with the <slot> API, and how",
    "id": "styling-*-angular-6"
  },
  {
    "url": "https://angular.dev/guide/components/styling",
    "title": "Styling • Angular",
    "chunk": " browser developer tools show elements. Always understand the full implications of using Shadow DOM in your application before enabling this option. ViewEncapsulation.None This mode disables all style encapsulation for the component. Any styles associated with the component behave as global styles. NOTE: In Emulated and ShadowDom modes, Angular doesn't 100% guarantee that your component's styles will always override styles coming from outside it. It is assumed that these styles have the same spe",
    "id": "styling-*-angular-7"
  },
  {
    "url": "https://angular.dev/guide/components/styling",
    "title": "Styling • Angular",
    "chunk": "cificity as your component's styles in case of collision. Defining styles in templates You can use the <style> element in a component's template to define additional styles. The component's view encapsulation mode applies to styles defined this way. Angular does not support bindings inside of style elements. Referencing external style files Component templates can use the <link> element to reference CSS files. Additionally, your CSS may use the @importat-rule to reference CSS files. Angular trea",
    "id": "styling-*-angular-8"
  },
  {
    "url": "https://angular.dev/guide/components/styling",
    "title": "Styling • Angular",
    "chunk": "ts these references as external styles. External styles are not affected by emulated view encapsulation. Social MediaBlogX (formerly Twitter)BlueskyYouTube Discord GitHub Stack Overflow Community Contribute Code of Conduct Report Issues Google's DevLibrary Angular Google Developer Experts ResourcesPress KitRoadmapLanguages简体中文版正體中文版日本語版한국어 Ελληνικά Super-powered by Google ©2010-2025. Code licensed under an MIT-style License . Documentation licensed under CC BY 4.0 .",
    "id": "styling-*-angular-9"
  },
  {
    "url": "https://angular.dev/guide/components/inputs",
    "title": "Accepting data with input properties • Angular",
    "chunk": "In-depth GuidesComponents Accepting data with input properties TIP: This guide assumes you've already read the Essentials Guide. Read that first if you're new to Angular. TIP: If you're familiar with other web frameworks, input properties are similar to props. When you use a component, you commonly want to pass some data to it. A component specifies the data that it accepts by declaring inputs: import {Component, input} from '@angular/core';@Component({/*...*/})export class CustomSlider { // Dec",
    "id": "accepting-data-with-input-properties-*-angular-0"
  },
  {
    "url": "https://angular.dev/guide/components/inputs",
    "title": "Accepting data with input properties • Angular",
    "chunk": "lare an input named 'value' with a default value of zero. value = input(0);} This lets you bind to the property in a template: <custom-slider [value]=\"50\" /> If an input has a default value, TypeScript infers the type from the default value: @Component({/*...*/})export class CustomSlider { // TypeScript infers that this input is a number, returning InputSignal<number>. value = input(0);} You can explicitly declare a type for the input by specifying a generic parameter to the function. If an inpu",
    "id": "accepting-data-with-input-properties-*-angular-1"
  },
  {
    "url": "https://angular.dev/guide/components/inputs",
    "title": "Accepting data with input properties • Angular",
    "chunk": "t without a default value is not set, its value is undefined: @Component({/*...*/})export class CustomSlider { // Produces an InputSignal<number | undefined> because `value` may not be set. value = input<number>();} Angular records inputs statically at compile-time. Inputs cannot be added or removed at run-time. The input function has special meaning to the Angular compiler. You can exclusively call input in component and directive property initializers. When extending a component class, inputs ",
    "id": "accepting-data-with-input-properties-*-angular-2"
  },
  {
    "url": "https://angular.dev/guide/components/inputs",
    "title": "Accepting data with input properties • Angular",
    "chunk": "are inherited by the child class. Input names are case-sensitive. On this pagearrow_upward_alt Back to the top Reading inputs The input function returns an InputSignal. You can read the value by calling the signal: import {Component, input} from '@angular/core';@Component({/*...*/})export class CustomSlider { // Declare an input named 'value' with a default value of zero. value = input(0); // Create a computed expression that reads the value input label = computed(() => `The slider's value is ${",
    "id": "accepting-data-with-input-properties-*-angular-3"
  },
  {
    "url": "https://angular.dev/guide/components/inputs",
    "title": "Accepting data with input properties • Angular",
    "chunk": "this.value()}`); } Signals created by the input function are read-only. Required inputs You can declare that an input is required by calling input.required instead of input: @Component({/*...*/})export class CustomSlider { // Declare a required input named value. Returns an `InputSignal<number>`. value = input.required<number>();} Angular enforces that required inputs must be set when the component is used in a template. If you try to use a component without specifying all of its required inputs",
    "id": "accepting-data-with-input-properties-*-angular-4"
  },
  {
    "url": "https://angular.dev/guide/components/inputs",
    "title": "Accepting data with input properties • Angular",
    "chunk": ", Angular reports an error at build-time. Required inputs do not automatically include undefined in the generic parameter of the returned InputSignal. Configuring inputs The input function accepts a config object as a second parameter that lets you change the way that input works. Input transforms You can specify a transform function to change the value of an input when it's set by Angular. @Component({ selector: 'custom-slider', /*...*/})export class CustomSlider { label = input('', {transform:",
    "id": "accepting-data-with-input-properties-*-angular-5"
  },
  {
    "url": "https://angular.dev/guide/components/inputs",
    "title": "Accepting data with input properties • Angular",
    "chunk": " trimString});}function trimString(value: string | undefined): string { return value?.trim() ?? '';} <custom-slider [label]=\"systemVolume\" /> In the example above, whenever the value of systemVolume changes, Angular runs trimString and sets label to the result. The most common use-case for input transforms is to accept a wider range of value types in templates, often including null and undefined. Input transform function must be statically analyzable at build-time. You cannot set transform funct",
    "id": "accepting-data-with-input-properties-*-angular-6"
  },
  {
    "url": "https://angular.dev/guide/components/inputs",
    "title": "Accepting data with input properties • Angular",
    "chunk": "ions conditionally or as the result of an expression evaluation. Input transform functions should always be pure functions. Relying on state outside the transform function can lead to unpredictable behavior. Type checking When you specify an input transform, the type of the transform function's parameter determines the types of values that can be set to the input in a template. @Component({/*...*/})export class CustomSlider { widthPx = input('', {transform: appendPx});}function appendPx(value: n",
    "id": "accepting-data-with-input-properties-*-angular-7"
  },
  {
    "url": "https://angular.dev/guide/components/inputs",
    "title": "Accepting data with input properties • Angular",
    "chunk": "umber): string { return `${value}px`;} In the example above, the widthPx input accepts a number while the InputSignal property returns a string. Built-in transformations Angular includes two built-in transform functions for the two most common scenarios: coercing values to boolean and numbers. import {Component, input, booleanAttribute, numberAttribute} from '@angular/core';@Component({/*...*/})export class CustomSlider { disabled = input(false, {transform: booleanAttribute}); value = input(0, {",
    "id": "accepting-data-with-input-properties-*-angular-8"
  },
  {
    "url": "https://angular.dev/guide/components/inputs",
    "title": "Accepting data with input properties • Angular",
    "chunk": "transform: numberAttribute}); } booleanAttribute imitates the behavior of standard HTML boolean attributes, where the presence of the attribute indicates a \"true\" value. However, Angular's booleanAttribute treats the literal string \"false\" as the boolean false. numberAttribute attempts to parse the given value to a number, producing NaN if parsing fails. Input aliases You can specify the alias option to change the name of an input in templates. @Component({/*...*/})export class CustomSlider { va",
    "id": "accepting-data-with-input-properties-*-angular-9"
  },
  {
    "url": "https://angular.dev/guide/components/inputs",
    "title": "Accepting data with input properties • Angular",
    "chunk": "lue = input(0, {alias: 'sliderValue'});} <custom-slider [sliderValue]=\"50\" /> This alias does not affect usage of the property in TypeScript code. While you should generally avoid aliasing inputs for components, this feature can be useful for renaming properties while preserving an alias for the original name or for avoiding collisions with the name of native DOM element properties. Model inputs Model inputs are a special type of input that enable a component to propagate new values back to its ",
    "id": "accepting-data-with-input-properties-*-angular-10"
  },
  {
    "url": "https://angular.dev/guide/components/inputs",
    "title": "Accepting data with input properties • Angular",
    "chunk": "parent component. When creating a component, you can define a model input similarly to how you create a standard input. Both types of input allow someone to bind a value into the property. However, model inputs allow the component author to write values into the property. If the property is bound with a two-way binding, the new value propagates to that binding. @Component({ /* ... */})export class CustomSlider { // Define a model input named \"value\". value = model(0); increment() { // Update the",
    "id": "accepting-data-with-input-properties-*-angular-11"
  },
  {
    "url": "https://angular.dev/guide/components/inputs",
    "title": "Accepting data with input properties • Angular",
    "chunk": " model input with a new value, propagating the value to any bindings. this.value.update(oldValue => oldValue + 10); }}@Component({ /* ... */ // Using the two-way binding syntax means that any changes to the slider's // value automatically propagate back to the `volume` signal. // Note that this binding uses the signal *instance*, not the signal value. template: `<custom-slider [(value)]=\"volume\" />`,})export class MediaControls { // Create a writable signal for the `volume` local state. volume =",
    "id": "accepting-data-with-input-properties-*-angular-12"
  },
  {
    "url": "https://angular.dev/guide/components/inputs",
    "title": "Accepting data with input properties • Angular",
    "chunk": " signal(0);} In the above example, the CustomSlider can write values into its value model input, which then propagates those values back to the volume signal in MediaControls. This binding keeps the values of value and volume in sync. Notice that the binding passes the volume signal instance, not the value of the signal. In other respects, model inputs work similarly to standard inputs. You can read the value by calling the signal function, including in reactive contexts like computed and effect",
    "id": "accepting-data-with-input-properties-*-angular-13"
  },
  {
    "url": "https://angular.dev/guide/components/inputs",
    "title": "Accepting data with input properties • Angular",
    "chunk": ". See Two-way binding for more details on two-way binding in templates. Two-way binding with plain properties You can bind a plain JavaScript property to a model input. @Component({ /* ... */ // `value` is a model input. // The parenthesis-inside-square-brackets syntax (aka \"banana-in-a-box\") creates a two-way binding template: '<custom-slider [(value)]=\"volume\" />',})export class MediaControls { protected volume = 0;} In the example above, the CustomSlider can write values into its value model ",
    "id": "accepting-data-with-input-properties-*-angular-14"
  },
  {
    "url": "https://angular.dev/guide/components/inputs",
    "title": "Accepting data with input properties • Angular",
    "chunk": "input, which then propagates those values back to the volume property in MediaControls. This binding keeps the values of value and volume in sync. Implicit change events When you declare a model input in a component or directive, Angular automatically creates a corresponding output for that model. The output's name is the model input's name suffixed with \"Change\". @Directive({ /* ... */ })export class CustomCheckbox { // This automatically creates an output named \"checkedChange\". // Can be subsc",
    "id": "accepting-data-with-input-properties-*-angular-15"
  },
  {
    "url": "https://angular.dev/guide/components/inputs",
    "title": "Accepting data with input properties • Angular",
    "chunk": "ribed to using `(checkedChange)=\"handler()\"` in the template. checked = model(false);} Angular emits this change event whenever you write a new value into the model input by calling its set or update methods. See Custom events with outputs for more details on outputs. Customizing model inputs You can mark a model input as required or provide an alias in the same way as a standard input. Model inputs do not support input transforms. When to use model inputs Use model inputs when you want a compon",
    "id": "accepting-data-with-input-properties-*-angular-16"
  },
  {
    "url": "https://angular.dev/guide/components/inputs",
    "title": "Accepting data with input properties • Angular",
    "chunk": "ent to support two-way binding. This is typically appropriate when a component exists to modify a value based on user interaction. Most commonly, custom form controls, such as a date picker or combobox, should use model inputs for their primary value. Choosing input names Avoid choosing input names that collide with properties on DOM elements like HTMLElement. Name collisions introduce confusion about whether the bound property belongs to the component or the DOM element. Avoid adding prefixes f",
    "id": "accepting-data-with-input-properties-*-angular-17"
  },
  {
    "url": "https://angular.dev/guide/components/inputs",
    "title": "Accepting data with input properties • Angular",
    "chunk": "or component inputs like you would with component selectors. Since a given element can only host one component, any custom properties can be assumed to belong to the component. Declaring inputs with the @Input decorator TIP: While the Angular team recommends using the signal-based input function for new projects, the original decorator-based @Input API remains fully supported. You can alternatively declare component inputs by adding the @Input decorator to a property: @Component({...})export cla",
    "id": "accepting-data-with-input-properties-*-angular-18"
  },
  {
    "url": "https://angular.dev/guide/components/inputs",
    "title": "Accepting data with input properties • Angular",
    "chunk": "ss CustomSlider { @Input() value = 0;} Binding to an input is the same in both signal-based and decorator-based inputs: <custom-slider [value]=\"50\" /> Customizing decorator-based inputs The @Input decorator accepts a config object that lets you change the way that input works. Required inputs You can specify the required option to enforce that a given input must always have a value. @Component({...})export class CustomSlider { @Input({required: true}) value = 0;} If you try to use a component wi",
    "id": "accepting-data-with-input-properties-*-angular-19"
  },
  {
    "url": "https://angular.dev/guide/components/inputs",
    "title": "Accepting data with input properties • Angular",
    "chunk": "thout specifying all of its required inputs, Angular reports an error at build-time. Input transforms You can specify a transform function to change the value of an input when it's set by Angular. This transform function works identically to transform functions for signal-based inputs described above. @Component({ selector: 'custom-slider', ...})export class CustomSlider { @Input({transform: trimString}) label = '';}function trimString(value: string | undefined) { return value?.trim() ?? ''; } I",
    "id": "accepting-data-with-input-properties-*-angular-20"
  },
  {
    "url": "https://angular.dev/guide/components/inputs",
    "title": "Accepting data with input properties • Angular",
    "chunk": "nput aliases You can specify the alias option to change the name of an input in templates. @Component({...})export class CustomSlider { @Input({alias: 'sliderValue'}) value = 0;} <custom-slider [sliderValue]=\"50\" /> The @Input decorator also accepts the alias as its first parameter in place of the config object. Input aliases work the same way as for signal-based inputs described above. Inputs with getters and setters When using decorator-based inputs, a property implemented with a getter and se",
    "id": "accepting-data-with-input-properties-*-angular-21"
  },
  {
    "url": "https://angular.dev/guide/components/inputs",
    "title": "Accepting data with input properties • Angular",
    "chunk": "tter can be an input: export class CustomSlider { @Input() get value(): number { return this.internalValue; }set value(newValue: number) { this.internalValue = newValue; }private internalValue = 0; } You can even create a write-only input by only defining a public setter: export class CustomSlider { @Input() set value(newValue: number) { this.internalValue = newValue; }private internalValue = 0; } Prefer using input transforms instead of getters and setters if possible. Avoid complex or costly g",
    "id": "accepting-data-with-input-properties-*-angular-22"
  },
  {
    "url": "https://angular.dev/guide/components/inputs",
    "title": "Accepting data with input properties • Angular",
    "chunk": "etters and setters. Angular may invoke an input's setter multiple times, which may negatively impact application performance if the setter performs any costly behaviors, such as DOM manipulation. Specify inputs in the @Component decorator In addition to the @Input decorator, you can also specify a component's inputs with the inputs property in the @Component decorator. This can be useful when a component inherits a property from a base class: // `CustomSlider` inherits the `disabled` property fr",
    "id": "accepting-data-with-input-properties-*-angular-23"
  },
  {
    "url": "https://angular.dev/guide/components/inputs",
    "title": "Accepting data with input properties • Angular",
    "chunk": "om `BaseSlider`.@Component({ ..., inputs: ['disabled'],})export class CustomSlider extends BaseSlider { } You can additionally specify an input alias in the inputs list by putting the alias after a colon in the string: // `CustomSlider` inherits the `disabled` property from `BaseSlider`.@Component({ ..., inputs: ['disabled: sliderDisabled'],})export class CustomSlider extends BaseSlider { } Social MediaBlogX (formerly Twitter)BlueskyYouTube Discord GitHub Stack Overflow Community Contribute Code",
    "id": "accepting-data-with-input-properties-*-angular-24"
  },
  {
    "url": "https://angular.dev/guide/components/inputs",
    "title": "Accepting data with input properties • Angular",
    "chunk": " of Conduct Report Issues Google's DevLibrary Angular Google Developer Experts ResourcesPress KitRoadmapLanguages简体中文版正體中文版日本語版한국어 Ελληνικά Super-powered by Google ©2010-2025. Code licensed under an MIT-style License . Documentation licensed under CC BY 4.0 .",
    "id": "accepting-data-with-input-properties-*-angular-25"
  },
  {
    "url": "https://angular.dev/guide/components/outputs",
    "title": "Custom events with outputs • Angular",
    "chunk": "In-depth GuidesComponents Custom events with outputs TIP: This guide assumes you've already read the Essentials Guide. Read that first if you're new to Angular. Angular components can define custom events by assigning a property to the output function: @Component({/*...*/})export class ExpandablePanel { panelClosed = output<void>();} <expandable-panel (panelClosed)=\"savePanelState()\" /> The output function returns an OutputEmitterRef. You can emit an event by calling the emit method on the Outpu",
    "id": "custom-events-with-outputs-*-angular-0"
  },
  {
    "url": "https://angular.dev/guide/components/outputs",
    "title": "Custom events with outputs • Angular",
    "chunk": "tEmitterRef: this.panelClosed.emit(); Angular refers to properties initialized with the output function as outputs. You can use outputs to raise custom events, similar to native browser events like click. Angular custom events do not bubble up the DOM. Output names are case-sensitive. When extending a component class, outputs are inherited by the child class. The output function has special meaning to the Angular compiler. You can exclusively call output in component and directive property initi",
    "id": "custom-events-with-outputs-*-angular-1"
  },
  {
    "url": "https://angular.dev/guide/components/outputs",
    "title": "Custom events with outputs • Angular",
    "chunk": "alizers. On this pagearrow_upward_alt Back to the top Emitting event data You can pass event data when calling emit: // You can emit primitive values.this.valueChanged.emit(7);// You can emit custom event objectsthis.thumbDropped.emit({ pointerX: 123, pointerY: 456,}) When defining an event listener in a template, you can access the event data from the $event variable: <custom-slider (valueChanged)=\"logValue($event)\" /> Customizing output names The output function accepts a parameter that lets y",
    "id": "custom-events-with-outputs-*-angular-2"
  },
  {
    "url": "https://angular.dev/guide/components/outputs",
    "title": "Custom events with outputs • Angular",
    "chunk": "ou specify a different name for the event in a template: @Component({/*...*/})export class CustomSlider { changed = output({alias: 'valueChanged'});} <custom-slider (valueChanged)=\"saveVolume()\" /> This alias does not affect usage of the property in TypeScript code. While you should generally avoid aliasing outputs for components, this feature can be useful for renaming properties while preserving an alias for the original name or for avoiding collisions with the name of native DOM events. Subsc",
    "id": "custom-events-with-outputs-*-angular-3"
  },
  {
    "url": "https://angular.dev/guide/components/outputs",
    "title": "Custom events with outputs • Angular",
    "chunk": "ribing to outputs programmatically When creating a component dynamically, you can programmatically subscribe to output events from the component instance. The OutputRef type includes a subscribe method: const someComponentRef: ComponentRef<SomeComponent> = viewContainerRef.createComponent(/*...*/);someComponentRef.instance.someEventProperty.subscribe(eventData => { console.log(eventData);}); Angular automatically cleans up event subscriptions when it destroys components with subscribers. Alterna",
    "id": "custom-events-with-outputs-*-angular-4"
  },
  {
    "url": "https://angular.dev/guide/components/outputs",
    "title": "Custom events with outputs • Angular",
    "chunk": "tively, you can manually unsubscribe from an event. The subscribe function returns an OutputRefSubscription with an unsubscribe method: const eventSubscription = someComponent.someEventProperty.subscribe(eventData => { console.log(eventData);});// ...eventSubscription.unsubscribe(); Choosing event names Avoid choosing output names that collide with events on DOM elements like HTMLElement. Name collisions introduce confusion about whether the bound property belongs to the component or the DOM ele",
    "id": "custom-events-with-outputs-*-angular-5"
  },
  {
    "url": "https://angular.dev/guide/components/outputs",
    "title": "Custom events with outputs • Angular",
    "chunk": "ment. Avoid adding prefixes for component outputs like you would with component selectors. Since a given element can only host one component, any custom properties can be assumed to belong to the component. Always use camelCase output names. Avoid prefixing output names with \"on\". Using outputs with RxJS See RxJS interop with component and directive outputs for details on interoperability between outputs and RxJS. Declaring outputs with the @Output decorator TIP: While the Angular team recommend",
    "id": "custom-events-with-outputs-*-angular-6"
  },
  {
    "url": "https://angular.dev/guide/components/outputs",
    "title": "Custom events with outputs • Angular",
    "chunk": "s using the output function for new projects, the original decorator-based @Output API remains fully supported. You can alternatively define custom events by assigning a property to a new EventEmitter and adding the @Output decorator: @Component({/*...*/})export class ExpandablePanel { @Output() panelClosed = new EventEmitter<void>();} You can emit an event by calling the emit method on the EventEmitter. Aliases with the @Output decorator The @Output decorator accepts a parameter that lets you s",
    "id": "custom-events-with-outputs-*-angular-7"
  },
  {
    "url": "https://angular.dev/guide/components/outputs",
    "title": "Custom events with outputs • Angular",
    "chunk": "pecify a different name for the event in a template: @Component({/*...*/})export class CustomSlider { @Output('valueChanged') changed = new EventEmitter<number>();} <custom-slider (valueChanged)=\"saveVolume()\" /> This alias does not affect usage of the property in TypeScript code. Specify outputs in the @Component decorator In addition to the @Output decorator, you can also specify a component's outputs with the outputs property in the @Component decorator. This can be useful when a component in",
    "id": "custom-events-with-outputs-*-angular-8"
  },
  {
    "url": "https://angular.dev/guide/components/outputs",
    "title": "Custom events with outputs • Angular",
    "chunk": "herits a property from a base class: // `CustomSlider` inherits the `valueChanged` property from `BaseSlider`.@Component({ /*...*/ outputs: ['valueChanged'],})export class CustomSlider extends BaseSlider {} You can additionally specify an output alias in the outputs list by putting the alias after a colon in the string: // `CustomSlider` inherits the `valueChanged` property from `BaseSlider`.@Component({ /*...*/ outputs: ['valueChanged: volumeChanged'],})export class CustomSlider extends BaseSli",
    "id": "custom-events-with-outputs-*-angular-9"
  },
  {
    "url": "https://angular.dev/guide/components/outputs",
    "title": "Custom events with outputs • Angular",
    "chunk": "der {} Social MediaBlogX (formerly Twitter)BlueskyYouTube Discord GitHub Stack Overflow Community Contribute Code of Conduct Report Issues Google's DevLibrary Angular Google Developer Experts ResourcesPress KitRoadmapLanguages简体中文版正體中文版日本語版한국어 Ελληνικά Super-powered by Google ©2010-2025. Code licensed under an MIT-style License . Documentation licensed under CC BY 4.0 .",
    "id": "custom-events-with-outputs-*-angular-10"
  },
  {
    "url": "https://angular.dev/guide/components/content-projection",
    "title": "Content projection with ng-content • Angular",
    "chunk": "In-depth GuidesComponents Content projection with ng-content TIP: This guide assumes you've already read the Essentials Guide. Read that first if you're new to Angular. You often need to create components that act as containers for different types of content. For example, you may want to create a custom card component: @Component({ selector: 'custom-card', template: '<div class=\"card-shadow\"> <!-- card content goes here --> </div>',})export class CustomCard {/* ... */} You can use the <ng-conten",
    "id": "content-projection-with-ng-content-*-angular-0"
  },
  {
    "url": "https://angular.dev/guide/components/content-projection",
    "title": "Content projection with ng-content • Angular",
    "chunk": "t> element as a placeholder to mark where content should go: @Component({ selector: 'custom-card', template: '<div class=\"card-shadow\"> <ng-content></ng-content> </div>',})export class CustomCard {/* ... */} TIP: <ng-content> works similarly to the native <slot> element, but with some Angular-specific functionality. When you use a component with <ng-content>, any children of the component host element are rendered, or projected, at the location of that <ng-content>: // Component source@Component",
    "id": "content-projection-with-ng-content-*-angular-1"
  },
  {
    "url": "https://angular.dev/guide/components/content-projection",
    "title": "Content projection with ng-content • Angular",
    "chunk": "({ selector: 'custom-card', template: ` <div class=\"card-shadow\"> <ng-content /> </div> `,})export class CustomCard {/* ... */} <!-- Using the component --><custom-card> <p>This is the projected content</p></custom-card> <!-- The rendered DOM --><custom-card> <div class=\"card-shadow\"> <p>This is the projected content</p> </div></custom-card> Angular refers to any children of a component passed this way as that component's content. This is distinct from the component's view, which refers to the e",
    "id": "content-projection-with-ng-content-*-angular-2"
  },
  {
    "url": "https://angular.dev/guide/components/content-projection",
    "title": "Content projection with ng-content • Angular",
    "chunk": "lements defined in the component's template. The <ng-content> element is neither a component nor DOM element. Instead, it is a special placeholder that tells Angular where to render content. Angular's compiler processes all <ng-content> elements at build-time. You cannot insert, remove, or modify <ng-content> at run time. You cannot add directives, styles, or arbitrary attributes to <ng-content>. You should not conditionally include <ng-content> with @if, @for, or @switch. Angular always instant",
    "id": "content-projection-with-ng-content-*-angular-3"
  },
  {
    "url": "https://angular.dev/guide/components/content-projection",
    "title": "Content projection with ng-content • Angular",
    "chunk": "iates and creates DOM nodes for content rendered to a <ng-content> placeholder, even if that <ng-content> placeholder is hidden. For conditional rendering of component content, see Template fragments. On this pagearrow_upward_alt Back to the top Multiple content placeholders Angular supports projecting multiple different elements into different <ng-content> placeholders based on CSS selector. Expanding the card example from above, you could create two placeholders for a card title and a card bod",
    "id": "content-projection-with-ng-content-*-angular-4"
  },
  {
    "url": "https://angular.dev/guide/components/content-projection",
    "title": "Content projection with ng-content • Angular",
    "chunk": "y by using the select attribute: <!-- Component template --><div class=\"card-shadow\"> <ng-content select=\"card-title\"></ng-content> <div class=\"card-divider\"></div> <ng-content select=\"card-body\"></ng-content></div> <!-- Using the component --><custom-card> <card-title>Hello</card-title> <card-body>Welcome to the example</card-body></custom-card> <!-- Rendered DOM --><custom-card> <div class=\"card-shadow\"> <card-title>Hello</card-title> <div class=\"card-divider\"></div> <card-body>Welcome to the ",
    "id": "content-projection-with-ng-content-*-angular-5"
  },
  {
    "url": "https://angular.dev/guide/components/content-projection",
    "title": "Content projection with ng-content • Angular",
    "chunk": "example</card-body> </div></custom-card> The <ng-content> placeholder supports the same CSS selectors as component selectors. If you include one or more <ng-content> placeholders with a select attribute and one <ng-content> placeholder without a select attribute, the latter captures all elements that did not match a select attribute: <!-- Component template --><div class=\"card-shadow\"> <ng-content select=\"card-title\"></ng-content> <div class=\"card-divider\"></div> <!-- capture anything except \"ca",
    "id": "content-projection-with-ng-content-*-angular-6"
  },
  {
    "url": "https://angular.dev/guide/components/content-projection",
    "title": "Content projection with ng-content • Angular",
    "chunk": "rd-title\" --> <ng-content></ng-content></div> <!-- Using the component --><custom-card> <card-title>Hello</card-title> <img src=\"...\" /> <p>Welcome to the example</p></custom-card> <!-- Rendered DOM --><custom-card> <div class=\"card-shadow\"> <card-title>Hello</card-title> <div class=\"card-divider\"></div> <img src=\"...\" /> <p>Welcome to the example</p> </div></custom-card> If a component does not include an <ng-content> placeholder without a select attribute, any elements that don't match one of ",
    "id": "content-projection-with-ng-content-*-angular-7"
  },
  {
    "url": "https://angular.dev/guide/components/content-projection",
    "title": "Content projection with ng-content • Angular",
    "chunk": "the component's placeholders do not render into the DOM. Fallback content Angular can show fallback content for a component's <ng-content> placeholder if that component doesn't have any matching child content. You can specify fallback content by adding child content to the <ng-content> element itself. <!-- Component template --><div class=\"card-shadow\"> <ng-content select=\"card-title\">Default Title</ng-content> <div class=\"card-divider\"></div> <ng-content select=\"card-body\">Default Body</ng-cont",
    "id": "content-projection-with-ng-content-*-angular-8"
  },
  {
    "url": "https://angular.dev/guide/components/content-projection",
    "title": "Content projection with ng-content • Angular",
    "chunk": "ent></div> <!-- Using the component --><custom-card> <card-title>Hello</card-title> <!-- No card-body provided --></custom-card> <!-- Rendered DOM --><custom-card> <div class=\"card-shadow\"> <card-title>Hello</card-title> <div class=\"card-divider\"></div> Default Body </div></custom-card> Aliasing content for projection Angular supports a special attribute, ngProjectAs, that allows you to specify a CSS selector on any element. Whenever an element with ngProjectAs is checked against an <ng-content>",
    "id": "content-projection-with-ng-content-*-angular-9"
  },
  {
    "url": "https://angular.dev/guide/components/content-projection",
    "title": "Content projection with ng-content • Angular",
    "chunk": " placeholder, Angular compares against the ngProjectAs value instead of the element's identity: <!-- Component template --><div class=\"card-shadow\"> <ng-content select=\"card-title\"></ng-content> <div class=\"card-divider\"></div> <ng-content></ng-content></div> <!-- Using the component --><custom-card> <h3 ngProjectAs=\"card-title\">Hello</h3> <p>Welcome to the example</p></custom-card> <!-- Rendered DOM --><custom-card> <div class=\"card-shadow\"> <h3>Hello</h3> <div class=\"card-divider\"></div> <p>We",
    "id": "content-projection-with-ng-content-*-angular-10"
  },
  {
    "url": "https://angular.dev/guide/components/content-projection",
    "title": "Content projection with ng-content • Angular",
    "chunk": "lcome to the example</p> </div></custom-card> ngProjectAs supports only static values and cannot be bound to dynamic expressions. Social MediaBlogX (formerly Twitter)BlueskyYouTube Discord GitHub Stack Overflow Community Contribute Code of Conduct Report Issues Google's DevLibrary Angular Google Developer Experts ResourcesPress KitRoadmapLanguages简体中文版正體中文版日本語版한국어 Ελληνικά Super-powered by Google ©2010-2025. Code licensed under an MIT-style License . Documentation licensed under CC BY 4.0 .",
    "id": "content-projection-with-ng-content-*-angular-11"
  },
  {
    "url": "https://angular.dev/guide/components/lifecycle",
    "title": "Lifecycle • Angular",
    "chunk": "In-depth GuidesComponents Component Lifecycle TIP: This guide assumes you've already read the Essentials Guide. Read that first if you're new to Angular. A component's lifecycle is the sequence of steps that happen between the component's creation and its destruction. Each step represents a different part of Angular's process for rendering components and checking them for updates over time. In your components, you can implement lifecycle hooks to run code during these steps. Lifecycle hooks that",
    "id": "lifecycle-*-angular-0"
  },
  {
    "url": "https://angular.dev/guide/components/lifecycle",
    "title": "Lifecycle • Angular",
    "chunk": " relate to a specific component instance are implemented as methods on your component class. Lifecycle hooks that relate the Angular application as a whole are implemented as functions that accept a callback. A component's lifecycle is tightly connected to how Angular checks your components for changes over time. For the purposes of understanding this lifecycle, you only need to know that Angular walks your application tree from top to bottom, checking template bindings for changes. The lifecycl",
    "id": "lifecycle-*-angular-1"
  },
  {
    "url": "https://angular.dev/guide/components/lifecycle",
    "title": "Lifecycle • Angular",
    "chunk": "e hooks described below run while Angular is doing this traversal. This traversal visits each component exactly once, so you should always avoid making further state changes in the middle of the process. On this pagearrow_upward_alt Back to the top Summary Phase Method Summary Creation constructor Standard JavaScript class constructor . Runs when Angular instantiates the component. ChangeDetection ngOnInit Runs once after Angular has initialized all the component's inputs. ngOnChanges Runs every",
    "id": "lifecycle-*-angular-2"
  },
  {
    "url": "https://angular.dev/guide/components/lifecycle",
    "title": "Lifecycle • Angular",
    "chunk": " time the component's inputs have changed. ngDoCheck Runs every time this component is checked for changes. ngAfterContentInit Runs once after the component's content has been initialized. ngAfterContentChecked Runs every time this component content has been checked for changes. ngAfterViewInit Runs once after the component's view has been initialized. ngAfterViewChecked Runs every time the component's view has been checked for changes. Rendering afterNextRender Runs once the next time that all ",
    "id": "lifecycle-*-angular-3"
  },
  {
    "url": "https://angular.dev/guide/components/lifecycle",
    "title": "Lifecycle • Angular",
    "chunk": "components have been rendered to the DOM. afterEveryRender Runs every time all components have been rendered to the DOM. Destruction ngOnDestroy Runs once before the component is destroyed. ngOnInit The ngOnInit method runs after Angular has initialized all the components inputs with their initial values. A component's ngOnInit runs exactly once. This step happens before the component's own template is initialized. This means that you can update the component's state based on its initial input v",
    "id": "lifecycle-*-angular-4"
  },
  {
    "url": "https://angular.dev/guide/components/lifecycle",
    "title": "Lifecycle • Angular",
    "chunk": "alues. ngOnChanges The ngOnChanges method runs after any component inputs have changed. This step happens before the component's own template is checked. This means that you can update the component's state based on its initial input values. During initialization, the first ngOnChanges runs before ngOnInit. Inspecting changes The ngOnChanges method accepts one SimpleChanges argument. This object is a Record mapping each component input name to a SimpleChange object. Each SimpleChange contains th",
    "id": "lifecycle-*-angular-5"
  },
  {
    "url": "https://angular.dev/guide/components/lifecycle",
    "title": "Lifecycle • Angular",
    "chunk": "e input's previous value, its current value, and a flag for whether this is the first time the input has changed. @Component({ /* ... */})export class UserProfile { name = input(''); ngOnChanges(changes: SimpleChanges) { for (const inputName in changes) { const inputValues = changes[inputName]; console.log(`Previous ${inputName} == ${inputValues.previousValue}`); console.log(`Current ${inputName} == ${inputValues.currentValue}`); console.log(`Is first ${inputName} change == ${inputValues.firstCh",
    "id": "lifecycle-*-angular-6"
  },
  {
    "url": "https://angular.dev/guide/components/lifecycle",
    "title": "Lifecycle • Angular",
    "chunk": "ange}`); } }} If you provide an alias for any input properties, the SimpleChanges Record still uses the TypeScript property name as a key, rather than the alias. ngOnDestroy The ngOnDestroy method runs once just before a component is destroyed. Angular destroys a component when it is no longer shown on the page, such as being hidden by @if or upon navigating to another page. DestroyRef As an alternative to the ngOnDestroy method, you can inject an instance of DestroyRef. You can register a callb",
    "id": "lifecycle-*-angular-7"
  },
  {
    "url": "https://angular.dev/guide/components/lifecycle",
    "title": "Lifecycle • Angular",
    "chunk": "ack to be invoked upon the component's destruction by calling the onDestroy method of DestroyRef. @Component({ /* ... */})export class UserProfile { constructor() { inject(DestroyRef).onDestroy(() => { console.log('UserProfile destruction'); }); }} You can pass the DestroyRef instance to functions or classes outside your component. Use this pattern if you have other code that should run some cleanup behavior when the component is destroyed. You can also use DestroyRef to keep setup code close to",
    "id": "lifecycle-*-angular-8"
  },
  {
    "url": "https://angular.dev/guide/components/lifecycle",
    "title": "Lifecycle • Angular",
    "chunk": " cleanup code, rather than putting all cleanup code in the ngOnDestroy method. ngDoCheck The ngDoCheck method runs before every time Angular checks a component's template for changes. You can use this lifecycle hook to manually check for state changes outside of Angular's normal change detection, manually updating the component's state. This method runs very frequently and can significantly impact your page's performance. Avoid defining this hook whenever possible, only using it when you have no",
    "id": "lifecycle-*-angular-9"
  },
  {
    "url": "https://angular.dev/guide/components/lifecycle",
    "title": "Lifecycle • Angular",
    "chunk": " alternative. During initialization, the first ngDoCheck runs after ngOnInit. ngAfterContentInit The ngAfterContentInit method runs once after all the children nested inside the component (its content) have been initialized. You can use this lifecycle hook to read the results of content queries. While you can access the initialized state of these queries, attempting to change any state in this method results in an ExpressionChangedAfterItHasBeenCheckedError ngAfterContentChecked The ngAfterConte",
    "id": "lifecycle-*-angular-10"
  },
  {
    "url": "https://angular.dev/guide/components/lifecycle",
    "title": "Lifecycle • Angular",
    "chunk": "ntChecked method runs every time the children nested inside the component (its content) have been checked for changes. This method runs very frequently and can significantly impact your page's performance. Avoid defining this hook whenever possible, only using it when you have no alternative. While you can access the updated state of content queries here, attempting to change any state in this method results in an ExpressionChangedAfterItHasBeenCheckedError. ngAfterViewInit The ngAfterViewInit m",
    "id": "lifecycle-*-angular-11"
  },
  {
    "url": "https://angular.dev/guide/components/lifecycle",
    "title": "Lifecycle • Angular",
    "chunk": "ethod runs once after all the children in the component's template (its view) have been initialized. You can use this lifecycle hook to read the results of view queries. While you can access the initialized state of these queries, attempting to change any state in this method results in an ExpressionChangedAfterItHasBeenCheckedError ngAfterViewChecked The ngAfterViewChecked method runs every time the children in the component's template (its view) have been checked for changes. This method runs ",
    "id": "lifecycle-*-angular-12"
  },
  {
    "url": "https://angular.dev/guide/components/lifecycle",
    "title": "Lifecycle • Angular",
    "chunk": "very frequently and can significantly impact your page's performance. Avoid defining this hook whenever possible, only using it when you have no alternative. While you can access the updated state of view queries here, attempting to change any state in this method results in an ExpressionChangedAfterItHasBeenCheckedError. afterEveryRender and afterNextRender The afterEveryRender and afterNextRender functions let you register a render callback to be invoked after Angular has finished rendering al",
    "id": "lifecycle-*-angular-13"
  },
  {
    "url": "https://angular.dev/guide/components/lifecycle",
    "title": "Lifecycle • Angular",
    "chunk": "l components on the page into the DOM. These functions are different from the other lifecycle hooks described in this guide. Rather than a class method, they are standalone functions that accept a callback. The execution of render callbacks are not tied to any specific component instance, but instead an application-wide hook. afterEveryRender and afterNextRender must be called in an injection context, typically a component's constructor. You can use render callbacks to perform manual DOM operati",
    "id": "lifecycle-*-angular-14"
  },
  {
    "url": "https://angular.dev/guide/components/lifecycle",
    "title": "Lifecycle • Angular",
    "chunk": "ons. See Using DOM APIs for guidance on working with the DOM in Angular. Render callbacks do not run during server-side rendering or during build-time pre-rendering. after*Render phases When using afterEveryRender or afterNextRender, you can optionally split the work into phases. The phase gives you control over the sequencing of DOM operations, letting you sequence write operations before read operations in order to minimize layout thrashing. In order to communicate across phases, a phase funct",
    "id": "lifecycle-*-angular-15"
  },
  {
    "url": "https://angular.dev/guide/components/lifecycle",
    "title": "Lifecycle • Angular",
    "chunk": "ion may return a result value that can be accessed in the next phase. import {Component, ElementRef, afterNextRender} from '@angular/core';@Component({...})export class UserProfile { private prevPadding = 0; private elementHeight = 0; constructor() { private elementRef = inject(ElementRef); const nativeElement = elementRef.nativeElement; afterNextRender({ // Use the `Write` phase to write to a geometric property. write: () => { const padding = computePadding(); const changed = padding !== this.p",
    "id": "lifecycle-*-angular-16"
  },
  {
    "url": "https://angular.dev/guide/components/lifecycle",
    "title": "Lifecycle • Angular",
    "chunk": "revPadding; if (changed) { nativeElement.style.padding = padding; } return changed; // Communicate whether anything changed to the read phase. }, // Use the `Read` phase to read geometric properties after all writes have occurred. read: (didWrite) => { if (didWrite) { this.elementHeight = nativeElement.getBoundingClientRect().height; } } }); }} There are four phases, run in the following order: Phase Description earlyRead Use this phase to read any layout-affecting DOM properties and styles that",
    "id": "lifecycle-*-angular-17"
  },
  {
    "url": "https://angular.dev/guide/components/lifecycle",
    "title": "Lifecycle • Angular",
    "chunk": " are strictly necessary for subsequent calculation. Avoid this phase if possible, preferring the write and read phases. mixedReadWrite Default phase. Use for any operations need to both read and write layout-affecting properties and styles. Avoid this phase if possible, preferring the explicit write and read phases. write Use this phase to write layout-affecting DOM properties and styles. read Use this phase to read any layout-affecting DOM properties. Lifecycle interfaces Angular provides a Typ",
    "id": "lifecycle-*-angular-18"
  },
  {
    "url": "https://angular.dev/guide/components/lifecycle",
    "title": "Lifecycle • Angular",
    "chunk": "eScript interface for each lifecycle method. You can optionally import and implement these interfaces to ensure that your implementation does not have any typos or misspellings. Each interface has the same name as the corresponding method without the ng prefix. For example, the interface for ngOnInit is OnInit. @Component({ /* ... */})export class UserProfile implements OnInit { ngOnInit() { /* ... */ }} Execution order The following diagrams show the execution order of Angular's lifecycle hooks",
    "id": "lifecycle-*-angular-19"
  },
  {
    "url": "https://angular.dev/guide/components/lifecycle",
    "title": "Lifecycle • Angular",
    "chunk": ". During initialization #mermaid-generated-diagram{font-family:\"trebuchet ms\",verdana,arial,sans-serif;font-size:16px;fill:#333;}@keyframes edge-animation-frame{from{stroke-dashoffset:0;}}@keyframes dash{to{stroke-dashoffset:0;}}#mermaid-generated-diagram .edge-animation-slow{stroke-dasharray:9,5!important;stroke-dashoffset:900;animation:dash 50s linear infinite;stroke-linecap:round;}#mermaid-generated-diagram .edge-animation-fast{stroke-dasharray:9,5!important;stroke-dashoffset:900;animation:da",
    "id": "lifecycle-*-angular-20"
  },
  {
    "url": "https://angular.dev/guide/components/lifecycle",
    "title": "Lifecycle • Angular",
    "chunk": "sh 20s linear infinite;stroke-linecap:round;}#mermaid-generated-diagram .error-icon{fill:hsl(220.5882352941, 100%, 98.3333333333%);}#mermaid-generated-diagram .error-text{fill:rgb(8.5000000002, 5.7500000001, 0);stroke:rgb(8.5000000002, 5.7500000001, 0);}#mermaid-generated-diagram .edge-thickness-normal{stroke-width:1px;}#mermaid-generated-diagram .edge-thickness-thick{stroke-width:3.5px;}#mermaid-generated-diagram .edge-pattern-solid{stroke-dasharray:0;}#mermaid-generated-diagram .edge-thickness",
    "id": "lifecycle-*-angular-21"
  },
  {
    "url": "https://angular.dev/guide/components/lifecycle",
    "title": "Lifecycle • Angular",
    "chunk": "-invisible{stroke-width:0;fill:none;}#mermaid-generated-diagram .edge-pattern-dashed{stroke-dasharray:3;}#mermaid-generated-diagram .edge-pattern-dotted{stroke-dasharray:2;}#mermaid-generated-diagram .marker{fill:#0b0b0b;stroke:#0b0b0b;}#mermaid-generated-diagram .marker.cross{stroke:#0b0b0b;}#mermaid-generated-diagram svg{font-family:\"trebuchet ms\",verdana,arial,sans-serif;font-size:16px;}#mermaid-generated-diagram p{margin:0;}#mermaid-generated-diagram .label{font-family:\"trebuchet ms\",verdana",
    "id": "lifecycle-*-angular-22"
  },
  {
    "url": "https://angular.dev/guide/components/lifecycle",
    "title": "Lifecycle • Angular",
    "chunk": ",arial,sans-serif;color:#333;}#mermaid-generated-diagram .cluster-label text{fill:rgb(8.5000000002, 5.7500000001, 0);}#mermaid-generated-diagram .cluster-label span{color:rgb(8.5000000002, 5.7500000001, 0);}#mermaid-generated-diagram .cluster-label span p{background-color:transparent;}#mermaid-generated-diagram .label text,#mermaid-generated-diagram span{fill:#333;color:#333;}#mermaid-generated-diagram .node rect,#mermaid-generated-diagram .node circle,#mermaid-generated-diagram .node ellipse,#m",
    "id": "lifecycle-*-angular-23"
  },
  {
    "url": "https://angular.dev/guide/components/lifecycle",
    "title": "Lifecycle • Angular",
    "chunk": "ermaid-generated-diagram .node polygon,#mermaid-generated-diagram .node path{fill:#fff4dd;stroke:hsl(40.5882352941, 60%, 83.3333333333%);stroke-width:1px;}#mermaid-generated-diagram .rough-node .label text,#mermaid-generated-diagram .node .label text,#mermaid-generated-diagram .image-shape .label,#mermaid-generated-diagram .icon-shape .label{text-anchor:middle;}#mermaid-generated-diagram .node .katex path{fill:#000;stroke:#000;stroke-width:1px;}#mermaid-generated-diagram .rough-node .label,#merm",
    "id": "lifecycle-*-angular-24"
  },
  {
    "url": "https://angular.dev/guide/components/lifecycle",
    "title": "Lifecycle • Angular",
    "chunk": "aid-generated-diagram .node .label,#mermaid-generated-diagram .image-shape .label,#mermaid-generated-diagram .icon-shape .label{text-align:center;}#mermaid-generated-diagram .node.clickable{cursor:pointer;}#mermaid-generated-diagram .root .anchor path{fill:#0b0b0b!important;stroke-width:0;stroke:#0b0b0b;}#mermaid-generated-diagram .arrowheadPath{fill:#0b0b0b;}#mermaid-generated-diagram .edgePath .path{stroke:#0b0b0b;stroke-width:2.0px;}#mermaid-generated-diagram .flowchart-link{stroke:#0b0b0b;fi",
    "id": "lifecycle-*-angular-25"
  },
  {
    "url": "https://angular.dev/guide/components/lifecycle",
    "title": "Lifecycle • Angular",
    "chunk": "ll:none;}#mermaid-generated-diagram .edgeLabel{background-color:hsl(-79.4117647059, 100%, 93.3333333333%);text-align:center;}#mermaid-generated-diagram .edgeLabel p{background-color:hsl(-79.4117647059, 100%, 93.3333333333%);}#mermaid-generated-diagram .edgeLabel rect{opacity:0.5;background-color:hsl(-79.4117647059, 100%, 93.3333333333%);fill:hsl(-79.4117647059, 100%, 93.3333333333%);}#mermaid-generated-diagram .labelBkg{background-color:rgba(243.9999999999, 220.9999999998, 255, 0.5);}#mermaid-ge",
    "id": "lifecycle-*-angular-26"
  },
  {
    "url": "https://angular.dev/guide/components/lifecycle",
    "title": "Lifecycle • Angular",
    "chunk": "nerated-diagram .cluster rect{fill:hsl(220.5882352941, 100%, 98.3333333333%);stroke:hsl(220.5882352941, 60%, 88.3333333333%);stroke-width:1px;}#mermaid-generated-diagram .cluster text{fill:rgb(8.5000000002, 5.7500000001, 0);}#mermaid-generated-diagram .cluster span{color:rgb(8.5000000002, 5.7500000001, 0);}#mermaid-generated-diagram div.mermaidTooltip{position:absolute;text-align:center;max-width:200px;padding:2px;font-family:\"trebuchet ms\",verdana,arial,sans-serif;font-size:12px;background:hsl(",
    "id": "lifecycle-*-angular-27"
  },
  {
    "url": "https://angular.dev/guide/components/lifecycle",
    "title": "Lifecycle • Angular",
    "chunk": "220.5882352941, 100%, 98.3333333333%);border:1px solid hsl(220.5882352941, 60%, 88.3333333333%);border-radius:2px;pointer-events:none;z-index:100;}#mermaid-generated-diagram .flowchartTitleText{text-anchor:middle;font-size:18px;fill:#333;}#mermaid-generated-diagram rect.text{fill:none;stroke-width:0;}#mermaid-generated-diagram .icon-shape,#mermaid-generated-diagram .image-shape{background-color:hsl(-79.4117647059, 100%, 93.3333333333%);text-align:center;}#mermaid-generated-diagram .icon-shape p,",
    "id": "lifecycle-*-angular-28"
  },
  {
    "url": "https://angular.dev/guide/components/lifecycle",
    "title": "Lifecycle • Angular",
    "chunk": "#mermaid-generated-diagram .image-shape p{background-color:hsl(-79.4117647059, 100%, 93.3333333333%);padding:2px;}#mermaid-generated-diagram .icon-shape rect,#mermaid-generated-diagram .image-shape rect{opacity:0.5;background-color:hsl(-79.4117647059, 100%, 93.3333333333%);fill:hsl(-79.4117647059, 100%, 93.3333333333%);}#mermaid-generated-diagram :root{--mermaid-font-family:\"trebuchet ms\",verdana,arial,sans-serif;}RenderingChange detectionngOnChangesngOnInitngDoCheckngAfterContentInitngAfterView",
    "id": "lifecycle-*-angular-29"
  },
  {
    "url": "https://angular.dev/guide/components/lifecycle",
    "title": "Lifecycle • Angular",
    "chunk": "InitngAfterContentCheckedngAfterViewCheckedconstructorafterNextRenderafterEveryRender Subsequent updates #mermaid-generated-diagram{font-family:\"trebuchet ms\",verdana,arial,sans-serif;font-size:16px;fill:#333;}@keyframes edge-animation-frame{from{stroke-dashoffset:0;}}@keyframes dash{to{stroke-dashoffset:0;}}#mermaid-generated-diagram .edge-animation-slow{stroke-dasharray:9,5!important;stroke-dashoffset:900;animation:dash 50s linear infinite;stroke-linecap:round;}#mermaid-generated-diagram .edge",
    "id": "lifecycle-*-angular-30"
  },
  {
    "url": "https://angular.dev/guide/components/lifecycle",
    "title": "Lifecycle • Angular",
    "chunk": "-animation-fast{stroke-dasharray:9,5!important;stroke-dashoffset:900;animation:dash 20s linear infinite;stroke-linecap:round;}#mermaid-generated-diagram .error-icon{fill:hsl(220.5882352941, 100%, 98.3333333333%);}#mermaid-generated-diagram .error-text{fill:rgb(8.5000000002, 5.7500000001, 0);stroke:rgb(8.5000000002, 5.7500000001, 0);}#mermaid-generated-diagram .edge-thickness-normal{stroke-width:1px;}#mermaid-generated-diagram .edge-thickness-thick{stroke-width:3.5px;}#mermaid-generated-diagram .",
    "id": "lifecycle-*-angular-31"
  },
  {
    "url": "https://angular.dev/guide/components/lifecycle",
    "title": "Lifecycle • Angular",
    "chunk": "edge-pattern-solid{stroke-dasharray:0;}#mermaid-generated-diagram .edge-thickness-invisible{stroke-width:0;fill:none;}#mermaid-generated-diagram .edge-pattern-dashed{stroke-dasharray:3;}#mermaid-generated-diagram .edge-pattern-dotted{stroke-dasharray:2;}#mermaid-generated-diagram .marker{fill:#0b0b0b;stroke:#0b0b0b;}#mermaid-generated-diagram .marker.cross{stroke:#0b0b0b;}#mermaid-generated-diagram svg{font-family:\"trebuchet ms\",verdana,arial,sans-serif;font-size:16px;}#mermaid-generated-diagram",
    "id": "lifecycle-*-angular-32"
  },
  {
    "url": "https://angular.dev/guide/components/lifecycle",
    "title": "Lifecycle • Angular",
    "chunk": " p{margin:0;}#mermaid-generated-diagram .label{font-family:\"trebuchet ms\",verdana,arial,sans-serif;color:#333;}#mermaid-generated-diagram .cluster-label text{fill:rgb(8.5000000002, 5.7500000001, 0);}#mermaid-generated-diagram .cluster-label span{color:rgb(8.5000000002, 5.7500000001, 0);}#mermaid-generated-diagram .cluster-label span p{background-color:transparent;}#mermaid-generated-diagram .label text,#mermaid-generated-diagram span{fill:#333;color:#333;}#mermaid-generated-diagram .node rect,#m",
    "id": "lifecycle-*-angular-33"
  },
  {
    "url": "https://angular.dev/guide/components/lifecycle",
    "title": "Lifecycle • Angular",
    "chunk": "ermaid-generated-diagram .node circle,#mermaid-generated-diagram .node ellipse,#mermaid-generated-diagram .node polygon,#mermaid-generated-diagram .node path{fill:#fff4dd;stroke:hsl(40.5882352941, 60%, 83.3333333333%);stroke-width:1px;}#mermaid-generated-diagram .rough-node .label text,#mermaid-generated-diagram .node .label text,#mermaid-generated-diagram .image-shape .label,#mermaid-generated-diagram .icon-shape .label{text-anchor:middle;}#mermaid-generated-diagram .node .katex path{fill:#000;",
    "id": "lifecycle-*-angular-34"
  },
  {
    "url": "https://angular.dev/guide/components/lifecycle",
    "title": "Lifecycle • Angular",
    "chunk": "stroke:#000;stroke-width:1px;}#mermaid-generated-diagram .rough-node .label,#mermaid-generated-diagram .node .label,#mermaid-generated-diagram .image-shape .label,#mermaid-generated-diagram .icon-shape .label{text-align:center;}#mermaid-generated-diagram .node.clickable{cursor:pointer;}#mermaid-generated-diagram .root .anchor path{fill:#0b0b0b!important;stroke-width:0;stroke:#0b0b0b;}#mermaid-generated-diagram .arrowheadPath{fill:#0b0b0b;}#mermaid-generated-diagram .edgePath .path{stroke:#0b0b0b",
    "id": "lifecycle-*-angular-35"
  },
  {
    "url": "https://angular.dev/guide/components/lifecycle",
    "title": "Lifecycle • Angular",
    "chunk": ";stroke-width:2.0px;}#mermaid-generated-diagram .flowchart-link{stroke:#0b0b0b;fill:none;}#mermaid-generated-diagram .edgeLabel{background-color:hsl(-79.4117647059, 100%, 93.3333333333%);text-align:center;}#mermaid-generated-diagram .edgeLabel p{background-color:hsl(-79.4117647059, 100%, 93.3333333333%);}#mermaid-generated-diagram .edgeLabel rect{opacity:0.5;background-color:hsl(-79.4117647059, 100%, 93.3333333333%);fill:hsl(-79.4117647059, 100%, 93.3333333333%);}#mermaid-generated-diagram .labe",
    "id": "lifecycle-*-angular-36"
  },
  {
    "url": "https://angular.dev/guide/components/lifecycle",
    "title": "Lifecycle • Angular",
    "chunk": "lBkg{background-color:rgba(243.9999999999, 220.9999999998, 255, 0.5);}#mermaid-generated-diagram .cluster rect{fill:hsl(220.5882352941, 100%, 98.3333333333%);stroke:hsl(220.5882352941, 60%, 88.3333333333%);stroke-width:1px;}#mermaid-generated-diagram .cluster text{fill:rgb(8.5000000002, 5.7500000001, 0);}#mermaid-generated-diagram .cluster span{color:rgb(8.5000000002, 5.7500000001, 0);}#mermaid-generated-diagram div.mermaidTooltip{position:absolute;text-align:center;max-width:200px;padding:2px;f",
    "id": "lifecycle-*-angular-37"
  },
  {
    "url": "https://angular.dev/guide/components/lifecycle",
    "title": "Lifecycle • Angular",
    "chunk": "ont-family:\"trebuchet ms\",verdana,arial,sans-serif;font-size:12px;background:hsl(220.5882352941, 100%, 98.3333333333%);border:1px solid hsl(220.5882352941, 60%, 88.3333333333%);border-radius:2px;pointer-events:none;z-index:100;}#mermaid-generated-diagram .flowchartTitleText{text-anchor:middle;font-size:18px;fill:#333;}#mermaid-generated-diagram rect.text{fill:none;stroke-width:0;}#mermaid-generated-diagram .icon-shape,#mermaid-generated-diagram .image-shape{background-color:hsl(-79.4117647059, 1",
    "id": "lifecycle-*-angular-38"
  },
  {
    "url": "https://angular.dev/guide/components/lifecycle",
    "title": "Lifecycle • Angular",
    "chunk": "00%, 93.3333333333%);text-align:center;}#mermaid-generated-diagram .icon-shape p,#mermaid-generated-diagram .image-shape p{background-color:hsl(-79.4117647059, 100%, 93.3333333333%);padding:2px;}#mermaid-generated-diagram .icon-shape rect,#mermaid-generated-diagram .image-shape rect{opacity:0.5;background-color:hsl(-79.4117647059, 100%, 93.3333333333%);fill:hsl(-79.4117647059, 100%, 93.3333333333%);}#mermaid-generated-diagram :root{--mermaid-font-family:\"trebuchet ms\",verdana,arial,sans-serif;}R",
    "id": "lifecycle-*-angular-39"
  },
  {
    "url": "https://angular.dev/guide/components/lifecycle",
    "title": "Lifecycle • Angular",
    "chunk": "enderingChange detectionngOnChangesngDoCheckngAfterContentCheckedngAfterViewCheckedafterEveryRender Ordering with directives When you put one or more directives on the same element as a component, either in a template or with the hostDirectives property, the framework does not guarantee any ordering of a given lifecycle hook between the component and the directives on a single element. Never depend on an observed ordering, as this may change in later versions of Angular. Social MediaBlogX (forme",
    "id": "lifecycle-*-angular-40"
  },
  {
    "url": "https://angular.dev/guide/components/lifecycle",
    "title": "Lifecycle • Angular",
    "chunk": "rly Twitter)BlueskyYouTube Discord GitHub Stack Overflow Community Contribute Code of Conduct Report Issues Google's DevLibrary Angular Google Developer Experts ResourcesPress KitRoadmapLanguages简体中文版正體中文版日本語版한국어 Ελληνικά Super-powered by Google ©2010-2025. Code licensed under an MIT-style License . Documentation licensed under CC BY 4.0 .",
    "id": "lifecycle-*-angular-41"
  },
  {
    "url": "https://angular.dev/guide/templates",
    "title": "Templates • Overview • Angular",
    "chunk": "In-depth GuidesTemplates Template syntax In Angular, a template is a chunk of HTML. Use special syntax within a template to leverage many of Angular's features. TIP: Check out Angular's Essentials before diving into this comprehensive guide. Every Angular component has a template that defines the DOM that the component renders onto the page. By using templates, Angular is able to automatically keep your page up-to-date as data changes. Templates are usually found within either the template prope",
    "id": "templates-*-overview-*-angular-0"
  },
  {
    "url": "https://angular.dev/guide/templates",
    "title": "Templates • Overview • Angular",
    "chunk": "rty of a *.component.ts file or the *.component.html file. To learn more, check out the in-depth components guide. On this pagearrow_upward_alt Back to the top How do templates work? Templates are based on HTML syntax, with additional features such as built-in template functions, data binding, event listening, variables, and more. Angular compiles templates into JavaScript in order to build up an internal understanding of your application. One of the benefits of this are built-in rendering optim",
    "id": "templates-*-overview-*-angular-1"
  },
  {
    "url": "https://angular.dev/guide/templates",
    "title": "Templates • Overview • Angular",
    "chunk": "izations that Angular applies to your application automatically. Differences from standard HTML Some differences between templates and standard HTML syntax include: Comments in the template source code are not included in the rendered output Component and directive elements can be self-closed (e.g., <UserProfile />) Attributes with certain characters (i.e., [], (), etc.) have special meaning to Angular. See binding docs and adding event listeners docs for more information. The @ character has a ",
    "id": "templates-*-overview-*-angular-2"
  },
  {
    "url": "https://angular.dev/guide/templates",
    "title": "Templates • Overview • Angular",
    "chunk": "special meaning to Angular for adding dynamic behavior, such as control flow, to templates. You can include a literal @ character by escaping it as an HTML entity code (&commat; or &#64;). Angular ignores and collapses unnecessary whitespace characters. See whitespace in templates for more details. Angular may add comment nodes to a page as placeholders for dynamic content, but developers can ignore these. In addition, while most HTML syntax is valid template syntax, Angular does not support <sc",
    "id": "templates-*-overview-*-angular-3"
  },
  {
    "url": "https://angular.dev/guide/templates",
    "title": "Templates • Overview • Angular",
    "chunk": "ript> element in templates. For more information, see the Security page. What's next? You might also be interested in the following: Topics Details Binding dynamic text, properties, and attributes Bind dynamic data to text, properties and attributes. Adding event listeners Respond to events in your templates. Two-way binding Simultaneously binds a value and propagate changes. Control flow Conditionally show, hide and repeat elements. Pipes Transform data declaratively. Slotting child content wit",
    "id": "templates-*-overview-*-angular-4"
  },
  {
    "url": "https://angular.dev/guide/templates",
    "title": "Templates • Overview • Angular",
    "chunk": "h ng-content Control how components render content. Create template fragments with ng-template Declare a template fragment. Grouping elements with ng-container Group multiple elements together or mark a location for rendering. Variables in templates Learn about variable declarations. Deferred loading with @defer Create deferrable views with @defer. Expression syntax Learn similarities and differences between Angular expressions and standard JavaScript. Whitespace in templates Learn how Angular h",
    "id": "templates-*-overview-*-angular-5"
  },
  {
    "url": "https://angular.dev/guide/templates",
    "title": "Templates • Overview • Angular",
    "chunk": "andles whitespace. Social MediaBlogX (formerly Twitter)BlueskyYouTube Discord GitHub Stack Overflow Community Contribute Code of Conduct Report Issues Google's DevLibrary Angular Google Developer Experts ResourcesPress KitRoadmapLanguages简体中文版正體中文版日本語版한국어 Ελληνικά Super-powered by Google ©2010-2025. Code licensed under an MIT-style License . Documentation licensed under CC BY 4.0 . In-depth GuidesTemplates Template syntax In Angular, a template is a chunk of HTML. Use special syntax within a tem",
    "id": "templates-*-overview-*-angular-6"
  },
  {
    "url": "https://angular.dev/guide/templates",
    "title": "Templates • Overview • Angular",
    "chunk": "plate to leverage many of Angular's features.",
    "id": "templates-*-overview-*-angular-7"
  },
  {
    "url": "https://angular.dev/guide/templates/event-listeners",
    "title": "Adding event listeners • Angular",
    "chunk": "In-depth GuidesTemplates Adding event listeners Angular supports defining event listeners on an element in your template by specifying the event name inside parentheses along with a statement that runs every time the event occurs. On this pagearrow_upward_alt Back to the top Listening to native events When you want to add event listeners to an HTML element, you wrap the event with parentheses, (), which allows you to specify a listener statement. @Component({ template: ` <input type=\"text\" (keyu",
    "id": "adding-event-listeners-*-angular-0"
  },
  {
    "url": "https://angular.dev/guide/templates/event-listeners",
    "title": "Adding event listeners • Angular",
    "chunk": "p)=\"updateField()\" /> `, ...})export class AppComponent{ updateField(): void { console.log('Field is updated!'); }} In this example, Angular calls updateField every time the <input> element emits a keyup event. You can add listeners for any native events, such as: click, keydown, mouseover, etc. To learn more, check out the all available events on elements on MDN. Accessing the event argument In every template event listener, Angular provides a variable named $event that contains a reference to ",
    "id": "adding-event-listeners-*-angular-1"
  },
  {
    "url": "https://angular.dev/guide/templates/event-listeners",
    "title": "Adding event listeners • Angular",
    "chunk": "the event object. @Component({ template: ` <input type=\"text\" (keyup)=\"updateField($event)\" /> `, ...})export class AppComponent { updateField(event: KeyboardEvent): void { console.log(`The user pressed: ${event.key}`); }} Using key modifiers When you want to capture specific keyboard events for a specific key, you might write some code like the following: @Component({ template: ` <input type=\"text\" (keyup)=\"updateField($event)\" /> `, ...})export class AppComponent { updateField(event: KeyboardE",
    "id": "adding-event-listeners-*-angular-2"
  },
  {
    "url": "https://angular.dev/guide/templates/event-listeners",
    "title": "Adding event listeners • Angular",
    "chunk": "vent): void { if (event.key === 'Enter') { console.log('The user pressed enter in the text field.'); } }} However, since this is a common scenario, Angular lets you filter the events by specifying a specific key using the period (.) character. By doing so, code can be simplified to: @Component({ template: ` <input type=\"text\" (keyup.enter)=\"updateField($event)\" /> `, ...})export class AppComponent{ updateField(event: KeyboardEvent): void { console.log('The user pressed enter in the text field.')",
    "id": "adding-event-listeners-*-angular-3"
  },
  {
    "url": "https://angular.dev/guide/templates/event-listeners",
    "title": "Adding event listeners • Angular",
    "chunk": "; }} You can also add additional key modifiers: <!-- Matches shift and enter --><input type=\"text\" (keyup.shift.enter)=\"updateField($event)\" /> Angular supports the modifiers alt, control, meta, and shift. You can specify the key or code that you would like to bind to keyboard events. The key and code fields are a native part of the browser keyboard event object. By default, event binding assumes you want to use the Key values for keyboard events. Angular also allows you to specify Code values f",
    "id": "adding-event-listeners-*-angular-4"
  },
  {
    "url": "https://angular.dev/guide/templates/event-listeners",
    "title": "Adding event listeners • Angular",
    "chunk": "or keyboard events by providing a built-in code suffix. <!-- Matches alt and left shift --><input type=\"text\" (keydown.code.alt.shiftleft)=\"updateField($event)\" /> This can be useful for handling keyboard events consistently across different operating systems. For example, when using the Alt key on MacOS devices, the key property reports the key based on the character already modified by the Alt key. This means that a combination like Alt + S reports a key value of 'ß'. The code property, howeve",
    "id": "adding-event-listeners-*-angular-5"
  },
  {
    "url": "https://angular.dev/guide/templates/event-listeners",
    "title": "Adding event listeners • Angular",
    "chunk": "r, corresponds to the physical or virtual button pressed rather than the character produced. Preventing event default behavior If your event handler should replace the native browser behavior, you can use the event object's preventDefault method: @Component({ template: ` <a href=\"#overlay\" (click)=\"showOverlay($event)\"> `, ...})export class AppComponent{ showOverlay(event: PointerEvent): void { event.preventDefault(); console.log('Show overlay without updating the URL!'); }} If the event handler",
    "id": "adding-event-listeners-*-angular-6"
  },
  {
    "url": "https://angular.dev/guide/templates/event-listeners",
    "title": "Adding event listeners • Angular",
    "chunk": " statement evaluates to false, Angular automatically calls preventDefault(), similar to native event handler attributes. Always prefer explicitly calling preventDefault, as this approach makes the code's intent obvious. Social MediaBlogX (formerly Twitter)BlueskyYouTube Discord GitHub Stack Overflow Community Contribute Code of Conduct Report Issues Google's DevLibrary Angular Google Developer Experts ResourcesPress KitRoadmapLanguages简体中文版正體中文版日本語版한국어 Ελληνικά Super-powered by Google ©2010-2025",
    "id": "adding-event-listeners-*-angular-7"
  },
  {
    "url": "https://angular.dev/guide/templates/event-listeners",
    "title": "Adding event listeners • Angular",
    "chunk": ". Code licensed under an MIT-style License . Documentation licensed under CC BY 4.0 .",
    "id": "adding-event-listeners-*-angular-8"
  },
  {
    "url": "https://angular.dev/guide/templates/binding",
    "title": "Binding dynamic text, properties and attributes • Angular",
    "chunk": "In-depth GuidesTemplates Binding dynamic text, properties and attributes In Angular, a binding creates a dynamic connection between a component's template and its data. This connection ensures that changes to the component's data automatically update the rendered template. On this pagearrow_upward_alt Back to the top Render dynamic text with text interpolation You can bind dynamic text in templates with double curly braces, which tells Angular that it is responsible for the expression inside and",
    "id": "binding-dynamic-text-properties-and-attributes-*-angular-0"
  },
  {
    "url": "https://angular.dev/guide/templates/binding",
    "title": "Binding dynamic text, properties and attributes • Angular",
    "chunk": " ensuring it is updated correctly. This is called text interpolation. @Component({ template: ` <p>Your color preference is {{ theme }}.</p> `, ...})export class AppComponent { theme = 'dark';} In this example, when the snippet is rendered to the page, Angular will replace {{ theme }} with dark. <!-- Rendered Output --><p>Your color preference is dark.</p> In addition to evaluating the expression at first render, Angular also updates the rendered content when the expression's value changes. Conti",
    "id": "binding-dynamic-text-properties-and-attributes-*-angular-1"
  },
  {
    "url": "https://angular.dev/guide/templates/binding",
    "title": "Binding dynamic text, properties and attributes • Angular",
    "chunk": "nuing the theme example, if a user clicks on a button that changes the value of theme to 'light' after the page loads, the page updates accordingly to: <!-- Rendered Output --><p>Your color preference is light.</p> You can use text interpolation anywhere you would normally write text in HTML. All expression values are converted to a string. Objects and arrays are converted using the value’s toString method. Binding dynamic properties and attributes Angular supports binding dynamic values into ob",
    "id": "binding-dynamic-text-properties-and-attributes-*-angular-2"
  },
  {
    "url": "https://angular.dev/guide/templates/binding",
    "title": "Binding dynamic text, properties and attributes • Angular",
    "chunk": "ject properties and HTML attributes with square brackets. You can bind to properties on an HTML element's DOM instance, a component instance, or a directive instance. Native element properties Every HTML element has a corresponding DOM representation. For example, each <button> HTML element corresponds to an instance of HTMLButtonElement in the DOM. In Angular, you use property bindings to set values directly to the DOM representation of the element. <!-- Bind the `disabled` property on the butt",
    "id": "binding-dynamic-text-properties-and-attributes-*-angular-3"
  },
  {
    "url": "https://angular.dev/guide/templates/binding",
    "title": "Binding dynamic text, properties and attributes • Angular",
    "chunk": "on element's DOM object --><button [disabled]=\"isFormValid\">Save</button> In this example, every time isFormValid changes, Angular automatically sets the disabled property of the HTMLButtonElement instance. Component and directive properties When an element is an Angular component, you can use property bindings to set component input properties using the same square bracket syntax. <!-- Bind the `value` property on the `MyListbox` component instance. --><my-listbox [value]=\"mySelection\" /> In th",
    "id": "binding-dynamic-text-properties-and-attributes-*-angular-4"
  },
  {
    "url": "https://angular.dev/guide/templates/binding",
    "title": "Binding dynamic text, properties and attributes • Angular",
    "chunk": "is example, every time mySelection changes, Angular automatically sets the value property of the MyListbox instance. You can bind to directive properties as well. <!-- Bind to the `ngSrc` property of the `NgOptimizedImage` directive --><img [ngSrc]=\"profilePhotoUrl\" alt=\"The current user's profile photo\"> Attributes When you need to set HTML attributes that do not have corresponding DOM properties, such as ARIA attributes or SVG attributes, you can bind attributes to elements in your template wi",
    "id": "binding-dynamic-text-properties-and-attributes-*-angular-5"
  },
  {
    "url": "https://angular.dev/guide/templates/binding",
    "title": "Binding dynamic text, properties and attributes • Angular",
    "chunk": "th the attr. prefix. <!-- Bind the `role` attribute on the `<ul>` element to the component's `listRole` property. --><ul [attr.role]=\"listRole\"> In this example, every time listRole changes, Angular automatically sets the role attribute of the <ul> element by calling setAttribute. If the value of an attribute binding is null, Angular removes the attribute by calling removeAttribute. Text interpolation in properties and attributes You can also use text interpolation syntax in properties and attri",
    "id": "binding-dynamic-text-properties-and-attributes-*-angular-6"
  },
  {
    "url": "https://angular.dev/guide/templates/binding",
    "title": "Binding dynamic text, properties and attributes • Angular",
    "chunk": "butes by using the double curly brace syntax instead of square braces around the property or attribute name. When using this syntax, Angular treats the assignment as a property binding. <!-- Binds a value to the `alt` property of the image element's DOM object. --><img src=\"profile-photo.jpg\" alt=\"Profile photo of {{ firstName }}\" > To bind to an attribute with the text interpolation syntax, prefix the attribute name with attr. <button attr.aria-label=\"Save changes to {{ objectType }}\"> CSS clas",
    "id": "binding-dynamic-text-properties-and-attributes-*-angular-7"
  },
  {
    "url": "https://angular.dev/guide/templates/binding",
    "title": "Binding dynamic text, properties and attributes • Angular",
    "chunk": "s and style property bindings Angular supports additional features for binding CSS classes and CSS style properties to elements. CSS classes You can create a CSS class binding to conditionally add or remove a CSS class on an element based on whether the bound value is truthy or falsy. <!-- When `isExpanded` is truthy, add the `expanded` CSS class. --><ul [class.expanded]=\"isExpanded\"> You can also bind directly to the class property. Angular accepts three types of value: Description of class val",
    "id": "binding-dynamic-text-properties-and-attributes-*-angular-8"
  },
  {
    "url": "https://angular.dev/guide/templates/binding",
    "title": "Binding dynamic text, properties and attributes • Angular",
    "chunk": "ue TypeScript type A string containing one or more CSS classes separated by spaces string An array of CSS class strings string[] An object where each property name is a CSS class name and each corresponding value determines whether that class is applied to the element, based on truthiness. Record<string, any> @Component({ template: ` <ul [class]=\"listClasses\"> ... </ul> <section [class]=\"sectionClasses\"> ... </section> <button [class]=\"buttonClasses\"> ... </button> `, ...})export class UserProfi",
    "id": "binding-dynamic-text-properties-and-attributes-*-angular-9"
  },
  {
    "url": "https://angular.dev/guide/templates/binding",
    "title": "Binding dynamic text, properties and attributes • Angular",
    "chunk": "le { listClasses = 'full-width outlined'; sectionClasses = ['expandable', 'elevated']; buttonClasses = { highlighted: true, embiggened: false, };} The above example renders the following DOM: <ul class=\"full-width outlined\"> ... </ul><section class=\"expandable elevated\"> ... </section><button class=\"highlighted\"> ... </button> Angular ignores any string values that are not valid CSS class names. When using static CSS classes, directly binding class, and binding specific classes, Angular intellig",
    "id": "binding-dynamic-text-properties-and-attributes-*-angular-10"
  },
  {
    "url": "https://angular.dev/guide/templates/binding",
    "title": "Binding dynamic text, properties and attributes • Angular",
    "chunk": "ently combines all of the classes in the rendered result. @Component({ template: `<ul class=\"list\" [class]=\"listType\" [class.expanded]=\"isExpanded\"> ...`, ...})export class Listbox { listType = 'box'; isExpanded = true;} In the example above, Angular renders the ul element with all three CSS classes. <ul class=\"list box expanded\"> Angular does not guarantee any specific order of CSS classes on rendered elements. When binding class to an array or an object, Angular compares the previous value to ",
    "id": "binding-dynamic-text-properties-and-attributes-*-angular-11"
  },
  {
    "url": "https://angular.dev/guide/templates/binding",
    "title": "Binding dynamic text, properties and attributes • Angular",
    "chunk": "the current value with the triple-equals operator (===). You must create a new object or array instance when you modify these values in order for Angular to apply any updates. If an element has multiple bindings for the same CSS class, Angular resolves collisions by following its style precedence order. CSS style properties You can also bind to CSS style properties directly on an element. <!-- Set the CSS `display` property based on the `isExpanded` property. --><section [style.display]=\"isExpan",
    "id": "binding-dynamic-text-properties-and-attributes-*-angular-12"
  },
  {
    "url": "https://angular.dev/guide/templates/binding",
    "title": "Binding dynamic text, properties and attributes • Angular",
    "chunk": "ded ? 'block' : 'none'\"> You can further specify units for CSS properties that accept units. <!-- Set the CSS `height` property to a pixel value based on the `sectionHeightInPixels` property. --><section [style.height.px]=\"sectionHeightInPixels\"> You can also set multiple style values in one binding. Angular accepts the following types of value: Description of style value TypeScript type A string containing zero or more CSS declarations, such as \"display: flex; margin: 8px\". string An object whe",
    "id": "binding-dynamic-text-properties-and-attributes-*-angular-13"
  },
  {
    "url": "https://angular.dev/guide/templates/binding",
    "title": "Binding dynamic text, properties and attributes • Angular",
    "chunk": "re each property name is a CSS property name and each corresponding value is the value of that CSS property. Record<string, any> @Component({ template: ` <ul [style]=\"listStyles\"> ... </ul> <section [style]=\"sectionStyles\"> ... </section> `, ...})export class UserProfile { listStyles = 'display: flex; padding: 8px'; sectionStyles = { border: '1px solid black', 'font-weight': 'bold', };} The above example renders the following DOM. <ul style=\"display: flex; padding: 8px\"> ... </ul><section style=",
    "id": "binding-dynamic-text-properties-and-attributes-*-angular-14"
  },
  {
    "url": "https://angular.dev/guide/templates/binding",
    "title": "Binding dynamic text, properties and attributes • Angular",
    "chunk": "\"border: 1px solid black; font-weight: bold\"> ... </section> When binding style to an object, Angular compares the previous value to the current value with the triple-equals operator (===). You must create a new object instance when you modify these values in order to Angular to apply any updates. If an element has multiple bindings for the same style property, Angular resolves collisions by following its style precedence order. Social MediaBlogX (formerly Twitter)BlueskyYouTube Discord GitHub S",
    "id": "binding-dynamic-text-properties-and-attributes-*-angular-15"
  },
  {
    "url": "https://angular.dev/guide/templates/binding",
    "title": "Binding dynamic text, properties and attributes • Angular",
    "chunk": "tack Overflow Community Contribute Code of Conduct Report Issues Google's DevLibrary Angular Google Developer Experts ResourcesPress KitRoadmapLanguages简体中文版正體中文版日本語版한국어 Ελληνικά Super-powered by Google ©2010-2025. Code licensed under an MIT-style License . Documentation licensed under CC BY 4.0 .",
    "id": "binding-dynamic-text-properties-and-attributes-*-angular-16"
  },
  {
    "url": "https://angular.dev/guide/templates/control-flow",
    "title": "Control flow • Angular",
    "chunk": "In-depth GuidesTemplates Control flow Angular templates support control flow blocks that let you conditionally show, hide, and repeat elements. On this pagearrow_upward_alt Back to the top Conditionally display content with @if, @else-if and @else The @if block conditionally displays its content when its condition expression is truthy: @if (a > b) { <p>{{a}} is greater than {{b}}</p>} If you want to display alternative content, you can do so by providing any number of @else if blocks and a singu",
    "id": "control-flow-*-angular-0"
  },
  {
    "url": "https://angular.dev/guide/templates/control-flow",
    "title": "Control flow • Angular",
    "chunk": "lar @else block. @if (a > b) { {{a}} is greater than {{b}}} @else if (b > a) { {{a}} is less than {{b}}} @else { {{a}} is equal to {{b}}} Referencing the conditional expression's result The @if conditional supports saving the result of the conditional expression into a variable for reuse inside of the block. @if (user.profile.settings.startDate; as startDate) { {{ startDate }}} This can be useful for referencing longer expressions that would be easier to read and maintain within the template. Re",
    "id": "control-flow-*-angular-1"
  },
  {
    "url": "https://angular.dev/guide/templates/control-flow",
    "title": "Control flow • Angular",
    "chunk": "peat content with the @for block The @for block loops through a collection and repeatedly renders the content of a block. The collection can be any JavaScript iterable, but Angular has additional performance optimizations for Array values. A typical @for loop looks like: @for (item of items; track item.id) { {{ item.name }}} Angular's @for block does not support flow-modifying statements like JavaScript's continue or break. Why is track in @for blocks important? The track expression allows Angul",
    "id": "control-flow-*-angular-2"
  },
  {
    "url": "https://angular.dev/guide/templates/control-flow",
    "title": "Control flow • Angular",
    "chunk": "ar to maintain a relationship between your data and the DOM nodes on the page. This allows Angular to optimize performance by executing the minimum necessary DOM operations when the data changes. Using track effectively can significantly improve your application's rendering performance when looping over data collections. Select a property that uniquely identifies each item in the track expression. If your data model includes a uniquely identifying property, commonly id or uuid, use this value. I",
    "id": "control-flow-*-angular-3"
  },
  {
    "url": "https://angular.dev/guide/templates/control-flow",
    "title": "Control flow • Angular",
    "chunk": "f your data does not include a field like this, strongly consider adding one. For static collections that never change, you can use $index to tell Angular to track each item by its index in the collection. If no other option is available, you can specify identity. This tells Angular to track the item by its reference identity using the triple-equals operator (===). Avoid this option whenever possible as it can lead to significantly slower rendering updates, as Angular has no way to map which dat",
    "id": "control-flow-*-angular-4"
  },
  {
    "url": "https://angular.dev/guide/templates/control-flow",
    "title": "Control flow • Angular",
    "chunk": "a item corresponds to which DOM nodes. Contextual variables in @for blocks Inside @for blocks, several implicit variables are always available: Variable Meaning $count Number of items in a collection iterated over $index Index of the current row $first Whether the current row is the first row $last Whether the current row is the last row $even Whether the current row index is even $odd Whether the current row index is odd These variables are always available with these names, but can be aliased ",
    "id": "control-flow-*-angular-5"
  },
  {
    "url": "https://angular.dev/guide/templates/control-flow",
    "title": "Control flow • Angular",
    "chunk": "via a let segment: @for (item of items; track item.id; let idx = $index, e = $even) { <p>Item #{{ idx }}: {{ item.name }}</p>} The aliasing is useful when nesting @for blocks, letting you read variables from the outer @for block from an inner @for block. Providing a fallback for @for blocks with the @empty block You can optionally include an @empty section immediately after the @for block content. The content of the @empty block displays when there are no items: @for (item of items; track item.n",
    "id": "control-flow-*-angular-6"
  },
  {
    "url": "https://angular.dev/guide/templates/control-flow",
    "title": "Control flow • Angular",
    "chunk": "ame) { <li> {{ item.name }}</li>} @empty { <li aria-hidden=\"true\"> There are no items. </li>} Conditionally display content with the @switch block While the @if block is great for most scenarios, the @switch block provides an alternate syntax to conditionally render data. Its syntax closely resembles JavaScript's switch statement. @switch (userPermissions) { @case ('admin') { <app-admin-dashboard /> } @case ('reviewer') { <app-reviewer-dashboard /> } @case ('editor') { <app-editor-dashboard /> }",
    "id": "control-flow-*-angular-7"
  },
  {
    "url": "https://angular.dev/guide/templates/control-flow",
    "title": "Control flow • Angular",
    "chunk": " @default { <app-viewer-dashboard /> }} The value of the conditional expression is compared to the case expression using the triple-equals (===) operator. @switch does not have a fallthrough, so you do not need an equivalent to a break or return statement in the block. You can optionally include a @default block. The content of the @default block displays if none of the preceding case expressions match the switch value. If no @case matches the expression and there is no @default block, nothing i",
    "id": "control-flow-*-angular-8"
  },
  {
    "url": "https://angular.dev/guide/templates/control-flow",
    "title": "Control flow • Angular",
    "chunk": "s shown. Social MediaBlogX (formerly Twitter)BlueskyYouTube Discord GitHub Stack Overflow Community Contribute Code of Conduct Report Issues Google's DevLibrary Angular Google Developer Experts ResourcesPress KitRoadmapLanguages简体中文版正體中文版日本語版한국어 Ελληνικά Super-powered by Google ©2010-2025. Code licensed under an MIT-style License . Documentation licensed under CC BY 4.0 .",
    "id": "control-flow-*-angular-9"
  },
  {
    "url": "https://angular.dev/guide/templates/variables",
    "title": "Variables in templates • Angular",
    "chunk": "In-depth GuidesTemplates Variables in templates Angular has two types of variable declarations in templates: local template variables and template reference variables. On this pagearrow_upward_alt Back to the top Local template variables with @let Angular's @let syntax allows you to define a local variable and re-use it across a template, similar to the JavaScript let syntax. Using @let Use @let to declare a variable whose value is based on the result of a template expression. Angular automatica",
    "id": "variables-in-templates-*-angular-0"
  },
  {
    "url": "https://angular.dev/guide/templates/variables",
    "title": "Variables in templates • Angular",
    "chunk": "lly keeps the variable's value up-to-date with the given expression, similar to bindings. @let name = user.name;@let greeting = 'Hello, ' + name;@let data = data$ | async;@let pi = 3.1459;@let coordinates = {x: 50, y: 100};@let longExpression = 'Lorem ipsum dolor sit amet, consectetur adipiscing elit ' + 'sed do eiusmod tempor incididunt ut labore et dolore magna ' + 'Ut enim ad minim veniam...'; Each @let block can declare exactly one variable. You cannot declare multiple variables in the same ",
    "id": "variables-in-templates-*-angular-1"
  },
  {
    "url": "https://angular.dev/guide/templates/variables",
    "title": "Variables in templates • Angular",
    "chunk": "block with a comma. Referencing the value of @let Once you've declared a variable with @let, you can reuse it in the same template: @let user = user$ | async;@if (user) { <h1>Hello, {{user.name}}</h1> <user-avatar [photo]=\"user.photo\"/> <ul> @for (snack of user.favoriteSnacks; track snack.id) { <li>{{snack.name}}</li> } </ul> <button (click)=\"update(user)\">Update profile</button>} Assignability A key difference between @let and JavaScript's let is that @let cannot be reassigned after declaration",
    "id": "variables-in-templates-*-angular-2"
  },
  {
    "url": "https://angular.dev/guide/templates/variables",
    "title": "Variables in templates • Angular",
    "chunk": ". However, Angular automatically keeps the variable's value up-to-date with the given expression. @let value = 1;<!-- Invalid - This does not work! --><button (click)=\"value = value + 1\">Increment the value</button> Variable scope @let declarations are scoped to the current view and its descendants. Angular creates a new view at component boundaries and wherever a template might contain dynamic content, such as control flow blocks, @defer blocks, or structural directives. Since @let declarations",
    "id": "variables-in-templates-*-angular-3"
  },
  {
    "url": "https://angular.dev/guide/templates/variables",
    "title": "Variables in templates • Angular",
    "chunk": " are not hoisted, they cannot be accessed by parent views or siblings: @let topLevel = value;<div> @let insideDiv = value;</div>{{topLevel}} <!-- Valid -->{{insideDiv}} <!-- Valid -->@if (condition) { {{topLevel + insideDiv}} <!-- Valid --> @let nested = value; @if (condition) { {{topLevel + insideDiv + nested}} <!-- Valid --> }}{{nested}} <!-- Error, not hoisted from @if --> Full syntax The @let syntax is formally defined as: The @let keyword. Followed by one or more whitespaces, not including ",
    "id": "variables-in-templates-*-angular-4"
  },
  {
    "url": "https://angular.dev/guide/templates/variables",
    "title": "Variables in templates • Angular",
    "chunk": "new lines. Followed by a valid JavaScript name and zero or more whitespaces. Followed by the = symbol and zero or more whitespaces. Followed by an Angular expression which can be multi-line. Terminated by the ; symbol. Template reference variables Template reference variables give you a way to declare a variable that references a value from an element in your template. A template reference variable can refer to the following: a DOM element within a template (including custom elements) an Angular",
    "id": "variables-in-templates-*-angular-5"
  },
  {
    "url": "https://angular.dev/guide/templates/variables",
    "title": "Variables in templates • Angular",
    "chunk": " component or directive a TemplateRef from an ng-template You can use template reference variables to read information from one part of the template in another part of the same template. Declaring a template reference variable You can declare a variable on an element in a template by adding an attribute that starts with the hash character (#) followed by the variable name. <!-- Create a template reference variable named \"taskInput\", referring to the HTMLInputElement. --><input #taskInput placeho",
    "id": "variables-in-templates-*-angular-6"
  },
  {
    "url": "https://angular.dev/guide/templates/variables",
    "title": "Variables in templates • Angular",
    "chunk": "lder=\"Enter task name\"> Assigning values to template reference variables Angular assigns a value to template variables based on the element on which the variable is declared. If you declare the variable on a Angular component, the variable refers to the component instance. <!-- The `startDate` variable is assigned the instance of `MyDatepicker`. --><my-datepicker #startDate /> If you declare the variable on an <ng-template> element, the variable refers to a TemplateRef instance which represents ",
    "id": "variables-in-templates-*-angular-7"
  },
  {
    "url": "https://angular.dev/guide/templates/variables",
    "title": "Variables in templates • Angular",
    "chunk": "the template. For more information, see How Angular uses the asterisk, *, syntax in Structural directives. <!-- The `myFragment` variable is assigned the `TemplateRef` instance corresponding to this template fragment. --><ng-template #myFragment> <p>This is a template fragment</p></ng-template> If you declare the variable on any other displayed element, the variable refers to the HTMLElement instance. <!-- The \"taskInput\" variable refers to the HTMLInputElement instance. --><input #taskInput pla",
    "id": "variables-in-templates-*-angular-8"
  },
  {
    "url": "https://angular.dev/guide/templates/variables",
    "title": "Variables in templates • Angular",
    "chunk": "ceholder=\"Enter task name\"> Assigning a reference to an Angular directive Angular directives may have an exportAs property that defines a name by which the directive can be referenced in a template: @Directive({ selector: '[dropZone]', exportAs: 'dropZone',})export class DropZone { /* ... */ } When you declare a template variable on an element, you can assign that variable a directive instance by specifying this exportAs name: <!-- The `firstZone` variable refers to the `DropZone` directive inst",
    "id": "variables-in-templates-*-angular-9"
  },
  {
    "url": "https://angular.dev/guide/templates/variables",
    "title": "Variables in templates • Angular",
    "chunk": "ance. --><section dropZone #firstZone=\"dropZone\"> ... </section> You cannot refer to a directive that does not specify an exportAs name. Using template reference variables with queries In addition to using template variables to read values from another part of the same template, you can also use this style of variable declaration to \"mark\" an element for component and directive queries. When you want to query for a specific element in a template, you can declare a template variable on that eleme",
    "id": "variables-in-templates-*-angular-10"
  },
  {
    "url": "https://angular.dev/guide/templates/variables",
    "title": "Variables in templates • Angular",
    "chunk": "nt and then query for the element based on the variable name. <input #description value=\"Original description\"> @Component({ /* ... */, template: `<input #description value=\"Original description\">`,})export class AppComponent { // Query for the input element based on the template variable name. @ViewChild('description') input: ElementRef | undefined;} See Referencing children with queries for more information on queries. Social MediaBlogX (formerly Twitter)BlueskyYouTube Discord GitHub Stack Ove",
    "id": "variables-in-templates-*-angular-11"
  },
  {
    "url": "https://angular.dev/guide/templates/variables",
    "title": "Variables in templates • Angular",
    "chunk": "rflow Community Contribute Code of Conduct Report Issues Google's DevLibrary Angular Google Developer Experts ResourcesPress KitRoadmapLanguages简体中文版正體中文版日本語版한국어 Ελληνικά Super-powered by Google ©2010-2025. Code licensed under an MIT-style License . Documentation licensed under CC BY 4.0 .",
    "id": "variables-in-templates-*-angular-12"
  },
  {
    "url": "https://angular.dev/guide/templates/defer",
    "title": "Deferred loading with @defer • Angular",
    "chunk": "In-depth GuidesTemplates Deferred loading with @defer Deferrable views, also known as @defer blocks, reduce the initial bundle size of your application by deferring the loading of code that is not strictly necessary for the initial rendering of a page. This often results in a faster initial load and improvement in Core Web Vitals (CWV), primarily Largest Contentful Paint (LCP) and Time to First Byte (TTFB). To use this feature, you can declaratively wrap a section of your template in a @defer bl",
    "id": "deferred-loading-with-@defer-*-angular-0"
  },
  {
    "url": "https://angular.dev/guide/templates/defer",
    "title": "Deferred loading with @defer • Angular",
    "chunk": "ock: @defer { <large-component />} The code for any components, directives, and pipes inside the @defer block is split into a separate JavaScript file and loaded only when necessary, after the rest of the template has been rendered. Deferrable views support a variety of triggers, prefetching options, and sub-blocks for placeholder, loading, and error state management. On this pagearrow_upward_alt Back to the top Which dependencies are deferred? Components, directives, pipes, and any component CS",
    "id": "deferred-loading-with-@defer-*-angular-1"
  },
  {
    "url": "https://angular.dev/guide/templates/defer",
    "title": "Deferred loading with @defer • Angular",
    "chunk": "S styles can be deferred when loading an application. In order for the dependencies within a @defer block to be deferred, they need to meet two conditions: They must be standalone. Non-standalone dependencies cannot be deferred and are still eagerly loaded, even if they are inside of @defer blocks. They cannot be referenced outside of @defer blocks within the same file. If they are referenced outside the @defer block or referenced within ViewChild queries, the dependencies will be eagerly loaded",
    "id": "deferred-loading-with-@defer-*-angular-2"
  },
  {
    "url": "https://angular.dev/guide/templates/defer",
    "title": "Deferred loading with @defer • Angular",
    "chunk": ". The transitive dependencies of the components, directives and pipes used in the @defer block do not strictly need to be standalone; transitive dependencies can still be declared in an NgModule and participate in deferred loading. Angular's compiler produces a dynamic import statement for each component, directive, and pipe used in the @defer block. The main content of the block renders after all the imports resolve. Angular does not guarantee any particular order for these imports. How to mana",
    "id": "deferred-loading-with-@defer-*-angular-3"
  },
  {
    "url": "https://angular.dev/guide/templates/defer",
    "title": "Deferred loading with @defer • Angular",
    "chunk": "ge different stages of deferred loading @defer blocks have several sub blocks to allow you to gracefully handle different stages in the deferred loading process. @defer This is the primary block that defines the section of content that is lazily loaded. It is not rendered initially– deferred content loads and renders once the specified trigger occurs or the when condition is met. By default, a @defer block is triggered when the browser state becomes idle. @defer { <large-component />} Show place",
    "id": "deferred-loading-with-@defer-*-angular-4"
  },
  {
    "url": "https://angular.dev/guide/templates/defer",
    "title": "Deferred loading with @defer • Angular",
    "chunk": "holder content with @placeholder By default, defer blocks do not render any content before they are triggered. The @placeholder is an optional block that declares what content to show before the @defer block is triggered. @defer { <large-component />} @placeholder { <p>Placeholder content</p>} While optional, certain triggers may require the presence of either a @placeholder or a template reference variable to function. See the Triggers section for more details. Angular replaces placeholder cont",
    "id": "deferred-loading-with-@defer-*-angular-5"
  },
  {
    "url": "https://angular.dev/guide/templates/defer",
    "title": "Deferred loading with @defer • Angular",
    "chunk": "ent with the main content once loading is complete. You can use any content in the placeholder section including plain HTML, components, directives, and pipes. Keep in mind the dependencies of the placeholder block are eagerly loaded. The @placeholder block accepts an optional parameter to specify the minimum amount of time that this placeholder should be shown after the placeholder content initially renders. @defer { <large-component />} @placeholder (minimum 500ms) { <p>Placeholder content</p>",
    "id": "deferred-loading-with-@defer-*-angular-6"
  },
  {
    "url": "https://angular.dev/guide/templates/defer",
    "title": "Deferred loading with @defer • Angular",
    "chunk": "} This minimum parameter is specified in time increments of milliseconds (ms) or seconds (s). You can use this parameter to prevent fast flickering of placeholder content in the case that the deferred dependencies are fetched quickly. Show loading content with @loading The @loading block is an optional block that allows you to declare content that is shown while deferred dependencies are loading. It replaces the @placeholder block once loading is triggered. @defer { <large-component />} @loading",
    "id": "deferred-loading-with-@defer-*-angular-7"
  },
  {
    "url": "https://angular.dev/guide/templates/defer",
    "title": "Deferred loading with @defer • Angular",
    "chunk": " { <img alt=\"loading...\" src=\"loading.gif\" />} @placeholder { <p>Placeholder content</p>} Its dependencies are eagerly loaded (similar to @placeholder). The @loading block accepts two optional parameters to help prevent fast flickering of content that may occur when deferred dependencies are fetched quickly,: minimum - the minimum amount of time that this placeholder should be shown after - the amount of time to wait after loading begins before showing the loading template @defer { <large-compon",
    "id": "deferred-loading-with-@defer-*-angular-8"
  },
  {
    "url": "https://angular.dev/guide/templates/defer",
    "title": "Deferred loading with @defer • Angular",
    "chunk": "ent />} @loading (after 100ms; minimum 1s) { <img alt=\"loading...\" src=\"loading.gif\" />} Both parameters are specified in time increments of milliseconds (ms) or seconds (s). In addition, the timers for both parameters begin immediately after the loading has been triggered. Show error state when deferred loading fails with @error The @error block is an optional block that displays if deferred loading fails. Similar to @placeholder and @loading, the dependencies of the @error block are eagerly lo",
    "id": "deferred-loading-with-@defer-*-angular-9"
  },
  {
    "url": "https://angular.dev/guide/templates/defer",
    "title": "Deferred loading with @defer • Angular",
    "chunk": "aded. @defer { <large-component />} @error { <p>Failed to load large component.</p>} Controlling deferred content loading with triggers You can specify triggers that control when Angular loads and displays deferred content. When a @defer block is triggered, it replaces placeholder content with lazily loaded content. Multiple event triggers can be defined by separating them with a semicolon, ; and will be evaluated as OR conditions. There are two types of triggers: on and when. on on specifies a ",
    "id": "deferred-loading-with-@defer-*-angular-10"
  },
  {
    "url": "https://angular.dev/guide/templates/defer",
    "title": "Deferred loading with @defer • Angular",
    "chunk": "condition for when the @defer block is triggered. The available triggers are as follows: Trigger Description idle Triggers when the browser is idle. viewport Triggers when specified content enters the viewport interaction Triggers when the user interacts with specified element hover Triggers when the mouse hovers over specified area immediate Triggers immediately after non-deferred content has finished rendering timer Triggers after a specific duration idle The idle trigger loads the deferred co",
    "id": "deferred-loading-with-@defer-*-angular-11"
  },
  {
    "url": "https://angular.dev/guide/templates/defer",
    "title": "Deferred loading with @defer • Angular",
    "chunk": "ntent once the browser has reached an idle state, based on requestIdleCallback. This is the default behavior with a defer block. <!-- @defer (on idle) -->@defer { <large-cmp />} @placeholder { <div>Large component placeholder</div>} viewport The viewport trigger loads the deferred content when the specified content enters the viewport using the Intersection Observer API. Observed content may be @placeholder content or an explicit element reference. By default, the @defer watches for the placehol",
    "id": "deferred-loading-with-@defer-*-angular-12"
  },
  {
    "url": "https://angular.dev/guide/templates/defer",
    "title": "Deferred loading with @defer • Angular",
    "chunk": "der entering the viewport. Placeholders used this way must have a single root element. @defer (on viewport) { <large-cmp />} @placeholder { <div>Large component placeholder</div>} Alternatively, you can specify a template reference variable in the same template as the @defer block as the element that is watched to enter the viewport. This variable is passed in as a parameter on the viewport trigger. <div #greeting>Hello!</div>@defer (on viewport(greeting)) { <greetings-cmp />} interaction The in",
    "id": "deferred-loading-with-@defer-*-angular-13"
  },
  {
    "url": "https://angular.dev/guide/templates/defer",
    "title": "Deferred loading with @defer • Angular",
    "chunk": "teraction trigger loads the deferred content when the user interacts with the specified element through click or keydown events. By default, the placeholder acts as the interaction element. Placeholders used this way must have a single root element. @defer (on interaction) { <large-cmp />} @placeholder { <div>Large component placeholder</div>} Alternatively, you can specify a template reference variable in the same template as the @defer block as the element that is watched for interactions. Thi",
    "id": "deferred-loading-with-@defer-*-angular-14"
  },
  {
    "url": "https://angular.dev/guide/templates/defer",
    "title": "Deferred loading with @defer • Angular",
    "chunk": "s variable is passed in as a parameter on the viewport trigger. <div #greeting>Hello!</div>@defer (on interaction(greeting)) { <greetings-cmp />} hover The hover trigger loads the deferred content when the mouse has hovered over the triggered area through the mouseover and focusin events. By default, the placeholder acts as the interaction element. Placeholders used this way must have a single root element. @defer (on hover) { <large-cmp />} @placeholder { <div>Large component placeholder</div>}",
    "id": "deferred-loading-with-@defer-*-angular-15"
  },
  {
    "url": "https://angular.dev/guide/templates/defer",
    "title": "Deferred loading with @defer • Angular",
    "chunk": " Alternatively, you can specify a template reference variable in the same template as the @defer block as the element that is watched to enter the viewport. This variable is passed in as a parameter on the viewport trigger. <div #greeting>Hello!</div>@defer (on hover(greeting)) { <greetings-cmp />} immediate The immediate trigger loads the deferred content immediately. This means that the deferred block loads as soon as all other non-deferred content has finished rendering. @defer (on immediate)",
    "id": "deferred-loading-with-@defer-*-angular-16"
  },
  {
    "url": "https://angular.dev/guide/templates/defer",
    "title": "Deferred loading with @defer • Angular",
    "chunk": " { <large-cmp />} @placeholder { <div>Large component placeholder</div>} timer The timer trigger loads the deferred content after a specified duration. @defer (on timer(500ms)) { <large-cmp />} @placeholder { <div>Large component placeholder</div>} The duration parameter must be specified in milliseconds (ms) or seconds (s). when The when trigger accepts a custom conditional expression and loads the deferred content when the condition becomes truthy. @defer (when condition) { <large-cmp />} @pla",
    "id": "deferred-loading-with-@defer-*-angular-17"
  },
  {
    "url": "https://angular.dev/guide/templates/defer",
    "title": "Deferred loading with @defer • Angular",
    "chunk": "ceholder { <div>Large component placeholder</div>} This is a one-time operation– the @defer block does not revert back to the placeholder if the condition changes to a falsy value after becoming truthy. Prefetching data with prefetch In addition to specifying a condition that determines when deferred content is shown, you can optionally specify a prefetch trigger. This trigger lets you load the JavaScript associated with the @defer block before the deferred content is shown. Prefetching enables ",
    "id": "deferred-loading-with-@defer-*-angular-18"
  },
  {
    "url": "https://angular.dev/guide/templates/defer",
    "title": "Deferred loading with @defer • Angular",
    "chunk": "more advanced behaviors, such as letting you start to prefetch resources before a user has actually seen or interacted with a defer block, but might interact with it soon, making the resources available faster. You can specify a prefetch trigger similarly to the block's main trigger, but prefixed with the prefetch keyword. The block's main trigger and prefetch trigger are separated with a semi-colon character (;). In the example below, the prefetching starts when a browser becomes idle and the c",
    "id": "deferred-loading-with-@defer-*-angular-19"
  },
  {
    "url": "https://angular.dev/guide/templates/defer",
    "title": "Deferred loading with @defer • Angular",
    "chunk": "ontents of the block is rendered only once the user interacts with the placeholder. @defer (on interaction; prefetch on idle) { <large-cmp />} @placeholder { <div>Large component placeholder</div>} Testing @defer blocks Angular provides TestBed APIs to simplify the process of testing @defer blocks and triggering different states during testing. By default, @defer blocks in tests play through like a defer block would behave in a real application. If you want to manually step through states, you c",
    "id": "deferred-loading-with-@defer-*-angular-20"
  },
  {
    "url": "https://angular.dev/guide/templates/defer",
    "title": "Deferred loading with @defer • Angular",
    "chunk": "an switch the defer block behavior to Manual in the TestBed configuration. it('should render a defer block in different states', async () => { // configures the defer block behavior to start in \"paused\" state for manual control. TestBed.configureTestingModule({deferBlockBehavior: DeferBlockBehavior.Manual}); @Component({ // ... template: ` @defer { <large-component /> } @placeholder { Placeholder } @loading { Loading... } ` }) class ComponentA {} // Create component fixture. const componentFixtu",
    "id": "deferred-loading-with-@defer-*-angular-21"
  },
  {
    "url": "https://angular.dev/guide/templates/defer",
    "title": "Deferred loading with @defer • Angular",
    "chunk": "re = TestBed.createComponent(ComponentA); // Retrieve the list of all defer block fixtures and get the first block. const deferBlockFixture = (await componentFixture.getDeferBlocks())[0]; // Renders placeholder state by default. expect(componentFixture.nativeElement.innerHTML).toContain('Placeholder'); // Render loading state and verify rendered output. await deferBlockFixture.render(DeferBlockState.Loading); expect(componentFixture.nativeElement.innerHTML).toContain('Loading'); // Render final ",
    "id": "deferred-loading-with-@defer-*-angular-22"
  },
  {
    "url": "https://angular.dev/guide/templates/defer",
    "title": "Deferred loading with @defer • Angular",
    "chunk": "state and verify the output. await deferBlockFixture.render(DeferBlockState.Complete); expect(componentFixture.nativeElement.innerHTML).toContain('large works!');}); Does @defer work with NgModule? @defer blocks are compatible with both standalone and NgModule-based components, directives and pipes. However, only standalone components, directives and pipes can be deferred. NgModule-based dependencies are not deferred and are included in the eagerly loaded bundle. How does @defer work with server",
    "id": "deferred-loading-with-@defer-*-angular-23"
  },
  {
    "url": "https://angular.dev/guide/templates/defer",
    "title": "Deferred loading with @defer • Angular",
    "chunk": "-side rendering (SSR) and static-site generation (SSG)? By default, when rendering an application on the server (either using SSR or SSG), defer blocks always render their @placeholder (or nothing if a placeholder is not specified) and triggers are not invoked. On the client, the content of the @placeholder is hydrated and triggers are activated. To render the main content of @defer blocks on the server (both SSR and SSG), you can enable the Incremental Hydration feature and configure hydrate tr",
    "id": "deferred-loading-with-@defer-*-angular-24"
  },
  {
    "url": "https://angular.dev/guide/templates/defer",
    "title": "Deferred loading with @defer • Angular",
    "chunk": "iggers for the necessary blocks. Best practices for deferring views Avoid cascading loads with nested @defer blocks When you have nested @defer blocks, they should have different triggers in order to avoid loading simultaneously, which causes cascading requests and may negatively impact page load performance. Avoid layout shifts Avoid deferring components that are visible in the user’s viewport on initial load. Doing this may negatively affect Core Web Vitals by causing an increase in cumulative",
    "id": "deferred-loading-with-@defer-*-angular-25"
  },
  {
    "url": "https://angular.dev/guide/templates/defer",
    "title": "Deferred loading with @defer • Angular",
    "chunk": " layout shift (CLS). In the event this is necessary, avoid immediate, timer, viewport, and custom when triggers that cause the content to load during the initial page render. Social MediaBlogX (formerly Twitter)BlueskyYouTube Discord GitHub Stack Overflow Community Contribute Code of Conduct Report Issues Google's DevLibrary Angular Google Developer Experts ResourcesPress KitRoadmapLanguages简体中文版正體中文版日本語版한국어 Ελληνικά Super-powered by Google ©2010-2025. Code licensed under an MIT-style License . ",
    "id": "deferred-loading-with-@defer-*-angular-26"
  },
  {
    "url": "https://angular.dev/guide/templates/defer",
    "title": "Deferred loading with @defer • Angular",
    "chunk": "Documentation licensed under CC BY 4.0 .",
    "id": "deferred-loading-with-@defer-*-angular-27"
  },
  {
    "url": "https://angular.dev/guide/templates/expression-syntax",
    "title": "Expression syntax • Angular",
    "chunk": "In-depth GuidesTemplates Expression Syntax Angular expressions are based on JavaScript, but differ in some key ways. This guide walks through the similarities and differences between Angular expressions and standard JavaScript. On this pagearrow_upward_alt Back to the top Value literals Angular supports a subset of literal values from JavaScript. Supported value literals Literal type Example values String 'Hello', \"World\" Boolean true, false Number 123, 3.14 Object {name: 'Alice'} Array ['Onion'",
    "id": "expression-syntax-*-angular-0"
  },
  {
    "url": "https://angular.dev/guide/templates/expression-syntax",
    "title": "Expression syntax • Angular",
    "chunk": ", 'Cheese', 'Garlic'] null null Template string `Hello ${name}` Tagged template string tag`Hello ${name}` Unsupported literals Literal type Example value RegExp /\\d+/ Tagged template string tag`Hello ${name}` Globals Angular expressions support the following globals: undefined $any No other JavaScript globals are supported. Common JavaScript globals include Number, Boolean, NaN, Infinity, parseInt, and more. Local variables Angular automatically makes special local variables available for use in",
    "id": "expression-syntax-*-angular-1"
  },
  {
    "url": "https://angular.dev/guide/templates/expression-syntax",
    "title": "Expression syntax • Angular",
    "chunk": " expressions in specific contexts. These special variables always start with the dollar sign character ($). For example, @for blocks make several local variables corresponding to information about the loop, such as $index. What operators are supported? Supported operators Angular supports the following operators from standard JavaScript. Operator Example(s) Add / Concatenate 1 + 2 Subtract 52 - 3 Multiply 41 * 6 Divide 20 / 4 Remainder (Modulo) 17 % 5 Exponentiation 10 ** 3 Parenthesis 9 * (8 + ",
    "id": "expression-syntax-*-angular-2"
  },
  {
    "url": "https://angular.dev/guide/templates/expression-syntax",
    "title": "Expression syntax • Angular",
    "chunk": "4) Conditional (Ternary) a > b ? true : false And (Logical) && Or (Logical) || Not (Logical) ! Nullish Coalescing possiblyNullValue ?? 'default' Comparison Operators <, <=, >, >=, ==, ===, !== Unary Negation -x Unary Plus +y Property Accessor person['name'] typeof typeof 42 void void 1 in 'model' in car Angular expressions additionally also support the following non-standard operators: Operator Example(s) Pipe {{ total | currency }} Optional chaining* someObj.someProp?.nestedProp Non-null assert",
    "id": "expression-syntax-*-angular-3"
  },
  {
    "url": "https://angular.dev/guide/templates/expression-syntax",
    "title": "Expression syntax • Angular",
    "chunk": "ion (TypeScript) someObj!.someProp NOTE: Optional chaining behaves differently from the standard JavaScript version in that if the left side of Angular’s optional chaining operator is null or undefined, it returns null instead of undefined. Unsupported operators Operator Example(s) All bitwise operators &, &=, ~, |=, ^=, etc. Assignment operators = Object destructuring const { name } = person Array destructuring const [firstItem] = items Comma operator x = (x++, x) in 'model' in car typeof typeo",
    "id": "expression-syntax-*-angular-4"
  },
  {
    "url": "https://angular.dev/guide/templates/expression-syntax",
    "title": "Expression syntax • Angular",
    "chunk": "f 42 void void 1 instanceof car instanceof Automobile new new Car() Lexical context for expressions Angular expressions are evaluated within the context of the component class as well as any relevant template variables, locals, and globals. When referring to component class members, this is always implied. However, if a template declares a template variables with the same name as a member, the variable shadows that member. You can unambiguously reference such a class member by explicitly using t",
    "id": "expression-syntax-*-angular-5"
  },
  {
    "url": "https://angular.dev/guide/templates/expression-syntax",
    "title": "Expression syntax • Angular",
    "chunk": "his.. This can be useful when creating an @let declaration that shadows a class member, e.g. for signal narrowing purposes. Declarations Generally speaking, declarations are not supported in Angular expressions. This includes, but is not limited to: Declarations Example(s) Variables let label = 'abc', const item = 'apple' Functions function myCustomFunction() { } Arrow Functions () => { } Classes class Rectangle { } Event listener statements Event handlers are statements rather than expressions.",
    "id": "expression-syntax-*-angular-6"
  },
  {
    "url": "https://angular.dev/guide/templates/expression-syntax",
    "title": "Expression syntax • Angular",
    "chunk": " While they support all of the same syntax as Angular expressions, the are two key differences: Statements do support assignment operators (but not destructing assignments) Statements do not support pipes Social MediaBlogX (formerly Twitter)BlueskyYouTube Discord GitHub Stack Overflow Community Contribute Code of Conduct Report Issues Google's DevLibrary Angular Google Developer Experts ResourcesPress KitRoadmapLanguages简体中文版正體中文版日本語版한국어 Ελληνικά Super-powered by Google ©2010-2025. Code licensed",
    "id": "expression-syntax-*-angular-7"
  },
  {
    "url": "https://angular.dev/guide/templates/expression-syntax",
    "title": "Expression syntax • Angular",
    "chunk": " under an MIT-style License . Documentation licensed under CC BY 4.0 .",
    "id": "expression-syntax-*-angular-8"
  },
  {
    "url": "https://angular.dev/guide/directives",
    "title": "Directives • Overview • Angular",
    "chunk": "In-depth GuidesDirectives Built-in directives Directives are classes that add additional behavior to elements in your Angular applications. Use Angular's built-in directives to manage forms, lists, styles, and what users see. The different types of Angular directives are as follows: Directive Types Details Components Used with a template. This type of directive is the most common directive type. Attribute directives Change the appearance or behavior of an element, component, or another directive",
    "id": "directives-*-overview-*-angular-0"
  },
  {
    "url": "https://angular.dev/guide/directives",
    "title": "Directives • Overview • Angular",
    "chunk": ". This guide covers built-in attribute directives. On this pagearrow_upward_alt Back to the top Built-in attribute directives Attribute directives listen to and modify the behavior of other HTML elements, attributes, properties, and components. The most common attribute directives are as follows: Common directives Details NgClass Adds and removes a set of CSS classes. NgStyle Adds and removes a set of HTML styles. NgModel Adds two-way data binding to an HTML form element. HELPFUL: Built-in direc",
    "id": "directives-*-overview-*-angular-1"
  },
  {
    "url": "https://angular.dev/guide/directives",
    "title": "Directives • Overview • Angular",
    "chunk": "tives use only public APIs. They do not have special access to any private APIs that other directives can't access. Adding and removing classes with NgClass Add or remove multiple CSS classes simultaneously with ngClass. HELPFUL: To add or remove a single class, use class binding rather than NgClass. Import NgClass in the component To use NgClass, add it to the component's imports list. src/app/app.component.ts (NgClass import) import {Component, OnInit} from '@angular/core';import {JsonPipe} fr",
    "id": "directives-*-overview-*-angular-2"
  },
  {
    "url": "https://angular.dev/guide/directives",
    "title": "Directives • Overview • Angular",
    "chunk": "om '@angular/common';import {NgIf} from '@angular/common';import {NgFor} from '@angular/common';import {NgSwitch, NgSwitchCase, NgSwitchDefault} from '@angular/common';import {NgStyle} from '@angular/common';import {NgClass} from '@angular/common';import {FormsModule} from '@angular/forms';import {Item} from './item';import {ItemDetailComponent} from './item-detail/item-detail.component';import {ItemSwitchComponents} from './item-switch.component';import {StoutItemComponent} from './item-switch.",
    "id": "directives-*-overview-*-angular-3"
  },
  {
    "url": "https://angular.dev/guide/directives",
    "title": "Directives • Overview • Angular",
    "chunk": "component';@Component({ selector: 'app-root', templateUrl: './app.component.html', styleUrls: ['./app.component.css'], imports: [ NgIf, // <-- import into the component NgFor, // <-- import into the component NgStyle, // <-- import into the component NgSwitch, // <-- import into the component NgSwitchCase, NgSwitchDefault, NgClass, // <-- import into the component FormsModule, // <--- import into the component JsonPipe, ItemDetailComponent, ItemSwitchComponents, StoutItemComponent, ],})export cl",
    "id": "directives-*-overview-*-angular-4"
  },
  {
    "url": "https://angular.dev/guide/directives",
    "title": "Directives • Overview • Angular",
    "chunk": "ass AppComponent implements OnInit { canSave = true; isSpecial = true; isUnchanged = true; isActive = true; nullCustomer: string | null = null; currentCustomer = { name: 'Laura', }; item!: Item; // defined to demonstrate template context precedence items: Item[] = []; currentItem!: Item; // trackBy change counting itemsNoTrackByCount = 0; itemsWithTrackByCount = 0; itemsWithTrackByCountReset = 0; itemIdIncrement = 1; currentClasses: Record<string, boolean> = {}; currentStyles: Record<string, str",
    "id": "directives-*-overview-*-angular-5"
  },
  {
    "url": "https://angular.dev/guide/directives",
    "title": "Directives • Overview • Angular",
    "chunk": "ing> = {}; ngOnInit() { this.resetItems(); this.setCurrentClasses(); this.setCurrentStyles(); this.itemsNoTrackByCount = 0; } setUppercaseName(name: string) { this.currentItem.name = name.toUpperCase(); } setCurrentClasses() { // CSS classes: added/removed per current state of component properties this.currentClasses = { saveable: this.canSave, modified: !this.isUnchanged, special: this.isSpecial, }; } setCurrentStyles() { // CSS styles: set per current state of component properties this.current",
    "id": "directives-*-overview-*-angular-6"
  },
  {
    "url": "https://angular.dev/guide/directives",
    "title": "Directives • Overview • Angular",
    "chunk": "Styles = { 'font-style': this.canSave ? 'italic' : 'normal', 'font-weight': !this.isUnchanged ? 'bold' : 'normal', 'font-size': this.isSpecial ? '24px' : '12px', }; } isActiveToggle() { this.isActive = !this.isActive; } giveNullCustomerValue() { this.nullCustomer = 'Kelly'; } resetItems() { this.items = Item.items.map((item) => item.clone()); this.currentItem = this.items[0]; this.item = this.currentItem; } resetList() { this.resetItems(); this.itemsWithTrackByCountReset = 0; this.itemsNoTrackBy",
    "id": "directives-*-overview-*-angular-7"
  },
  {
    "url": "https://angular.dev/guide/directives",
    "title": "Directives • Overview • Angular",
    "chunk": "Count = ++this.itemsNoTrackByCount; } changeIds() { this.items.forEach((i) => (i.id += 1 * this.itemIdIncrement)); this.itemsWithTrackByCountReset = -1; this.itemsNoTrackByCount = ++this.itemsNoTrackByCount; this.itemsWithTrackByCount = ++this.itemsWithTrackByCount; } clearTrackByCounts() { this.resetItems(); this.itemsNoTrackByCount = 0; this.itemsWithTrackByCount = 0; this.itemIdIncrement = 1; } trackByItems(index: number, item: Item): number { return item.id; } trackById(index: number, item: ",
    "id": "directives-*-overview-*-angular-8"
  },
  {
    "url": "https://angular.dev/guide/directives",
    "title": "Directives • Overview • Angular",
    "chunk": "any): number { return item.id; } getValue(event: Event): string { return (event.target as HTMLInputElement).value; }} Using NgClass with an expression On the element you'd like to style, add [ngClass] and set it equal to an expression. In this case, isSpecial is a boolean set to true in app.component.ts. Because isSpecial is true, ngClass applies the class of special to the <div>. src/app/app.component.html <h1>Built-in Directives</h1><h2>Built-in attribute directives</h2><h3 id=\"ngModel\">NgMode",
    "id": "directives-*-overview-*-angular-9"
  },
  {
    "url": "https://angular.dev/guide/directives",
    "title": "Directives • Overview • Angular",
    "chunk": "l (two-way) Binding</h3><fieldset><h4>NgModel examples</h4> <p>Current item name: {{ currentItem.name }}</p> <p> <label for=\"without\">without NgModel:</label> <input [value]=\"currentItem.name\" (input)=\"currentItem.name=getValue($event)\" id=\"without\"> </p> <p> <label for=\"example-ngModel\">[(ngModel)]:</label> <input [(ngModel)]=\"currentItem.name\" id=\"example-ngModel\"> </p> <p> <label for=\"example-change\">(ngModelChange)=\"...name=$event\":</label> <input [ngModel]=\"currentItem.name\" (ngModelChange)",
    "id": "directives-*-overview-*-angular-10"
  },
  {
    "url": "https://angular.dev/guide/directives",
    "title": "Directives • Overview • Angular",
    "chunk": "=\"currentItem.name=$event\" id=\"example-change\"> </p> <p> <label for=\"example-uppercase\">(ngModelChange)=\"setUppercaseName($event)\" <input [ngModel]=\"currentItem.name\" (ngModelChange)=\"setUppercaseName($event)\" id=\"example-uppercase\"> </label> </p></fieldset><hr><h2 id=\"ngClass\">NgClass Binding</h2><p>currentClasses is {{ currentClasses | json }}</p><div [ngClass]=\"currentClasses\">This div is initially saveable, unchanged, and special.</div><ul> <li> <label for=\"saveable\">saveable</label> <input ",
    "id": "directives-*-overview-*-angular-11"
  },
  {
    "url": "https://angular.dev/guide/directives",
    "title": "Directives • Overview • Angular",
    "chunk": "type=\"checkbox\" [(ngModel)]=\"canSave\" id=\"saveable\"> </li> <li> <label for=\"modified\">modified:</label> <input type=\"checkbox\" [value]=\"!isUnchanged\" (change)=\"isUnchanged=!isUnchanged\" id=\"modified\"></li> <li> <label for=\"special\">special: <input type=\"checkbox\" [(ngModel)]=\"isSpecial\" id=\"special\"></label></li></ul><button type=\"button\" (click)=\"setCurrentClasses()\">Refresh currentClasses</button><div [ngClass]=\"currentClasses\"> This div should be {{ canSave ? \"\": \"not\"}} saveable, {{ isUnchan",
    "id": "directives-*-overview-*-angular-12"
  },
  {
    "url": "https://angular.dev/guide/directives",
    "title": "Directives • Overview • Angular",
    "chunk": "ged ? \"unchanged\" : \"modified\" }} and {{ isSpecial ? \"\": \"not\"}} special after clicking \"Refresh\".</div><br><br><!-- toggle the \"special\" class on/off with a property --><div [ngClass]=\"isSpecial ? 'special' : ''\">This div is special</div><div class=\"helpful study course\">Helpful study course</div><div [ngClass]=\"{'helpful':false, 'study':true, 'course':true}\">Study course</div><!-- NgStyle binding --><hr><h3>NgStyle Binding</h3><div [style.font-size]=\"isSpecial ? 'x-large' : 'smaller'\"> This di",
    "id": "directives-*-overview-*-angular-13"
  },
  {
    "url": "https://angular.dev/guide/directives",
    "title": "Directives • Overview • Angular",
    "chunk": "v is x-large or smaller.</div><h4>[ngStyle] binding to currentStyles - CSS property names</h4><p>currentStyles is {{ currentStyles | json }}</p><div [ngStyle]=\"currentStyles\"> This div is initially italic, normal weight, and extra large (24px).</div><br><label for=\"canSave\">italic: <input id=\"canSave\" type=\"checkbox\" [(ngModel)]=\"canSave\"></label> |<label for=\"isUnchanged\">normal: <input id=\"isUnchanged\" type=\"checkbox\" [(ngModel)]=\"isUnchanged\"></label> |<label for=\"isSpecial\">xlarge: <input id",
    "id": "directives-*-overview-*-angular-14"
  },
  {
    "url": "https://angular.dev/guide/directives",
    "title": "Directives • Overview • Angular",
    "chunk": "=\"isSpecial\" type=\"checkbox\" [(ngModel)]=\"isSpecial\"></label><button type=\"button\" (click)=\"setCurrentStyles()\">Refresh currentStyles</button><br><br><div [ngStyle]=\"currentStyles\"> This div should be {{ canSave ? \"italic\": \"plain\"}}, {{ isUnchanged ? \"normal weight\" : \"bold\" }} and, {{ isSpecial ? \"extra large\": \"normal size\"}} after clicking \"Refresh\".</div><hr><h2>Built-in structural directives</h2><h3 id=\"ngIf\">NgIf Binding</h3><div> <p>If isActive is true, app-item-detail will render: </p> ",
    "id": "directives-*-overview-*-angular-15"
  },
  {
    "url": "https://angular.dev/guide/directives",
    "title": "Directives • Overview • Angular",
    "chunk": "<app-item-detail *ngIf=\"isActive\" [item]=\"item\"></app-item-detail> <button type=\"button\" (click)=\"isActiveToggle()\">Toggle app-item-detail</button></div><p>If currentCustomer isn't null, say hello to Laura:</p><div *ngIf=\"currentCustomer\">Hello, {{ currentCustomer.name }}</div><p>nullCustomer is null by default. NgIf guards against null. Give it a value to show it:</p><div *ngIf=\"nullCustomer\">Hello, <span>{{ nullCustomer }}</span></div><button type=\"button\" (click)=\"giveNullCustomerValue()\">Giv",
    "id": "directives-*-overview-*-angular-16"
  },
  {
    "url": "https://angular.dev/guide/directives",
    "title": "Directives • Overview • Angular",
    "chunk": "e nullCustomer a value</button><h4>NgIf binding with template (no *)</h4><ng-template [ngIf]=\"currentItem\">Add {{ currentItem.name }} with template</ng-template><hr><h4>Show/hide vs. NgIf</h4><!-- isSpecial is true --><div [class.hidden]=\"!isSpecial\">Show with class</div><div [class.hidden]=\"isSpecial\">Hide with class</div><p>ItemDetail is in the DOM but hidden</p><app-item-detail [class.hidden]=\"isSpecial\"></app-item-detail><div [style.display]=\"isSpecial ? 'block' : 'none'\">Show with style</di",
    "id": "directives-*-overview-*-angular-17"
  },
  {
    "url": "https://angular.dev/guide/directives",
    "title": "Directives • Overview • Angular",
    "chunk": "v><div [style.display]=\"isSpecial ? 'none' : 'block'\">Hide with style</div><hr><h2 id=\"ngFor\">NgFor Binding</h2><div class=\"box\"> <div *ngFor=\"let item of items\">{{ item.name }}</div></div><p>*ngFor with ItemDetailComponent element</p><div class=\"box\"> <app-item-detail *ngFor=\"let item of items\" [item]=\"item\"></app-item-detail></div><h4 id=\"ngFor-index\">*ngFor with index</h4><p>with <em>semi-colon</em> separator</p><div class=\"box\"> <div *ngFor=\"let item of items; let i=index\">{{ i + 1 }} - {{ i",
    "id": "directives-*-overview-*-angular-18"
  },
  {
    "url": "https://angular.dev/guide/directives",
    "title": "Directives • Overview • Angular",
    "chunk": "tem.name }}</div></div><p>with <em>comma</em> separator</p><div class=\"box\"> <div *ngFor=\"let item of items, let i=index\">{{ i + 1 }} - {{ item.name }}</div></div><h4 id=\"ngFor-trackBy\">*ngFor trackBy</h4><button type=\"button\" (click)=\"resetList()\">Reset items</button><button type=\"button\" (click)=\"changeIds()\">Change ids</button><button type=\"button\" (click)=\"clearTrackByCounts()\">Clear counts</button><p><em>without</em> trackBy</p><div class=\"box\"> <div #noTrackBy *ngFor=\"let item of items\">({",
    "id": "directives-*-overview-*-angular-19"
  },
  {
    "url": "https://angular.dev/guide/directives",
    "title": "Directives • Overview • Angular",
    "chunk": "{ item.id }}) {{ item.name }}</div> <div id=\"noTrackByCnt\" *ngIf=\"itemsNoTrackByCount\" > Item DOM elements change #{{ itemsNoTrackByCount }} without trackBy </div></div><p>with trackBy</p><div class=\"box\"> <div #withTrackBy *ngFor=\"let item of items; trackBy: trackByItems\">({{ item.id }}) {{ item.name }}</div> <div id=\"withTrackByCnt\" *ngIf=\"itemsWithTrackByCount\"> Item DOM elements change #{{ itemsWithTrackByCount }} with trackBy </div></div><br><br><br><p>with trackBy and <em>semi-colon</em> s",
    "id": "directives-*-overview-*-angular-20"
  },
  {
    "url": "https://angular.dev/guide/directives",
    "title": "Directives • Overview • Angular",
    "chunk": "eparator</p><div class=\"box\"> <div *ngFor=\"let item of items; trackBy: trackByItems\"> ({{ item.id }}) {{ item.name }} </div></div><p>with trackBy and <em>comma</em> separator</p><div class=\"box\"> <div *ngFor=\"let item of items, trackBy: trackByItems\">({{ item.id }}) {{ item.name }}</div></div><p>with trackBy and <em>space</em> separator</p><div class=\"box\"> <div *ngFor=\"let item of items trackBy: trackByItems\">({{ item.id }}) {{ item.name }}</div></div><p>with <em>generic</em> trackById function",
    "id": "directives-*-overview-*-angular-21"
  },
  {
    "url": "https://angular.dev/guide/directives",
    "title": "Directives • Overview • Angular",
    "chunk": "</p><div class=\"box\"> <div *ngFor=\"let item of items, trackBy: trackById\">({{ item.id }}) {{ item.name }}</div></div><hr><h2>NgSwitch Binding</h2><p>Pick your favorite item</p><div> <label for=\"item-{{i}}\" *ngFor=\"let i of items\"> <div><input id=\"item-{{i}}\"type=\"radio\" name=\"items\" [(ngModel)]=\"currentItem\" [value]=\"i\">{{ i.name }} </div> </label></div><div [ngSwitch]=\"currentItem.feature\"> <app-stout-item *ngSwitchCase=\"'stout'\" [item]=\"currentItem\"></app-stout-item> <app-device-item *ngSwitch",
    "id": "directives-*-overview-*-angular-22"
  },
  {
    "url": "https://angular.dev/guide/directives",
    "title": "Directives • Overview • Angular",
    "chunk": "Case=\"'slim'\" [item]=\"currentItem\"></app-device-item> <app-lost-item *ngSwitchCase=\"'vintage'\" [item]=\"currentItem\"></app-lost-item> <app-best-item *ngSwitchCase=\"'bright'\" [item]=\"currentItem\"></app-best-item> <div *ngSwitchCase=\"'bright'\">Are you as bright as {{ currentItem.name }}?</div> <app-unknown-item *ngSwitchDefault [item]=\"currentItem\"></app-unknown-item></div> Using NgClass with a method To use NgClass with a method, add the method to the component class. In the following example, set",
    "id": "directives-*-overview-*-angular-23"
  },
  {
    "url": "https://angular.dev/guide/directives",
    "title": "Directives • Overview • Angular",
    "chunk": "CurrentClasses() sets the property currentClasses with an object that adds or removes three classes based on the true or false state of three other component properties. Each key of the object is a CSS class name. If a key is true, ngClass adds the class. If a key is false, ngClass removes the class. src/app/app.component.ts import {Component, OnInit} from '@angular/core';import {JsonPipe} from '@angular/common';import {NgIf} from '@angular/common';import {NgFor} from '@angular/common';import {N",
    "id": "directives-*-overview-*-angular-24"
  },
  {
    "url": "https://angular.dev/guide/directives",
    "title": "Directives • Overview • Angular",
    "chunk": "gSwitch, NgSwitchCase, NgSwitchDefault} from '@angular/common';import {NgStyle} from '@angular/common';import {NgClass} from '@angular/common';import {FormsModule} from '@angular/forms';import {Item} from './item';import {ItemDetailComponent} from './item-detail/item-detail.component';import {ItemSwitchComponents} from './item-switch.component';import {StoutItemComponent} from './item-switch.component';@Component({ selector: 'app-root', templateUrl: './app.component.html', styleUrls: ['./app.com",
    "id": "directives-*-overview-*-angular-25"
  },
  {
    "url": "https://angular.dev/guide/directives",
    "title": "Directives • Overview • Angular",
    "chunk": "ponent.css'], imports: [ NgIf, // <-- import into the component NgFor, // <-- import into the component NgStyle, // <-- import into the component NgSwitch, // <-- import into the component NgSwitchCase, NgSwitchDefault, NgClass, // <-- import into the component FormsModule, // <--- import into the component JsonPipe, ItemDetailComponent, ItemSwitchComponents, StoutItemComponent, ],})export class AppComponent implements OnInit { canSave = true; isSpecial = true; isUnchanged = true; isActive = tru",
    "id": "directives-*-overview-*-angular-26"
  },
  {
    "url": "https://angular.dev/guide/directives",
    "title": "Directives • Overview • Angular",
    "chunk": "e; nullCustomer: string | null = null; currentCustomer = { name: 'Laura', }; item!: Item; // defined to demonstrate template context precedence items: Item[] = []; currentItem!: Item; // trackBy change counting itemsNoTrackByCount = 0; itemsWithTrackByCount = 0; itemsWithTrackByCountReset = 0; itemIdIncrement = 1; currentClasses: Record<string, boolean> = {}; currentStyles: Record<string, string> = {}; ngOnInit() { this.resetItems(); this.setCurrentClasses(); this.setCurrentStyles(); this.itemsN",
    "id": "directives-*-overview-*-angular-27"
  },
  {
    "url": "https://angular.dev/guide/directives",
    "title": "Directives • Overview • Angular",
    "chunk": "oTrackByCount = 0; } setUppercaseName(name: string) { this.currentItem.name = name.toUpperCase(); } setCurrentClasses() { // CSS classes: added/removed per current state of component properties this.currentClasses = { saveable: this.canSave, modified: !this.isUnchanged, special: this.isSpecial, }; } setCurrentStyles() { // CSS styles: set per current state of component properties this.currentStyles = { 'font-style': this.canSave ? 'italic' : 'normal', 'font-weight': !this.isUnchanged ? 'bold' : ",
    "id": "directives-*-overview-*-angular-28"
  },
  {
    "url": "https://angular.dev/guide/directives",
    "title": "Directives • Overview • Angular",
    "chunk": "'normal', 'font-size': this.isSpecial ? '24px' : '12px', }; } isActiveToggle() { this.isActive = !this.isActive; } giveNullCustomerValue() { this.nullCustomer = 'Kelly'; } resetItems() { this.items = Item.items.map((item) => item.clone()); this.currentItem = this.items[0]; this.item = this.currentItem; } resetList() { this.resetItems(); this.itemsWithTrackByCountReset = 0; this.itemsNoTrackByCount = ++this.itemsNoTrackByCount; } changeIds() { this.items.forEach((i) => (i.id += 1 * this.itemIdInc",
    "id": "directives-*-overview-*-angular-29"
  },
  {
    "url": "https://angular.dev/guide/directives",
    "title": "Directives • Overview • Angular",
    "chunk": "rement)); this.itemsWithTrackByCountReset = -1; this.itemsNoTrackByCount = ++this.itemsNoTrackByCount; this.itemsWithTrackByCount = ++this.itemsWithTrackByCount; } clearTrackByCounts() { this.resetItems(); this.itemsNoTrackByCount = 0; this.itemsWithTrackByCount = 0; this.itemIdIncrement = 1; } trackByItems(index: number, item: Item): number { return item.id; } trackById(index: number, item: any): number { return item.id; } getValue(event: Event): string { return (event.target as HTMLInputElemen",
    "id": "directives-*-overview-*-angular-30"
  },
  {
    "url": "https://angular.dev/guide/directives",
    "title": "Directives • Overview • Angular",
    "chunk": "t).value; }} In the template, add the ngClass property binding to currentClasses to set the element's classes: src/app/app.component.html <h1>Built-in Directives</h1><h2>Built-in attribute directives</h2><h3 id=\"ngModel\">NgModel (two-way) Binding</h3><fieldset><h4>NgModel examples</h4> <p>Current item name: {{ currentItem.name }}</p> <p> <label for=\"without\">without NgModel:</label> <input [value]=\"currentItem.name\" (input)=\"currentItem.name=getValue($event)\" id=\"without\"> </p> <p> <label for=\"e",
    "id": "directives-*-overview-*-angular-31"
  },
  {
    "url": "https://angular.dev/guide/directives",
    "title": "Directives • Overview • Angular",
    "chunk": "xample-ngModel\">[(ngModel)]:</label> <input [(ngModel)]=\"currentItem.name\" id=\"example-ngModel\"> </p> <p> <label for=\"example-change\">(ngModelChange)=\"...name=$event\":</label> <input [ngModel]=\"currentItem.name\" (ngModelChange)=\"currentItem.name=$event\" id=\"example-change\"> </p> <p> <label for=\"example-uppercase\">(ngModelChange)=\"setUppercaseName($event)\" <input [ngModel]=\"currentItem.name\" (ngModelChange)=\"setUppercaseName($event)\" id=\"example-uppercase\"> </label> </p></fieldset><hr><h2 id=\"ngC",
    "id": "directives-*-overview-*-angular-32"
  },
  {
    "url": "https://angular.dev/guide/directives",
    "title": "Directives • Overview • Angular",
    "chunk": "lass\">NgClass Binding</h2><p>currentClasses is {{ currentClasses | json }}</p><div [ngClass]=\"currentClasses\">This div is initially saveable, unchanged, and special.</div><ul> <li> <label for=\"saveable\">saveable</label> <input type=\"checkbox\" [(ngModel)]=\"canSave\" id=\"saveable\"> </li> <li> <label for=\"modified\">modified:</label> <input type=\"checkbox\" [value]=\"!isUnchanged\" (change)=\"isUnchanged=!isUnchanged\" id=\"modified\"></li> <li> <label for=\"special\">special: <input type=\"checkbox\" [(ngModel",
    "id": "directives-*-overview-*-angular-33"
  },
  {
    "url": "https://angular.dev/guide/directives",
    "title": "Directives • Overview • Angular",
    "chunk": ")]=\"isSpecial\" id=\"special\"></label></li></ul><button type=\"button\" (click)=\"setCurrentClasses()\">Refresh currentClasses</button><div [ngClass]=\"currentClasses\"> This div should be {{ canSave ? \"\": \"not\"}} saveable, {{ isUnchanged ? \"unchanged\" : \"modified\" }} and {{ isSpecial ? \"\": \"not\"}} special after clicking \"Refresh\".</div><br><br><!-- toggle the \"special\" class on/off with a property --><div [ngClass]=\"isSpecial ? 'special' : ''\">This div is special</div><div class=\"helpful study course\">",
    "id": "directives-*-overview-*-angular-34"
  },
  {
    "url": "https://angular.dev/guide/directives",
    "title": "Directives • Overview • Angular",
    "chunk": "Helpful study course</div><div [ngClass]=\"{'helpful':false, 'study':true, 'course':true}\">Study course</div><!-- NgStyle binding --><hr><h3>NgStyle Binding</h3><div [style.font-size]=\"isSpecial ? 'x-large' : 'smaller'\"> This div is x-large or smaller.</div><h4>[ngStyle] binding to currentStyles - CSS property names</h4><p>currentStyles is {{ currentStyles | json }}</p><div [ngStyle]=\"currentStyles\"> This div is initially italic, normal weight, and extra large (24px).</div><br><label for=\"canSave",
    "id": "directives-*-overview-*-angular-35"
  },
  {
    "url": "https://angular.dev/guide/directives",
    "title": "Directives • Overview • Angular",
    "chunk": "\">italic: <input id=\"canSave\" type=\"checkbox\" [(ngModel)]=\"canSave\"></label> |<label for=\"isUnchanged\">normal: <input id=\"isUnchanged\" type=\"checkbox\" [(ngModel)]=\"isUnchanged\"></label> |<label for=\"isSpecial\">xlarge: <input id=\"isSpecial\" type=\"checkbox\" [(ngModel)]=\"isSpecial\"></label><button type=\"button\" (click)=\"setCurrentStyles()\">Refresh currentStyles</button><br><br><div [ngStyle]=\"currentStyles\"> This div should be {{ canSave ? \"italic\": \"plain\"}}, {{ isUnchanged ? \"normal weight\" : \"bo",
    "id": "directives-*-overview-*-angular-36"
  },
  {
    "url": "https://angular.dev/guide/directives",
    "title": "Directives • Overview • Angular",
    "chunk": "ld\" }} and, {{ isSpecial ? \"extra large\": \"normal size\"}} after clicking \"Refresh\".</div><hr><h2>Built-in structural directives</h2><h3 id=\"ngIf\">NgIf Binding</h3><div> <p>If isActive is true, app-item-detail will render: </p> <app-item-detail *ngIf=\"isActive\" [item]=\"item\"></app-item-detail> <button type=\"button\" (click)=\"isActiveToggle()\">Toggle app-item-detail</button></div><p>If currentCustomer isn't null, say hello to Laura:</p><div *ngIf=\"currentCustomer\">Hello, {{ currentCustomer.name }}<",
    "id": "directives-*-overview-*-angular-37"
  },
  {
    "url": "https://angular.dev/guide/directives",
    "title": "Directives • Overview • Angular",
    "chunk": "/div><p>nullCustomer is null by default. NgIf guards against null. Give it a value to show it:</p><div *ngIf=\"nullCustomer\">Hello, <span>{{ nullCustomer }}</span></div><button type=\"button\" (click)=\"giveNullCustomerValue()\">Give nullCustomer a value</button><h4>NgIf binding with template (no *)</h4><ng-template [ngIf]=\"currentItem\">Add {{ currentItem.name }} with template</ng-template><hr><h4>Show/hide vs. NgIf</h4><!-- isSpecial is true --><div [class.hidden]=\"!isSpecial\">Show with class</div><",
    "id": "directives-*-overview-*-angular-38"
  },
  {
    "url": "https://angular.dev/guide/directives",
    "title": "Directives • Overview • Angular",
    "chunk": "div [class.hidden]=\"isSpecial\">Hide with class</div><p>ItemDetail is in the DOM but hidden</p><app-item-detail [class.hidden]=\"isSpecial\"></app-item-detail><div [style.display]=\"isSpecial ? 'block' : 'none'\">Show with style</div><div [style.display]=\"isSpecial ? 'none' : 'block'\">Hide with style</div><hr><h2 id=\"ngFor\">NgFor Binding</h2><div class=\"box\"> <div *ngFor=\"let item of items\">{{ item.name }}</div></div><p>*ngFor with ItemDetailComponent element</p><div class=\"box\"> <app-item-detail *ng",
    "id": "directives-*-overview-*-angular-39"
  },
  {
    "url": "https://angular.dev/guide/directives",
    "title": "Directives • Overview • Angular",
    "chunk": "For=\"let item of items\" [item]=\"item\"></app-item-detail></div><h4 id=\"ngFor-index\">*ngFor with index</h4><p>with <em>semi-colon</em> separator</p><div class=\"box\"> <div *ngFor=\"let item of items; let i=index\">{{ i + 1 }} - {{ item.name }}</div></div><p>with <em>comma</em> separator</p><div class=\"box\"> <div *ngFor=\"let item of items, let i=index\">{{ i + 1 }} - {{ item.name }}</div></div><h4 id=\"ngFor-trackBy\">*ngFor trackBy</h4><button type=\"button\" (click)=\"resetList()\">Reset items</button><but",
    "id": "directives-*-overview-*-angular-40"
  },
  {
    "url": "https://angular.dev/guide/directives",
    "title": "Directives • Overview • Angular",
    "chunk": "ton type=\"button\" (click)=\"changeIds()\">Change ids</button><button type=\"button\" (click)=\"clearTrackByCounts()\">Clear counts</button><p><em>without</em> trackBy</p><div class=\"box\"> <div #noTrackBy *ngFor=\"let item of items\">({{ item.id }}) {{ item.name }}</div> <div id=\"noTrackByCnt\" *ngIf=\"itemsNoTrackByCount\" > Item DOM elements change #{{ itemsNoTrackByCount }} without trackBy </div></div><p>with trackBy</p><div class=\"box\"> <div #withTrackBy *ngFor=\"let item of items; trackBy: trackByItems\"",
    "id": "directives-*-overview-*-angular-41"
  },
  {
    "url": "https://angular.dev/guide/directives",
    "title": "Directives • Overview • Angular",
    "chunk": ">({{ item.id }}) {{ item.name }}</div> <div id=\"withTrackByCnt\" *ngIf=\"itemsWithTrackByCount\"> Item DOM elements change #{{ itemsWithTrackByCount }} with trackBy </div></div><br><br><br><p>with trackBy and <em>semi-colon</em> separator</p><div class=\"box\"> <div *ngFor=\"let item of items; trackBy: trackByItems\"> ({{ item.id }}) {{ item.name }} </div></div><p>with trackBy and <em>comma</em> separator</p><div class=\"box\"> <div *ngFor=\"let item of items, trackBy: trackByItems\">({{ item.id }}) {{ ite",
    "id": "directives-*-overview-*-angular-42"
  },
  {
    "url": "https://angular.dev/guide/directives",
    "title": "Directives • Overview • Angular",
    "chunk": "m.name }}</div></div><p>with trackBy and <em>space</em> separator</p><div class=\"box\"> <div *ngFor=\"let item of items trackBy: trackByItems\">({{ item.id }}) {{ item.name }}</div></div><p>with <em>generic</em> trackById function</p><div class=\"box\"> <div *ngFor=\"let item of items, trackBy: trackById\">({{ item.id }}) {{ item.name }}</div></div><hr><h2>NgSwitch Binding</h2><p>Pick your favorite item</p><div> <label for=\"item-{{i}}\" *ngFor=\"let i of items\"> <div><input id=\"item-{{i}}\"type=\"radio\" na",
    "id": "directives-*-overview-*-angular-43"
  },
  {
    "url": "https://angular.dev/guide/directives",
    "title": "Directives • Overview • Angular",
    "chunk": "me=\"items\" [(ngModel)]=\"currentItem\" [value]=\"i\">{{ i.name }} </div> </label></div><div [ngSwitch]=\"currentItem.feature\"> <app-stout-item *ngSwitchCase=\"'stout'\" [item]=\"currentItem\"></app-stout-item> <app-device-item *ngSwitchCase=\"'slim'\" [item]=\"currentItem\"></app-device-item> <app-lost-item *ngSwitchCase=\"'vintage'\" [item]=\"currentItem\"></app-lost-item> <app-best-item *ngSwitchCase=\"'bright'\" [item]=\"currentItem\"></app-best-item> <div *ngSwitchCase=\"'bright'\">Are you as bright as {{ currentI",
    "id": "directives-*-overview-*-angular-44"
  },
  {
    "url": "https://angular.dev/guide/directives",
    "title": "Directives • Overview • Angular",
    "chunk": "tem.name }}?</div> <app-unknown-item *ngSwitchDefault [item]=\"currentItem\"></app-unknown-item></div> For this use case, Angular applies the classes on initialization and in case of changes caused by reassigning the currentClasses object. The full example calls setCurrentClasses() initially with ngOnInit() when the user clicks on the Refresh currentClasses button. These steps are not necessary to implement ngClass. Setting inline styles with NgStyle HELPFUL: To add or remove a single style, use s",
    "id": "directives-*-overview-*-angular-45"
  },
  {
    "url": "https://angular.dev/guide/directives",
    "title": "Directives • Overview • Angular",
    "chunk": "tyle bindings rather than NgStyle. Import NgStyle in the component To use NgStyle, add it to the component's imports list. src/app/app.component.ts (NgStyle import) import {Component, OnInit} from '@angular/core';import {JsonPipe} from '@angular/common';import {NgIf} from '@angular/common';import {NgFor} from '@angular/common';import {NgSwitch, NgSwitchCase, NgSwitchDefault} from '@angular/common';import {NgStyle} from '@angular/common';import {NgClass} from '@angular/common';import {FormsModule",
    "id": "directives-*-overview-*-angular-46"
  },
  {
    "url": "https://angular.dev/guide/directives",
    "title": "Directives • Overview • Angular",
    "chunk": "} from '@angular/forms';import {Item} from './item';import {ItemDetailComponent} from './item-detail/item-detail.component';import {ItemSwitchComponents} from './item-switch.component';import {StoutItemComponent} from './item-switch.component';@Component({ selector: 'app-root', templateUrl: './app.component.html', styleUrls: ['./app.component.css'], imports: [ NgIf, // <-- import into the component NgFor, // <-- import into the component NgStyle, // <-- import into the component NgSwitch, // <--",
    "id": "directives-*-overview-*-angular-47"
  },
  {
    "url": "https://angular.dev/guide/directives",
    "title": "Directives • Overview • Angular",
    "chunk": " import into the component NgSwitchCase, NgSwitchDefault, NgClass, // <-- import into the component FormsModule, // <--- import into the component JsonPipe, ItemDetailComponent, ItemSwitchComponents, StoutItemComponent, ],})export class AppComponent implements OnInit { canSave = true; isSpecial = true; isUnchanged = true; isActive = true; nullCustomer: string | null = null; currentCustomer = { name: 'Laura', }; item!: Item; // defined to demonstrate template context precedence items: Item[] = []",
    "id": "directives-*-overview-*-angular-48"
  },
  {
    "url": "https://angular.dev/guide/directives",
    "title": "Directives • Overview • Angular",
    "chunk": "; currentItem!: Item; // trackBy change counting itemsNoTrackByCount = 0; itemsWithTrackByCount = 0; itemsWithTrackByCountReset = 0; itemIdIncrement = 1; currentClasses: Record<string, boolean> = {}; currentStyles: Record<string, string> = {}; ngOnInit() { this.resetItems(); this.setCurrentClasses(); this.setCurrentStyles(); this.itemsNoTrackByCount = 0; } setUppercaseName(name: string) { this.currentItem.name = name.toUpperCase(); } setCurrentClasses() { // CSS classes: added/removed per curren",
    "id": "directives-*-overview-*-angular-49"
  },
  {
    "url": "https://angular.dev/guide/directives",
    "title": "Directives • Overview • Angular",
    "chunk": "t state of component properties this.currentClasses = { saveable: this.canSave, modified: !this.isUnchanged, special: this.isSpecial, }; } setCurrentStyles() { // CSS styles: set per current state of component properties this.currentStyles = { 'font-style': this.canSave ? 'italic' : 'normal', 'font-weight': !this.isUnchanged ? 'bold' : 'normal', 'font-size': this.isSpecial ? '24px' : '12px', }; } isActiveToggle() { this.isActive = !this.isActive; } giveNullCustomerValue() { this.nullCustomer = '",
    "id": "directives-*-overview-*-angular-50"
  },
  {
    "url": "https://angular.dev/guide/directives",
    "title": "Directives • Overview • Angular",
    "chunk": "Kelly'; } resetItems() { this.items = Item.items.map((item) => item.clone()); this.currentItem = this.items[0]; this.item = this.currentItem; } resetList() { this.resetItems(); this.itemsWithTrackByCountReset = 0; this.itemsNoTrackByCount = ++this.itemsNoTrackByCount; } changeIds() { this.items.forEach((i) => (i.id += 1 * this.itemIdIncrement)); this.itemsWithTrackByCountReset = -1; this.itemsNoTrackByCount = ++this.itemsNoTrackByCount; this.itemsWithTrackByCount = ++this.itemsWithTrackByCount; ",
    "id": "directives-*-overview-*-angular-51"
  },
  {
    "url": "https://angular.dev/guide/directives",
    "title": "Directives • Overview • Angular",
    "chunk": "} clearTrackByCounts() { this.resetItems(); this.itemsNoTrackByCount = 0; this.itemsWithTrackByCount = 0; this.itemIdIncrement = 1; } trackByItems(index: number, item: Item): number { return item.id; } trackById(index: number, item: any): number { return item.id; } getValue(event: Event): string { return (event.target as HTMLInputElement).value; }} Use NgStyle to set multiple inline styles simultaneously, based on the state of the component. To use NgStyle, add a method to the component class. I",
    "id": "directives-*-overview-*-angular-52"
  },
  {
    "url": "https://angular.dev/guide/directives",
    "title": "Directives • Overview • Angular",
    "chunk": "n the following example, setCurrentStyles() sets the property currentStyles with an object that defines three styles, based on the state of three other component properties. src/app/app.component.ts import {Component, OnInit} from '@angular/core';import {JsonPipe} from '@angular/common';import {NgIf} from '@angular/common';import {NgFor} from '@angular/common';import {NgSwitch, NgSwitchCase, NgSwitchDefault} from '@angular/common';import {NgStyle} from '@angular/common';import {NgClass} from '@a",
    "id": "directives-*-overview-*-angular-53"
  },
  {
    "url": "https://angular.dev/guide/directives",
    "title": "Directives • Overview • Angular",
    "chunk": "ngular/common';import {FormsModule} from '@angular/forms';import {Item} from './item';import {ItemDetailComponent} from './item-detail/item-detail.component';import {ItemSwitchComponents} from './item-switch.component';import {StoutItemComponent} from './item-switch.component';@Component({ selector: 'app-root', templateUrl: './app.component.html', styleUrls: ['./app.component.css'], imports: [ NgIf, // <-- import into the component NgFor, // <-- import into the component NgStyle, // <-- import i",
    "id": "directives-*-overview-*-angular-54"
  },
  {
    "url": "https://angular.dev/guide/directives",
    "title": "Directives • Overview • Angular",
    "chunk": "nto the component NgSwitch, // <-- import into the component NgSwitchCase, NgSwitchDefault, NgClass, // <-- import into the component FormsModule, // <--- import into the component JsonPipe, ItemDetailComponent, ItemSwitchComponents, StoutItemComponent, ],})export class AppComponent implements OnInit { canSave = true; isSpecial = true; isUnchanged = true; isActive = true; nullCustomer: string | null = null; currentCustomer = { name: 'Laura', }; item!: Item; // defined to demonstrate template con",
    "id": "directives-*-overview-*-angular-55"
  },
  {
    "url": "https://angular.dev/guide/directives",
    "title": "Directives • Overview • Angular",
    "chunk": "text precedence items: Item[] = []; currentItem!: Item; // trackBy change counting itemsNoTrackByCount = 0; itemsWithTrackByCount = 0; itemsWithTrackByCountReset = 0; itemIdIncrement = 1; currentClasses: Record<string, boolean> = {}; currentStyles: Record<string, string> = {}; ngOnInit() { this.resetItems(); this.setCurrentClasses(); this.setCurrentStyles(); this.itemsNoTrackByCount = 0; } setUppercaseName(name: string) { this.currentItem.name = name.toUpperCase(); } setCurrentClasses() { // CSS",
    "id": "directives-*-overview-*-angular-56"
  },
  {
    "url": "https://angular.dev/guide/directives",
    "title": "Directives • Overview • Angular",
    "chunk": " classes: added/removed per current state of component properties this.currentClasses = { saveable: this.canSave, modified: !this.isUnchanged, special: this.isSpecial, }; } setCurrentStyles() { // CSS styles: set per current state of component properties this.currentStyles = { 'font-style': this.canSave ? 'italic' : 'normal', 'font-weight': !this.isUnchanged ? 'bold' : 'normal', 'font-size': this.isSpecial ? '24px' : '12px', }; } isActiveToggle() { this.isActive = !this.isActive; } giveNullCusto",
    "id": "directives-*-overview-*-angular-57"
  },
  {
    "url": "https://angular.dev/guide/directives",
    "title": "Directives • Overview • Angular",
    "chunk": "merValue() { this.nullCustomer = 'Kelly'; } resetItems() { this.items = Item.items.map((item) => item.clone()); this.currentItem = this.items[0]; this.item = this.currentItem; } resetList() { this.resetItems(); this.itemsWithTrackByCountReset = 0; this.itemsNoTrackByCount = ++this.itemsNoTrackByCount; } changeIds() { this.items.forEach((i) => (i.id += 1 * this.itemIdIncrement)); this.itemsWithTrackByCountReset = -1; this.itemsNoTrackByCount = ++this.itemsNoTrackByCount; this.itemsWithTrackByCoun",
    "id": "directives-*-overview-*-angular-58"
  },
  {
    "url": "https://angular.dev/guide/directives",
    "title": "Directives • Overview • Angular",
    "chunk": "t = ++this.itemsWithTrackByCount; } clearTrackByCounts() { this.resetItems(); this.itemsNoTrackByCount = 0; this.itemsWithTrackByCount = 0; this.itemIdIncrement = 1; } trackByItems(index: number, item: Item): number { return item.id; } trackById(index: number, item: any): number { return item.id; } getValue(event: Event): string { return (event.target as HTMLInputElement).value; }} To set the element's styles, add an ngStyle property binding to currentStyles. src/app/app.component.html <h1>Built",
    "id": "directives-*-overview-*-angular-59"
  },
  {
    "url": "https://angular.dev/guide/directives",
    "title": "Directives • Overview • Angular",
    "chunk": "-in Directives</h1><h2>Built-in attribute directives</h2><h3 id=\"ngModel\">NgModel (two-way) Binding</h3><fieldset><h4>NgModel examples</h4> <p>Current item name: {{ currentItem.name }}</p> <p> <label for=\"without\">without NgModel:</label> <input [value]=\"currentItem.name\" (input)=\"currentItem.name=getValue($event)\" id=\"without\"> </p> <p> <label for=\"example-ngModel\">[(ngModel)]:</label> <input [(ngModel)]=\"currentItem.name\" id=\"example-ngModel\"> </p> <p> <label for=\"example-change\">(ngModelChang",
    "id": "directives-*-overview-*-angular-60"
  },
  {
    "url": "https://angular.dev/guide/directives",
    "title": "Directives • Overview • Angular",
    "chunk": "e)=\"...name=$event\":</label> <input [ngModel]=\"currentItem.name\" (ngModelChange)=\"currentItem.name=$event\" id=\"example-change\"> </p> <p> <label for=\"example-uppercase\">(ngModelChange)=\"setUppercaseName($event)\" <input [ngModel]=\"currentItem.name\" (ngModelChange)=\"setUppercaseName($event)\" id=\"example-uppercase\"> </label> </p></fieldset><hr><h2 id=\"ngClass\">NgClass Binding</h2><p>currentClasses is {{ currentClasses | json }}</p><div [ngClass]=\"currentClasses\">This div is initially saveable, uncha",
    "id": "directives-*-overview-*-angular-61"
  },
  {
    "url": "https://angular.dev/guide/directives",
    "title": "Directives • Overview • Angular",
    "chunk": "nged, and special.</div><ul> <li> <label for=\"saveable\">saveable</label> <input type=\"checkbox\" [(ngModel)]=\"canSave\" id=\"saveable\"> </li> <li> <label for=\"modified\">modified:</label> <input type=\"checkbox\" [value]=\"!isUnchanged\" (change)=\"isUnchanged=!isUnchanged\" id=\"modified\"></li> <li> <label for=\"special\">special: <input type=\"checkbox\" [(ngModel)]=\"isSpecial\" id=\"special\"></label></li></ul><button type=\"button\" (click)=\"setCurrentClasses()\">Refresh currentClasses</button><div [ngClass]=\"cu",
    "id": "directives-*-overview-*-angular-62"
  },
  {
    "url": "https://angular.dev/guide/directives",
    "title": "Directives • Overview • Angular",
    "chunk": "rrentClasses\"> This div should be {{ canSave ? \"\": \"not\"}} saveable, {{ isUnchanged ? \"unchanged\" : \"modified\" }} and {{ isSpecial ? \"\": \"not\"}} special after clicking \"Refresh\".</div><br><br><!-- toggle the \"special\" class on/off with a property --><div [ngClass]=\"isSpecial ? 'special' : ''\">This div is special</div><div class=\"helpful study course\">Helpful study course</div><div [ngClass]=\"{'helpful':false, 'study':true, 'course':true}\">Study course</div><!-- NgStyle binding --><hr><h3>NgStyle",
    "id": "directives-*-overview-*-angular-63"
  },
  {
    "url": "https://angular.dev/guide/directives",
    "title": "Directives • Overview • Angular",
    "chunk": " Binding</h3><div [style.font-size]=\"isSpecial ? 'x-large' : 'smaller'\"> This div is x-large or smaller.</div><h4>[ngStyle] binding to currentStyles - CSS property names</h4><p>currentStyles is {{ currentStyles | json }}</p><div [ngStyle]=\"currentStyles\"> This div is initially italic, normal weight, and extra large (24px).</div><br><label for=\"canSave\">italic: <input id=\"canSave\" type=\"checkbox\" [(ngModel)]=\"canSave\"></label> |<label for=\"isUnchanged\">normal: <input id=\"isUnchanged\" type=\"checkb",
    "id": "directives-*-overview-*-angular-64"
  },
  {
    "url": "https://angular.dev/guide/directives",
    "title": "Directives • Overview • Angular",
    "chunk": "ox\" [(ngModel)]=\"isUnchanged\"></label> |<label for=\"isSpecial\">xlarge: <input id=\"isSpecial\" type=\"checkbox\" [(ngModel)]=\"isSpecial\"></label><button type=\"button\" (click)=\"setCurrentStyles()\">Refresh currentStyles</button><br><br><div [ngStyle]=\"currentStyles\"> This div should be {{ canSave ? \"italic\": \"plain\"}}, {{ isUnchanged ? \"normal weight\" : \"bold\" }} and, {{ isSpecial ? \"extra large\": \"normal size\"}} after clicking \"Refresh\".</div><hr><h2>Built-in structural directives</h2><h3 id=\"ngIf\">N",
    "id": "directives-*-overview-*-angular-65"
  },
  {
    "url": "https://angular.dev/guide/directives",
    "title": "Directives • Overview • Angular",
    "chunk": "gIf Binding</h3><div> <p>If isActive is true, app-item-detail will render: </p> <app-item-detail *ngIf=\"isActive\" [item]=\"item\"></app-item-detail> <button type=\"button\" (click)=\"isActiveToggle()\">Toggle app-item-detail</button></div><p>If currentCustomer isn't null, say hello to Laura:</p><div *ngIf=\"currentCustomer\">Hello, {{ currentCustomer.name }}</div><p>nullCustomer is null by default. NgIf guards against null. Give it a value to show it:</p><div *ngIf=\"nullCustomer\">Hello, <span>{{ nullCus",
    "id": "directives-*-overview-*-angular-66"
  },
  {
    "url": "https://angular.dev/guide/directives",
    "title": "Directives • Overview • Angular",
    "chunk": "tomer }}</span></div><button type=\"button\" (click)=\"giveNullCustomerValue()\">Give nullCustomer a value</button><h4>NgIf binding with template (no *)</h4><ng-template [ngIf]=\"currentItem\">Add {{ currentItem.name }} with template</ng-template><hr><h4>Show/hide vs. NgIf</h4><!-- isSpecial is true --><div [class.hidden]=\"!isSpecial\">Show with class</div><div [class.hidden]=\"isSpecial\">Hide with class</div><p>ItemDetail is in the DOM but hidden</p><app-item-detail [class.hidden]=\"isSpecial\"></app-ite",
    "id": "directives-*-overview-*-angular-67"
  },
  {
    "url": "https://angular.dev/guide/directives",
    "title": "Directives • Overview • Angular",
    "chunk": "m-detail><div [style.display]=\"isSpecial ? 'block' : 'none'\">Show with style</div><div [style.display]=\"isSpecial ? 'none' : 'block'\">Hide with style</div><hr><h2 id=\"ngFor\">NgFor Binding</h2><div class=\"box\"> <div *ngFor=\"let item of items\">{{ item.name }}</div></div><p>*ngFor with ItemDetailComponent element</p><div class=\"box\"> <app-item-detail *ngFor=\"let item of items\" [item]=\"item\"></app-item-detail></div><h4 id=\"ngFor-index\">*ngFor with index</h4><p>with <em>semi-colon</em> separator</p><",
    "id": "directives-*-overview-*-angular-68"
  },
  {
    "url": "https://angular.dev/guide/directives",
    "title": "Directives • Overview • Angular",
    "chunk": "div class=\"box\"> <div *ngFor=\"let item of items; let i=index\">{{ i + 1 }} - {{ item.name }}</div></div><p>with <em>comma</em> separator</p><div class=\"box\"> <div *ngFor=\"let item of items, let i=index\">{{ i + 1 }} - {{ item.name }}</div></div><h4 id=\"ngFor-trackBy\">*ngFor trackBy</h4><button type=\"button\" (click)=\"resetList()\">Reset items</button><button type=\"button\" (click)=\"changeIds()\">Change ids</button><button type=\"button\" (click)=\"clearTrackByCounts()\">Clear counts</button><p><em>without",
    "id": "directives-*-overview-*-angular-69"
  },
  {
    "url": "https://angular.dev/guide/directives",
    "title": "Directives • Overview • Angular",
    "chunk": "</em> trackBy</p><div class=\"box\"> <div #noTrackBy *ngFor=\"let item of items\">({{ item.id }}) {{ item.name }}</div> <div id=\"noTrackByCnt\" *ngIf=\"itemsNoTrackByCount\" > Item DOM elements change #{{ itemsNoTrackByCount }} without trackBy </div></div><p>with trackBy</p><div class=\"box\"> <div #withTrackBy *ngFor=\"let item of items; trackBy: trackByItems\">({{ item.id }}) {{ item.name }}</div> <div id=\"withTrackByCnt\" *ngIf=\"itemsWithTrackByCount\"> Item DOM elements change #{{ itemsWithTrackByCount }",
    "id": "directives-*-overview-*-angular-70"
  },
  {
    "url": "https://angular.dev/guide/directives",
    "title": "Directives • Overview • Angular",
    "chunk": "} with trackBy </div></div><br><br><br><p>with trackBy and <em>semi-colon</em> separator</p><div class=\"box\"> <div *ngFor=\"let item of items; trackBy: trackByItems\"> ({{ item.id }}) {{ item.name }} </div></div><p>with trackBy and <em>comma</em> separator</p><div class=\"box\"> <div *ngFor=\"let item of items, trackBy: trackByItems\">({{ item.id }}) {{ item.name }}</div></div><p>with trackBy and <em>space</em> separator</p><div class=\"box\"> <div *ngFor=\"let item of items trackBy: trackByItems\">({{ it",
    "id": "directives-*-overview-*-angular-71"
  },
  {
    "url": "https://angular.dev/guide/directives",
    "title": "Directives • Overview • Angular",
    "chunk": "em.id }}) {{ item.name }}</div></div><p>with <em>generic</em> trackById function</p><div class=\"box\"> <div *ngFor=\"let item of items, trackBy: trackById\">({{ item.id }}) {{ item.name }}</div></div><hr><h2>NgSwitch Binding</h2><p>Pick your favorite item</p><div> <label for=\"item-{{i}}\" *ngFor=\"let i of items\"> <div><input id=\"item-{{i}}\"type=\"radio\" name=\"items\" [(ngModel)]=\"currentItem\" [value]=\"i\">{{ i.name }} </div> </label></div><div [ngSwitch]=\"currentItem.feature\"> <app-stout-item *ngSwitch",
    "id": "directives-*-overview-*-angular-72"
  },
  {
    "url": "https://angular.dev/guide/directives",
    "title": "Directives • Overview • Angular",
    "chunk": "Case=\"'stout'\" [item]=\"currentItem\"></app-stout-item> <app-device-item *ngSwitchCase=\"'slim'\" [item]=\"currentItem\"></app-device-item> <app-lost-item *ngSwitchCase=\"'vintage'\" [item]=\"currentItem\"></app-lost-item> <app-best-item *ngSwitchCase=\"'bright'\" [item]=\"currentItem\"></app-best-item> <div *ngSwitchCase=\"'bright'\">Are you as bright as {{ currentItem.name }}?</div> <app-unknown-item *ngSwitchDefault [item]=\"currentItem\"></app-unknown-item></div> For this use case, Angular applies the styles ",
    "id": "directives-*-overview-*-angular-73"
  },
  {
    "url": "https://angular.dev/guide/directives",
    "title": "Directives • Overview • Angular",
    "chunk": "upon initialization and in case of changes. To do this, the full example calls setCurrentStyles() initially with ngOnInit() and when the dependent properties change through a button click. However, these steps are not necessary to implement ngStyle on its own. Displaying and updating properties with ngModel Use the NgModel directive to display a data property and update that property when the user makes changes. Import FormsModule and add it to the AppComponent's imports list. src/app/app.compon",
    "id": "directives-*-overview-*-angular-74"
  },
  {
    "url": "https://angular.dev/guide/directives",
    "title": "Directives • Overview • Angular",
    "chunk": "ent.ts (FormsModule import) import {Component, OnInit} from '@angular/core';import {JsonPipe} from '@angular/common';import {NgIf} from '@angular/common';import {NgFor} from '@angular/common';import {NgSwitch, NgSwitchCase, NgSwitchDefault} from '@angular/common';import {NgStyle} from '@angular/common';import {NgClass} from '@angular/common';import {FormsModule} from '@angular/forms';import {Item} from './item';import {ItemDetailComponent} from './item-detail/item-detail.component';import {ItemS",
    "id": "directives-*-overview-*-angular-75"
  },
  {
    "url": "https://angular.dev/guide/directives",
    "title": "Directives • Overview • Angular",
    "chunk": "witchComponents} from './item-switch.component';import {StoutItemComponent} from './item-switch.component';@Component({ selector: 'app-root', templateUrl: './app.component.html', styleUrls: ['./app.component.css'], imports: [ NgIf, // <-- import into the component NgFor, // <-- import into the component NgStyle, // <-- import into the component NgSwitch, // <-- import into the component NgSwitchCase, NgSwitchDefault, NgClass, // <-- import into the component FormsModule, // <--- import into the ",
    "id": "directives-*-overview-*-angular-76"
  },
  {
    "url": "https://angular.dev/guide/directives",
    "title": "Directives • Overview • Angular",
    "chunk": "component JsonPipe, ItemDetailComponent, ItemSwitchComponents, StoutItemComponent, ],})export class AppComponent implements OnInit { canSave = true; isSpecial = true; isUnchanged = true; isActive = true; nullCustomer: string | null = null; currentCustomer = { name: 'Laura', }; item!: Item; // defined to demonstrate template context precedence items: Item[] = []; currentItem!: Item; // trackBy change counting itemsNoTrackByCount = 0; itemsWithTrackByCount = 0; itemsWithTrackByCountReset = 0; item",
    "id": "directives-*-overview-*-angular-77"
  },
  {
    "url": "https://angular.dev/guide/directives",
    "title": "Directives • Overview • Angular",
    "chunk": "IdIncrement = 1; currentClasses: Record<string, boolean> = {}; currentStyles: Record<string, string> = {}; ngOnInit() { this.resetItems(); this.setCurrentClasses(); this.setCurrentStyles(); this.itemsNoTrackByCount = 0; } setUppercaseName(name: string) { this.currentItem.name = name.toUpperCase(); } setCurrentClasses() { // CSS classes: added/removed per current state of component properties this.currentClasses = { saveable: this.canSave, modified: !this.isUnchanged, special: this.isSpecial, }; ",
    "id": "directives-*-overview-*-angular-78"
  },
  {
    "url": "https://angular.dev/guide/directives",
    "title": "Directives • Overview • Angular",
    "chunk": "} setCurrentStyles() { // CSS styles: set per current state of component properties this.currentStyles = { 'font-style': this.canSave ? 'italic' : 'normal', 'font-weight': !this.isUnchanged ? 'bold' : 'normal', 'font-size': this.isSpecial ? '24px' : '12px', }; } isActiveToggle() { this.isActive = !this.isActive; } giveNullCustomerValue() { this.nullCustomer = 'Kelly'; } resetItems() { this.items = Item.items.map((item) => item.clone()); this.currentItem = this.items[0]; this.item = this.currentI",
    "id": "directives-*-overview-*-angular-79"
  },
  {
    "url": "https://angular.dev/guide/directives",
    "title": "Directives • Overview • Angular",
    "chunk": "tem; } resetList() { this.resetItems(); this.itemsWithTrackByCountReset = 0; this.itemsNoTrackByCount = ++this.itemsNoTrackByCount; } changeIds() { this.items.forEach((i) => (i.id += 1 * this.itemIdIncrement)); this.itemsWithTrackByCountReset = -1; this.itemsNoTrackByCount = ++this.itemsNoTrackByCount; this.itemsWithTrackByCount = ++this.itemsWithTrackByCount; } clearTrackByCounts() { this.resetItems(); this.itemsNoTrackByCount = 0; this.itemsWithTrackByCount = 0; this.itemIdIncrement = 1; } tra",
    "id": "directives-*-overview-*-angular-80"
  },
  {
    "url": "https://angular.dev/guide/directives",
    "title": "Directives • Overview • Angular",
    "chunk": "ckByItems(index: number, item: Item): number { return item.id; } trackById(index: number, item: any): number { return item.id; } getValue(event: Event): string { return (event.target as HTMLInputElement).value; }} Add an [(ngModel)] binding on an HTML <form> element and set it equal to the property, here name. src/app/app.component.html (NgModel example) <h1>Built-in Directives</h1><h2>Built-in attribute directives</h2><h3 id=\"ngModel\">NgModel (two-way) Binding</h3><fieldset><h4>NgModel examples",
    "id": "directives-*-overview-*-angular-81"
  },
  {
    "url": "https://angular.dev/guide/directives",
    "title": "Directives • Overview • Angular",
    "chunk": "</h4> <p>Current item name: {{ currentItem.name }}</p> <p> <label for=\"without\">without NgModel:</label> <input [value]=\"currentItem.name\" (input)=\"currentItem.name=getValue($event)\" id=\"without\"> </p> <p> <label for=\"example-ngModel\">[(ngModel)]:</label> <input [(ngModel)]=\"currentItem.name\" id=\"example-ngModel\"> </p> <p> <label for=\"example-change\">(ngModelChange)=\"...name=$event\":</label> <input [ngModel]=\"currentItem.name\" (ngModelChange)=\"currentItem.name=$event\" id=\"example-change\"> </p> <",
    "id": "directives-*-overview-*-angular-82"
  },
  {
    "url": "https://angular.dev/guide/directives",
    "title": "Directives • Overview • Angular",
    "chunk": "p> <label for=\"example-uppercase\">(ngModelChange)=\"setUppercaseName($event)\" <input [ngModel]=\"currentItem.name\" (ngModelChange)=\"setUppercaseName($event)\" id=\"example-uppercase\"> </label> </p></fieldset><hr><h2 id=\"ngClass\">NgClass Binding</h2><p>currentClasses is {{ currentClasses | json }}</p><div [ngClass]=\"currentClasses\">This div is initially saveable, unchanged, and special.</div><ul> <li> <label for=\"saveable\">saveable</label> <input type=\"checkbox\" [(ngModel)]=\"canSave\" id=\"saveable\"> <",
    "id": "directives-*-overview-*-angular-83"
  },
  {
    "url": "https://angular.dev/guide/directives",
    "title": "Directives • Overview • Angular",
    "chunk": "/li> <li> <label for=\"modified\">modified:</label> <input type=\"checkbox\" [value]=\"!isUnchanged\" (change)=\"isUnchanged=!isUnchanged\" id=\"modified\"></li> <li> <label for=\"special\">special: <input type=\"checkbox\" [(ngModel)]=\"isSpecial\" id=\"special\"></label></li></ul><button type=\"button\" (click)=\"setCurrentClasses()\">Refresh currentClasses</button><div [ngClass]=\"currentClasses\"> This div should be {{ canSave ? \"\": \"not\"}} saveable, {{ isUnchanged ? \"unchanged\" : \"modified\" }} and {{ isSpecial ? \"",
    "id": "directives-*-overview-*-angular-84"
  },
  {
    "url": "https://angular.dev/guide/directives",
    "title": "Directives • Overview • Angular",
    "chunk": "\": \"not\"}} special after clicking \"Refresh\".</div><br><br><!-- toggle the \"special\" class on/off with a property --><div [ngClass]=\"isSpecial ? 'special' : ''\">This div is special</div><div class=\"helpful study course\">Helpful study course</div><div [ngClass]=\"{'helpful':false, 'study':true, 'course':true}\">Study course</div><!-- NgStyle binding --><hr><h3>NgStyle Binding</h3><div [style.font-size]=\"isSpecial ? 'x-large' : 'smaller'\"> This div is x-large or smaller.</div><h4>[ngStyle] binding to",
    "id": "directives-*-overview-*-angular-85"
  },
  {
    "url": "https://angular.dev/guide/directives",
    "title": "Directives • Overview • Angular",
    "chunk": " currentStyles - CSS property names</h4><p>currentStyles is {{ currentStyles | json }}</p><div [ngStyle]=\"currentStyles\"> This div is initially italic, normal weight, and extra large (24px).</div><br><label for=\"canSave\">italic: <input id=\"canSave\" type=\"checkbox\" [(ngModel)]=\"canSave\"></label> |<label for=\"isUnchanged\">normal: <input id=\"isUnchanged\" type=\"checkbox\" [(ngModel)]=\"isUnchanged\"></label> |<label for=\"isSpecial\">xlarge: <input id=\"isSpecial\" type=\"checkbox\" [(ngModel)]=\"isSpecial\"><",
    "id": "directives-*-overview-*-angular-86"
  },
  {
    "url": "https://angular.dev/guide/directives",
    "title": "Directives • Overview • Angular",
    "chunk": "/label><button type=\"button\" (click)=\"setCurrentStyles()\">Refresh currentStyles</button><br><br><div [ngStyle]=\"currentStyles\"> This div should be {{ canSave ? \"italic\": \"plain\"}}, {{ isUnchanged ? \"normal weight\" : \"bold\" }} and, {{ isSpecial ? \"extra large\": \"normal size\"}} after clicking \"Refresh\".</div><hr><h2>Built-in structural directives</h2><h3 id=\"ngIf\">NgIf Binding</h3><div> <p>If isActive is true, app-item-detail will render: </p> <app-item-detail *ngIf=\"isActive\" [item]=\"item\"></app-",
    "id": "directives-*-overview-*-angular-87"
  },
  {
    "url": "https://angular.dev/guide/directives",
    "title": "Directives • Overview • Angular",
    "chunk": "item-detail> <button type=\"button\" (click)=\"isActiveToggle()\">Toggle app-item-detail</button></div><p>If currentCustomer isn't null, say hello to Laura:</p><div *ngIf=\"currentCustomer\">Hello, {{ currentCustomer.name }}</div><p>nullCustomer is null by default. NgIf guards against null. Give it a value to show it:</p><div *ngIf=\"nullCustomer\">Hello, <span>{{ nullCustomer }}</span></div><button type=\"button\" (click)=\"giveNullCustomerValue()\">Give nullCustomer a value</button><h4>NgIf binding with t",
    "id": "directives-*-overview-*-angular-88"
  },
  {
    "url": "https://angular.dev/guide/directives",
    "title": "Directives • Overview • Angular",
    "chunk": "emplate (no *)</h4><ng-template [ngIf]=\"currentItem\">Add {{ currentItem.name }} with template</ng-template><hr><h4>Show/hide vs. NgIf</h4><!-- isSpecial is true --><div [class.hidden]=\"!isSpecial\">Show with class</div><div [class.hidden]=\"isSpecial\">Hide with class</div><p>ItemDetail is in the DOM but hidden</p><app-item-detail [class.hidden]=\"isSpecial\"></app-item-detail><div [style.display]=\"isSpecial ? 'block' : 'none'\">Show with style</div><div [style.display]=\"isSpecial ? 'none' : 'block'\">",
    "id": "directives-*-overview-*-angular-89"
  },
  {
    "url": "https://angular.dev/guide/directives",
    "title": "Directives • Overview • Angular",
    "chunk": "Hide with style</div><hr><h2 id=\"ngFor\">NgFor Binding</h2><div class=\"box\"> <div *ngFor=\"let item of items\">{{ item.name }}</div></div><p>*ngFor with ItemDetailComponent element</p><div class=\"box\"> <app-item-detail *ngFor=\"let item of items\" [item]=\"item\"></app-item-detail></div><h4 id=\"ngFor-index\">*ngFor with index</h4><p>with <em>semi-colon</em> separator</p><div class=\"box\"> <div *ngFor=\"let item of items; let i=index\">{{ i + 1 }} - {{ item.name }}</div></div><p>with <em>comma</em> separato",
    "id": "directives-*-overview-*-angular-90"
  },
  {
    "url": "https://angular.dev/guide/directives",
    "title": "Directives • Overview • Angular",
    "chunk": "r</p><div class=\"box\"> <div *ngFor=\"let item of items, let i=index\">{{ i + 1 }} - {{ item.name }}</div></div><h4 id=\"ngFor-trackBy\">*ngFor trackBy</h4><button type=\"button\" (click)=\"resetList()\">Reset items</button><button type=\"button\" (click)=\"changeIds()\">Change ids</button><button type=\"button\" (click)=\"clearTrackByCounts()\">Clear counts</button><p><em>without</em> trackBy</p><div class=\"box\"> <div #noTrackBy *ngFor=\"let item of items\">({{ item.id }}) {{ item.name }}</div> <div id=\"noTrackBy",
    "id": "directives-*-overview-*-angular-91"
  },
  {
    "url": "https://angular.dev/guide/directives",
    "title": "Directives • Overview • Angular",
    "chunk": "Cnt\" *ngIf=\"itemsNoTrackByCount\" > Item DOM elements change #{{ itemsNoTrackByCount }} without trackBy </div></div><p>with trackBy</p><div class=\"box\"> <div #withTrackBy *ngFor=\"let item of items; trackBy: trackByItems\">({{ item.id }}) {{ item.name }}</div> <div id=\"withTrackByCnt\" *ngIf=\"itemsWithTrackByCount\"> Item DOM elements change #{{ itemsWithTrackByCount }} with trackBy </div></div><br><br><br><p>with trackBy and <em>semi-colon</em> separator</p><div class=\"box\"> <div *ngFor=\"let item of",
    "id": "directives-*-overview-*-angular-92"
  },
  {
    "url": "https://angular.dev/guide/directives",
    "title": "Directives • Overview • Angular",
    "chunk": " items; trackBy: trackByItems\"> ({{ item.id }}) {{ item.name }} </div></div><p>with trackBy and <em>comma</em> separator</p><div class=\"box\"> <div *ngFor=\"let item of items, trackBy: trackByItems\">({{ item.id }}) {{ item.name }}</div></div><p>with trackBy and <em>space</em> separator</p><div class=\"box\"> <div *ngFor=\"let item of items trackBy: trackByItems\">({{ item.id }}) {{ item.name }}</div></div><p>with <em>generic</em> trackById function</p><div class=\"box\"> <div *ngFor=\"let item of items, ",
    "id": "directives-*-overview-*-angular-93"
  },
  {
    "url": "https://angular.dev/guide/directives",
    "title": "Directives • Overview • Angular",
    "chunk": "trackBy: trackById\">({{ item.id }}) {{ item.name }}</div></div><hr><h2>NgSwitch Binding</h2><p>Pick your favorite item</p><div> <label for=\"item-{{i}}\" *ngFor=\"let i of items\"> <div><input id=\"item-{{i}}\"type=\"radio\" name=\"items\" [(ngModel)]=\"currentItem\" [value]=\"i\">{{ i.name }} </div> </label></div><div [ngSwitch]=\"currentItem.feature\"> <app-stout-item *ngSwitchCase=\"'stout'\" [item]=\"currentItem\"></app-stout-item> <app-device-item *ngSwitchCase=\"'slim'\" [item]=\"currentItem\"></app-device-item> ",
    "id": "directives-*-overview-*-angular-94"
  },
  {
    "url": "https://angular.dev/guide/directives",
    "title": "Directives • Overview • Angular",
    "chunk": "<app-lost-item *ngSwitchCase=\"'vintage'\" [item]=\"currentItem\"></app-lost-item> <app-best-item *ngSwitchCase=\"'bright'\" [item]=\"currentItem\"></app-best-item> <div *ngSwitchCase=\"'bright'\">Are you as bright as {{ currentItem.name }}?</div> <app-unknown-item *ngSwitchDefault [item]=\"currentItem\"></app-unknown-item></div> This [(ngModel)] syntax can only set a data-bound property. To customize your configuration, write the expanded form, which separates the property and event binding. Use property b",
    "id": "directives-*-overview-*-angular-95"
  },
  {
    "url": "https://angular.dev/guide/directives",
    "title": "Directives • Overview • Angular",
    "chunk": "inding to set the property and event binding to respond to changes. The following example changes the <input> value to uppercase: src/app/app.component.html <h1>Built-in Directives</h1><h2>Built-in attribute directives</h2><h3 id=\"ngModel\">NgModel (two-way) Binding</h3><fieldset><h4>NgModel examples</h4> <p>Current item name: {{ currentItem.name }}</p> <p> <label for=\"without\">without NgModel:</label> <input [value]=\"currentItem.name\" (input)=\"currentItem.name=getValue($event)\" id=\"without\"> </p",
    "id": "directives-*-overview-*-angular-96"
  },
  {
    "url": "https://angular.dev/guide/directives",
    "title": "Directives • Overview • Angular",
    "chunk": "> <p> <label for=\"example-ngModel\">[(ngModel)]:</label> <input [(ngModel)]=\"currentItem.name\" id=\"example-ngModel\"> </p> <p> <label for=\"example-change\">(ngModelChange)=\"...name=$event\":</label> <input [ngModel]=\"currentItem.name\" (ngModelChange)=\"currentItem.name=$event\" id=\"example-change\"> </p> <p> <label for=\"example-uppercase\">(ngModelChange)=\"setUppercaseName($event)\" <input [ngModel]=\"currentItem.name\" (ngModelChange)=\"setUppercaseName($event)\" id=\"example-uppercase\"> </label> </p></field",
    "id": "directives-*-overview-*-angular-97"
  },
  {
    "url": "https://angular.dev/guide/directives",
    "title": "Directives • Overview • Angular",
    "chunk": "set><hr><h2 id=\"ngClass\">NgClass Binding</h2><p>currentClasses is {{ currentClasses | json }}</p><div [ngClass]=\"currentClasses\">This div is initially saveable, unchanged, and special.</div><ul> <li> <label for=\"saveable\">saveable</label> <input type=\"checkbox\" [(ngModel)]=\"canSave\" id=\"saveable\"> </li> <li> <label for=\"modified\">modified:</label> <input type=\"checkbox\" [value]=\"!isUnchanged\" (change)=\"isUnchanged=!isUnchanged\" id=\"modified\"></li> <li> <label for=\"special\">special: <input type=\"",
    "id": "directives-*-overview-*-angular-98"
  },
  {
    "url": "https://angular.dev/guide/directives",
    "title": "Directives • Overview • Angular",
    "chunk": "checkbox\" [(ngModel)]=\"isSpecial\" id=\"special\"></label></li></ul><button type=\"button\" (click)=\"setCurrentClasses()\">Refresh currentClasses</button><div [ngClass]=\"currentClasses\"> This div should be {{ canSave ? \"\": \"not\"}} saveable, {{ isUnchanged ? \"unchanged\" : \"modified\" }} and {{ isSpecial ? \"\": \"not\"}} special after clicking \"Refresh\".</div><br><br><!-- toggle the \"special\" class on/off with a property --><div [ngClass]=\"isSpecial ? 'special' : ''\">This div is special</div><div class=\"hel",
    "id": "directives-*-overview-*-angular-99"
  },
  {
    "url": "https://angular.dev/guide/directives",
    "title": "Directives • Overview • Angular",
    "chunk": "pful study course\">Helpful study course</div><div [ngClass]=\"{'helpful':false, 'study':true, 'course':true}\">Study course</div><!-- NgStyle binding --><hr><h3>NgStyle Binding</h3><div [style.font-size]=\"isSpecial ? 'x-large' : 'smaller'\"> This div is x-large or smaller.</div><h4>[ngStyle] binding to currentStyles - CSS property names</h4><p>currentStyles is {{ currentStyles | json }}</p><div [ngStyle]=\"currentStyles\"> This div is initially italic, normal weight, and extra large (24px).</div><br>",
    "id": "directives-*-overview-*-angular-100"
  },
  {
    "url": "https://angular.dev/guide/directives",
    "title": "Directives • Overview • Angular",
    "chunk": "<label for=\"canSave\">italic: <input id=\"canSave\" type=\"checkbox\" [(ngModel)]=\"canSave\"></label> |<label for=\"isUnchanged\">normal: <input id=\"isUnchanged\" type=\"checkbox\" [(ngModel)]=\"isUnchanged\"></label> |<label for=\"isSpecial\">xlarge: <input id=\"isSpecial\" type=\"checkbox\" [(ngModel)]=\"isSpecial\"></label><button type=\"button\" (click)=\"setCurrentStyles()\">Refresh currentStyles</button><br><br><div [ngStyle]=\"currentStyles\"> This div should be {{ canSave ? \"italic\": \"plain\"}}, {{ isUnchanged ? \"n",
    "id": "directives-*-overview-*-angular-101"
  },
  {
    "url": "https://angular.dev/guide/directives",
    "title": "Directives • Overview • Angular",
    "chunk": "ormal weight\" : \"bold\" }} and, {{ isSpecial ? \"extra large\": \"normal size\"}} after clicking \"Refresh\".</div><hr><h2>Built-in structural directives</h2><h3 id=\"ngIf\">NgIf Binding</h3><div> <p>If isActive is true, app-item-detail will render: </p> <app-item-detail *ngIf=\"isActive\" [item]=\"item\"></app-item-detail> <button type=\"button\" (click)=\"isActiveToggle()\">Toggle app-item-detail</button></div><p>If currentCustomer isn't null, say hello to Laura:</p><div *ngIf=\"currentCustomer\">Hello, {{ curre",
    "id": "directives-*-overview-*-angular-102"
  },
  {
    "url": "https://angular.dev/guide/directives",
    "title": "Directives • Overview • Angular",
    "chunk": "ntCustomer.name }}</div><p>nullCustomer is null by default. NgIf guards against null. Give it a value to show it:</p><div *ngIf=\"nullCustomer\">Hello, <span>{{ nullCustomer }}</span></div><button type=\"button\" (click)=\"giveNullCustomerValue()\">Give nullCustomer a value</button><h4>NgIf binding with template (no *)</h4><ng-template [ngIf]=\"currentItem\">Add {{ currentItem.name }} with template</ng-template><hr><h4>Show/hide vs. NgIf</h4><!-- isSpecial is true --><div [class.hidden]=\"!isSpecial\">Sho",
    "id": "directives-*-overview-*-angular-103"
  },
  {
    "url": "https://angular.dev/guide/directives",
    "title": "Directives • Overview • Angular",
    "chunk": "w with class</div><div [class.hidden]=\"isSpecial\">Hide with class</div><p>ItemDetail is in the DOM but hidden</p><app-item-detail [class.hidden]=\"isSpecial\"></app-item-detail><div [style.display]=\"isSpecial ? 'block' : 'none'\">Show with style</div><div [style.display]=\"isSpecial ? 'none' : 'block'\">Hide with style</div><hr><h2 id=\"ngFor\">NgFor Binding</h2><div class=\"box\"> <div *ngFor=\"let item of items\">{{ item.name }}</div></div><p>*ngFor with ItemDetailComponent element</p><div class=\"box\"> <",
    "id": "directives-*-overview-*-angular-104"
  },
  {
    "url": "https://angular.dev/guide/directives",
    "title": "Directives • Overview • Angular",
    "chunk": "app-item-detail *ngFor=\"let item of items\" [item]=\"item\"></app-item-detail></div><h4 id=\"ngFor-index\">*ngFor with index</h4><p>with <em>semi-colon</em> separator</p><div class=\"box\"> <div *ngFor=\"let item of items; let i=index\">{{ i + 1 }} - {{ item.name }}</div></div><p>with <em>comma</em> separator</p><div class=\"box\"> <div *ngFor=\"let item of items, let i=index\">{{ i + 1 }} - {{ item.name }}</div></div><h4 id=\"ngFor-trackBy\">*ngFor trackBy</h4><button type=\"button\" (click)=\"resetList()\">Reset",
    "id": "directives-*-overview-*-angular-105"
  },
  {
    "url": "https://angular.dev/guide/directives",
    "title": "Directives • Overview • Angular",
    "chunk": " items</button><button type=\"button\" (click)=\"changeIds()\">Change ids</button><button type=\"button\" (click)=\"clearTrackByCounts()\">Clear counts</button><p><em>without</em> trackBy</p><div class=\"box\"> <div #noTrackBy *ngFor=\"let item of items\">({{ item.id }}) {{ item.name }}</div> <div id=\"noTrackByCnt\" *ngIf=\"itemsNoTrackByCount\" > Item DOM elements change #{{ itemsNoTrackByCount }} without trackBy </div></div><p>with trackBy</p><div class=\"box\"> <div #withTrackBy *ngFor=\"let item of items; tra",
    "id": "directives-*-overview-*-angular-106"
  },
  {
    "url": "https://angular.dev/guide/directives",
    "title": "Directives • Overview • Angular",
    "chunk": "ckBy: trackByItems\">({{ item.id }}) {{ item.name }}</div> <div id=\"withTrackByCnt\" *ngIf=\"itemsWithTrackByCount\"> Item DOM elements change #{{ itemsWithTrackByCount }} with trackBy </div></div><br><br><br><p>with trackBy and <em>semi-colon</em> separator</p><div class=\"box\"> <div *ngFor=\"let item of items; trackBy: trackByItems\"> ({{ item.id }}) {{ item.name }} </div></div><p>with trackBy and <em>comma</em> separator</p><div class=\"box\"> <div *ngFor=\"let item of items, trackBy: trackByItems\">({{",
    "id": "directives-*-overview-*-angular-107"
  },
  {
    "url": "https://angular.dev/guide/directives",
    "title": "Directives • Overview • Angular",
    "chunk": " item.id }}) {{ item.name }}</div></div><p>with trackBy and <em>space</em> separator</p><div class=\"box\"> <div *ngFor=\"let item of items trackBy: trackByItems\">({{ item.id }}) {{ item.name }}</div></div><p>with <em>generic</em> trackById function</p><div class=\"box\"> <div *ngFor=\"let item of items, trackBy: trackById\">({{ item.id }}) {{ item.name }}</div></div><hr><h2>NgSwitch Binding</h2><p>Pick your favorite item</p><div> <label for=\"item-{{i}}\" *ngFor=\"let i of items\"> <div><input id=\"item-{{",
    "id": "directives-*-overview-*-angular-108"
  },
  {
    "url": "https://angular.dev/guide/directives",
    "title": "Directives • Overview • Angular",
    "chunk": "i}}\"type=\"radio\" name=\"items\" [(ngModel)]=\"currentItem\" [value]=\"i\">{{ i.name }} </div> </label></div><div [ngSwitch]=\"currentItem.feature\"> <app-stout-item *ngSwitchCase=\"'stout'\" [item]=\"currentItem\"></app-stout-item> <app-device-item *ngSwitchCase=\"'slim'\" [item]=\"currentItem\"></app-device-item> <app-lost-item *ngSwitchCase=\"'vintage'\" [item]=\"currentItem\"></app-lost-item> <app-best-item *ngSwitchCase=\"'bright'\" [item]=\"currentItem\"></app-best-item> <div *ngSwitchCase=\"'bright'\">Are you as br",
    "id": "directives-*-overview-*-angular-109"
  },
  {
    "url": "https://angular.dev/guide/directives",
    "title": "Directives • Overview • Angular",
    "chunk": "ight as {{ currentItem.name }}?</div> <app-unknown-item *ngSwitchDefault [item]=\"currentItem\"></app-unknown-item></div> Here are all variations in action, including the uppercase version: NgModel and value accessors The NgModel directive works for an element supported by a ControlValueAccessor. Angular provides value accessors for all of the basic HTML form elements. For more information, see Forms. To apply [(ngModel)] to a non-form built-in element or a third-party custom component, you have t",
    "id": "directives-*-overview-*-angular-110"
  },
  {
    "url": "https://angular.dev/guide/directives",
    "title": "Directives • Overview • Angular",
    "chunk": "o write a value accessor. For more information, see the API documentation on DefaultValueAccessor. HELPFUL: When you write an Angular component, you don't need a value accessor or NgModel if you name the value and event properties according to Angular's two-way binding syntax. Hosting a directive without a DOM element The Angular <ng-container> is a grouping element that doesn't interfere with styles or layout because Angular doesn't put it in the DOM. Use <ng-container> when there's no single e",
    "id": "directives-*-overview-*-angular-111"
  },
  {
    "url": "https://angular.dev/guide/directives",
    "title": "Directives • Overview • Angular",
    "chunk": "lement to host the directive. Here's a conditional paragraph using <ng-container>. src/app/app.component.html (ngif-ngcontainer) <h1>Structural Directives</h1><p>Conditional display of hero</p><blockquote><div *ngIf=\"hero\" class=\"name\">{{hero.name}}</div></blockquote><p>List of heroes</p><ul> <li *ngFor=\"let hero of heroes\">{{hero.name}}</li></ul><hr><h2 id=\"ngIf\">NgIf</h2><p *ngIf=\"true\"> Expression is true and ngIf is true. This paragraph is in the DOM.</p><p *ngIf=\"false\"> Expression is false",
    "id": "directives-*-overview-*-angular-112"
  },
  {
    "url": "https://angular.dev/guide/directives",
    "title": "Directives • Overview • Angular",
    "chunk": " and ngIf is false. This paragraph is not in the DOM.</p><p [style.display]=\"'block'\"> Expression sets display to \"block\". This paragraph is visible.</p><p [style.display]=\"'none'\"> Expression sets display to \"none\". This paragraph is hidden but still in the DOM.</p><h4>NgIf with template</h4><p><ng-template> element</p><ng-template [ngIf]=\"hero\"> <div class=\"name\">{{hero.name}}</div></ng-template><hr><h2 id=\"ng-container\"><ng-container></h2><h4>*ngIf with a <ng-container></h4><button type=\"butt",
    "id": "directives-*-overview-*-angular-113"
  },
  {
    "url": "https://angular.dev/guide/directives",
    "title": "Directives • Overview • Angular",
    "chunk": "on\" (click)=\"hero = hero ? null : heroes[0]\">Toggle hero</button><p> I turned the corner <ng-container *ngIf=\"hero\"> and saw {{hero.name}}. I waved </ng-container> and continued on my way.</p><p> I turned the corner <span *ngIf=\"hero\"> and saw {{hero.name}}. I waved </span> and continued on my way.</p><p><em><select> with <span></em></p><div> Pick your favorite hero (<label for=\"show-sad\"><input id=\"show-sad\" type=\"checkbox\" checked (change)=\"showSad = !showSad\">show sad</label>)</div><select [(",
    "id": "directives-*-overview-*-angular-114"
  },
  {
    "url": "https://angular.dev/guide/directives",
    "title": "Directives • Overview • Angular",
    "chunk": "ngModel)]=\"hero\"> <span *ngFor=\"let h of heroes\"> <span *ngIf=\"showSad || h.emotion !== 'sad'\"> <option [ngValue]=\"h\">{{h.name}} ({{h.emotion}})</option> </span> </span></select><p><em><select> with <ng-container></em></p><div> Pick your favorite hero (<label for=\"showSad\"><input id=\"showSad\" type=\"checkbox\" checked (change)=\"showSad = !showSad\">show sad</label>)</div><select [(ngModel)]=\"hero\"> <ng-container *ngFor=\"let h of heroes\"> <ng-container *ngIf=\"showSad || h.emotion !== 'sad'\"> <option",
    "id": "directives-*-overview-*-angular-115"
  },
  {
    "url": "https://angular.dev/guide/directives",
    "title": "Directives • Overview • Angular",
    "chunk": " [ngValue]=\"h\">{{h.name}} ({{h.emotion}})</option> </ng-container> </ng-container></select><br><br><hr><h2 id=\"ngFor\">NgFor</h2><div class=\"box\"><p class=\"code\"><div *ngFor=\"let hero of heroes; let i=index; let odd=odd; trackBy: trackById\" [class.odd]=\"odd\"></p><div *ngFor=\"let hero of heroes; let i=index; let odd=odd; trackBy: trackById\" [class.odd]=\"odd\"> ({{i}}) {{hero.name}}</div><p class=\"code\"><ng-template ngFor let-hero [ngForOf]=\"heroes\" let-i=\"index\" let-odd=\"odd\" [ngForTrackBy]=\"trackB",
    "id": "directives-*-overview-*-angular-116"
  },
  {
    "url": "https://angular.dev/guide/directives",
    "title": "Directives • Overview • Angular",
    "chunk": "yId\"/></p><ng-template ngFor let-hero [ngForOf]=\"heroes\" let-i=\"index\" let-odd=\"odd\" [ngForTrackBy]=\"trackById\"> <div [class.odd]=\"odd\"> ({{i}}) {{hero.name}} </div></ng-template></div><hr><h2 id=\"ngSwitch\">NgSwitch</h2><div>Pick your favorite hero</div><p> <label for=\"hero-{{h}}\" *ngFor=\"let h of heroes\"> <input id=\"hero-{{h}}\" type=\"radio\" name=\"heroes\" [(ngModel)]=\"hero\" [value]=\"h\">{{h.name}} </label> <label for=\"none-of-the-above\"><input id=\"none-of-the-above\" type=\"radio\" name=\"heroes\" (cl",
    "id": "directives-*-overview-*-angular-117"
  },
  {
    "url": "https://angular.dev/guide/directives",
    "title": "Directives • Overview • Angular",
    "chunk": "ick)=\"hero = null\">None of the above</label></p><h4>NgSwitch</h4><div [ngSwitch]=\"hero?.emotion\"> <app-happy-hero *ngSwitchCase=\"'happy'\" [hero]=\"hero!\"></app-happy-hero> <app-sad-hero *ngSwitchCase=\"'sad'\" [hero]=\"hero!\"></app-sad-hero> <app-confused-hero *ngSwitchCase=\"'confused'\" [hero]=\"hero!\"></app-confused-hero> <app-unknown-hero *ngSwitchDefault [hero]=\"hero!\"></app-unknown-hero></div><h4>NgSwitch with <ng-template></h4><div [ngSwitch]=\"hero?.emotion\"> <ng-template ngSwitchCase=\"happy\"> <",
    "id": "directives-*-overview-*-angular-118"
  },
  {
    "url": "https://angular.dev/guide/directives",
    "title": "Directives • Overview • Angular",
    "chunk": "app-happy-hero [hero]=\"hero!\"></app-happy-hero> </ng-template> <ng-template ngSwitchCase=\"sad\"> <app-sad-hero [hero]=\"hero!\"></app-sad-hero> </ng-template> <ng-template ngSwitchCase=\"confused\"> <app-confused-hero [hero]=\"hero!\"></app-confused-hero> </ng-template > <ng-template ngSwitchDefault> <app-unknown-hero [hero]=\"hero!\"></app-unknown-hero> </ng-template></div><hr><hr><h2 id=\"appIfLoaded\">IfLoadedDirective</h2><app-hero></app-hero><hr><h2 id=\"appTrigonometry\">TrigonometryDirective</h2><ul *",
    "id": "directives-*-overview-*-angular-119"
  },
  {
    "url": "https://angular.dev/guide/directives",
    "title": "Directives • Overview • Angular",
    "chunk": "appTrigonometry=\"30; sin as s; cos as c; tan as t\"> <li>sin(30°): {{ s }}</li> <li>cos(30°): {{ c }}</li> <li>tan(30°): {{ t }}</li></ul> Import the ngModel directive from FormsModule. Add FormsModule to the imports section of the relevant Angular module. To conditionally exclude an <option>, wrap the <option> in an <ng-container>. src/app/app.component.html (select-ngcontainer) <h1>Structural Directives</h1><p>Conditional display of hero</p><blockquote><div *ngIf=\"hero\" class=\"name\">{{hero.name",
    "id": "directives-*-overview-*-angular-120"
  },
  {
    "url": "https://angular.dev/guide/directives",
    "title": "Directives • Overview • Angular",
    "chunk": "}}</div></blockquote><p>List of heroes</p><ul> <li *ngFor=\"let hero of heroes\">{{hero.name}}</li></ul><hr><h2 id=\"ngIf\">NgIf</h2><p *ngIf=\"true\"> Expression is true and ngIf is true. This paragraph is in the DOM.</p><p *ngIf=\"false\"> Expression is false and ngIf is false. This paragraph is not in the DOM.</p><p [style.display]=\"'block'\"> Expression sets display to \"block\". This paragraph is visible.</p><p [style.display]=\"'none'\"> Expression sets display to \"none\". This paragraph is hidden but s",
    "id": "directives-*-overview-*-angular-121"
  },
  {
    "url": "https://angular.dev/guide/directives",
    "title": "Directives • Overview • Angular",
    "chunk": "till in the DOM.</p><h4>NgIf with template</h4><p><ng-template> element</p><ng-template [ngIf]=\"hero\"> <div class=\"name\">{{hero.name}}</div></ng-template><hr><h2 id=\"ng-container\"><ng-container></h2><h4>*ngIf with a <ng-container></h4><button type=\"button\" (click)=\"hero = hero ? null : heroes[0]\">Toggle hero</button><p> I turned the corner <ng-container *ngIf=\"hero\"> and saw {{hero.name}}. I waved </ng-container> and continued on my way.</p><p> I turned the corner <span *ngIf=\"hero\"> and saw {{h",
    "id": "directives-*-overview-*-angular-122"
  },
  {
    "url": "https://angular.dev/guide/directives",
    "title": "Directives • Overview • Angular",
    "chunk": "ero.name}}. I waved </span> and continued on my way.</p><p><em><select> with <span></em></p><div> Pick your favorite hero (<label for=\"show-sad\"><input id=\"show-sad\" type=\"checkbox\" checked (change)=\"showSad = !showSad\">show sad</label>)</div><select [(ngModel)]=\"hero\"> <span *ngFor=\"let h of heroes\"> <span *ngIf=\"showSad || h.emotion !== 'sad'\"> <option [ngValue]=\"h\">{{h.name}} ({{h.emotion}})</option> </span> </span></select><p><em><select> with <ng-container></em></p><div> Pick your favorite ",
    "id": "directives-*-overview-*-angular-123"
  },
  {
    "url": "https://angular.dev/guide/directives",
    "title": "Directives • Overview • Angular",
    "chunk": "hero (<label for=\"showSad\"><input id=\"showSad\" type=\"checkbox\" checked (change)=\"showSad = !showSad\">show sad</label>)</div><select [(ngModel)]=\"hero\"> <ng-container *ngFor=\"let h of heroes\"> <ng-container *ngIf=\"showSad || h.emotion !== 'sad'\"> <option [ngValue]=\"h\">{{h.name}} ({{h.emotion}})</option> </ng-container> </ng-container></select><br><br><hr><h2 id=\"ngFor\">NgFor</h2><div class=\"box\"><p class=\"code\"><div *ngFor=\"let hero of heroes; let i=index; let odd=odd; trackBy: trackById\" [class.",
    "id": "directives-*-overview-*-angular-124"
  },
  {
    "url": "https://angular.dev/guide/directives",
    "title": "Directives • Overview • Angular",
    "chunk": "odd]=\"odd\"></p><div *ngFor=\"let hero of heroes; let i=index; let odd=odd; trackBy: trackById\" [class.odd]=\"odd\"> ({{i}}) {{hero.name}}</div><p class=\"code\"><ng-template ngFor let-hero [ngForOf]=\"heroes\" let-i=\"index\" let-odd=\"odd\" [ngForTrackBy]=\"trackById\"/></p><ng-template ngFor let-hero [ngForOf]=\"heroes\" let-i=\"index\" let-odd=\"odd\" [ngForTrackBy]=\"trackById\"> <div [class.odd]=\"odd\"> ({{i}}) {{hero.name}} </div></ng-template></div><hr><h2 id=\"ngSwitch\">NgSwitch</h2><div>Pick your favorite her",
    "id": "directives-*-overview-*-angular-125"
  },
  {
    "url": "https://angular.dev/guide/directives",
    "title": "Directives • Overview • Angular",
    "chunk": "o</div><p> <label for=\"hero-{{h}}\" *ngFor=\"let h of heroes\"> <input id=\"hero-{{h}}\" type=\"radio\" name=\"heroes\" [(ngModel)]=\"hero\" [value]=\"h\">{{h.name}} </label> <label for=\"none-of-the-above\"><input id=\"none-of-the-above\" type=\"radio\" name=\"heroes\" (click)=\"hero = null\">None of the above</label></p><h4>NgSwitch</h4><div [ngSwitch]=\"hero?.emotion\"> <app-happy-hero *ngSwitchCase=\"'happy'\" [hero]=\"hero!\"></app-happy-hero> <app-sad-hero *ngSwitchCase=\"'sad'\" [hero]=\"hero!\"></app-sad-hero> <app-conf",
    "id": "directives-*-overview-*-angular-126"
  },
  {
    "url": "https://angular.dev/guide/directives",
    "title": "Directives • Overview • Angular",
    "chunk": "used-hero *ngSwitchCase=\"'confused'\" [hero]=\"hero!\"></app-confused-hero> <app-unknown-hero *ngSwitchDefault [hero]=\"hero!\"></app-unknown-hero></div><h4>NgSwitch with <ng-template></h4><div [ngSwitch]=\"hero?.emotion\"> <ng-template ngSwitchCase=\"happy\"> <app-happy-hero [hero]=\"hero!\"></app-happy-hero> </ng-template> <ng-template ngSwitchCase=\"sad\"> <app-sad-hero [hero]=\"hero!\"></app-sad-hero> </ng-template> <ng-template ngSwitchCase=\"confused\"> <app-confused-hero [hero]=\"hero!\"></app-confused-hero",
    "id": "directives-*-overview-*-angular-127"
  },
  {
    "url": "https://angular.dev/guide/directives",
    "title": "Directives • Overview • Angular",
    "chunk": "> </ng-template > <ng-template ngSwitchDefault> <app-unknown-hero [hero]=\"hero!\"></app-unknown-hero> </ng-template></div><hr><hr><h2 id=\"appIfLoaded\">IfLoadedDirective</h2><app-hero></app-hero><hr><h2 id=\"appTrigonometry\">TrigonometryDirective</h2><ul *appTrigonometry=\"30; sin as s; cos as c; tan as t\"> <li>sin(30°): {{ s }}</li> <li>cos(30°): {{ c }}</li> <li>tan(30°): {{ t }}</li></ul> What's next Attribute Directives Structural Directives Directive composition API Social MediaBlogX (formerly ",
    "id": "directives-*-overview-*-angular-128"
  },
  {
    "url": "https://angular.dev/guide/directives",
    "title": "Directives • Overview • Angular",
    "chunk": "Twitter)BlueskyYouTube Discord GitHub Stack Overflow Community Contribute Code of Conduct Report Issues Google's DevLibrary Angular Google Developer Experts ResourcesPress KitRoadmapLanguages简体中文版正體中文版日本語版한국어 Ελληνικά Super-powered by Google ©2010-2025. Code licensed under an MIT-style License . Documentation licensed under CC BY 4.0 . In-depth GuidesDirectives Built-in directives Directives are classes that add additional behavior to elements in your Angular applications.",
    "id": "directives-*-overview-*-angular-129"
  },
  {
    "url": "https://angular.dev/guide/directives/attribute-directives",
    "title": "Attribute directives • Angular",
    "chunk": "In-depth GuidesDirectives Attribute directives Change the appearance or behavior of DOM elements and Angular components with attribute directives. On this pagearrow_upward_alt Back to the top Building an attribute directive This section walks you through creating a highlight directive that sets the background color of the host element to yellow. To create a directive, use the CLI command ng generate directive. ng generate directive highlight The CLI creates src/app/highlight.directive.ts, a corr",
    "id": "attribute-directives-*-angular-0"
  },
  {
    "url": "https://angular.dev/guide/directives/attribute-directives",
    "title": "Attribute directives • Angular",
    "chunk": "esponding test file src/app/highlight.directive.spec.ts. src/app/highlight.directive.ts import {Directive} from '@angular/core';@Directive({ selector: '[appHighlight]',})export class HighlightDirective {} The @Directive() decorator's configuration property specifies the directive's CSS attribute selector, [appHighlight]. Import ElementRef from @angular/core. ElementRef grants direct access to the host DOM element through its nativeElement property. Add ElementRef in the directive's constructor()",
    "id": "attribute-directives-*-angular-1"
  },
  {
    "url": "https://angular.dev/guide/directives/attribute-directives",
    "title": "Attribute directives • Angular",
    "chunk": " to inject a reference to the host DOM element, the element to which you apply appHighlight. Add logic to the HighlightDirective class that sets the background to yellow. src/app/highlight.directive.ts import {Directive, ElementRef, inject} from '@angular/core';@Directive({ selector: '[appHighlight]',})export class HighlightDirective { private el = inject(ElementRef); constructor() { this.el.nativeElement.style.backgroundColor = 'yellow'; }} HELPFUL: Directives do not support namespaces. src/app",
    "id": "attribute-directives-*-angular-2"
  },
  {
    "url": "https://angular.dev/guide/directives/attribute-directives",
    "title": "Attribute directives • Angular",
    "chunk": "/app.component.avoid.html (unsupported) <p app:Highlight>This is invalid</p> Applying an attribute directive To use the HighlightDirective, add a <p> element to the HTML template with the directive as an attribute. src/app/app.component.html <h1>My First Attribute Directive</h1><p appHighlight>Highlight me!</p><p appHighlight=\"yellow\">Highlighted in yellow</p><p [appHighlight]=\"'orange'\">Highlighted in orange</p><p [appHighlight]=\"color\">Highlighted with parent component's color</p> Angular crea",
    "id": "attribute-directives-*-angular-3"
  },
  {
    "url": "https://angular.dev/guide/directives/attribute-directives",
    "title": "Attribute directives • Angular",
    "chunk": "tes an instance of the HighlightDirective class and injects a reference to the <p> element into the directive's constructor, which sets the <p> element's background style to yellow. Handling user events This section shows you how to detect when a user mouses into or out of the element and to respond by setting or clearing the highlight color. Import HostListener from '@angular/core'. src/app/highlight.directive.ts (imports) import {Directive, ElementRef, HostListener, inject} from '@angular/core",
    "id": "attribute-directives-*-angular-4"
  },
  {
    "url": "https://angular.dev/guide/directives/attribute-directives",
    "title": "Attribute directives • Angular",
    "chunk": "';@Directive({ selector: '[appHighlight]',})export class HighlightDirective { private el = inject(ElementRef); @HostListener('mouseenter') onMouseEnter() { this.highlight('yellow'); } @HostListener('mouseleave') onMouseLeave() { this.highlight(''); } private highlight(color: string) { this.el.nativeElement.style.backgroundColor = color; }} Add two event handlers that respond when the mouse enters or leaves, each with the @HostListener() decorator. src/app/highlight.directive.ts (mouse-methods) i",
    "id": "attribute-directives-*-angular-5"
  },
  {
    "url": "https://angular.dev/guide/directives/attribute-directives",
    "title": "Attribute directives • Angular",
    "chunk": "mport {Directive, ElementRef, HostListener, inject} from '@angular/core';@Directive({ selector: '[appHighlight]',})export class HighlightDirective { private el = inject(ElementRef); @HostListener('mouseenter') onMouseEnter() { this.highlight('yellow'); } @HostListener('mouseleave') onMouseLeave() { this.highlight(''); } private highlight(color: string) { this.el.nativeElement.style.backgroundColor = color; }} Subscribe to events of the DOM element that hosts an attribute directive, the <p> in th",
    "id": "attribute-directives-*-angular-6"
  },
  {
    "url": "https://angular.dev/guide/directives/attribute-directives",
    "title": "Attribute directives • Angular",
    "chunk": "is case, with the @HostListener() decorator. HELPFUL: The handlers delegate to a helper method, highlight(), that sets the color on the host DOM element, el. The complete directive is as follows: src/app/highlight.directive.ts import {Directive, ElementRef, HostListener, inject} from '@angular/core';@Directive({ selector: '[appHighlight]',})export class HighlightDirective { private el = inject(ElementRef); @HostListener('mouseenter') onMouseEnter() { this.highlight('yellow'); } @HostListener('mo",
    "id": "attribute-directives-*-angular-7"
  },
  {
    "url": "https://angular.dev/guide/directives/attribute-directives",
    "title": "Attribute directives • Angular",
    "chunk": "useleave') onMouseLeave() { this.highlight(''); } private highlight(color: string) { this.el.nativeElement.style.backgroundColor = color; }} The background color appears when the pointer hovers over the paragraph element and disappears as the pointer moves out. Passing values into an attribute directive This section walks you through setting the highlight color while applying the HighlightDirective. In highlight.directive.ts, import Input from @angular/core. src/app/highlight.directive.ts (impor",
    "id": "attribute-directives-*-angular-8"
  },
  {
    "url": "https://angular.dev/guide/directives/attribute-directives",
    "title": "Attribute directives • Angular",
    "chunk": "ts) import {Directive, ElementRef, HostListener, inject, input} from '@angular/core';@Directive({ selector: '[appHighlight]',})export class HighlightDirective { private el = inject(ElementRef); appHighlight = input(''); @HostListener('mouseenter') onMouseEnter() { this.highlight(this.appHighlight() || 'red'); } @HostListener('mouseleave') onMouseLeave() { this.highlight(''); } private highlight(color: string) { this.el.nativeElement.style.backgroundColor = color; }} Add an appHighlight input pro",
    "id": "attribute-directives-*-angular-9"
  },
  {
    "url": "https://angular.dev/guide/directives/attribute-directives",
    "title": "Attribute directives • Angular",
    "chunk": "perty. src/app/highlight.directive.ts import {Directive, ElementRef, HostListener, inject, input} from '@angular/core';@Directive({ selector: '[appHighlight]',})export class HighlightDirective { private el = inject(ElementRef); appHighlight = input(''); @HostListener('mouseenter') onMouseEnter() { this.highlight(this.appHighlight() || 'red'); } @HostListener('mouseleave') onMouseLeave() { this.highlight(''); } private highlight(color: string) { this.el.nativeElement.style.backgroundColor = color",
    "id": "attribute-directives-*-angular-10"
  },
  {
    "url": "https://angular.dev/guide/directives/attribute-directives",
    "title": "Attribute directives • Angular",
    "chunk": "; }} The input() function adds metadata to the class that makes the directive's appHighlight property available for binding. In app.component.ts, add a color property to the AppComponent. src/app/app.component.ts (class) import {Component} from '@angular/core';import {HighlightDirective} from './highlight.directive';@Component({ selector: 'app-root', templateUrl: './app.component.1.html', imports: [HighlightDirective],})export class AppComponent { color = 'yellow';} To simultaneously apply the d",
    "id": "attribute-directives-*-angular-11"
  },
  {
    "url": "https://angular.dev/guide/directives/attribute-directives",
    "title": "Attribute directives • Angular",
    "chunk": "irective and the color, use property binding with the appHighlight directive selector, setting it equal to color. src/app/app.component.html (color) <h1>My First Attribute Directive</h1><h2>Pick a highlight color</h2><div> <input type=\"radio\" name=\"colors\" (click)=\"color='lightgreen'\">Green <input type=\"radio\" name=\"colors\" (click)=\"color='yellow'\">Yellow <input type=\"radio\" name=\"colors\" (click)=\"color='cyan'\">Cyan</div><p [appHighlight]=\"color\">Highlight me!</p><p [appHighlight]=\"color\" defaul",
    "id": "attribute-directives-*-angular-12"
  },
  {
    "url": "https://angular.dev/guide/directives/attribute-directives",
    "title": "Attribute directives • Angular",
    "chunk": "tColor=\"violet\"> Highlight me too!</p><hr><h2>Mouse over the following lines to see fixed highlights</h2><p [appHighlight]=\"'yellow'\">Highlighted in yellow</p><p appHighlight=\"orange\">Highlighted in orange</p><hr><h2>ngNonBindable</h2><p>Use ngNonBindable to stop evaluation.</p><p ngNonBindable>This should not evaluate: {{ 1 + 1 }}</p><h3>ngNonBindable with a directive</h3><div ngNonBindable [appHighlight]=\"'yellow'\">This should not evaluate: {{ 1 +1 }}, but will highlight yellow.</div> The [app",
    "id": "attribute-directives-*-angular-13"
  },
  {
    "url": "https://angular.dev/guide/directives/attribute-directives",
    "title": "Attribute directives • Angular",
    "chunk": "Highlight] attribute binding performs two tasks: Applies the highlighting directive to the <p> element Sets the directive's highlight color with a property binding Setting the value with user input This section guides you through adding radio buttons to bind your color choice to the appHighlight directive. Add markup to app.component.html for choosing a color as follows: src/app/app.component.html (v2) <h1>My First Attribute Directive</h1><h2>Pick a highlight color</h2><div> <input type=\"radio\" ",
    "id": "attribute-directives-*-angular-14"
  },
  {
    "url": "https://angular.dev/guide/directives/attribute-directives",
    "title": "Attribute directives • Angular",
    "chunk": "name=\"colors\" (click)=\"color='lightgreen'\">Green <input type=\"radio\" name=\"colors\" (click)=\"color='yellow'\">Yellow <input type=\"radio\" name=\"colors\" (click)=\"color='cyan'\">Cyan</div><p [appHighlight]=\"color\">Highlight me!</p><p [appHighlight]=\"color\" defaultColor=\"violet\"> Highlight me too!</p><hr><h2>Mouse over the following lines to see fixed highlights</h2><p [appHighlight]=\"'yellow'\">Highlighted in yellow</p><p appHighlight=\"orange\">Highlighted in orange</p><hr><h2>ngNonBindable</h2><p>Use n",
    "id": "attribute-directives-*-angular-15"
  },
  {
    "url": "https://angular.dev/guide/directives/attribute-directives",
    "title": "Attribute directives • Angular",
    "chunk": "gNonBindable to stop evaluation.</p><p ngNonBindable>This should not evaluate: {{ 1 + 1 }}</p><h3>ngNonBindable with a directive</h3><div ngNonBindable [appHighlight]=\"'yellow'\">This should not evaluate: {{ 1 +1 }}, but will highlight yellow.</div> Revise the AppComponent.color so that it has no initial value. src/app/app.component.ts (class) import {Component} from '@angular/core';import {HighlightDirective} from './highlight.directive';@Component({ selector: 'app-root', templateUrl: './app.com",
    "id": "attribute-directives-*-angular-16"
  },
  {
    "url": "https://angular.dev/guide/directives/attribute-directives",
    "title": "Attribute directives • Angular",
    "chunk": "ponent.html', imports: [HighlightDirective],})export class AppComponent { color = '';} In highlight.directive.ts, revise onMouseEnter method so that it first tries to highlight with appHighlight and falls back to red if appHighlight is undefined. src/app/highlight.directive.ts (mouse-enter) import {Directive, ElementRef, HostListener, inject, input} from '@angular/core';@Directive({ selector: '[appHighlight]',})export class HighlightDirective { private el = inject(ElementRef); appHighlight = inp",
    "id": "attribute-directives-*-angular-17"
  },
  {
    "url": "https://angular.dev/guide/directives/attribute-directives",
    "title": "Attribute directives • Angular",
    "chunk": "ut(''); @HostListener('mouseenter') onMouseEnter() { this.highlight(this.appHighlight() || 'red'); } @HostListener('mouseleave') onMouseLeave() { this.highlight(''); } private highlight(color: string) { this.el.nativeElement.style.backgroundColor = color; }} Serve your application to verify that the user can choose the color with the radio buttons. Binding to a second property This section guides you through configuring your application so the developer can set the default color. Add a second In",
    "id": "attribute-directives-*-angular-18"
  },
  {
    "url": "https://angular.dev/guide/directives/attribute-directives",
    "title": "Attribute directives • Angular",
    "chunk": "put() property to HighlightDirective called defaultColor. src/app/highlight.directive.ts (defaultColor) import {Directive, ElementRef, HostListener, inject, input} from '@angular/core';@Directive({ selector: '[appHighlight]',})export class HighlightDirective { private el = inject(ElementRef); defaultColor = input(''); appHighlight = input(''); @HostListener('mouseenter') onMouseEnter() { this.highlight(this.appHighlight() || this.defaultColor() || 'red'); } @HostListener('mouseleave') onMouseLea",
    "id": "attribute-directives-*-angular-19"
  },
  {
    "url": "https://angular.dev/guide/directives/attribute-directives",
    "title": "Attribute directives • Angular",
    "chunk": "ve() { this.highlight(''); } private highlight(color: string) { this.el.nativeElement.style.backgroundColor = color; }} Revise the directive's onMouseEnter so that it first tries to highlight with the appHighlight, then with the defaultColor, and falls back to red if both properties are undefined. src/app/highlight.directive.ts (mouse-enter) import {Directive, ElementRef, HostListener, inject, input} from '@angular/core';@Directive({ selector: '[appHighlight]',})export class HighlightDirective {",
    "id": "attribute-directives-*-angular-20"
  },
  {
    "url": "https://angular.dev/guide/directives/attribute-directives",
    "title": "Attribute directives • Angular",
    "chunk": " private el = inject(ElementRef); defaultColor = input(''); appHighlight = input(''); @HostListener('mouseenter') onMouseEnter() { this.highlight(this.appHighlight() || this.defaultColor() || 'red'); } @HostListener('mouseleave') onMouseLeave() { this.highlight(''); } private highlight(color: string) { this.el.nativeElement.style.backgroundColor = color; }} To bind to the AppComponent.color and fall back to \"violet\" as the default color, add the following HTML. In this case, the defaultColor bin",
    "id": "attribute-directives-*-angular-21"
  },
  {
    "url": "https://angular.dev/guide/directives/attribute-directives",
    "title": "Attribute directives • Angular",
    "chunk": "ding doesn't use square brackets, [], because it is static. src/app/app.component.html (defaultColor) <h1>My First Attribute Directive</h1><h2>Pick a highlight color</h2><div> <input type=\"radio\" name=\"colors\" (click)=\"color='lightgreen'\">Green <input type=\"radio\" name=\"colors\" (click)=\"color='yellow'\">Yellow <input type=\"radio\" name=\"colors\" (click)=\"color='cyan'\">Cyan</div><p [appHighlight]=\"color\">Highlight me!</p><p [appHighlight]=\"color\" defaultColor=\"violet\"> Highlight me too!</p><hr><h2>M",
    "id": "attribute-directives-*-angular-22"
  },
  {
    "url": "https://angular.dev/guide/directives/attribute-directives",
    "title": "Attribute directives • Angular",
    "chunk": "ouse over the following lines to see fixed highlights</h2><p [appHighlight]=\"'yellow'\">Highlighted in yellow</p><p appHighlight=\"orange\">Highlighted in orange</p><hr><h2>ngNonBindable</h2><p>Use ngNonBindable to stop evaluation.</p><p ngNonBindable>This should not evaluate: {{ 1 + 1 }}</p><h3>ngNonBindable with a directive</h3><div ngNonBindable [appHighlight]=\"'yellow'\">This should not evaluate: {{ 1 +1 }}, but will highlight yellow.</div> As with components, you can add multiple directive prop",
    "id": "attribute-directives-*-angular-23"
  },
  {
    "url": "https://angular.dev/guide/directives/attribute-directives",
    "title": "Attribute directives • Angular",
    "chunk": "erty bindings to a host element. The default color is red if there is no default color binding. When the user chooses a color the selected color becomes the active highlight color. Deactivating Angular processing with NgNonBindable To prevent expression evaluation in the browser, add ngNonBindable to the host element. ngNonBindable deactivates interpolation, directives, and binding in templates. In the following example, the expression {{ 1 + 1 }} renders just as it does in your code editor, and",
    "id": "attribute-directives-*-angular-24"
  },
  {
    "url": "https://angular.dev/guide/directives/attribute-directives",
    "title": "Attribute directives • Angular",
    "chunk": " does not display 2. src/app/app.component.html <h1>My First Attribute Directive</h1><h2>Pick a highlight color</h2><div> <input type=\"radio\" name=\"colors\" (click)=\"color='lightgreen'\">Green <input type=\"radio\" name=\"colors\" (click)=\"color='yellow'\">Yellow <input type=\"radio\" name=\"colors\" (click)=\"color='cyan'\">Cyan</div><p [appHighlight]=\"color\">Highlight me!</p><p [appHighlight]=\"color\" defaultColor=\"violet\"> Highlight me too!</p><hr><h2>Mouse over the following lines to see fixed highlights<",
    "id": "attribute-directives-*-angular-25"
  },
  {
    "url": "https://angular.dev/guide/directives/attribute-directives",
    "title": "Attribute directives • Angular",
    "chunk": "/h2><p [appHighlight]=\"'yellow'\">Highlighted in yellow</p><p appHighlight=\"orange\">Highlighted in orange</p><hr><h2>ngNonBindable</h2><p>Use ngNonBindable to stop evaluation.</p><p ngNonBindable>This should not evaluate: {{ 1 + 1 }}</p><h3>ngNonBindable with a directive</h3><div ngNonBindable [appHighlight]=\"'yellow'\">This should not evaluate: {{ 1 +1 }}, but will highlight yellow.</div> Applying ngNonBindable to an element stops binding for that element's child elements. However, ngNonBindable ",
    "id": "attribute-directives-*-angular-26"
  },
  {
    "url": "https://angular.dev/guide/directives/attribute-directives",
    "title": "Attribute directives • Angular",
    "chunk": "still lets directives work on the element where you apply ngNonBindable. In the following example, the appHighlight directive is still active but Angular does not evaluate the expression {{ 1 + 1 }}. src/app/app.component.html <h1>My First Attribute Directive</h1><h2>Pick a highlight color</h2><div> <input type=\"radio\" name=\"colors\" (click)=\"color='lightgreen'\">Green <input type=\"radio\" name=\"colors\" (click)=\"color='yellow'\">Yellow <input type=\"radio\" name=\"colors\" (click)=\"color='cyan'\">Cyan</d",
    "id": "attribute-directives-*-angular-27"
  },
  {
    "url": "https://angular.dev/guide/directives/attribute-directives",
    "title": "Attribute directives • Angular",
    "chunk": "iv><p [appHighlight]=\"color\">Highlight me!</p><p [appHighlight]=\"color\" defaultColor=\"violet\"> Highlight me too!</p><hr><h2>Mouse over the following lines to see fixed highlights</h2><p [appHighlight]=\"'yellow'\">Highlighted in yellow</p><p appHighlight=\"orange\">Highlighted in orange</p><hr><h2>ngNonBindable</h2><p>Use ngNonBindable to stop evaluation.</p><p ngNonBindable>This should not evaluate: {{ 1 + 1 }}</p><h3>ngNonBindable with a directive</h3><div ngNonBindable [appHighlight]=\"'yellow'\">T",
    "id": "attribute-directives-*-angular-28"
  },
  {
    "url": "https://angular.dev/guide/directives/attribute-directives",
    "title": "Attribute directives • Angular",
    "chunk": "his should not evaluate: {{ 1 +1 }}, but will highlight yellow.</div> If you apply ngNonBindable to a parent element, Angular disables interpolation and binding of any sort, such as property binding or event binding, for the element's children. Social MediaBlogX (formerly Twitter)BlueskyYouTube Discord GitHub Stack Overflow Community Contribute Code of Conduct Report Issues Google's DevLibrary Angular Google Developer Experts ResourcesPress KitRoadmapLanguages简体中文版正體中文版日本語版한국어 Ελληνικά Super-pow",
    "id": "attribute-directives-*-angular-29"
  },
  {
    "url": "https://angular.dev/guide/directives/attribute-directives",
    "title": "Attribute directives • Angular",
    "chunk": "ered by Google ©2010-2025. Code licensed under an MIT-style License . Documentation licensed under CC BY 4.0 .",
    "id": "attribute-directives-*-angular-30"
  },
  {
    "url": "https://angular.dev/guide/directives/structural-directives",
    "title": "Structural directives • Angular",
    "chunk": "In-depth GuidesDirectives Structural directives Structural directives are directives applied to an <ng-template> element that conditionally or repeatedly render the content of that <ng-template>. On this pagearrow_upward_alt Back to the top Example use case In this guide you'll build a structural directive which fetches data from a given data source and renders its template when that data is available. This directive is called SelectDirective, after the SQL keyword SELECT, and match it with an a",
    "id": "structural-directives-*-angular-0"
  },
  {
    "url": "https://angular.dev/guide/directives/structural-directives",
    "title": "Structural directives • Angular",
    "chunk": "ttribute selector [select]. SelectDirective will have an input naming the data source to be used, which you will call selectFrom. The select prefix for this input is important for the shorthand syntax. The directive will instantiate its <ng-template> with a template context providing the selected data. The following is an example of using this directive directly on an <ng-template> would look like: <ng-template select let-data [selectFrom]=\"source\"> <p>The data is: {{ data }}</p></ng-template> T",
    "id": "structural-directives-*-angular-1"
  },
  {
    "url": "https://angular.dev/guide/directives/structural-directives",
    "title": "Structural directives • Angular",
    "chunk": "he structural directive can wait for the data to become available and then render its <ng-template>. HELPFUL: Note that Angular's <ng-template> element defines a template that doesn't render anything by default, if you just wrap elements in an <ng-template> without applying a structural directive those elements will not be rendered. For more information, see the ng-template API documentation. Structural directive shorthand Angular supports a shorthand syntax for structural directives which avoid",
    "id": "structural-directives-*-angular-2"
  },
  {
    "url": "https://angular.dev/guide/directives/structural-directives",
    "title": "Structural directives • Angular",
    "chunk": "s the need to explicitly author an <ng-template> element. Structural directives can be applied directly on an element by prefixing the directive attribute selector with an asterisk (*), such as *select. Angular transforms the asterisk in front of a structural directive into an <ng-template> that hosts the directive and surrounds the element and its descendants. You can use this with SelectDirective as follows: <p *select=\"let data from source\">The data is: {{data}}</p> This example shows the fle",
    "id": "structural-directives-*-angular-3"
  },
  {
    "url": "https://angular.dev/guide/directives/structural-directives",
    "title": "Structural directives • Angular",
    "chunk": "xibility of structural directive shorthand syntax, which is sometimes called microsyntax. When used in this way, only the structural directive and its bindings are applied to the <ng-template>. Any other attributes or bindings on the <p> tag are left alone. For example, these two forms are equivalent: <!-- Shorthand syntax: --><p class=\"data-view\" *select=\"let data from source\">The data is: {{data}}</p><!-- Long-form syntax: --><ng-template select let-data [selectFrom]=\"source\"> <p class=\"data-v",
    "id": "structural-directives-*-angular-4"
  },
  {
    "url": "https://angular.dev/guide/directives/structural-directives",
    "title": "Structural directives • Angular",
    "chunk": "iew\">The data is: {{data}}</p></ng-template> Shorthand syntax is expanded through a set of conventions. A more thorough grammar is defined below, but in the above example, this transformation can be explained as follows: The first part of the *select expression is let data, which declares a template variable data. Since no assignment follows, the template variable is bound to the template context property $implicit. The second piece of syntax is a key-expression pair, from source. from is a bind",
    "id": "structural-directives-*-angular-5"
  },
  {
    "url": "https://angular.dev/guide/directives/structural-directives",
    "title": "Structural directives • Angular",
    "chunk": "ing key and source is a regular template expression. Binding keys are mapped to properties by transforming them to PascalCase and prepending the structural directive selector. The from key is mapped to selectFrom, which is then bound to the expression source. This is why many structural directives will have inputs that are all prefixed with the structural directive's selector. One structural directive per element You can only apply one structural directive per element when using the shorthand sy",
    "id": "structural-directives-*-angular-6"
  },
  {
    "url": "https://angular.dev/guide/directives/structural-directives",
    "title": "Structural directives • Angular",
    "chunk": "ntax. This is because there is only one <ng-template> element onto which that directive gets unwrapped. Multiple directives would require multiple nested <ng-template>, and it's unclear which directive should be first. <ng-container> can be used when to create wrapper layers when multiple structural directives need to be applied around the same physical DOM element or component, which allows the user to define the nested structure. Creating a structural directive This section guides you through ",
    "id": "structural-directives-*-angular-7"
  },
  {
    "url": "https://angular.dev/guide/directives/structural-directives",
    "title": "Structural directives • Angular",
    "chunk": "creating the SelectDirective. Generate the directive Using the Angular CLI, run the following command, where select is the name of the directive: ng generate directive select Angular creates the directive class and specifies the CSS selector, [select], that identifies the directive in a template. Make the directive structural Import TemplateRef, and ViewContainerRef. Inject TemplateRef and ViewContainerRef in the directive as private properties. import {Directive, TemplateRef, ViewContainerRef} ",
    "id": "structural-directives-*-angular-8"
  },
  {
    "url": "https://angular.dev/guide/directives/structural-directives",
    "title": "Structural directives • Angular",
    "chunk": "from '@angular/core';@Directive({ selector: '[select]',})export class SelectDirective { private templateRef = inject(TemplateRef); private viewContainerRef = inject(ViewContainerRef);} Add the 'selectFrom' input Add a selectFrom @Input() property. export class SelectDirective { // ... @Input({required: true}) selectFrom!: DataSource;} Add the business logic With SelectDirective now scaffolded as a structural directive with its input, you can now add the logic to fetch the data and render the tem",
    "id": "structural-directives-*-angular-9"
  },
  {
    "url": "https://angular.dev/guide/directives/structural-directives",
    "title": "Structural directives • Angular",
    "chunk": "plate with it: export class SelectDirective { // ... async ngOnInit() { const data = await this.selectFrom.load(); this.viewContainerRef.createEmbeddedView(this.templateRef, { // Create the embedded view with a context object that contains // the data via the key `$implicit`. $implicit: data, }); }} That's it - SelectDirective is up and running. A follow-up step might be to add template type-checking support. Structural directive syntax reference When you write your own structural directives, us",
    "id": "structural-directives-*-angular-10"
  },
  {
    "url": "https://angular.dev/guide/directives/structural-directives",
    "title": "Structural directives • Angular",
    "chunk": "e the following syntax: *:prefix=\"( :let | :expression ) (';' | ',')? ( :let | :as | :keyExp )*\" The following patterns describe each portion of the structural directive grammar: as = :export \"as\" :local \";\"?keyExp = :key \":\"? :expression (\"as\" :local)? \";\"?let = \"let\" :local \"=\" :export \";\"? Keyword Details prefix HTML attribute key key HTML attribute key local Local variable name used in the template export Value exported by the directive under a given name expression Standard Angular expressi",
    "id": "structural-directives-*-angular-11"
  },
  {
    "url": "https://angular.dev/guide/directives/structural-directives",
    "title": "Structural directives • Angular",
    "chunk": "on How Angular translates shorthand Angular translates structural directive shorthand into the normal binding syntax as follows: Shorthand Translation prefix and naked expression [prefix]=\"expression\" keyExp [prefixKey]=\"expression\" (The prefix is added to the key) let local let-local=\"export\" Shorthand examples The following table provides shorthand examples: Shorthand How Angular interprets the syntax *myDir=\"let item of [1,2,3]\" <ng-template myDir let-item [myDirOf]=\"[1, 2, 3]\"> *myDir=\"let i",
    "id": "structural-directives-*-angular-12"
  },
  {
    "url": "https://angular.dev/guide/directives/structural-directives",
    "title": "Structural directives • Angular",
    "chunk": "tem of [1,2,3] as items; trackBy: myTrack; index as i\" <ng-template myDir let-item [myDirOf]=\"[1,2,3]\" let-items=\"myDirOf\" [myDirTrackBy]=\"myTrack\" let-i=\"index\"> *ngComponentOutlet=\"componentClass\"; <ng-template [ngComponentOutlet]=\"componentClass\"> *ngComponentOutlet=\"componentClass; inputs: myInputs\"; <ng-template [ngComponentOutlet]=\"componentClass\" [ngComponentOutletInputs]=\"myInputs\"> *myDir=\"exp as value\" <ng-template [myDir]=\"exp\" let-value=\"myDir\"> Improving template type checking for c",
    "id": "structural-directives-*-angular-13"
  },
  {
    "url": "https://angular.dev/guide/directives/structural-directives",
    "title": "Structural directives • Angular",
    "chunk": "ustom directives You can improve template type checking for custom directives by adding template guards to your directive definition. These guards help the Angular template type checker find mistakes in the template at compile time, which can avoid runtime errors. Two different types of guards are possible: ngTemplateGuard_(input) lets you control how an input expression should be narrowed based on the type of a specific input. ngTemplateContextGuard is used to determine the type of the context ",
    "id": "structural-directives-*-angular-14"
  },
  {
    "url": "https://angular.dev/guide/directives/structural-directives",
    "title": "Structural directives • Angular",
    "chunk": "object for the template, based on the type of the directive itself. This section provides examples of both kinds of guards. For more information, see Template type checking. Type narrowing with template guards A structural directive in a template controls whether that template is rendered at run time. Some structural directives want to perform type narrowing based on the type of input expression. There are two narrowings which are possible with input guards: Narrowing the input expression based ",
    "id": "structural-directives-*-angular-15"
  },
  {
    "url": "https://angular.dev/guide/directives/structural-directives",
    "title": "Structural directives • Angular",
    "chunk": "on a TypeScript type assertion function. Narrowing the input expression based on its truthiness. To narrow the input expression by defining a type assertion function: // This directive only renders its template if the actor is a user.// You want to assert that within the template, the type of the `actor`// expression is narrowed to `User`.@Directive(...)class ActorIsUser { @Input() actor: User|Robot; static ngTemplateGuard_actor(dir: ActorIsUser, expr: User|Robot): expr is User { // The return s",
    "id": "structural-directives-*-angular-16"
  },
  {
    "url": "https://angular.dev/guide/directives/structural-directives",
    "title": "Structural directives • Angular",
    "chunk": "tatement is unnecessary in practice, but included to // prevent TypeScript errors. return true; }} Type-checking will behave within the template as if the ngTemplateGuard_actor has been asserted on the expression bound to the input. Some directives only render their templates when an input is truthy. It's not possible to capture the full semantics of truthiness in a type assertion function, so instead a literal type of 'binding' can be used to signal to the template type-checker that the binding",
    "id": "structural-directives-*-angular-17"
  },
  {
    "url": "https://angular.dev/guide/directives/structural-directives",
    "title": "Structural directives • Angular",
    "chunk": " expression itself should be used as the guard: @Directive(...)class CustomIf { @Input() condition!: any; static ngTemplateGuard_condition: 'binding';} The template type-checker will behave as if the expression bound to condition was asserted to be truthy within the template. Typing the directive's context If your structural directive provides a context to the instantiated template, you can properly type it inside the template by providing a static ngTemplateContextGuard type assertion function.",
    "id": "structural-directives-*-angular-18"
  },
  {
    "url": "https://angular.dev/guide/directives/structural-directives",
    "title": "Structural directives • Angular",
    "chunk": " This function can use the type of the directive to derive the type of the context, which is useful when the type of the directive is generic. For the SelectDirective described above, you can implement an ngTemplateContextGuard to correctly specify the data type, even if the data source is generic. // Declare an interface for the template context:export interface SelectTemplateContext<T> { $implicit: T;}@Directive(...)export class SelectDirective<T> { // The directive's generic type `T` will be ",
    "id": "structural-directives-*-angular-19"
  },
  {
    "url": "https://angular.dev/guide/directives/structural-directives",
    "title": "Structural directives • Angular",
    "chunk": "inferred from the `DataSource` type // passed to the input. @Input({required: true}) selectFrom!: DataSource<T>; // Narrow the type of the context using the generic type of the directive. static ngTemplateContextGuard<T>(dir: SelectDirective<T>, ctx: any): ctx is SelectTemplateContext<T> { // As before the guard body is not used at runtime, and included only to avoid // TypeScript errors. return true; }} Social MediaBlogX (formerly Twitter)BlueskyYouTube Discord GitHub Stack Overflow Community C",
    "id": "structural-directives-*-angular-20"
  },
  {
    "url": "https://angular.dev/guide/directives/structural-directives",
    "title": "Structural directives • Angular",
    "chunk": "ontribute Code of Conduct Report Issues Google's DevLibrary Angular Google Developer Experts ResourcesPress KitRoadmapLanguages简体中文版正體中文版日本語版한국어 Ελληνικά Super-powered by Google ©2010-2025. Code licensed under an MIT-style License . Documentation licensed under CC BY 4.0 .",
    "id": "structural-directives-*-angular-21"
  },
  {
    "url": "https://angular.dev/guide/directives/directive-composition-api",
    "title": "Directive composition API • Angular",
    "chunk": "In-depth GuidesDirectives Directive composition API Angular directives offer a great way to encapsulate reusable behaviors— directives can apply attributes, CSS classes, and event listeners to an element. The directive composition API lets you apply directives to a component's host element from within the component TypeScript class. On this pagearrow_upward_alt Back to the top Adding directives to a component You apply directives to a component by adding a hostDirectives property to a component'",
    "id": "directive-composition-api-*-angular-0"
  },
  {
    "url": "https://angular.dev/guide/directives/directive-composition-api",
    "title": "Directive composition API • Angular",
    "chunk": "s decorator. We call such directives host directives. In this example, we apply the directive MenuBehavior to the host element of AdminMenu. This works similarly to applying the MenuBehavior to the <admin-menu> element in a template. @Component({ selector: 'admin-menu', template: 'admin-menu.html', hostDirectives: [MenuBehavior],})export class AdminMenu { } When the framework renders a component, Angular also creates an instance of each host directive. The directives' host bindings apply to the ",
    "id": "directive-composition-api-*-angular-1"
  },
  {
    "url": "https://angular.dev/guide/directives/directive-composition-api",
    "title": "Directive composition API • Angular",
    "chunk": "component's host element. By default, host directive inputs and outputs are not exposed as part of the component's public API. See Including inputs and outputs below for more information. Angular applies host directives statically at compile time. You cannot dynamically add directives at runtime. Directives used in hostDirectives may not specify standalone: false. Angular ignores the selector of directives applied in the hostDirectives property. Including inputs and outputs When you apply hostDi",
    "id": "directive-composition-api-*-angular-2"
  },
  {
    "url": "https://angular.dev/guide/directives/directive-composition-api",
    "title": "Directive composition API • Angular",
    "chunk": "rectives to your component, the inputs and outputs from the host directives are not included in your component's API by default. You can explicitly include inputs and outputs in your component's API by expanding the entry in hostDirectives: @Component({ selector: 'admin-menu', template: 'admin-menu.html', hostDirectives: [{ directive: MenuBehavior, inputs: ['menuId'], outputs: ['menuClosed'], }],})export class AdminMenu { } By explicitly specifying the inputs and outputs, consumers of the compon",
    "id": "directive-composition-api-*-angular-3"
  },
  {
    "url": "https://angular.dev/guide/directives/directive-composition-api",
    "title": "Directive composition API • Angular",
    "chunk": "ent with hostDirective can bind them in a template: <admin-menu menuId=\"top-menu\" (menuClosed)=\"logMenuClosed()\"> Furthermore, you can alias inputs and outputs from hostDirective to customize the API of your component: @Component({ selector: 'admin-menu', template: 'admin-menu.html', hostDirectives: [{ directive: MenuBehavior, inputs: ['menuId: id'], outputs: ['menuClosed: closed'], }],})export class AdminMenu { } <admin-menu id=\"top-menu\" (closed)=\"logMenuClosed()\"> Adding directives to another",
    "id": "directive-composition-api-*-angular-4"
  },
  {
    "url": "https://angular.dev/guide/directives/directive-composition-api",
    "title": "Directive composition API • Angular",
    "chunk": " directive You can also add hostDirectives to other directives, in addition to components. This enables the transitive aggregation of multiple behaviors. In the following example, we define two directives, Menu and Tooltip. We then compose the behavior of these two directives in MenuWithTooltip. Finally, we apply MenuWithTooltip to SpecializedMenuWithTooltip. When SpecializedMenuWithTooltip is used in a template, it creates instances of all of Menu , Tooltip, and MenuWithTooltip. Each of these d",
    "id": "directive-composition-api-*-angular-5"
  },
  {
    "url": "https://angular.dev/guide/directives/directive-composition-api",
    "title": "Directive composition API • Angular",
    "chunk": "irectives' host bindings apply to the host element of SpecializedMenuWithTooltip. @Directive({...})export class Menu { }@Directive({...})export class Tooltip { }// MenuWithTooltip can compose behaviors from multiple other directives@Directive({ hostDirectives: [Tooltip, Menu],})export class MenuWithTooltip { }// CustomWidget can apply the already-composed behaviors from MenuWithTooltip@Directive({ hostDirectives: [MenuWithTooltip],})export class SpecializedMenuWithTooltip { } Host directive sema",
    "id": "directive-composition-api-*-angular-6"
  },
  {
    "url": "https://angular.dev/guide/directives/directive-composition-api",
    "title": "Directive composition API • Angular",
    "chunk": "ntics Directive execution order Host directives go through the same lifecycle as components and directives used directly in a template. However, host directives always execute their constructor, lifecycle hooks, and bindings before the component or directive on which they are applied. The following example shows minimal use of a host directive: @Component({ selector: 'admin-menu', template: 'admin-menu.html', hostDirectives: [MenuBehavior],})export class AdminMenu { } The order of execution here",
    "id": "directive-composition-api-*-angular-7"
  },
  {
    "url": "https://angular.dev/guide/directives/directive-composition-api",
    "title": "Directive composition API • Angular",
    "chunk": " is: MenuBehavior instantiated AdminMenu instantiated MenuBehavior receives inputs (ngOnInit) AdminMenu receives inputs (ngOnInit) MenuBehavior applies host bindings AdminMenu applies host bindings This order of operations means that components with hostDirectives can override any host bindings specified by a host directive. This order of operations extends to nested chains of host directives, as shown in the following example. @Directive({...})export class Tooltip { }@Directive({ hostDirectives",
    "id": "directive-composition-api-*-angular-8"
  },
  {
    "url": "https://angular.dev/guide/directives/directive-composition-api",
    "title": "Directive composition API • Angular",
    "chunk": ": [Tooltip],})export class CustomTooltip { }@Directive({ hostDirectives: [CustomTooltip],})export class EvenMoreCustomTooltip { } In the example above, the order of execution is: Tooltip instantiated CustomTooltip instantiated EvenMoreCustomTooltip instantiated Tooltip receives inputs (ngOnInit) CustomTooltip receives inputs (ngOnInit) EvenMoreCustomTooltip receives inputs (ngOnInit) Tooltip applies host bindings CustomTooltip applies host bindings EvenMoreCustomTooltip applies host bindings Dep",
    "id": "directive-composition-api-*-angular-9"
  },
  {
    "url": "https://angular.dev/guide/directives/directive-composition-api",
    "title": "Directive composition API • Angular",
    "chunk": "endency injection A component or directive that specifies hostDirectives can inject the instances of those host directives and vice versa. When applying host directives to a component, both the component and host directives can define providers. If a component or directive with hostDirectives and those host directives both provide the same injection token, the providers defined by class with hostDirectives take precedence over providers defined by the host directives. Social MediaBlogX (formerly",
    "id": "directive-composition-api-*-angular-10"
  },
  {
    "url": "https://angular.dev/guide/directives/directive-composition-api",
    "title": "Directive composition API • Angular",
    "chunk": " Twitter)BlueskyYouTube Discord GitHub Stack Overflow Community Contribute Code of Conduct Report Issues Google's DevLibrary Angular Google Developer Experts ResourcesPress KitRoadmapLanguages简体中文版正體中文版日本語版한국어 Ελληνικά Super-powered by Google ©2010-2025. Code licensed under an MIT-style License . Documentation licensed under CC BY 4.0 .",
    "id": "directive-composition-api-*-angular-11"
  },
  {
    "url": "https://angular.dev/guide/image-optimization",
    "title": "Optimizing images with NgOptimizedImage • Angular",
    "chunk": "In-depth GuidesDirectives Getting started with NgOptimizedImage The NgOptimizedImage directive makes it easy to adopt performance best practices for loading images. The directive ensures that the loading of the Largest Contentful Paint (LCP) image is prioritized by: Automatically setting the fetchpriority attribute on the <img> tag Lazy loading other images by default Automatically generating a preconnect link tag in the document head Automatically generating a srcset attribute Generating a prel",
    "id": "optimizing-images-with-ngoptimizedimage-*-angular-0"
  },
  {
    "url": "https://angular.dev/guide/image-optimization",
    "title": "Optimizing images with NgOptimizedImage • Angular",
    "chunk": "oad hint if app is using SSR In addition to optimizing the loading of the LCP image, NgOptimizedImage enforces a number of image best practices, such as: Using image CDN URLs to apply image optimizations Preventing layout shift by requiring width and height Warning if width or height have been set incorrectly Warning if the image will be visually distorted when rendered If you're using a background image in CSS, start here. NOTE: Although the NgOptimizedImage directive was made a stable feature ",
    "id": "optimizing-images-with-ngoptimizedimage-*-angular-1"
  },
  {
    "url": "https://angular.dev/guide/image-optimization",
    "title": "Optimizing images with NgOptimizedImage • Angular",
    "chunk": "in Angular version 15, it has been backported and is available as a stable feature in versions 13.4.0 and 14.3.0 as well. On this pagearrow_upward_alt Back to the top Getting Started Import NgOptimizedImage directive Import NgOptimizedImage directive from @angular/common: import { NgOptimizedImage } from '@angular/common' and include it into the imports array of a standalone component or an NgModule: imports: [ NgOptimizedImage, // ...], (Optional) Set up a Loader An image loader is not required",
    "id": "optimizing-images-with-ngoptimizedimage-*-angular-2"
  },
  {
    "url": "https://angular.dev/guide/image-optimization",
    "title": "Optimizing images with NgOptimizedImage • Angular",
    "chunk": " in order to use NgOptimizedImage, but using one with an image CDN enables powerful performance features, including automatic srcsets for your images. A brief guide for setting up a loader can be found in the Configuring an Image Loader section at the end of this page. Enable the directive To activate the NgOptimizedImage directive, replace your image's src attribute with ngSrc. <img ngSrc=\"cat.jpg\"> If you're using a built-in third-party loader, make sure to omit the base URL path from src, as ",
    "id": "optimizing-images-with-ngoptimizedimage-*-angular-3"
  },
  {
    "url": "https://angular.dev/guide/image-optimization",
    "title": "Optimizing images with NgOptimizedImage • Angular",
    "chunk": "that will be prepended automatically by the loader. Mark images as priority Always mark the LCP image on your page as priority to prioritize its loading. <img ngSrc=\"cat.jpg\" width=\"400\" height=\"200\" priority> Marking an image as priority applies the following optimizations: Sets fetchpriority=high (read more about priority hints here) Sets loading=eager (read more about native lazy loading here) Automatically generates a preload link element if rendering on the server. Angular displays a warnin",
    "id": "optimizing-images-with-ngoptimizedimage-*-angular-4"
  },
  {
    "url": "https://angular.dev/guide/image-optimization",
    "title": "Optimizing images with NgOptimizedImage • Angular",
    "chunk": "g during development if the LCP element is an image that does not have the priority attribute. A page’s LCP element can vary based on a number of factors - such as the dimensions of a user's screen, so a page may have multiple images that should be marked priority. See CSS for Web Vitals for more details. Include Width and Height In order to prevent image-related layout shifts, NgOptimizedImage requires that you specify a height and width for your image, as follows: <img ngSrc=\"cat.jpg\" width=\"4",
    "id": "optimizing-images-with-ngoptimizedimage-*-angular-5"
  },
  {
    "url": "https://angular.dev/guide/image-optimization",
    "title": "Optimizing images with NgOptimizedImage • Angular",
    "chunk": "00\" height=\"200\"> For responsive images (images which you've styled to grow and shrink relative to the viewport), the width and height attributes should be the intrinsic size of the image file. For responsive images it's also important to set a value for sizes. For fixed size images, the width and height attributes should reflect the desired rendered size of the image. The aspect ratio of these attributes should always match the intrinsic aspect ratio of the image. NOTE: If you don't know the si",
    "id": "optimizing-images-with-ngoptimizedimage-*-angular-6"
  },
  {
    "url": "https://angular.dev/guide/image-optimization",
    "title": "Optimizing images with NgOptimizedImage • Angular",
    "chunk": "ze of your images, consider using \"fill mode\" to inherit the size of the parent container, as described below. Using fill mode In cases where you want to have an image fill a containing element, you can use the fill attribute. This is often useful when you want to achieve a \"background image\" behavior. It can also be helpful when you don't know the exact width and height of your image, but you do have a parent container with a known size that you'd like to fit your image into (see \"object-fit\" b",
    "id": "optimizing-images-with-ngoptimizedimage-*-angular-7"
  },
  {
    "url": "https://angular.dev/guide/image-optimization",
    "title": "Optimizing images with NgOptimizedImage • Angular",
    "chunk": "elow). When you add the fill attribute to your image, you do not need and should not include a width and height, as in this example: <img ngSrc=\"cat.jpg\" fill> You can use the object-fit CSS property to change how the image will fill its container. If you style your image with object-fit: \"contain\", the image will maintain its aspect ratio and be \"letterboxed\" to fit the element. If you set object-fit: \"cover\", the element will retain its aspect ratio, fully fill the element, and some content ma",
    "id": "optimizing-images-with-ngoptimizedimage-*-angular-8"
  },
  {
    "url": "https://angular.dev/guide/image-optimization",
    "title": "Optimizing images with NgOptimizedImage • Angular",
    "chunk": "y be \"cropped\" off. See visual examples of the above at the MDN object-fit documentation. You can also style your image with the object-position property to adjust its position within its containing element. IMPORTANT: For the \"fill\" image to render properly, its parent element must be styled with position: \"relative\", position: \"fixed\", or position: \"absolute\". How to migrate your background image Here's a simple step-by-step process for migrating from background-image to NgOptimizedImage. For ",
    "id": "optimizing-images-with-ngoptimizedimage-*-angular-9"
  },
  {
    "url": "https://angular.dev/guide/image-optimization",
    "title": "Optimizing images with NgOptimizedImage • Angular",
    "chunk": "these steps, we'll refer to the element that has an image background as the \"containing element\": Remove the background-image style from the containing element. Ensure that the containing element has position: \"relative\", position: \"fixed\", or position: \"absolute\". Create a new image element as a child of the containing element, using ngSrc to enable the NgOptimizedImage directive. Give that element the fill attribute. Do not include a height and width. If you believe this image might be your LC",
    "id": "optimizing-images-with-ngoptimizedimage-*-angular-10"
  },
  {
    "url": "https://angular.dev/guide/image-optimization",
    "title": "Optimizing images with NgOptimizedImage • Angular",
    "chunk": "P element, add the priority attribute to the image element. You can adjust how the background image fills the container as described in the Using fill mode section. Using placeholders Automatic placeholders NgOptimizedImage can display an automatic low-resolution placeholder for your image if you're using a CDN or image host that provides automatic image resizing. Take advantage of this feature by adding the placeholder attribute to your image: <img ngSrc=\"cat.jpg\" width=\"400\" height=\"200\" place",
    "id": "optimizing-images-with-ngoptimizedimage-*-angular-11"
  },
  {
    "url": "https://angular.dev/guide/image-optimization",
    "title": "Optimizing images with NgOptimizedImage • Angular",
    "chunk": "holder> Adding this attribute automatically requests a second, smaller version of the image using your specified image loader. This small image will be applied as a background-image style with a CSS blur while your image loads. If no image loader is provided, no placeholder image can be generated and an error will be thrown. The default size for generated placeholders is 30px wide. You can change this size by specifying a pixel value in the IMAGE_CONFIG provider, as seen below: providers: [ { pr",
    "id": "optimizing-images-with-ngoptimizedimage-*-angular-12"
  },
  {
    "url": "https://angular.dev/guide/image-optimization",
    "title": "Optimizing images with NgOptimizedImage • Angular",
    "chunk": "ovide: IMAGE_CONFIG, useValue: { placeholderResolution: 40 } },], If you want sharp edges around your blurred placeholder, you can wrap your image in a containing <div> with the overflow: hidden style. As long as the <div> is the same size as the image (such as by using the width: fit-content style), the \"fuzzy edges\" of the placeholder will be hidden. Data URL placeholders You can also specify a placeholder using a base64 data URL without an image loader. The data url format is data:image/[imag",
    "id": "optimizing-images-with-ngoptimizedimage-*-angular-13"
  },
  {
    "url": "https://angular.dev/guide/image-optimization",
    "title": "Optimizing images with NgOptimizedImage • Angular",
    "chunk": "etype];[data], where [imagetype] is the image format, just as png, and [data] is a base64 encoding of the image. That encoding can be done using the command line or in JavaScript. For specific commands, see the MDN documentation. An example of a data URL placeholder with truncated data is shown below: <img ngSrc=\"cat.jpg\" width=\"400\" height=\"200\" placeholder=\"data:image/png;base64,iVBORw0K...\"/> However, large data URLs increase the size of your Angular bundles and slow down page load. If you ca",
    "id": "optimizing-images-with-ngoptimizedimage-*-angular-14"
  },
  {
    "url": "https://angular.dev/guide/image-optimization",
    "title": "Optimizing images with NgOptimizedImage • Angular",
    "chunk": "nnot use an image loader, the Angular team recommends keeping base64 placeholder images smaller than 4KB and using them exclusively on critical images. In addition to decreasing placeholder dimensions, consider changing image formats or parameters used when saving images. At very low resolutions, these parameters can have a large effect on file size. Non-blurred placeholders By default, NgOptimizedImage applies a CSS blur effect to image placeholders. To render a placeholder without blur, provid",
    "id": "optimizing-images-with-ngoptimizedimage-*-angular-15"
  },
  {
    "url": "https://angular.dev/guide/image-optimization",
    "title": "Optimizing images with NgOptimizedImage • Angular",
    "chunk": "e a placeholderConfig argument with an object that includes the blur property, set to false. For example: <img ngSrc=\"cat.jpg\" width=\"400\" height=\"200\" placeholder [placeholderConfig]=\"{blur: false}\"/> Adjusting image styling Depending on the image's styling, adding width and height attributes may cause the image to render differently. NgOptimizedImage warns you if your image styling renders the image at a distorted aspect ratio. You can typically fix this by adding height: auto or width: auto t",
    "id": "optimizing-images-with-ngoptimizedimage-*-angular-16"
  },
  {
    "url": "https://angular.dev/guide/image-optimization",
    "title": "Optimizing images with NgOptimizedImage • Angular",
    "chunk": "o your image styles. For more information, see the web.dev article on the <img> tag. If the width and height attribute on the image are preventing you from sizing the image the way you want with CSS, consider using fill mode instead, and styling the image's parent element. Performance Features NgOptimizedImage includes a number of features designed to improve loading performance in your app. These features are described in this section. Add resource hints A preconnect resource hint for your imag",
    "id": "optimizing-images-with-ngoptimizedimage-*-angular-17"
  },
  {
    "url": "https://angular.dev/guide/image-optimization",
    "title": "Optimizing images with NgOptimizedImage • Angular",
    "chunk": "e origin ensures that the LCP image loads as quickly as possible. Preconnect links are automatically generated for domains provided as an argument to a loader. If an image origin cannot be automatically identified, and no preconnect link is detected for the LCP image, NgOptimizedImage will warn during development. In that case, you should manually add a resource hint to index.html. Within the <head> of the document, add a link tag with rel=\"preconnect\", as shown below: <link rel=\"preconnect\" hre",
    "id": "optimizing-images-with-ngoptimizedimage-*-angular-18"
  },
  {
    "url": "https://angular.dev/guide/image-optimization",
    "title": "Optimizing images with NgOptimizedImage • Angular",
    "chunk": "f=\"https://my.cdn.origin\" /> To disable preconnect warnings, inject the PRECONNECT_CHECK_BLOCKLIST token: providers: [ {provide: PRECONNECT_CHECK_BLOCKLIST, useValue: 'https://your-domain.com'}], See more information on automatic preconnect generation here. Request images at the correct size with automatic srcset Defining a srcset attribute ensures that the browser requests an image at the right size for your user's viewport, so it doesn't waste time downloading an image that's too large. NgOpti",
    "id": "optimizing-images-with-ngoptimizedimage-*-angular-19"
  },
  {
    "url": "https://angular.dev/guide/image-optimization",
    "title": "Optimizing images with NgOptimizedImage • Angular",
    "chunk": "mizedImage generates an appropriate srcset for the image, based on the presence and value of the sizes attribute on the image tag. Fixed-size images If your image should be \"fixed\" in size (i.e. the same size across devices, except for pixel density), there is no need to set a sizes attribute. A srcset can be generated automatically from the image's width and height attributes with no further input required. Example srcset generated: <img ... srcset=\"image-400w.jpg 1x, image-800w.jpg 2x\"> Respon",
    "id": "optimizing-images-with-ngoptimizedimage-*-angular-20"
  },
  {
    "url": "https://angular.dev/guide/image-optimization",
    "title": "Optimizing images with NgOptimizedImage • Angular",
    "chunk": "sive images If your image should be responsive (i.e. grow and shrink according to viewport size), then you will need to define a sizes attribute to generate the srcset. If you haven't used sizes before, a good place to start is to set it based on viewport width. For example, if your CSS causes the image to fill 100% of viewport width, set sizes to 100vw and the browser will select the image in the srcset that is closest to the viewport width (after accounting for pixel density). If your image is",
    "id": "optimizing-images-with-ngoptimizedimage-*-angular-21"
  },
  {
    "url": "https://angular.dev/guide/image-optimization",
    "title": "Optimizing images with NgOptimizedImage • Angular",
    "chunk": " only likely to take up half the screen (ex: in a sidebar), set sizes to 50vw to ensure the browser selects a smaller image. And so on. If you find that the above does not cover your desired image behavior, see the documentation on advanced sizes values. Note that NgOptimizedImage automatically prepends \"auto\" to the provided sizes value. This is an optimization that increases the accuracy of srcset selection on browsers which support sizes=\"auto\", and is ignored by browsers which do not. By def",
    "id": "optimizing-images-with-ngoptimizedimage-*-angular-22"
  },
  {
    "url": "https://angular.dev/guide/image-optimization",
    "title": "Optimizing images with NgOptimizedImage • Angular",
    "chunk": "ault, the responsive breakpoints are: [16, 32, 48, 64, 96, 128, 256, 384, 640, 750, 828, 1080, 1200, 1920, 2048, 3840] If you would like to customize these breakpoints, you can do so using the IMAGE_CONFIG provider: providers: [ { provide: IMAGE_CONFIG, useValue: { breakpoints: [16, 48, 96, 128, 384, 640, 750, 828, 1080, 1200, 1920] } },], If you would like to manually define a srcset attribute, you can provide your own using the ngSrcset attribute: <img ngSrc=\"hero.jpg\" ngSrcset=\"100w, 200w, 30",
    "id": "optimizing-images-with-ngoptimizedimage-*-angular-23"
  },
  {
    "url": "https://angular.dev/guide/image-optimization",
    "title": "Optimizing images with NgOptimizedImage • Angular",
    "chunk": "0w\"> If the ngSrcset attribute is present, NgOptimizedImage generates and sets the srcset based on the sizes included. Do not include image file names in ngSrcset - the directive infers this information from ngSrc. The directive supports both width descriptors (e.g. 100w) and density descriptors (e.g. 1x). <img ngSrc=\"hero.jpg\" ngSrcset=\"100w, 200w, 300w\" sizes=\"50vw\"> Disabling automatic srcset generation To disable srcset generation for a single image, you can add the disableOptimizedSrcset at",
    "id": "optimizing-images-with-ngoptimizedimage-*-angular-24"
  },
  {
    "url": "https://angular.dev/guide/image-optimization",
    "title": "Optimizing images with NgOptimizedImage • Angular",
    "chunk": "tribute on the image: <img ngSrc=\"about.jpg\" disableOptimizedSrcset> Disabling image lazy loading By default, NgOptimizedImage sets loading=lazy for all images that are not marked priority. You can disable this behavior for non-priority images by setting the loading attribute. This attribute accepts values: eager, auto, and lazy. See the documentation for the standard image loading attribute for details. <img ngSrc=\"cat.jpg\" width=\"400\" height=\"200\" loading=\"eager\"> Advanced 'sizes' values You m",
    "id": "optimizing-images-with-ngoptimizedimage-*-angular-25"
  },
  {
    "url": "https://angular.dev/guide/image-optimization",
    "title": "Optimizing images with NgOptimizedImage • Angular",
    "chunk": "ay want to have images displayed at varying widths on differently-sized screens. A common example of this pattern is a grid- or column-based layout that renders a single column on mobile devices, and two columns on larger devices. You can capture this behavior in the sizes attribute, using a \"media query\" syntax, such as the following: <img ngSrc=\"cat.jpg\" width=\"400\" height=\"200\" sizes=\"(max-width: 768px) 100vw, 50vw\"> The sizes attribute in the above example says \"I expect this image to be 100",
    "id": "optimizing-images-with-ngoptimizedimage-*-angular-26"
  },
  {
    "url": "https://angular.dev/guide/image-optimization",
    "title": "Optimizing images with NgOptimizedImage • Angular",
    "chunk": " percent of the screen width on devices under 768px wide. Otherwise, I expect it to be 50 percent of the screen width. For additional information about the sizes attribute, see web.dev or mdn. Configuring an image loader for NgOptimizedImage A \"loader\" is a function that generates an image transformation URL for a given image file. When appropriate, NgOptimizedImage sets the size, format, and image quality transformations for an image. NgOptimizedImage provides both a generic loader that applies",
    "id": "optimizing-images-with-ngoptimizedimage-*-angular-27"
  },
  {
    "url": "https://angular.dev/guide/image-optimization",
    "title": "Optimizing images with NgOptimizedImage • Angular",
    "chunk": " no transformations, as well as loaders for various third-party image services. It also supports writing your own custom loader. Loader type Behavior Generic loader The URL returned by the generic loader will always match the value of src. In other words, this loader applies no transformations. Sites that use Angular to serve images are the primary intended use case for this loader. Loaders for third-party image services The URL returned by the loaders for third-party image services will follow ",
    "id": "optimizing-images-with-ngoptimizedimage-*-angular-28"
  },
  {
    "url": "https://angular.dev/guide/image-optimization",
    "title": "Optimizing images with NgOptimizedImage • Angular",
    "chunk": "API conventions used by that particular image service. Custom loaders A custom loader's behavior is defined by its developer. You should use a custom loader if your image service isn't supported by the loaders that come preconfigured with NgOptimizedImage. Based on the image services commonly used with Angular applications, NgOptimizedImage provides loaders preconfigured to work with the following image services: Image Service Angular API Documentation Cloudflare Image Resizing provideCloudflare",
    "id": "optimizing-images-with-ngoptimizedimage-*-angular-29"
  },
  {
    "url": "https://angular.dev/guide/image-optimization",
    "title": "Optimizing images with NgOptimizedImage • Angular",
    "chunk": "Loader Documentation Cloudinary provideCloudinaryLoader Documentation ImageKit provideImageKitLoader Documentation Imgix provideImgixLoader Documentation Netlify provideNetlifyLoader Documentation To use the generic loader no additional code changes are necessary. This is the default behavior. Built-in Loaders To use an existing loader for a third-party image service, add the provider factory for your chosen service to the providers array. In the example below, the Imgix loader is used: provider",
    "id": "optimizing-images-with-ngoptimizedimage-*-angular-30"
  },
  {
    "url": "https://angular.dev/guide/image-optimization",
    "title": "Optimizing images with NgOptimizedImage • Angular",
    "chunk": "s: [ provideImgixLoader('https://my.base.url/'),], The base URL for your image assets should be passed to the provider factory as an argument. For most sites, this base URL should match one of the following patterns: https://yoursite.yourcdn.com https://subdomain.yoursite.com https://subdomain.yourcdn.com/yoursite You can learn more about the base URL structure in the docs of a corresponding CDN provider. Custom Loaders To use a custom loader, provide your loader function as a value for the IMAG",
    "id": "optimizing-images-with-ngoptimizedimage-*-angular-31"
  },
  {
    "url": "https://angular.dev/guide/image-optimization",
    "title": "Optimizing images with NgOptimizedImage • Angular",
    "chunk": "E_LOADER DI token. In the example below, the custom loader function returns a URL starting with https://example.com that includes src and width as URL parameters. providers: [ { provide: IMAGE_LOADER, useValue: (config: ImageLoaderConfig) => { return `https://example.com/images?src=${config.src}&width=${config.width}`; }, },], A loader function for the NgOptimizedImage directive takes an object with the ImageLoaderConfig type (from @angular/common) as its argument and returns the absolute URL of",
    "id": "optimizing-images-with-ngoptimizedimage-*-angular-32"
  },
  {
    "url": "https://angular.dev/guide/image-optimization",
    "title": "Optimizing images with NgOptimizedImage • Angular",
    "chunk": " the image asset. The ImageLoaderConfig object contains the src property, and optional width and loaderParams properties. NOTE: even though the width property may not always be present, a custom loader must use it to support requesting images at various widths in order for ngSrcset to work properly. The loaderParams Property There is an additional attribute supported by the NgOptimizedImage directive, called loaderParams, which is specifically designed to support the use of custom loaders. The l",
    "id": "optimizing-images-with-ngoptimizedimage-*-angular-33"
  },
  {
    "url": "https://angular.dev/guide/image-optimization",
    "title": "Optimizing images with NgOptimizedImage • Angular",
    "chunk": "oaderParams attribute takes an object with any properties as a value, and does not do anything on its own. The data in loaderParams is added to the ImageLoaderConfig object passed to your custom loader, and can be used to control the behavior of the loader. A common use for loaderParams is controlling advanced image CDN features. Example custom loader The following shows an example of a custom loader function. This example function concatenates src and width, and uses loaderParams to control a c",
    "id": "optimizing-images-with-ngoptimizedimage-*-angular-34"
  },
  {
    "url": "https://angular.dev/guide/image-optimization",
    "title": "Optimizing images with NgOptimizedImage • Angular",
    "chunk": "ustom CDN feature for rounded corners: const myCustomLoader = (config: ImageLoaderConfig) => { let url = `https://example.com/images/${config.src}?`; let queryParams = []; if (config.width) { queryParams.push(`w=${config.width}`); } if (config.loaderParams?.roundedCorners) { queryParams.push('mask=corners&corner-radius=5'); } return url + queryParams.join('&');}; Note that in the above example, we've invented the 'roundedCorners' property name to control a feature of our custom loader. We could ",
    "id": "optimizing-images-with-ngoptimizedimage-*-angular-35"
  },
  {
    "url": "https://angular.dev/guide/image-optimization",
    "title": "Optimizing images with NgOptimizedImage • Angular",
    "chunk": "then use this feature when creating an image, as follows: <img ngSrc=\"profile.jpg\" width=\"300\" height=\"300\" [loaderParams]=\"{roundedCorners: true}\"> Frequently Asked Questions Does NgOptimizedImage support the background-image css property? The NgOptimizedImage does not directly support the background-image css property, but it is designed to easily accommodate the use case of having an image as the background of another element. For a step-by-step process for migration from background-image to ",
    "id": "optimizing-images-with-ngoptimizedimage-*-angular-36"
  },
  {
    "url": "https://angular.dev/guide/image-optimization",
    "title": "Optimizing images with NgOptimizedImage • Angular",
    "chunk": "NgOptimizedImage, see the How to migrate your background image section above. Why can't I use src with NgOptimizedImage? The ngSrc attribute was chosen as the trigger for NgOptimizedImage due to technical considerations around how images are loaded by the browser. NgOptimizedImage makes programmatic changes to the loading attribute -- if the browser sees the src attribute before those changes are made, it will begin eagerly downloading the image file, and the loading changes will be ignored. Why",
    "id": "optimizing-images-with-ngoptimizedimage-*-angular-37"
  },
  {
    "url": "https://angular.dev/guide/image-optimization",
    "title": "Optimizing images with NgOptimizedImage • Angular",
    "chunk": " is a preconnect element not being generated for my image domain? Preconnect generation is performed based on static analysis of your application. That means that the image domain must be directly included in the loader parameter, as in the following example: providers: [ provideImgixLoader('https://my.base.url/'),], If you use a variable to pass the domain string to the loader, or you're not using a loader, the static analysis will not be able to identify the domain, and no preconnect link will",
    "id": "optimizing-images-with-ngoptimizedimage-*-angular-38"
  },
  {
    "url": "https://angular.dev/guide/image-optimization",
    "title": "Optimizing images with NgOptimizedImage • Angular",
    "chunk": " be generated. In this case you should manually add a preconnect link to the document head, as described above. Can I use two different image domains in the same page? The image loaders provider pattern is designed to be as simple as possible for the common use case of having only a single image CDN used within a component. However, it's still very possible to manage multiple image CDNs using a single provider. To do this, we recommend writing a custom image loader which uses the loaderParams pr",
    "id": "optimizing-images-with-ngoptimizedimage-*-angular-39"
  },
  {
    "url": "https://angular.dev/guide/image-optimization",
    "title": "Optimizing images with NgOptimizedImage • Angular",
    "chunk": "operty to pass a flag that specifies which image CDN should be used, and then invokes the appropriate loader based on that flag. Can you add a new built-in loader for my preferred CDN? For maintenance reasons, we don't currently plan to support additional built-in loaders in the Angular repository. Instead, we encourage developers to publish any additional image loaders as third-party packages. Can I use this with the <picture> tag No, but this is on our roadmap, so stay tuned. If you're waiting",
    "id": "optimizing-images-with-ngoptimizedimage-*-angular-40"
  },
  {
    "url": "https://angular.dev/guide/image-optimization",
    "title": "Optimizing images with NgOptimizedImage • Angular",
    "chunk": " on this feature, please upvote the Github issue here. How do I find my LCP image with Chrome DevTools? Using the performance tab of the Chrome DevTools, click on the \"start profiling and reload page\" button on the top left. It looks like a page refresh icon. This will trigger a profiling snapshot of your Angular application. Once the profiling result is available, select \"LCP\" in the timings section. A summary entry should appear in the panel at the bottom. You can find the LCP element in the r",
    "id": "optimizing-images-with-ngoptimizedimage-*-angular-41"
  },
  {
    "url": "https://angular.dev/guide/image-optimization",
    "title": "Optimizing images with NgOptimizedImage • Angular",
    "chunk": "ow for \"related node\". Clicking on it will reveal the element in the Elements panel. NOTE: This only identifies the LCP element within the viewport of the page you are testing. It is also recommended to use mobile emulation to identify the LCP element for smaller screens. Social MediaBlogX (formerly Twitter)BlueskyYouTube Discord GitHub Stack Overflow Community Contribute Code of Conduct Report Issues Google's DevLibrary Angular Google Developer Experts ResourcesPress KitRoadmapLanguages简体中文版正體中",
    "id": "optimizing-images-with-ngoptimizedimage-*-angular-42"
  },
  {
    "url": "https://angular.dev/guide/image-optimization",
    "title": "Optimizing images with NgOptimizedImage • Angular",
    "chunk": "文版日本語版한국어 Ελληνικά Super-powered by Google ©2010-2025. Code licensed under an MIT-style License . Documentation licensed under CC BY 4.0 .",
    "id": "optimizing-images-with-ngoptimizedimage-*-angular-43"
  },
  {
    "url": "https://angular.dev/guide/signals",
    "title": "Signals • Overview • Angular",
    "chunk": "In-depth GuidesSignals Angular Signals Angular Signals is a system that granularly tracks how and where your state is used throughout an application, allowing the framework to optimize rendering updates. TIP: Check out Angular's Essentials before diving into this comprehensive guide. On this pagearrow_upward_alt Back to the top What are signals? A signal is a wrapper around a value that notifies interested consumers when that value changes. Signals can contain any value, from primitives to compl",
    "id": "signals-*-overview-*-angular-0"
  },
  {
    "url": "https://angular.dev/guide/signals",
    "title": "Signals • Overview • Angular",
    "chunk": "ex data structures. You read a signal's value by calling its getter function, which allows Angular to track where the signal is used. Signals may be either writable or read-only. Writable signals Writable signals provide an API for updating their values directly. You create writable signals by calling the signal function with the signal's initial value: const count = signal(0);// Signals are getter functions - calling them reads their value.console.log('The count is: ' + count()); To change the ",
    "id": "signals-*-overview-*-angular-1"
  },
  {
    "url": "https://angular.dev/guide/signals",
    "title": "Signals • Overview • Angular",
    "chunk": "value of a writable signal, either .set() it directly: count.set(3); or use the .update() operation to compute a new value from the previous one: // Increment the count by 1.count.update(value => value + 1); Writable signals have the type WritableSignal. Computed signals Computed signal are read-only signals that derive their value from other signals. You define computed signals using the computed function and specifying a derivation: const count: WritableSignal<number> = signal(0);const doubleC",
    "id": "signals-*-overview-*-angular-2"
  },
  {
    "url": "https://angular.dev/guide/signals",
    "title": "Signals • Overview • Angular",
    "chunk": "ount: Signal<number> = computed(() => count() * 2); The doubleCount signal depends on the count signal. Whenever count updates, Angular knows that doubleCount needs to update as well. Computed signals are both lazily evaluated and memoized doubleCount's derivation function does not run to calculate its value until the first time you read doubleCount. The calculated value is then cached, and if you read doubleCount again, it will return the cached value without recalculating. If you then change c",
    "id": "signals-*-overview-*-angular-3"
  },
  {
    "url": "https://angular.dev/guide/signals",
    "title": "Signals • Overview • Angular",
    "chunk": "ount, Angular knows that doubleCount's cached value is no longer valid, and the next time you read doubleCount its new value will be calculated. As a result, you can safely perform computationally expensive derivations in computed signals, such as filtering arrays. Computed signals are not writable signals You cannot directly assign values to a computed signal. That is, doubleCount.set(3); produces a compilation error, because doubleCount is not a WritableSignal. Computed signal dependencies are",
    "id": "signals-*-overview-*-angular-4"
  },
  {
    "url": "https://angular.dev/guide/signals",
    "title": "Signals • Overview • Angular",
    "chunk": " dynamic Only the signals actually read during the derivation are tracked. For example, in this computed the count signal is only read if the showCount signal is true: const showCount = signal(false);const count = signal(0);const conditionalCount = computed(() => { if (showCount()) { return `The count is ${count()}.`; } else { return 'Nothing to see here!'; }}); When you read conditionalCount, if showCount is false the \"Nothing to see here!\" message is returned without reading the count signal. ",
    "id": "signals-*-overview-*-angular-5"
  },
  {
    "url": "https://angular.dev/guide/signals",
    "title": "Signals • Overview • Angular",
    "chunk": "This means that if you later update count it will not result in a recomputation of conditionalCount. If you set showCount to true and then read conditionalCount again, the derivation will re-execute and take the branch where showCount is true, returning the message which shows the value of count. Changing count will then invalidate conditionalCount's cached value. Note that dependencies can be removed during a derivation as well as added. If you later set showCount back to false, then count will",
    "id": "signals-*-overview-*-angular-6"
  },
  {
    "url": "https://angular.dev/guide/signals",
    "title": "Signals • Overview • Angular",
    "chunk": " no longer be considered a dependency of conditionalCount. Reading signals in OnPush components When you read a signal within an OnPush component's template, Angular tracks the signal as a dependency of that component. When the value of that signal changes, Angular automatically marks the component to ensure it gets updated the next time change detection runs. Refer to the Skipping component subtrees guide for more information about OnPush components. Effects Signals are useful because they noti",
    "id": "signals-*-overview-*-angular-7"
  },
  {
    "url": "https://angular.dev/guide/signals",
    "title": "Signals • Overview • Angular",
    "chunk": "fy interested consumers when they change. An effect is an operation that runs whenever one or more signal values change. You can create an effect with the effect function: effect(() => { console.log(`The current count is: ${count()}`);}); Effects always run at least once. When an effect runs, it tracks any signal value reads. Whenever any of these signal values change, the effect runs again. Similar to computed signals, effects keep track of their dependencies dynamically, and only track signals",
    "id": "signals-*-overview-*-angular-8"
  },
  {
    "url": "https://angular.dev/guide/signals",
    "title": "Signals • Overview • Angular",
    "chunk": " which were read in the most recent execution. Effects always execute asynchronously, during the change detection process. Use cases for effects Effects are rarely needed in most application code, but may be useful in specific circumstances. Here are some examples of situations where an effect might be a good solution: Logging data being displayed and when it changes, either for analytics or as a debugging tool. Keeping data in sync with window.localStorage. Adding custom DOM behavior that can't",
    "id": "signals-*-overview-*-angular-9"
  },
  {
    "url": "https://angular.dev/guide/signals",
    "title": "Signals • Overview • Angular",
    "chunk": " be expressed with template syntax. Performing custom rendering to a <canvas>, charting library, or other third party UI library. When not to use effects Avoid using effects for propagation of state changes. This can result in ExpressionChangedAfterItHasBeenChecked errors, infinite circular updates, or unnecessary change detection cycles. Instead, use computed signals to model state that depends on other state. Injection context By default, you can only create an effect() within an injection con",
    "id": "signals-*-overview-*-angular-10"
  },
  {
    "url": "https://angular.dev/guide/signals",
    "title": "Signals • Overview • Angular",
    "chunk": "text (where you have access to the inject function). The easiest way to satisfy this requirement is to call effect within a component, directive, or service constructor: @Component({...})export class EffectiveCounterComponent { readonly count = signal(0); constructor() { // Register a new effect. effect(() => { console.log(`The count is: ${this.count()}`); }); }} Alternatively, you can assign the effect to a field (which also gives it a descriptive name). @Component({...})export class EffectiveC",
    "id": "signals-*-overview-*-angular-11"
  },
  {
    "url": "https://angular.dev/guide/signals",
    "title": "Signals • Overview • Angular",
    "chunk": "ounterComponent { readonly count = signal(0); private loggingEffect = effect(() => { console.log(`The count is: ${this.count()}`); });} To create an effect outside the constructor, you can pass an Injector to effect via its options: @Component({...})export class EffectiveCounterComponent { readonly count = signal(0); private injector = inject(Injector); initializeLogging(): void { effect(() => { console.log(`The count is: ${this.count()}`); }, {injector: this.injector}); }} Destroying effects Wh",
    "id": "signals-*-overview-*-angular-12"
  },
  {
    "url": "https://angular.dev/guide/signals",
    "title": "Signals • Overview • Angular",
    "chunk": "en you create an effect, it is automatically destroyed when its enclosing context is destroyed. This means that effects created within components are destroyed when the component is destroyed. The same goes for effects within directives, services, etc. Effects return an EffectRef that you can use to destroy them manually, by calling the .destroy() method. You can combine this with the manualCleanup option to create an effect that lasts until it is manually destroyed. Be careful to actually clean",
    "id": "signals-*-overview-*-angular-13"
  },
  {
    "url": "https://angular.dev/guide/signals",
    "title": "Signals • Overview • Angular",
    "chunk": " up such effects when they're no longer required. Advanced topics Signal equality functions When creating a signal, you can optionally provide an equality function, which will be used to check whether the new value is actually different than the previous one. import _ from 'lodash';const data = signal(['test'], {equal: _.isEqual});// Even though this is a different array instance, the deep equality// function will consider the values to be equal, and the signal won't// trigger any updates.data.s",
    "id": "signals-*-overview-*-angular-14"
  },
  {
    "url": "https://angular.dev/guide/signals",
    "title": "Signals • Overview • Angular",
    "chunk": "et(['test']); Equality functions can be provided to both writable and computed signals. HELPFUL: By default, signals use referential equality (Object.is() comparison). Reading without tracking dependencies Rarely, you may want to execute code which may read signals within a reactive function such as computed or effect without creating a dependency. For example, suppose that when currentUser changes, the value of a counter should be logged. You could create an effect which reads both signals: eff",
    "id": "signals-*-overview-*-angular-15"
  },
  {
    "url": "https://angular.dev/guide/signals",
    "title": "Signals • Overview • Angular",
    "chunk": "ect(() => { console.log(`User set to ${currentUser()} and the counter is ${counter()}`);}); This example will log a message when either currentUser or counter changes. However, if the effect should only run when currentUser changes, then the read of counter is only incidental and changes to counter shouldn't log a new message. You can prevent a signal read from being tracked by calling its getter with untracked: effect(() => { console.log(`User set to ${currentUser()} and the counter is ${untrac",
    "id": "signals-*-overview-*-angular-16"
  },
  {
    "url": "https://angular.dev/guide/signals",
    "title": "Signals • Overview • Angular",
    "chunk": "ked(counter)}`);}); untracked is also useful when an effect needs to invoke some external code which shouldn't be treated as a dependency: effect(() => { const user = currentUser(); untracked(() => { // If the `loggingService` reads signals, they won't be counted as // dependencies of this effect. this.loggingService.log(`User set to ${user}`); });}); Effect cleanup functions Effects might start long-running operations, which you should cancel if the effect is destroyed or runs again before the ",
    "id": "signals-*-overview-*-angular-17"
  },
  {
    "url": "https://angular.dev/guide/signals",
    "title": "Signals • Overview • Angular",
    "chunk": "first operation finished. When you create an effect, your function can optionally accept an onCleanup function as its first parameter. This onCleanup function lets you register a callback that is invoked before the next run of the effect begins, or when the effect is destroyed. effect((onCleanup) => { const user = currentUser(); const timer = setTimeout(() => { console.log(`1 second ago, the user became ${user}`); }, 1000); onCleanup(() => { clearTimeout(timer); });}); Using signals with RxJS Se",
    "id": "signals-*-overview-*-angular-18"
  },
  {
    "url": "https://angular.dev/guide/signals",
    "title": "Signals • Overview • Angular",
    "chunk": "e RxJS interop with Angular signals for details on interoperability between signals and RxJS. Social MediaBlogX (formerly Twitter)BlueskyYouTube Discord GitHub Stack Overflow Community Contribute Code of Conduct Report Issues Google's DevLibrary Angular Google Developer Experts ResourcesPress KitRoadmapLanguages简体中文版正體中文版日本語版한국어 Ελληνικά Super-powered by Google ©2010-2025. Code licensed under an MIT-style License . Documentation licensed under CC BY 4.0 . In-depth GuidesSignals Angular Signals A",
    "id": "signals-*-overview-*-angular-19"
  },
  {
    "url": "https://angular.dev/guide/signals",
    "title": "Signals • Overview • Angular",
    "chunk": "ngular Signals is a system that granularly tracks how and where your state is used throughout an application, allowing the framework to optimize rendering updates.",
    "id": "signals-*-overview-*-angular-20"
  },
  {
    "url": "https://angular.dev/guide/signals/linked-signal",
    "title": "Dependent state with linkedSignal • Angular",
    "chunk": "In-depth GuidesSignals Dependent state with linkedSignal You can use the signal function to hold some state in your Angular code. Sometimes, this state depends on some other state. For example, imagine a component that lets the user select a shipping method for an order: @Component({/* ... */})export class ShippingMethodPicker { shippingOptions: Signal<ShippingMethod[]> = getShippingOptions(); // Select the first shipping option by default. selectedOption = signal(this.shippingOptions()[0]); cha",
    "id": "dependent-state-with-linkedsignal-*-angular-0"
  },
  {
    "url": "https://angular.dev/guide/signals/linked-signal",
    "title": "Dependent state with linkedSignal • Angular",
    "chunk": "ngeShipping(newOptionIndex: number) { this.selectedOption.set(this.shippingOptions()[newOptionIndex]); }} In this example, the selectedOption defaults to the first option, but changes if the user selects another option. But shippingOptions is a signal— its value may change! If shippingOptions changes, selectedOption may contain a value that is no longer a valid option. The linkedSignal function lets you create a signal to hold some state that is intrinsically linked to some other state. Revisiti",
    "id": "dependent-state-with-linkedsignal-*-angular-1"
  },
  {
    "url": "https://angular.dev/guide/signals/linked-signal",
    "title": "Dependent state with linkedSignal • Angular",
    "chunk": "ng the example above, linkedSignal can replace signal: @Component({/* ... */})export class ShippingMethodPicker { shippingOptions: Signal<ShippingMethod[]> = getShippingOptions(); // Initialize selectedOption to the first shipping option. selectedOption = linkedSignal(() => this.shippingOptions()[0]); changeShipping(index: number) { this.selectedOption.set(this.shippingOptions()[index]); }} linkedSignal works similarly to signal with one key difference— instead of passing a default value, you pa",
    "id": "dependent-state-with-linkedsignal-*-angular-2"
  },
  {
    "url": "https://angular.dev/guide/signals/linked-signal",
    "title": "Dependent state with linkedSignal • Angular",
    "chunk": "ss a computation function, just like computed. When the value of the computation changes, the value of the linkedSignal changes to the computation result. This helps ensure that the linkedSignal always has a valid value. The following example shows how the value of a linkedSignal can change based on its linked state: const shippingOptions = signal(['Ground', 'Air', 'Sea']);const selectedOption = linkedSignal(() => shippingOptions()[0]);console.log(selectedOption()); // 'Ground'selectedOption.set",
    "id": "dependent-state-with-linkedsignal-*-angular-3"
  },
  {
    "url": "https://angular.dev/guide/signals/linked-signal",
    "title": "Dependent state with linkedSignal • Angular",
    "chunk": "(shippingOptions()[2]);console.log(selectedOption()); // 'Sea'shippingOptions.set(['Email', 'Will Call', 'Postal service']);console.log(selectedOption()); // 'Email' On this pagearrow_upward_alt Back to the top Accounting for previous state In some cases, the computation for a linkedSignal needs to account for the previous value of the linkedSignal. In the example above, selectedOption always updates back to the first option when shippingOptions changes. You may, however, want to preserve the us",
    "id": "dependent-state-with-linkedsignal-*-angular-4"
  },
  {
    "url": "https://angular.dev/guide/signals/linked-signal",
    "title": "Dependent state with linkedSignal • Angular",
    "chunk": "er's selection if their selected option is still somewhere in the list. To accomplish this, you can create a linkedSignal with a separate source and computation: interface ShippingMethod { id: number; name: string;}@Component({/* ... */})export class ShippingMethodPicker { constructor() { this.changeShipping(2); this.changeShippingOptions(); console.log(this.selectedOption()); // {\"id\":2,\"name\":\"Postal Service\"} } shippingOptions = signal<ShippingMethod[]>([ { id: 0, name: 'Ground' }, { id: 1, n",
    "id": "dependent-state-with-linkedsignal-*-angular-5"
  },
  {
    "url": "https://angular.dev/guide/signals/linked-signal",
    "title": "Dependent state with linkedSignal • Angular",
    "chunk": "ame: 'Air' }, { id: 2, name: 'Sea' }, ]); selectedOption = linkedSignal<ShippingMethod[], ShippingMethod>({ // `selectedOption` is set to the `computation` result whenever this `source` changes. source: this.shippingOptions, computation: (newOptions, previous) => { // If the newOptions contain the previously selected option, preserve that selection. // Otherwise, default to the first option. return ( newOptions.find((opt) => opt.id === previous?.value.id) ?? newOptions[0] ); }, }); changeShippin",
    "id": "dependent-state-with-linkedsignal-*-angular-6"
  },
  {
    "url": "https://angular.dev/guide/signals/linked-signal",
    "title": "Dependent state with linkedSignal • Angular",
    "chunk": "g(index: number) { this.selectedOption.set(this.shippingOptions()[index]); } changeShippingOptions() { this.shippingOptions.set([ { id: 0, name: 'Email' }, { id: 1, name: 'Sea' }, { id: 2, name: 'Postal Service' }, ]); }} When you create a linkedSignal, you can pass an object with separate source and computation properties instead of providing just a computation. The source can be any signal, such as a computed or component input. When the value of source changes, linkedSignal updates its value ",
    "id": "dependent-state-with-linkedsignal-*-angular-7"
  },
  {
    "url": "https://angular.dev/guide/signals/linked-signal",
    "title": "Dependent state with linkedSignal • Angular",
    "chunk": "to the result of the provided computation. The computation is a function that receives the new value of source and a previous object. The previous object has two properties— previous.source is the previous value of source, and previous.value is the previous result of the computation. You can use these previous values to decide the new result of the computation. HELPFUL: When using the previous parameter, it is necessary to provide the generic type arguments of linkedSignal explicitly. The first ",
    "id": "dependent-state-with-linkedsignal-*-angular-8"
  },
  {
    "url": "https://angular.dev/guide/signals/linked-signal",
    "title": "Dependent state with linkedSignal • Angular",
    "chunk": "generic type corresponds with the type of source and the second generic type determines the output type of computation. Custom equality comparison linkedSignal, as any other signal, can be configured with a custom equality function. This function is used by downstream dependencies to determine if that value of the linkedSignal (result of a computation) changed: const activeUser = signal({id: 123, name: 'Morgan', isAdmin: true});const activeUserEditCopy = linkedSignal(() => activeUser(), { // Con",
    "id": "dependent-state-with-linkedsignal-*-angular-9"
  },
  {
    "url": "https://angular.dev/guide/signals/linked-signal",
    "title": "Dependent state with linkedSignal • Angular",
    "chunk": "sider the user as the same if it's the same `id`. equal: (a, b) => a.id === b.id,});// Or, if separating `source` and `computation`const activeUserEditCopy = linkedSignal({ source: activeUser, computation: user => user, equal: (a, b) => a.id === b.id,}); Social MediaBlogX (formerly Twitter)BlueskyYouTube Discord GitHub Stack Overflow Community Contribute Code of Conduct Report Issues Google's DevLibrary Angular Google Developer Experts ResourcesPress KitRoadmapLanguages简体中文版正體中文版日本語版한국어 Ελληνικά",
    "id": "dependent-state-with-linkedsignal-*-angular-10"
  },
  {
    "url": "https://angular.dev/guide/signals/linked-signal",
    "title": "Dependent state with linkedSignal • Angular",
    "chunk": " Super-powered by Google ©2010-2025. Code licensed under an MIT-style License . Documentation licensed under CC BY 4.0 .",
    "id": "dependent-state-with-linkedsignal-*-angular-11"
  },
  {
    "url": "https://angular.dev/guide/signals/resource",
    "title": "Async reactivity with resources • Angular",
    "chunk": "In-depth GuidesSignals Async reactivity with resources IMPORTANT: resource is experimental. It's ready for you to try, but it might change before it is stable. Most signal APIs are synchronous— signal, computed, input, etc. However, applications often need to deal with data that is available asynchronously. A Resource gives you a way to incorporate async data into your application's signal-based code. You can use a Resource to perform any kind of async operation, but the most common use-case for",
    "id": "async-reactivity-with-resources-*-angular-0"
  },
  {
    "url": "https://angular.dev/guide/signals/resource",
    "title": "Async reactivity with resources • Angular",
    "chunk": " Resource is fetching data from a server. The following example creates a resource to fetch some user data. The easiest way to create a Resource is the resource function. import {resource, Signal} from '@angular/core';const userId: Signal<string> = getUserId();const userResource = resource({ // Define a reactive computation. // The params value recomputes whenever any read signals change. params: () => ({id: userId()}), // Define an async loader that retrieves data. // The resource calls this fu",
    "id": "async-reactivity-with-resources-*-angular-1"
  },
  {
    "url": "https://angular.dev/guide/signals/resource",
    "title": "Async reactivity with resources • Angular",
    "chunk": "nction every time the `params` value changes. loader: ({params}) => fetchUser(params),});// Create a computed signal based on the result of the resource's loader function.const firstName = computed(() => userResource.value().firstName); The resource function accepts a ResourceOptions object with two main properties: params and loader. The params property defines a reactive computation that produces a parameter value. Whenever signals read in this computation change, the resource produces a new p",
    "id": "async-reactivity-with-resources-*-angular-2"
  },
  {
    "url": "https://angular.dev/guide/signals/resource",
    "title": "Async reactivity with resources • Angular",
    "chunk": "arameter value, similar to computed. The loader property defines a ResourceLoader— an async function that retrieves some state. The resource calls the loader every time the params computation produces a new value, passing that value to the loader. See Resource loaders below for more details. Resource has a value signal that contains the results of the loader. On this pagearrow_upward_alt Back to the top Resource loaders When creating a resource, you specify a ResourceLoader. This loader is an as",
    "id": "async-reactivity-with-resources-*-angular-3"
  },
  {
    "url": "https://angular.dev/guide/signals/resource",
    "title": "Async reactivity with resources • Angular",
    "chunk": "ync function that accepts a single parameter— a ResourceLoaderParams object— and returns a value. The ResourceLoaderParams object contains three properties: params, previous, and abortSignal. Property Description params The value of the resource's params computation. previous An object with a status property, containing the previous ResourceStatus. abortSignal An AbortSignal. See Aborting requests below for details. If the params computation returns undefined, the loader function does not run an",
    "id": "async-reactivity-with-resources-*-angular-4"
  },
  {
    "url": "https://angular.dev/guide/signals/resource",
    "title": "Async reactivity with resources • Angular",
    "chunk": "d the resource status becomes 'idle'. Aborting requests A resource aborts an outstanding loading operation if the params computation changes while the resource is loading. You can use the abortSignal in ResourceLoaderParams to respond to aborted requests. For example, the native fetch function accepts an AbortSignal: const userId: Signal<string> = getUserId();const userResource = resource({ params: () => ({id: userId()}), loader: ({params, abortSignal}): Promise<User> => { // fetch cancels any o",
    "id": "async-reactivity-with-resources-*-angular-5"
  },
  {
    "url": "https://angular.dev/guide/signals/resource",
    "title": "Async reactivity with resources • Angular",
    "chunk": "utstanding HTTP requests when the given `AbortSignal` // indicates that the request has been aborted. return fetch(`users/${params.id}`, {signal: abortSignal}); },}); See AbortSignal on MDN for more details on request cancellation with AbortSignal. Reloading You can programmatically trigger a resource's loader by calling the reload method. const userId: Signal<string> = getUserId();const userResource = resource({ params: () => ({id: userId()}), loader: ({params}) => fetchUser(params),});// ...us",
    "id": "async-reactivity-with-resources-*-angular-6"
  },
  {
    "url": "https://angular.dev/guide/signals/resource",
    "title": "Async reactivity with resources • Angular",
    "chunk": "erResource.reload(); Resource status The resource object has several signal properties for reading the status of the asynchronous loader. Property Description value The most recent value of the resource, or undefined if no value has been received. hasValue Whether the resource has a value. error The most recent error encountered while running the resource's loader, or undefined if no error has occurred. isLoading Whether the resource loader is currently running. status The resource's specific Re",
    "id": "async-reactivity-with-resources-*-angular-7"
  },
  {
    "url": "https://angular.dev/guide/signals/resource",
    "title": "Async reactivity with resources • Angular",
    "chunk": "sourceStatus, as described below. The status signal provides a specific ResourceStatus that describes the state of the resource using a string constant. Status value() Description 'idle' undefined The resource has no valid request and the loader has not run. 'error' undefined The loader has encountered an error. 'loading' undefined The loader is running as a result of the request value changing. 'reloading' Previous value The loader is running as a result calling of the resource's reload method.",
    "id": "async-reactivity-with-resources-*-angular-8"
  },
  {
    "url": "https://angular.dev/guide/signals/resource",
    "title": "Async reactivity with resources • Angular",
    "chunk": " 'resolved' Resolved value The loader has completed. 'local' Locally set value The resource's value has been set locally via .set() or .update() You can use this status information to conditionally display user interface elements, such loading indicators and error messages. Reactive data fetching with httpResource httpResource is a wrapper around HttpClient that gives you the request status and response as signals. It makes HTTP requests through the Angular HTTP stack, including interceptors. So",
    "id": "async-reactivity-with-resources-*-angular-9"
  },
  {
    "url": "https://angular.dev/guide/signals/resource",
    "title": "Async reactivity with resources • Angular",
    "chunk": "cial MediaBlogX (formerly Twitter)BlueskyYouTube Discord GitHub Stack Overflow Community Contribute Code of Conduct Report Issues Google's DevLibrary Angular Google Developer Experts ResourcesPress KitRoadmapLanguages简体中文版正體中文版日本語版한국어 Ελληνικά Super-powered by Google ©2010-2025. Code licensed under an MIT-style License . Documentation licensed under CC BY 4.0 .",
    "id": "async-reactivity-with-resources-*-angular-10"
  },
  {
    "url": "https://angular.dev/guide/di",
    "title": "Dependency Injection • Overview • Angular",
    "chunk": "In-depth GuidesDependency Injection Dependency injection in Angular \"DI\" is a design pattern and mechanism for creating and delivering some parts of an app to other parts of an app that require them. TIP: Check out Angular's Essentials before diving into this comprehensive guide. When you develop a smaller part of your system, like a module or a class, you may need to use features from other classes. For example, you may need an HTTP service to make backend calls. Dependency Injection, or DI, is",
    "id": "dependency-injection-*-overview-*-angular-0"
  },
  {
    "url": "https://angular.dev/guide/di",
    "title": "Dependency Injection • Overview • Angular",
    "chunk": " a design pattern and mechanism for creating and delivering some parts of an application to other parts of an application that require them. Angular supports this design pattern and you can use it in your applications to increase flexibility and modularity. In Angular, dependencies are typically services, but they also can be values, such as strings or functions. An injector for an application (created automatically during bootstrap) instantiates dependencies when needed, using a configured prov",
    "id": "dependency-injection-*-overview-*-angular-1"
  },
  {
    "url": "https://angular.dev/guide/di",
    "title": "Dependency Injection • Overview • Angular",
    "chunk": "ider of the service or value. On this pagearrow_upward_alt Back to the top Learn about Angular dependency injection Understanding dependency injection Learn basic principles of dependency injection in Angular. Learn more Creating and injecting service Describes how to create a service and inject it in other services and components. Learn more Configuring dependency providers Describes how to configure dependencies using the providers field on the @Component and @NgModule decorators. Also describ",
    "id": "dependency-injection-*-overview-*-angular-2"
  },
  {
    "url": "https://angular.dev/guide/di",
    "title": "Dependency Injection • Overview • Angular",
    "chunk": "es how to use InjectionToken to provide and inject values in DI, which can be helpful when you want to use a value other than classes as dependencies. Learn more Injection context Describes what an injection context is and how to use the DI system where you need it. Learn more Hierarchical injectors Hierarchical DI enables you to share dependencies between different parts of the application only when and if you need to. This is an advanced topic. Learn more Social MediaBlogX (formerly Twitter)Bl",
    "id": "dependency-injection-*-overview-*-angular-3"
  },
  {
    "url": "https://angular.dev/guide/di",
    "title": "Dependency Injection • Overview • Angular",
    "chunk": "ueskyYouTube Discord GitHub Stack Overflow Community Contribute Code of Conduct Report Issues Google's DevLibrary Angular Google Developer Experts ResourcesPress KitRoadmapLanguages简体中文版正體中文版日本語版한국어 Ελληνικά Super-powered by Google ©2010-2025. Code licensed under an MIT-style License . Documentation licensed under CC BY 4.0 . In-depth GuidesDependency Injection Dependency injection in Angular \"DI\" is a design pattern and mechanism for creating and delivering some parts of an app to other parts o",
    "id": "dependency-injection-*-overview-*-angular-4"
  },
  {
    "url": "https://angular.dev/guide/di",
    "title": "Dependency Injection • Overview • Angular",
    "chunk": "f an app that require them.",
    "id": "dependency-injection-*-overview-*-angular-5"
  },
  {
    "url": "https://angular.dev/guide/di/dependency-injection",
    "title": "Understanding dependency injection • Angular",
    "chunk": "In-depth GuidesDependency Injection Understanding dependency injection Dependency injection, or DI, is one of the fundamental concepts in Angular. DI is wired into the Angular framework and allows classes with Angular decorators, such as Components, Directives, Pipes, and Injectables, to configure dependencies that they need. Two main roles exist in the DI system: dependency consumer and dependency provider. Angular facilitates the interaction between dependency consumers and dependency provider",
    "id": "understanding-dependency-injection-*-angular-0"
  },
  {
    "url": "https://angular.dev/guide/di/dependency-injection",
    "title": "Understanding dependency injection • Angular",
    "chunk": "s using an abstraction called Injector. When a dependency is requested, the injector checks its registry to see if there is an instance already available there. If not, a new instance is created and stored in the registry. Angular creates an application-wide injector (also known as the \"root\" injector) during the application bootstrap process. In most cases you don't need to manually create injectors, but you should know that there is a layer that connects providers and consumers. This topic cov",
    "id": "understanding-dependency-injection-*-angular-1"
  },
  {
    "url": "https://angular.dev/guide/di/dependency-injection",
    "title": "Understanding dependency injection • Angular",
    "chunk": "ers basic scenarios of how a class can act as a dependency. Angular also allows you to use functions, objects, primitive types such as string or Boolean, or any other types as dependencies. For more information, see Dependency providers. On this pagearrow_upward_alt Back to the top Providing a dependency Consider a class called HeroService that needs to act as a dependency in a component. The first step is to add the @Injectable decorator to show that the class can be injected. @Injectable()clas",
    "id": "understanding-dependency-injection-*-angular-2"
  },
  {
    "url": "https://angular.dev/guide/di/dependency-injection",
    "title": "Understanding dependency injection • Angular",
    "chunk": "s HeroService {} The next step is to make it available in the DI by providing it. A dependency can be provided in multiple places: Preferred: At the application root level using providedIn At the Component level At the application root level using ApplicationConfig NgModule based applications Preferred: At the application root level using providedIn Providing a service at the application root level using providedIn allows injecting the service into all other classes. Using providedIn enables Ang",
    "id": "understanding-dependency-injection-*-angular-3"
  },
  {
    "url": "https://angular.dev/guide/di/dependency-injection",
    "title": "Understanding dependency injection • Angular",
    "chunk": "ular and JavaScript code optimizers to effectively remove services that are unused (known as tree-shaking). You can provide a service by using providedIn: 'root' in the @Injectable decorator: @Injectable({ providedIn: 'root'})class HeroService {} When you provide the service at the root level, Angular creates a single, shared instance of the HeroService and injects it into any class that asks for it. At the Component level You can provide services at @Component level by using the providers field",
    "id": "understanding-dependency-injection-*-angular-4"
  },
  {
    "url": "https://angular.dev/guide/di/dependency-injection",
    "title": "Understanding dependency injection • Angular",
    "chunk": " of the @Component decorator. In this case the HeroService becomes available to all instances of this component and other components and directives used in the template. For example: @Component({ selector: 'hero-list', template: '...', providers: [HeroService]})class HeroListComponent {} When you register a provider at the component level, you get a new instance of the service with each new instance of that component. NOTE: Declaring a service like this causes HeroService to always be included i",
    "id": "understanding-dependency-injection-*-angular-5"
  },
  {
    "url": "https://angular.dev/guide/di/dependency-injection",
    "title": "Understanding dependency injection • Angular",
    "chunk": "n your application— even if the service is unused. At the application root level using ApplicationConfig You can use the providers field of the ApplicationConfig (passed to the bootstrapApplication function) to provide a service or other Injectable at the application level. In the example below, the HeroService is available to all components, directives, and pipes: export const appConfig: ApplicationConfig = { providers: [ { provide: HeroService }, ]}; Then, in main.ts: bootstrapApplication(AppC",
    "id": "understanding-dependency-injection-*-angular-6"
  },
  {
    "url": "https://angular.dev/guide/di/dependency-injection",
    "title": "Understanding dependency injection • Angular",
    "chunk": "omponent, appConfig) NOTE: Declaring a service like this causes HeroService to always be included in your application— even if the service is unused. NgModule based applications @NgModule-based applications use the providers field of the @NgModule decorator to provide a service or other Injectable available at the application level. A service provided in a module is available to all declarations of the module, or to any other modules which share the same ModuleInjector. To understand all edge-ca",
    "id": "understanding-dependency-injection-*-angular-7"
  },
  {
    "url": "https://angular.dev/guide/di/dependency-injection",
    "title": "Understanding dependency injection • Angular",
    "chunk": "ses, see Hierarchical injectors. NOTE: Declaring a service using providers causes the service to be included in your application— even if the service is unused. Injecting/consuming a dependency Use Angular's inject function to retrieve dependencies. import {inject, Component} from 'angular/core';@Component({/* ... */})export class UserProfile { // You can use the `inject` function in property initializers. private userClient = inject(UserClient); constructor() { // You can also use the `inject` ",
    "id": "understanding-dependency-injection-*-angular-8"
  },
  {
    "url": "https://angular.dev/guide/di/dependency-injection",
    "title": "Understanding dependency injection • Angular",
    "chunk": "function in a constructor. const logger = inject(Logger); }} You can use the inject function in any injection context. Most of the time, this is in a class property initializer or a class constructor for components, directives, services, and pipes. When Angular discovers that a component depends on a service, it first checks if the injector has any existing instances of that service. If a requested service instance doesn't yet exist, the injector creates one using the registered provider, and ad",
    "id": "understanding-dependency-injection-*-angular-9"
  },
  {
    "url": "https://angular.dev/guide/di/dependency-injection",
    "title": "Understanding dependency injection • Angular",
    "chunk": "ds it to the injector before returning the service to Angular. When all requested services have been resolved and returned, Angular can call the component's constructor with those services as arguments. #mermaid-generated-diagram{font-family:\"trebuchet ms\",verdana,arial,sans-serif;font-size:16px;fill:#333;}@keyframes edge-animation-frame{from{stroke-dashoffset:0;}}@keyframes dash{to{stroke-dashoffset:0;}}#mermaid-generated-diagram .edge-animation-slow{stroke-dasharray:9,5!important;stroke-dashof",
    "id": "understanding-dependency-injection-*-angular-10"
  },
  {
    "url": "https://angular.dev/guide/di/dependency-injection",
    "title": "Understanding dependency injection • Angular",
    "chunk": "fset:900;animation:dash 50s linear infinite;stroke-linecap:round;}#mermaid-generated-diagram .edge-animation-fast{stroke-dasharray:9,5!important;stroke-dashoffset:900;animation:dash 20s linear infinite;stroke-linecap:round;}#mermaid-generated-diagram .error-icon{fill:hsl(220.5882352941, 100%, 98.3333333333%);}#mermaid-generated-diagram .error-text{fill:rgb(8.5000000002, 5.7500000001, 0);stroke:rgb(8.5000000002, 5.7500000001, 0);}#mermaid-generated-diagram .edge-thickness-normal{stroke-width:1px;",
    "id": "understanding-dependency-injection-*-angular-11"
  },
  {
    "url": "https://angular.dev/guide/di/dependency-injection",
    "title": "Understanding dependency injection • Angular",
    "chunk": "}#mermaid-generated-diagram .edge-thickness-thick{stroke-width:3.5px;}#mermaid-generated-diagram .edge-pattern-solid{stroke-dasharray:0;}#mermaid-generated-diagram .edge-thickness-invisible{stroke-width:0;fill:none;}#mermaid-generated-diagram .edge-pattern-dashed{stroke-dasharray:3;}#mermaid-generated-diagram .edge-pattern-dotted{stroke-dasharray:2;}#mermaid-generated-diagram .marker{fill:#0b0b0b;stroke:#0b0b0b;}#mermaid-generated-diagram .marker.cross{stroke:#0b0b0b;}#mermaid-generated-diagram ",
    "id": "understanding-dependency-injection-*-angular-12"
  },
  {
    "url": "https://angular.dev/guide/di/dependency-injection",
    "title": "Understanding dependency injection • Angular",
    "chunk": "svg{font-family:\"trebuchet ms\",verdana,arial,sans-serif;font-size:16px;}#mermaid-generated-diagram p{margin:0;}#mermaid-generated-diagram .label{font-family:\"trebuchet ms\",verdana,arial,sans-serif;color:#333;}#mermaid-generated-diagram .cluster-label text{fill:rgb(8.5000000002, 5.7500000001, 0);}#mermaid-generated-diagram .cluster-label span{color:rgb(8.5000000002, 5.7500000001, 0);}#mermaid-generated-diagram .cluster-label span p{background-color:transparent;}#mermaid-generated-diagram .label t",
    "id": "understanding-dependency-injection-*-angular-13"
  },
  {
    "url": "https://angular.dev/guide/di/dependency-injection",
    "title": "Understanding dependency injection • Angular",
    "chunk": "ext,#mermaid-generated-diagram span{fill:#333;color:#333;}#mermaid-generated-diagram .node rect,#mermaid-generated-diagram .node circle,#mermaid-generated-diagram .node ellipse,#mermaid-generated-diagram .node polygon,#mermaid-generated-diagram .node path{fill:#fff4dd;stroke:hsl(40.5882352941, 60%, 83.3333333333%);stroke-width:1px;}#mermaid-generated-diagram .rough-node .label text,#mermaid-generated-diagram .node .label text,#mermaid-generated-diagram .image-shape .label,#mermaid-generated-diag",
    "id": "understanding-dependency-injection-*-angular-14"
  },
  {
    "url": "https://angular.dev/guide/di/dependency-injection",
    "title": "Understanding dependency injection • Angular",
    "chunk": "ram .icon-shape .label{text-anchor:middle;}#mermaid-generated-diagram .node .katex path{fill:#000;stroke:#000;stroke-width:1px;}#mermaid-generated-diagram .rough-node .label,#mermaid-generated-diagram .node .label,#mermaid-generated-diagram .image-shape .label,#mermaid-generated-diagram .icon-shape .label{text-align:center;}#mermaid-generated-diagram .node.clickable{cursor:pointer;}#mermaid-generated-diagram .root .anchor path{fill:#0b0b0b!important;stroke-width:0;stroke:#0b0b0b;}#mermaid-genera",
    "id": "understanding-dependency-injection-*-angular-15"
  },
  {
    "url": "https://angular.dev/guide/di/dependency-injection",
    "title": "Understanding dependency injection • Angular",
    "chunk": "ted-diagram .arrowheadPath{fill:#0b0b0b;}#mermaid-generated-diagram .edgePath .path{stroke:#0b0b0b;stroke-width:2.0px;}#mermaid-generated-diagram .flowchart-link{stroke:#0b0b0b;fill:none;}#mermaid-generated-diagram .edgeLabel{background-color:hsl(-79.4117647059, 100%, 93.3333333333%);text-align:center;}#mermaid-generated-diagram .edgeLabel p{background-color:hsl(-79.4117647059, 100%, 93.3333333333%);}#mermaid-generated-diagram .edgeLabel rect{opacity:0.5;background-color:hsl(-79.4117647059, 100%",
    "id": "understanding-dependency-injection-*-angular-16"
  },
  {
    "url": "https://angular.dev/guide/di/dependency-injection",
    "title": "Understanding dependency injection • Angular",
    "chunk": ", 93.3333333333%);fill:hsl(-79.4117647059, 100%, 93.3333333333%);}#mermaid-generated-diagram .labelBkg{background-color:rgba(243.9999999999, 220.9999999998, 255, 0.5);}#mermaid-generated-diagram .cluster rect{fill:hsl(220.5882352941, 100%, 98.3333333333%);stroke:hsl(220.5882352941, 60%, 88.3333333333%);stroke-width:1px;}#mermaid-generated-diagram .cluster text{fill:rgb(8.5000000002, 5.7500000001, 0);}#mermaid-generated-diagram .cluster span{color:rgb(8.5000000002, 5.7500000001, 0);}#mermaid-gene",
    "id": "understanding-dependency-injection-*-angular-17"
  },
  {
    "url": "https://angular.dev/guide/di/dependency-injection",
    "title": "Understanding dependency injection • Angular",
    "chunk": "rated-diagram div.mermaidTooltip{position:absolute;text-align:center;max-width:200px;padding:2px;font-family:\"trebuchet ms\",verdana,arial,sans-serif;font-size:12px;background:hsl(220.5882352941, 100%, 98.3333333333%);border:1px solid hsl(220.5882352941, 60%, 88.3333333333%);border-radius:2px;pointer-events:none;z-index:100;}#mermaid-generated-diagram .flowchartTitleText{text-anchor:middle;font-size:18px;fill:#333;}#mermaid-generated-diagram rect.text{fill:none;stroke-width:0;}#mermaid-generated-",
    "id": "understanding-dependency-injection-*-angular-18"
  },
  {
    "url": "https://angular.dev/guide/di/dependency-injection",
    "title": "Understanding dependency injection • Angular",
    "chunk": "diagram .icon-shape,#mermaid-generated-diagram .image-shape{background-color:hsl(-79.4117647059, 100%, 93.3333333333%);text-align:center;}#mermaid-generated-diagram .icon-shape p,#mermaid-generated-diagram .image-shape p{background-color:hsl(-79.4117647059, 100%, 93.3333333333%);padding:2px;}#mermaid-generated-diagram .icon-shape rect,#mermaid-generated-diagram .image-shape rect{opacity:0.5;background-color:hsl(-79.4117647059, 100%, 93.3333333333%);fill:hsl(-79.4117647059, 100%, 93.3333333333%);",
    "id": "understanding-dependency-injection-*-angular-19"
  },
  {
    "url": "https://angular.dev/guide/di/dependency-injection",
    "title": "Understanding dependency injection • Angular",
    "chunk": "}#mermaid-generated-diagram :root{--mermaid-font-family:\"trebuchet ms\",verdana,arial,sans-serif;}InjectorService AHeroServiceService CService DComponent heroService = inject(HeroService) What's next Creating an injectable service Social MediaBlogX (formerly Twitter)BlueskyYouTube Discord GitHub Stack Overflow Community Contribute Code of Conduct Report Issues Google's DevLibrary Angular Google Developer Experts ResourcesPress KitRoadmapLanguages简体中文版正體中文版日本語版한국어 Ελληνικά Super-powered by Google ",
    "id": "understanding-dependency-injection-*-angular-20"
  },
  {
    "url": "https://angular.dev/guide/di/dependency-injection",
    "title": "Understanding dependency injection • Angular",
    "chunk": "©2010-2025. Code licensed under an MIT-style License . Documentation licensed under CC BY 4.0 .",
    "id": "understanding-dependency-injection-*-angular-21"
  },
  {
    "url": "https://angular.dev/guide/di/creating-injectable-service",
    "title": "Creating an injectable service • Angular",
    "chunk": "In-depth GuidesDependency Injection Creating an injectable service Service is a broad category encompassing any value, function, or feature that an application needs. A service is typically a class with a narrow, well-defined purpose. A component is one type of class that can use DI. Angular distinguishes components from services to increase modularity and reusability. By separating a component's view-related features from other kinds of processing, you can make your component classes lean and e",
    "id": "creating-an-injectable-service-*-angular-0"
  },
  {
    "url": "https://angular.dev/guide/di/creating-injectable-service",
    "title": "Creating an injectable service • Angular",
    "chunk": "fficient. Ideally, a component's job is to enable the user experience and nothing more. A component should present properties and methods for data binding, to mediate between the view (rendered by the template) and the application logic (which often includes some notion of a model). A component can delegate certain tasks to services, such as fetching data from the server, validating user input, or logging directly to the console. By defining such processing tasks in an injectable service class, ",
    "id": "creating-an-injectable-service-*-angular-1"
  },
  {
    "url": "https://angular.dev/guide/di/creating-injectable-service",
    "title": "Creating an injectable service • Angular",
    "chunk": "you make those tasks available to any component. You can also make your application more adaptable by configuring different providers of the same kind of service, as appropriate in different circumstances. Angular does not enforce these principles. Angular helps you follow these principles by making it easy to factor your application logic into services and make those services available to components through DI. On this pagearrow_upward_alt Back to the top Service examples Here's an example of a",
    "id": "creating-an-injectable-service-*-angular-2"
  },
  {
    "url": "https://angular.dev/guide/di/creating-injectable-service",
    "title": "Creating an injectable service • Angular",
    "chunk": " service class that logs to the browser console: src/app/logger.service.ts (class) export class Logger { log(msg: unknown) { console.log(msg); } error(msg: unknown) { console.error(msg); } warn(msg: unknown) { console.warn(msg); }} Services can depend on other services. For example, here's a HeroService that depends on the Logger service, and also uses BackendService to get heroes. That service in turn might depend on the HttpClient service to fetch heroes asynchronously from a server: src/app/h",
    "id": "creating-an-injectable-service-*-angular-3"
  },
  {
    "url": "https://angular.dev/guide/di/creating-injectable-service",
    "title": "Creating an injectable service • Angular",
    "chunk": "ero.service.ts import { inject } from \"@angular/core\";export class HeroService { private heroes: Hero[] = []; private backend = inject(BackendService); private logger = inject(Logger); async getHeroes() { // Fetch this.heroes = await this.backend.getAll(Hero); // Log this.logger.log(`Fetched ${this.heroes.length} heroes.`); return this.heroes; }} Creating an injectable service The Angular CLI provides a command to create a new service. In the following example, you add a new service to an existi",
    "id": "creating-an-injectable-service-*-angular-4"
  },
  {
    "url": "https://angular.dev/guide/di/creating-injectable-service",
    "title": "Creating an injectable service • Angular",
    "chunk": "ng application. To generate a new HeroService class in the src/app/heroes folder, follow these steps: Run this Angular CLI command: ng generate service heroes/hero This command creates the following default HeroService: src/app/heroes/hero.service.ts (CLI-generated) import { Injectable } from '@angular/core';@Injectable({ providedIn: 'root',})export class HeroService {} The @Injectable() decorator specifies that Angular can use this class in the DI system. The metadata, providedIn: 'root', means",
    "id": "creating-an-injectable-service-*-angular-5"
  },
  {
    "url": "https://angular.dev/guide/di/creating-injectable-service",
    "title": "Creating an injectable service • Angular",
    "chunk": " that the HeroService is provided throughout the application. Add a getHeroes() method that returns the heroes from mock.heroes.ts to get the hero mock data: src/app/heroes/hero.service.ts import { Injectable } from '@angular/core';import { HEROES } from './mock-heroes';@Injectable({ // declares that this service should be created // by the root application injector. providedIn: 'root',})export class HeroService { getHeroes() { return HEROES; }} For clarity and maintainability, it is recommended",
    "id": "creating-an-injectable-service-*-angular-6"
  },
  {
    "url": "https://angular.dev/guide/di/creating-injectable-service",
    "title": "Creating an injectable service • Angular",
    "chunk": " that you define components and services in separate files. Injecting services To inject a service as a dependency into a component, you can declare a class field representing the dependency and use Angular's inject function to initialize it. The following example specifies the HeroService in the HeroListComponent. The type of heroService is HeroService. src/app/heroes/hero-list.component.ts import { inject } from \"@angular/core\";export class HeroListComponent { private heroService = inject(Hero",
    "id": "creating-an-injectable-service-*-angular-7"
  },
  {
    "url": "https://angular.dev/guide/di/creating-injectable-service",
    "title": "Creating an injectable service • Angular",
    "chunk": "Service);} It is also possible to inject a service into a component using the component's constructor: src/app/heroes/hero-list.component.ts (constructor signature) constructor(private heroService: HeroService) The inject method can be used in both classes and functions, while the constructor method can naturally only be used in a class constructor. However, in either case a dependency may only be injected in a valid injection context, usually in the construction or initialization of a component",
    "id": "creating-an-injectable-service-*-angular-8"
  },
  {
    "url": "https://angular.dev/guide/di/creating-injectable-service",
    "title": "Creating an injectable service • Angular",
    "chunk": ". Injecting services in other services When a service depends on another service, follow the same pattern as injecting into a component. In the following example, HeroService depends on a Logger service to report its activities: src/app/heroes/hero.service.ts import { inject, Injectable } from '@angular/core';import { HEROES } from './mock-heroes';import { Logger } from '../logger.service';@Injectable({ providedIn: 'root',})export class HeroService { private logger = inject(Logger); getHeroes() ",
    "id": "creating-an-injectable-service-*-angular-9"
  },
  {
    "url": "https://angular.dev/guide/di/creating-injectable-service",
    "title": "Creating an injectable service • Angular",
    "chunk": "{ this.logger.log('Getting heroes.'); return HEROES; }} In this example, the getHeroes() method uses the Logger service by logging a message when fetching heroes. What's next Configuring dependency providers InjectionTokens Social MediaBlogX (formerly Twitter)BlueskyYouTube Discord GitHub Stack Overflow Community Contribute Code of Conduct Report Issues Google's DevLibrary Angular Google Developer Experts ResourcesPress KitRoadmapLanguages简体中文版正體中文版日本語版한국어 Ελληνικά Super-powered by Google ©2010-",
    "id": "creating-an-injectable-service-*-angular-10"
  },
  {
    "url": "https://angular.dev/guide/di/creating-injectable-service",
    "title": "Creating an injectable service • Angular",
    "chunk": "2025. Code licensed under an MIT-style License . Documentation licensed under CC BY 4.0 .",
    "id": "creating-an-injectable-service-*-angular-11"
  },
  {
    "url": "https://angular.dev/guide/di/dependency-injection-providers",
    "title": "Defining dependency providers • Angular",
    "chunk": "In-depth GuidesDependency Injection Configuring dependency providers The previous sections described how to use class instances as dependencies. Aside from classes, you can also use values such as boolean, string, Date, and objects as dependencies. Angular provides the necessary APIs to make the dependency configuration flexible, so you can make those values available in DI. On this pagearrow_upward_alt Back to the top Specifying a provider token If you specify the service class as the provider ",
    "id": "defining-dependency-providers-*-angular-0"
  },
  {
    "url": "https://angular.dev/guide/di/dependency-injection-providers",
    "title": "Defining dependency providers • Angular",
    "chunk": "token, the default behavior is for the injector to instantiate that class using the new operator. In the following example, the app component provides a Logger instance: src/app/app.component.ts providers: [Logger], You can, however, configure DI to associate the Logger provider token with a different class or any other value. So when the Logger is injected, the configured value is used instead. In fact, the class provider syntax is a shorthand expression that expands into a provider configurati",
    "id": "defining-dependency-providers-*-angular-1"
  },
  {
    "url": "https://angular.dev/guide/di/dependency-injection-providers",
    "title": "Defining dependency providers • Angular",
    "chunk": "on, defined by the Provider interface. Angular expands the providers value in this case into a full provider object as follows: src/app/app.component.ts [{ provide: Logger, useClass: Logger }] The expanded provider configuration is an object literal with two properties: The provide property holds the token that serves as the key for consuming the dependency value. The second property is a provider definition object, which tells the injector how to create the dependency value. The provider-defini",
    "id": "defining-dependency-providers-*-angular-2"
  },
  {
    "url": "https://angular.dev/guide/di/dependency-injection-providers",
    "title": "Defining dependency providers • Angular",
    "chunk": "tion can be one of the following: useClass - this option tells Angular DI to instantiate a provided class when a dependency is injected useExisting - allows you to alias a token and reference any existing one. useFactory - allows you to define a function that constructs a dependency. useValue - provides a static value that should be used as a dependency. The sections below describe how to use the different provider definitions. Class providers: useClass The useClass provider key lets you create ",
    "id": "defining-dependency-providers-*-angular-3"
  },
  {
    "url": "https://angular.dev/guide/di/dependency-injection-providers",
    "title": "Defining dependency providers • Angular",
    "chunk": "and return a new instance of the specified class. You can use this type of provider to substitute an alternative implementation for a common or default class. The alternative implementation can, for example, implement a different strategy, extend the default class, or emulate the behavior of the real class in a test case. In the following example, BetterLogger would be instantiated when the Logger dependency is requested in a component or any other class: src/app/app.component.ts [{ provide: Log",
    "id": "defining-dependency-providers-*-angular-4"
  },
  {
    "url": "https://angular.dev/guide/di/dependency-injection-providers",
    "title": "Defining dependency providers • Angular",
    "chunk": "ger, useClass: BetterLogger }] If the alternative class providers have their own dependencies, specify both providers in the providers metadata property of the parent module or component: src/app/app.component.ts [ UserService, // dependency needed in `EvenBetterLogger`. { provide: Logger, useClass: EvenBetterLogger },] In this example, EvenBetterLogger displays the user name in the log message. This logger gets the user from an injected UserService instance: src/app/even-better-logger.component",
    "id": "defining-dependency-providers-*-angular-5"
  },
  {
    "url": "https://angular.dev/guide/di/dependency-injection-providers",
    "title": "Defining dependency providers • Angular",
    "chunk": ".ts @Injectable()export class EvenBetterLogger extends Logger { private userService = inject(UserService); override log(message: string) { const name = this.userService.user.name; super.log(`Message to ${name}: ${message}`); }} Angular DI knows how to construct the UserService dependency, since it has been configured above and is available in the injector. Alias providers: useExisting The useExisting provider key lets you map one token to another. In effect, the first token is an alias for the s",
    "id": "defining-dependency-providers-*-angular-6"
  },
  {
    "url": "https://angular.dev/guide/di/dependency-injection-providers",
    "title": "Defining dependency providers • Angular",
    "chunk": "ervice associated with the second token, creating two ways to access the same service object. In the following example, the injector injects the singleton instance of NewLogger when the component asks for either the new or the old logger: In this way, OldLogger is an alias for NewLogger. src/app/app.component.ts [ NewLogger, // Alias OldLogger w/ reference to NewLogger { provide: OldLogger, useExisting: NewLogger},] NOTE: Ensure you do not alias OldLogger to NewLogger with useClass, as this crea",
    "id": "defining-dependency-providers-*-angular-7"
  },
  {
    "url": "https://angular.dev/guide/di/dependency-injection-providers",
    "title": "Defining dependency providers • Angular",
    "chunk": "tes two different NewLogger instances. Factory providers: useFactory The useFactory provider key lets you create a dependency object by calling a factory function. With this approach, you can create a dynamic value based on information available in the DI and elsewhere in the app. In the following example, only authorized users should see secret heroes in the HeroService. Authorization can change during the course of a single application session, as when a different user logs in . To keep securi",
    "id": "defining-dependency-providers-*-angular-8"
  },
  {
    "url": "https://angular.dev/guide/di/dependency-injection-providers",
    "title": "Defining dependency providers • Angular",
    "chunk": "ty-sensitive information in UserService and out of HeroService, give the HeroService constructor a boolean flag to control display of secret heroes: src/app/heroes/hero.service.ts class HeroService { constructor( private logger: Logger, private isAuthorized: boolean) { } getHeroes() { const auth = this.isAuthorized ? 'authorized' : 'unauthorized'; this.logger.log(`Getting heroes for ${auth} user.`); return HEROES.filter(hero => this.isAuthorized || !hero.isSecret); }} To implement the isAuthoriz",
    "id": "defining-dependency-providers-*-angular-9"
  },
  {
    "url": "https://angular.dev/guide/di/dependency-injection-providers",
    "title": "Defining dependency providers • Angular",
    "chunk": "ed flag, use a factory provider to create a new logger instance for HeroService. This is necessary as we need to manually pass Logger when constructing the hero service: src/app/heroes/hero.service.provider.ts const heroServiceFactory = (logger: Logger, userService: UserService) => new HeroService(logger, userService.user.isAuthorized); The factory function has access to UserService. You inject both Logger and UserService into the factory provider so the injector can pass them along to the facto",
    "id": "defining-dependency-providers-*-angular-10"
  },
  {
    "url": "https://angular.dev/guide/di/dependency-injection-providers",
    "title": "Defining dependency providers • Angular",
    "chunk": "ry function: src/app/heroes/hero.service.provider.ts export const heroServiceProvider = { provide: HeroService, useFactory: heroServiceFactory, deps: [Logger, UserService]}; The useFactory field specifies that the provider is a factory function whose implementation is heroServiceFactory. The deps property is an array of provider tokens. The Logger and UserService classes serve as tokens for their own class providers. The injector resolves these tokens and injects the corresponding services into ",
    "id": "defining-dependency-providers-*-angular-11"
  },
  {
    "url": "https://angular.dev/guide/di/dependency-injection-providers",
    "title": "Defining dependency providers • Angular",
    "chunk": "the matching heroServiceFactory factory function parameters, based on the order specified. Capturing the factory provider in the exported variable, heroServiceProvider, makes the factory provider reusable. Value providers: useValue The useValue key lets you associate a static value with a DI token. Use this technique to provide runtime configuration constants such as website base addresses and feature flags. You can also use a value provider in a unit test to provide mock data in place of a prod",
    "id": "defining-dependency-providers-*-angular-12"
  },
  {
    "url": "https://angular.dev/guide/di/dependency-injection-providers",
    "title": "Defining dependency providers • Angular",
    "chunk": "uction data service. The next section provides more information about the useValue key. Using an InjectionToken object Use an InjectionToken object as provider token for non-class dependencies. The following example defines a token, APP_CONFIG. of the type InjectionToken: src/app/app.config.ts import { InjectionToken } from '@angular/core';export interface AppConfig { title: string;}export const APP_CONFIG = new InjectionToken<AppConfig>('app.config description'); The optional type parameter, <A",
    "id": "defining-dependency-providers-*-angular-13"
  },
  {
    "url": "https://angular.dev/guide/di/dependency-injection-providers",
    "title": "Defining dependency providers • Angular",
    "chunk": "ppConfig>, and the token description, app.config description, specify the token's purpose. Next, register the dependency provider in the component using the InjectionToken object of APP_CONFIG: src/app/app.component.ts const MY_APP_CONFIG_VARIABLE: AppConfig = { title: 'Hello',};providers: [{ provide: APP_CONFIG, useValue: MY_APP_CONFIG_VARIABLE }] Now, inject the configuration object in the constructor body with the inject function: src/app/app.component.ts export class AppComponent { construct",
    "id": "defining-dependency-providers-*-angular-14"
  },
  {
    "url": "https://angular.dev/guide/di/dependency-injection-providers",
    "title": "Defining dependency providers • Angular",
    "chunk": "or() { const config = inject(APP_CONFIG); this.title = config.title; }} Interfaces and DI Though the TypeScript AppConfig interface supports typing within the class, the AppConfig interface plays no role in DI. In TypeScript, an interface is a design-time artifact, and does not have a runtime representation, or token, that the DI framework can use. When the TypeScript transpiles to JavaScript, the interface disappears because JavaScript doesn't have interfaces. Because there is no interface for ",
    "id": "defining-dependency-providers-*-angular-15"
  },
  {
    "url": "https://angular.dev/guide/di/dependency-injection-providers",
    "title": "Defining dependency providers • Angular",
    "chunk": "Angular to find at runtime, the interface cannot be a token, nor can you inject it: src/app/app.component.ts // Can't use interface as provider token[{ provide: AppConfig, useValue: MY_APP_CONFIG_VARIABLE })] src/app/app.component.ts export class AppComponent { // Can't inject using the interface as the parameter type private config = inject(AppConfig);} Social MediaBlogX (formerly Twitter)BlueskyYouTube Discord GitHub Stack Overflow Community Contribute Code of Conduct Report Issues Google's De",
    "id": "defining-dependency-providers-*-angular-16"
  },
  {
    "url": "https://angular.dev/guide/di/dependency-injection-providers",
    "title": "Defining dependency providers • Angular",
    "chunk": "vLibrary Angular Google Developer Experts ResourcesPress KitRoadmapLanguages简体中文版正體中文版日本語版한국어 Ελληνικά Super-powered by Google ©2010-2025. Code licensed under an MIT-style License . Documentation licensed under CC BY 4.0 .",
    "id": "defining-dependency-providers-*-angular-17"
  },
  {
    "url": "https://angular.dev/guide/di/dependency-injection-context",
    "title": "Injection context • Angular",
    "chunk": "In-depth GuidesDependency Injection Injection context The dependency injection (DI) system relies internally on a runtime context where the current injector is available. This means that injectors can only work when code is executed in such a context. The injection context is available in these situations: During construction (via the constructor) of a class being instantiated by the DI system, such as an @Injectable or @Component. In the initializer for fields of such classes. In the factory fu",
    "id": "injection-context-*-angular-0"
  },
  {
    "url": "https://angular.dev/guide/di/dependency-injection-context",
    "title": "Injection context • Angular",
    "chunk": "nction specified for useFactory of a Provider or an @Injectable. In the factory function specified for an InjectionToken. Within a stack frame that runs in an injection context. Knowing when you are in an injection context will allow you to use the inject function to inject instances. On this pagearrow_upward_alt Back to the top Class constructors Every time the DI system instantiates a class, it does so in an injection context. This is handled by the framework itself. The constructor of the cla",
    "id": "injection-context-*-angular-1"
  },
  {
    "url": "https://angular.dev/guide/di/dependency-injection-context",
    "title": "Injection context • Angular",
    "chunk": "ss is executed in that runtime context, which also allows injection of a token using the inject function. class MyComponent { private service1: Service1; private service2: Service2 = inject(Service2); // In context constructor() { this.service1 = inject(Service1) // In context }} Stack frame in context Some APIs are designed to be run in an injection context. This is the case, for example, with router guards. This allows the use of inject within the guard function to access a service. Here is an",
    "id": "injection-context-*-angular-2"
  },
  {
    "url": "https://angular.dev/guide/di/dependency-injection-context",
    "title": "Injection context • Angular",
    "chunk": " example for CanActivateFn const canActivateTeam: CanActivateFn = (route: ActivatedRouteSnapshot, state: RouterStateSnapshot) => { return inject(PermissionsService).canActivate(inject(UserToken), route.params.id); }; Run within an injection context When you want to run a given function in an injection context without already being in one, you can do so with runInInjectionContext. This requires access to a given injector, like the EnvironmentInjector, for example: src/app/heroes/hero.service.ts @",
    "id": "injection-context-*-angular-3"
  },
  {
    "url": "https://angular.dev/guide/di/dependency-injection-context",
    "title": "Injection context • Angular",
    "chunk": "Injectable({ providedIn: 'root',})export class HeroService { private environmentInjector = inject(EnvironmentInjector); someMethod() { runInInjectionContext(this.environmentInjector, () => { inject(SomeService); // Do what you need with the injected service }); }} Note that inject will return an instance only if the injector can resolve the required token. Asserts the context Angular provides the assertInInjectionContext helper function to assert that the current context is an injection context.",
    "id": "injection-context-*-angular-4"
  },
  {
    "url": "https://angular.dev/guide/di/dependency-injection-context",
    "title": "Injection context • Angular",
    "chunk": " Using DI outside of a context Calling inject or calling assertInInjectionContext outside of an injection context will throw error NG0203. Social MediaBlogX (formerly Twitter)BlueskyYouTube Discord GitHub Stack Overflow Community Contribute Code of Conduct Report Issues Google's DevLibrary Angular Google Developer Experts ResourcesPress KitRoadmapLanguages简体中文版正體中文版日本語版한국어 Ελληνικά Super-powered by Google ©2010-2025. Code licensed under an MIT-style License . Documentation licensed under CC BY 4",
    "id": "injection-context-*-angular-5"
  },
  {
    "url": "https://angular.dev/guide/di/dependency-injection-context",
    "title": "Injection context • Angular",
    "chunk": ".0 .",
    "id": "injection-context-*-angular-6"
  },
  {
    "url": "https://angular.dev/guide/di/hierarchical-dependency-injection",
    "title": "Hierarchical injectors • Angular",
    "chunk": "In-depth GuidesDependency Injection Hierarchical injectors Injectors in Angular have rules that you can leverage to achieve the desired visibility of injectables in your applications. By understanding these rules, you can determine whether to declare a provider at the application level, in a Component, or in a Directive. The applications you build with Angular can become quite large, and one way to manage this complexity is to split up the application into a well-defined tree of components. Ther",
    "id": "hierarchical-injectors-*-angular-0"
  },
  {
    "url": "https://angular.dev/guide/di/hierarchical-dependency-injection",
    "title": "Hierarchical injectors • Angular",
    "chunk": "e can be sections of your page that work in a completely independent way than the rest of the application, with its own local copies of the services and other dependencies that it needs. Some of the services that these sections of the application use might be shared with other parts of the application, or with parent components that are further up in the component tree, while other dependencies are meant to be private. With hierarchical dependency injection, you can isolate sections of the appli",
    "id": "hierarchical-injectors-*-angular-1"
  },
  {
    "url": "https://angular.dev/guide/di/hierarchical-dependency-injection",
    "title": "Hierarchical injectors • Angular",
    "chunk": "cation and give them their own private dependencies not shared with the rest of the application, or have parent components share certain dependencies with its child components only but not with the rest of the component tree, and so on. Hierarchical dependency injection enables you to share dependencies between different parts of the application only when and if you need to. On this pagearrow_upward_alt Back to the top Types of injector hierarchies Angular has two injector hierarchies: Injector ",
    "id": "hierarchical-injectors-*-angular-2"
  },
  {
    "url": "https://angular.dev/guide/di/hierarchical-dependency-injection",
    "title": "Hierarchical injectors • Angular",
    "chunk": "hierarchies Details EnvironmentInjector hierarchy Configure an EnvironmentInjector in this hierarchy using @Injectable() or providers array in ApplicationConfig. ElementInjector hierarchy Created implicitly at each DOM element. An ElementInjector is empty by default unless you configure it in the providers property on @Directive() or @Component(). NgModule Based Applications For NgModule based applications, you can provide dependencies with the ModuleInjector hierarchy using an @NgModule() or @I",
    "id": "hierarchical-injectors-*-angular-3"
  },
  {
    "url": "https://angular.dev/guide/di/hierarchical-dependency-injection",
    "title": "Hierarchical injectors • Angular",
    "chunk": "njectable() annotation. EnvironmentInjector The EnvironmentInjector can be configured in one of two ways by using: The @Injectable() providedIn property to refer to root or platform The ApplicationConfig providers array Tree-shaking and @Injectable() Using the @Injectable() providedIn property is preferable to using the ApplicationConfig providers array. With @Injectable() providedIn, optimization tools can perform tree-shaking, which removes services that your application isn't using. This resu",
    "id": "hierarchical-injectors-*-angular-4"
  },
  {
    "url": "https://angular.dev/guide/di/hierarchical-dependency-injection",
    "title": "Hierarchical injectors • Angular",
    "chunk": "lts in smaller bundle sizes. Tree-shaking is especially useful for a library because the application which uses the library may not have a need to inject it. EnvironmentInjector is configured by the ApplicationConfig.providers. Provide services using providedIn of @Injectable() as follows: import { Injectable } from '@angular/core';@Injectable({ providedIn: 'root' // <--provides this service in the root EnvironmentInjector})export class ItemService { name = 'telephone';} The @Injectable() decora",
    "id": "hierarchical-injectors-*-angular-5"
  },
  {
    "url": "https://angular.dev/guide/di/hierarchical-dependency-injection",
    "title": "Hierarchical injectors • Angular",
    "chunk": "tor identifies a service class. The providedIn property configures a specific EnvironmentInjector, here root, which makes the service available in the root EnvironmentInjector. ModuleInjector In the case of NgModule based applications, the ModuleInjector can be configured in one of two ways by using: The @Injectable() providedIn property to refer to root or platform The @NgModule() providers array ModuleInjector is configured by the @NgModule.providers and NgModule.imports property. ModuleInject",
    "id": "hierarchical-injectors-*-angular-6"
  },
  {
    "url": "https://angular.dev/guide/di/hierarchical-dependency-injection",
    "title": "Hierarchical injectors • Angular",
    "chunk": "or is a flattening of all the providers arrays that can be reached by following the NgModule.imports recursively. Child ModuleInjector hierarchies are created when lazy loading other @NgModules. Platform injector There are two more injectors above root, an additional EnvironmentInjector and NullInjector(). Consider how Angular bootstraps the application with the following in main.ts: bootstrapApplication(AppComponent, appConfig); The bootstrapApplication() method creates a child injector of the ",
    "id": "hierarchical-injectors-*-angular-7"
  },
  {
    "url": "https://angular.dev/guide/di/hierarchical-dependency-injection",
    "title": "Hierarchical injectors • Angular",
    "chunk": "platform injector which is configured by the ApplicationConfig instance. This is the root EnvironmentInjector. The platformBrowserDynamic() method creates an injector configured by a PlatformModule, which contains platform-specific dependencies. This allows multiple applications to share a platform configuration. For example, a browser has only one URL bar, no matter how many applications you have running. You can configure additional platform-specific providers at the platform level by supplyin",
    "id": "hierarchical-injectors-*-angular-8"
  },
  {
    "url": "https://angular.dev/guide/di/hierarchical-dependency-injection",
    "title": "Hierarchical injectors • Angular",
    "chunk": "g extraProviders using the platformBrowser() function. The next parent injector in the hierarchy is the NullInjector(), which is the top of the tree. If you've gone so far up the tree that you are looking for a service in the NullInjector(), you'll get an error unless you've used @Optional() because ultimately, everything ends at the NullInjector() and it returns an error or, in the case of @Optional(), null. For more information on @Optional(), see the @Optional() section of this guide. The fol",
    "id": "hierarchical-injectors-*-angular-9"
  },
  {
    "url": "https://angular.dev/guide/di/hierarchical-dependency-injection",
    "title": "Hierarchical injectors • Angular",
    "chunk": "lowing diagram represents the relationship between the root ModuleInjector and its parent injectors as the previous paragraphs describe. #mermaid-generated-diagram{font-family:\"trebuchet ms\",verdana,arial,sans-serif;font-size:16px;fill:#333;}@keyframes edge-animation-frame{from{stroke-dashoffset:0;}}@keyframes dash{to{stroke-dashoffset:0;}}#mermaid-generated-diagram .edge-animation-slow{stroke-dasharray:9,5!important;stroke-dashoffset:900;animation:dash 50s linear infinite;stroke-linecap:round;}",
    "id": "hierarchical-injectors-*-angular-10"
  },
  {
    "url": "https://angular.dev/guide/di/hierarchical-dependency-injection",
    "title": "Hierarchical injectors • Angular",
    "chunk": "#mermaid-generated-diagram .edge-animation-fast{stroke-dasharray:9,5!important;stroke-dashoffset:900;animation:dash 20s linear infinite;stroke-linecap:round;}#mermaid-generated-diagram .error-icon{fill:hsl(220.5882352941, 100%, 98.3333333333%);}#mermaid-generated-diagram .error-text{fill:rgb(8.5000000002, 5.7500000001, 0);stroke:rgb(8.5000000002, 5.7500000001, 0);}#mermaid-generated-diagram .edge-thickness-normal{stroke-width:1px;}#mermaid-generated-diagram .edge-thickness-thick{stroke-width:3.5",
    "id": "hierarchical-injectors-*-angular-11"
  },
  {
    "url": "https://angular.dev/guide/di/hierarchical-dependency-injection",
    "title": "Hierarchical injectors • Angular",
    "chunk": "px;}#mermaid-generated-diagram .edge-pattern-solid{stroke-dasharray:0;}#mermaid-generated-diagram .edge-thickness-invisible{stroke-width:0;fill:none;}#mermaid-generated-diagram .edge-pattern-dashed{stroke-dasharray:3;}#mermaid-generated-diagram .edge-pattern-dotted{stroke-dasharray:2;}#mermaid-generated-diagram .marker{fill:#0b0b0b;stroke:#0b0b0b;}#mermaid-generated-diagram .marker.cross{stroke:#0b0b0b;}#mermaid-generated-diagram svg{font-family:\"trebuchet ms\",verdana,arial,sans-serif;font-size:",
    "id": "hierarchical-injectors-*-angular-12"
  },
  {
    "url": "https://angular.dev/guide/di/hierarchical-dependency-injection",
    "title": "Hierarchical injectors • Angular",
    "chunk": "16px;}#mermaid-generated-diagram p{margin:0;}#mermaid-generated-diagram defs #statediagram-barbEnd{fill:#0b0b0b;stroke:#0b0b0b;}#mermaid-generated-diagram g.stateGroup text{fill:hsl(40.5882352941, 60%, 83.3333333333%);stroke:none;font-size:10px;}#mermaid-generated-diagram g.stateGroup text{fill:#333;stroke:none;font-size:10px;}#mermaid-generated-diagram g.stateGroup .state-title{font-weight:bolder;fill:#333;}#mermaid-generated-diagram g.stateGroup rect{fill:#fff4dd;stroke:hsl(40.5882352941, 60%,",
    "id": "hierarchical-injectors-*-angular-13"
  },
  {
    "url": "https://angular.dev/guide/di/hierarchical-dependency-injection",
    "title": "Hierarchical injectors • Angular",
    "chunk": " 83.3333333333%);}#mermaid-generated-diagram g.stateGroup line{stroke:#0b0b0b;stroke-width:1;}#mermaid-generated-diagram .transition{stroke:#0b0b0b;stroke-width:1;fill:none;}#mermaid-generated-diagram .stateGroup .composit{fill:#f4f4f4;border-bottom:1px;}#mermaid-generated-diagram .stateGroup .alt-composit{fill:#e0e0e0;border-bottom:1px;}#mermaid-generated-diagram .state-note{stroke:hsl(52.6829268293, 60%, 73.9215686275%);fill:#fff5ad;}#mermaid-generated-diagram .state-note text{fill:#333;stroke",
    "id": "hierarchical-injectors-*-angular-14"
  },
  {
    "url": "https://angular.dev/guide/di/hierarchical-dependency-injection",
    "title": "Hierarchical injectors • Angular",
    "chunk": ":none;font-size:10px;}#mermaid-generated-diagram .stateLabel .box{stroke:none;stroke-width:0;fill:#fff4dd;opacity:0.5;}#mermaid-generated-diagram .edgeLabel .label rect{fill:#fff4dd;opacity:0.5;}#mermaid-generated-diagram .edgeLabel{background-color:hsl(-79.4117647059, 100%, 93.3333333333%);text-align:center;}#mermaid-generated-diagram .edgeLabel p{background-color:hsl(-79.4117647059, 100%, 93.3333333333%);}#mermaid-generated-diagram .edgeLabel rect{opacity:0.5;background-color:hsl(-79.411764705",
    "id": "hierarchical-injectors-*-angular-15"
  },
  {
    "url": "https://angular.dev/guide/di/hierarchical-dependency-injection",
    "title": "Hierarchical injectors • Angular",
    "chunk": "9, 100%, 93.3333333333%);fill:hsl(-79.4117647059, 100%, 93.3333333333%);}#mermaid-generated-diagram .edgeLabel .label text{fill:#333;}#mermaid-generated-diagram .label div .edgeLabel{color:#333;}#mermaid-generated-diagram .stateLabel text{fill:#333;font-size:10px;font-weight:bold;}#mermaid-generated-diagram .node circle.state-start{fill:#0b0b0b;stroke:#0b0b0b;}#mermaid-generated-diagram .node .fork-join{fill:#0b0b0b;stroke:#0b0b0b;}#mermaid-generated-diagram .node circle.state-end{fill:hsl(40.58",
    "id": "hierarchical-injectors-*-angular-16"
  },
  {
    "url": "https://angular.dev/guide/di/hierarchical-dependency-injection",
    "title": "Hierarchical injectors • Angular",
    "chunk": "82352941, 60%, 83.3333333333%);stroke:#f4f4f4;stroke-width:1.5;}#mermaid-generated-diagram .end-state-inner{fill:#f4f4f4;stroke-width:1.5;}#mermaid-generated-diagram .node rect{fill:#fff4dd;stroke:hsl(40.5882352941, 60%, 83.3333333333%);stroke-width:1px;}#mermaid-generated-diagram .node polygon{fill:#fff4dd;stroke:hsl(40.5882352941, 60%, 83.3333333333%);stroke-width:1px;}#mermaid-generated-diagram #statediagram-barbEnd{fill:#0b0b0b;}#mermaid-generated-diagram .statediagram-cluster rect{fill:#fff",
    "id": "hierarchical-injectors-*-angular-17"
  },
  {
    "url": "https://angular.dev/guide/di/hierarchical-dependency-injection",
    "title": "Hierarchical injectors • Angular",
    "chunk": "4dd;stroke:hsl(40.5882352941, 60%, 83.3333333333%);stroke-width:1px;}#mermaid-generated-diagram .cluster-label,#mermaid-generated-diagram .nodeLabel{color:#333;}#mermaid-generated-diagram .statediagram-cluster rect.outer{rx:5px;ry:5px;}#mermaid-generated-diagram .statediagram-state .divider{stroke:hsl(40.5882352941, 60%, 83.3333333333%);}#mermaid-generated-diagram .statediagram-state .title-state{rx:5px;ry:5px;}#mermaid-generated-diagram .statediagram-cluster.statediagram-cluster .inner{fill:#f4",
    "id": "hierarchical-injectors-*-angular-18"
  },
  {
    "url": "https://angular.dev/guide/di/hierarchical-dependency-injection",
    "title": "Hierarchical injectors • Angular",
    "chunk": "f4f4;}#mermaid-generated-diagram .statediagram-cluster.statediagram-cluster-alt .inner{fill:hsl(220.5882352941, 100%, 98.3333333333%);}#mermaid-generated-diagram .statediagram-cluster .inner{rx:0;ry:0;}#mermaid-generated-diagram .statediagram-state rect.basic{rx:5px;ry:5px;}#mermaid-generated-diagram .statediagram-state rect.divider{stroke-dasharray:10,10;fill:hsl(220.5882352941, 100%, 98.3333333333%);}#mermaid-generated-diagram .note-edge{stroke-dasharray:5;}#mermaid-generated-diagram .statedia",
    "id": "hierarchical-injectors-*-angular-19"
  },
  {
    "url": "https://angular.dev/guide/di/hierarchical-dependency-injection",
    "title": "Hierarchical injectors • Angular",
    "chunk": "gram-note rect{fill:#fff5ad;stroke:hsl(52.6829268293, 60%, 73.9215686275%);stroke-width:1px;rx:0;ry:0;}#mermaid-generated-diagram .statediagram-note rect{fill:#fff5ad;stroke:hsl(52.6829268293, 60%, 73.9215686275%);stroke-width:1px;rx:0;ry:0;}#mermaid-generated-diagram .statediagram-note text{fill:#333;}#mermaid-generated-diagram .statediagram-note .nodeLabel{color:#333;}#mermaid-generated-diagram .statediagram .edgeLabel{color:red;}#mermaid-generated-diagram #dependencyStart,#mermaid-generated-d",
    "id": "hierarchical-injectors-*-angular-20"
  },
  {
    "url": "https://angular.dev/guide/di/hierarchical-dependency-injection",
    "title": "Hierarchical injectors • Angular",
    "chunk": "iagram #dependencyEnd{fill:#0b0b0b;stroke:#0b0b0b;stroke-width:1;}#mermaid-generated-diagram .statediagramTitleText{text-anchor:middle;font-size:18px;fill:#333;}#mermaid-generated-diagram :root{--mermaid-font-family:\"trebuchet ms\",verdana,arial,sans-serif;}EnvironmentInjector(configured by Angular)has special things like DomSanitizer => providedIn 'platform'root EnvironmentInjector(configured by AppConfig)has things for your app => bootstrapApplication(..., AppConfig)NullInjectoralways throws an",
    "id": "hierarchical-injectors-*-angular-21"
  },
  {
    "url": "https://angular.dev/guide/di/hierarchical-dependency-injection",
    "title": "Hierarchical injectors • Angular",
    "chunk": " error unlessyou use @Optional()While the name root is a special alias, other EnvironmentInjector hierarchies don't have aliases. You have the option to create EnvironmentInjector hierarchies whenever a dynamically loaded component is created, such as with the Router, which will create child EnvironmentInjector hierarchies. All requests forward up to the root injector, whether you configured it with the ApplicationConfig instance passed to the bootstrapApplication() method, or registered all pro",
    "id": "hierarchical-injectors-*-angular-22"
  },
  {
    "url": "https://angular.dev/guide/di/hierarchical-dependency-injection",
    "title": "Hierarchical injectors • Angular",
    "chunk": "viders with root in their own services. @Injectable() vs. ApplicationConfig If you configure an app-wide provider in the ApplicationConfig of bootstrapApplication, it overrides one configured for root in the @Injectable() metadata. You can do this to configure a non-default provider of a service that is shared with multiple applications. Here is an example of the case where the component router configuration includes a non-default location strategy by listing its provider in the providers list o",
    "id": "hierarchical-injectors-*-angular-23"
  },
  {
    "url": "https://angular.dev/guide/di/hierarchical-dependency-injection",
    "title": "Hierarchical injectors • Angular",
    "chunk": "f the ApplicationConfig. providers: [ { provide: LocationStrategy, useClass: HashLocationStrategy }] For NgModule based applications, configure app-wide providers in the AppModule providers. ElementInjector Angular creates ElementInjector hierarchies implicitly for each DOM element. Providing a service in the @Component() decorator using its providers or viewProviders property configures an ElementInjector. For example, the following TestComponent configures the ElementInjector by providing the ",
    "id": "hierarchical-injectors-*-angular-24"
  },
  {
    "url": "https://angular.dev/guide/di/hierarchical-dependency-injection",
    "title": "Hierarchical injectors • Angular",
    "chunk": "service as follows: @Component({ … providers: [{ provide: ItemService, useValue: { name: 'lamp' } }]})export class TestComponent HELPFUL: See the resolution rules section to understand the relationship between the EnvironmentInjector tree, the ModuleInjector and the ElementInjector tree. When you provide services in a component, that service is available by way of the ElementInjector at that component instance. It may also be visible at child component/directives based on visibility rules descri",
    "id": "hierarchical-injectors-*-angular-25"
  },
  {
    "url": "https://angular.dev/guide/di/hierarchical-dependency-injection",
    "title": "Hierarchical injectors • Angular",
    "chunk": "bed in the resolution rules section. When the component instance is destroyed, so is that service instance. @Directive() and @Component() A component is a special type of directive, which means that just as @Directive() has a providers property, @Component() does too. This means that directives as well as components can configure providers, using the providers property. When you configure a provider for a component or directive using the providers property, that provider belongs to the ElementIn",
    "id": "hierarchical-injectors-*-angular-26"
  },
  {
    "url": "https://angular.dev/guide/di/hierarchical-dependency-injection",
    "title": "Hierarchical injectors • Angular",
    "chunk": "jector of that component or directive. Components and directives on the same element share an injector. Resolution rules When resolving a token for a component/directive, Angular resolves it in two phases: Against its parents in the ElementInjector hierarchy. Against its parents in the EnvironmentInjector hierarchy. When a component declares a dependency, Angular tries to satisfy that dependency with its own ElementInjector. If the component's injector lacks the provider, it passes the request u",
    "id": "hierarchical-injectors-*-angular-27"
  },
  {
    "url": "https://angular.dev/guide/di/hierarchical-dependency-injection",
    "title": "Hierarchical injectors • Angular",
    "chunk": "p to its parent component's ElementInjector. The requests keep forwarding up until Angular finds an injector that can handle the request or runs out of ancestor ElementInjector hierarchies. If Angular doesn't find the provider in any ElementInjector hierarchies, it goes back to the element where the request originated and looks in the EnvironmentInjector hierarchy. If Angular still doesn't find the provider, it throws an error. If you have registered a provider for the same DI token at different",
    "id": "hierarchical-injectors-*-angular-28"
  },
  {
    "url": "https://angular.dev/guide/di/hierarchical-dependency-injection",
    "title": "Hierarchical injectors • Angular",
    "chunk": " levels, the first one Angular encounters is the one it uses to resolve the dependency. If, for example, a provider is registered locally in the component that needs a service, Angular doesn't look for another provider of the same service. HELPFUL: For NgModule based applications, Angular will search the ModuleInjector hierarchy if it cannot find a provider in the ElementInjector hierarchies. Resolution modifiers Angular's resolution behavior can be modified with optional, self, skipSelf and hos",
    "id": "hierarchical-injectors-*-angular-29"
  },
  {
    "url": "https://angular.dev/guide/di/hierarchical-dependency-injection",
    "title": "Hierarchical injectors • Angular",
    "chunk": "t. Import each of them from @angular/core and use each in the inject configuration when you inject your service. Types of modifiers Resolution modifiers fall into three categories: What to do if Angular doesn't find what you're looking for, that is optional Where to start looking, that is skipSelf Where to stop looking, host and self By default, Angular always starts at the current Injector and keeps searching all the way up. Modifiers allow you to change the starting, or self, location and the ",
    "id": "hierarchical-injectors-*-angular-30"
  },
  {
    "url": "https://angular.dev/guide/di/hierarchical-dependency-injection",
    "title": "Hierarchical injectors • Angular",
    "chunk": "ending location. Additionally, you can combine all of the modifiers except: host and self skipSelf and self. optional optional allows Angular to consider a service you inject to be optional. This way, if it can't be resolved at runtime, Angular resolves the service as null, rather than throwing an error. In the following example, the service, OptionalService, isn't provided in the service, ApplicationConfig, @NgModule(), or component class, so it isn't available anywhere in the app. src/app/opti",
    "id": "hierarchical-injectors-*-angular-31"
  },
  {
    "url": "https://angular.dev/guide/di/hierarchical-dependency-injection",
    "title": "Hierarchical injectors • Angular",
    "chunk": "onal/optional.component.ts export class OptionalComponent { public optional? = inject(OptionalService, {optional: true});} self Use self so that Angular will only look at the ElementInjector for the current component or directive. A good use case for self is to inject a service but only if it is available on the current host element. To avoid errors in this situation, combine self with optional. For example, in the following SelfNoDataComponent, notice the injected LeafService as a property. src",
    "id": "hierarchical-injectors-*-angular-32"
  },
  {
    "url": "https://angular.dev/guide/di/hierarchical-dependency-injection",
    "title": "Hierarchical injectors • Angular",
    "chunk": "/app/self-no-data/self-no-data.component.ts @Component({ selector: 'app-self-no-data', templateUrl: './self-no-data.component.html', styleUrls: ['./self-no-data.component.css']})export class SelfNoDataComponent { public leaf = inject(LeafService, {optional: true, self: true});} In this example, there is a parent provider and injecting the service will return the value, however, injecting the service with self and optional will return null because self tells the injector to stop searching in the ",
    "id": "hierarchical-injectors-*-angular-33"
  },
  {
    "url": "https://angular.dev/guide/di/hierarchical-dependency-injection",
    "title": "Hierarchical injectors • Angular",
    "chunk": "current host element. Another example shows the component class with a provider for FlowerService. In this case, the injector looks no further than the current ElementInjector because it finds the FlowerService and returns the tulip 🌷. src/app/self/self.component.ts import {Component, Self} from '@angular/core';import {FlowerService} from '../flower.service';@Component({ selector: 'app-self', templateUrl: './self.component.html', styleUrls: ['./self.component.css'], providers: [{provide: Flower",
    "id": "hierarchical-injectors-*-angular-34"
  },
  {
    "url": "https://angular.dev/guide/di/hierarchical-dependency-injection",
    "title": "Hierarchical injectors • Angular",
    "chunk": "Service, useValue: {emoji: '🌷'}}],})export class SelfComponent { constructor(@Self() public flower: FlowerService) {}}// This component provides the FlowerService so the injector// doesn't have to look further up the injector tree skipSelf skipSelf is the opposite of self. With skipSelf, Angular starts its search for a service in the parent ElementInjector, rather than in the current one. So if the parent ElementInjector were using the fern 🌿 value for emoji, but you had maple leaf 🍁 in the c",
    "id": "hierarchical-injectors-*-angular-35"
  },
  {
    "url": "https://angular.dev/guide/di/hierarchical-dependency-injection",
    "title": "Hierarchical injectors • Angular",
    "chunk": "omponent's providers array, Angular would ignore maple leaf 🍁 and use fern 🌿. To see this in code, assume that the following value for emoji is what the parent component were using, as in this service: src/app/leaf.service.ts export class LeafService { emoji = '🌿';} Imagine that in the child component, you had a different value, maple leaf 🍁 but you wanted to use the parent's value instead. This is when you'd use skipSelf: src/app/skipself/skipself.component.ts @Component({ selector: 'app-sk",
    "id": "hierarchical-injectors-*-angular-36"
  },
  {
    "url": "https://angular.dev/guide/di/hierarchical-dependency-injection",
    "title": "Hierarchical injectors • Angular",
    "chunk": "ipself', templateUrl: './skipself.component.html', styleUrls: ['./skipself.component.css'], // Angular would ignore this LeafService instance providers: [{ provide: LeafService, useValue: { emoji: '🍁' } }]})export class SkipselfComponent { // Use skipSelf as inject option public leaf = inject(LeafService, {skipSelf: true});} In this case, the value you'd get for emoji would be fern 🌿, not maple leaf 🍁. skipSelf option with optional Use the skipSelf option with optional to prevent an error if ",
    "id": "hierarchical-injectors-*-angular-37"
  },
  {
    "url": "https://angular.dev/guide/di/hierarchical-dependency-injection",
    "title": "Hierarchical injectors • Angular",
    "chunk": "the value is null. In the following example, the Person service is injected during property initialization. skipSelf tells Angular to skip the current injector and optional will prevent an error should the Person service be null. class Person { parent = inject(Person, {optional: true, skipSelf: true})} host host lets you designate a component as the last stop in the injector tree when searching for providers. Even if there is a service instance further up the tree, Angular won't continue looking",
    "id": "hierarchical-injectors-*-angular-38"
  },
  {
    "url": "https://angular.dev/guide/di/hierarchical-dependency-injection",
    "title": "Hierarchical injectors • Angular",
    "chunk": ". Use host as follows: src/app/host/host.component.ts @Component({ selector: 'app-host', templateUrl: './host.component.html', styleUrls: ['./host.component.css'], // provide the service providers: [{ provide: FlowerService, useValue: { emoji: '🌷' } }]})export class HostComponent { // use host when injecting the service flower = inject(FlowerService, {host: true, optional: true});} Since HostComponent has the host option , no matter what the parent of HostComponent might have as a flower.emoji ",
    "id": "hierarchical-injectors-*-angular-39"
  },
  {
    "url": "https://angular.dev/guide/di/hierarchical-dependency-injection",
    "title": "Hierarchical injectors • Angular",
    "chunk": "value, the HostComponent will use tulip 🌷. Modifiers with constructor injection Similarly as presented before, the behavior of constructor injection can be modified with @Optional(), @Self(), @SkipSelf() and @Host(). Import each of them from @angular/core and use each in the component class constructor when you inject your service. src/app/self-no-data/self-no-data.component.ts export class SelfNoDataComponent { constructor(@Self() @Optional() public leaf?: LeafService) { }} Logical structure o",
    "id": "hierarchical-injectors-*-angular-40"
  },
  {
    "url": "https://angular.dev/guide/di/hierarchical-dependency-injection",
    "title": "Hierarchical injectors • Angular",
    "chunk": "f the template When you provide services in the component class, services are visible within the ElementInjector tree relative to where and how you provide those services. Understanding the underlying logical structure of the Angular template will give you a foundation for configuring services and in turn control their visibility. Components are used in your templates, as in the following example: <app-root> <app-child></app-child>;</app-root> HELPFUL: Usually, you declare the components and the",
    "id": "hierarchical-injectors-*-angular-41"
  },
  {
    "url": "https://angular.dev/guide/di/hierarchical-dependency-injection",
    "title": "Hierarchical injectors • Angular",
    "chunk": "ir templates in separate files. For the purposes of understanding how the injection system works, it is useful to look at them from the point of view of a combined logical tree. The term logical distinguishes it from the render tree, which is your application's DOM tree. To mark the locations of where the component templates are located, this guide uses the <#VIEW> pseudo-element, which doesn't actually exist in the render tree and is present for mental model purposes only. The following is an e",
    "id": "hierarchical-injectors-*-angular-42"
  },
  {
    "url": "https://angular.dev/guide/di/hierarchical-dependency-injection",
    "title": "Hierarchical injectors • Angular",
    "chunk": "xample of how the <app-root> and <app-child> view trees are combined into a single logical tree: <app-root> <#VIEW> <app-child> <#VIEW> …content goes here… </#VIEW> </app-child> </#VIEW></app-root> Understanding the idea of the <#VIEW> demarcation is especially significant when you configure services in the component class. Example: Providing services in @Component() How you provide services using a @Component() (or @Directive()) decorator determines their visibility. The following sections demo",
    "id": "hierarchical-injectors-*-angular-43"
  },
  {
    "url": "https://angular.dev/guide/di/hierarchical-dependency-injection",
    "title": "Hierarchical injectors • Angular",
    "chunk": "nstrate providers and viewProviders along with ways to modify service visibility with skipSelf and host. A component class can provide services in two ways: Arrays Details With a providers array @Component({ providers: [SomeService] }) With a viewProviders array @Component({ viewProviders: [SomeService] }) In the examples below, you will see the logical tree of an Angular application. To illustrate how the injector works in the context of templates, the logical tree will represent the HTML struc",
    "id": "hierarchical-injectors-*-angular-44"
  },
  {
    "url": "https://angular.dev/guide/di/hierarchical-dependency-injection",
    "title": "Hierarchical injectors • Angular",
    "chunk": "ture of the application. For example, the logical tree will show that <child-component> is a direct children of <parent-component>. In the logical tree, you will see special attributes: @Provide, @Inject, and @ApplicationConfig. These aren't real attributes but are here to demonstrate what is going on under the hood. Angular service attribute Details @Inject(Token)=>Value If Token is injected at this location in the logical tree, its value would be Value. @Provide(Token=Value) Indicates that Tok",
    "id": "hierarchical-injectors-*-angular-45"
  },
  {
    "url": "https://angular.dev/guide/di/hierarchical-dependency-injection",
    "title": "Hierarchical injectors • Angular",
    "chunk": "en is provided with Value at this location in the logical tree. @ApplicationConfig Demonstrates that a fallback EnvironmentInjector should be used at this location. Example app structure The example application has a FlowerService provided in root with an emoji value of red hibiscus 🌺. src/app/flower.service.ts @Injectable({ providedIn: 'root'})export class FlowerService { emoji = '🌺';} Consider an application with only an AppComponent and a ChildComponent. The most basic rendered view would l",
    "id": "hierarchical-injectors-*-angular-46"
  },
  {
    "url": "https://angular.dev/guide/di/hierarchical-dependency-injection",
    "title": "Hierarchical injectors • Angular",
    "chunk": "ook like nested HTML elements such as the following: <app-root> <!-- AppComponent selector --> <app-child> <!-- ChildComponent selector --> </app-child></app-root> However, behind the scenes, Angular uses a logical view representation as follows when resolving injection requests: <app-root> <!-- AppComponent selector --> <#VIEW> <app-child> <!-- ChildComponent selector --> <#VIEW> </#VIEW> </app-child> </#VIEW></app-root> The <#VIEW> here represents an instance of a template. Notice that each co",
    "id": "hierarchical-injectors-*-angular-47"
  },
  {
    "url": "https://angular.dev/guide/di/hierarchical-dependency-injection",
    "title": "Hierarchical injectors • Angular",
    "chunk": "mponent has its own <#VIEW>. Knowledge of this structure can inform how you provide and inject your services, and give you complete control of service visibility. Now, consider that <app-root> injects the FlowerService: src/app/app.component.ts export class AppComponent { flower = inject(FlowerService);} Add a binding to the <app-root> template to visualize the result: src/app/app.component.html <p>Emoji from FlowerService: {{flower.emoji}}</p> The output in the view would be: Emoji from FlowerS",
    "id": "hierarchical-injectors-*-angular-48"
  },
  {
    "url": "https://angular.dev/guide/di/hierarchical-dependency-injection",
    "title": "Hierarchical injectors • Angular",
    "chunk": "ervice: 🌺 In the logical tree, this would be represented as follows: <app-root @ApplicationConfig @Inject(FlowerService) flower=>\"🌺\"> <#VIEW> <p>Emoji from FlowerService: {{flower.emoji}} (🌺)</p> <app-child> <#VIEW> </#VIEW> </app-child> </#VIEW></app-root> When <app-root> requests the FlowerService, it is the injector's job to resolve the FlowerService token. The resolution of the token happens in two phases: The injector determines the starting location in the logical tree and an ending loc",
    "id": "hierarchical-injectors-*-angular-49"
  },
  {
    "url": "https://angular.dev/guide/di/hierarchical-dependency-injection",
    "title": "Hierarchical injectors • Angular",
    "chunk": "ation of the search. The injector begins with the starting location and looks for the token at each view level in the logical tree. If the token is found it is returned. If the token is not found, the injector looks for the closest parent EnvironmentInjector to delegate the request to. In the example case, the constraints are: Start with <#VIEW> belonging to <app-root> and end with <app-root>. Normally the starting point for search is at the point of injection. However, in this case <app-root> i",
    "id": "hierarchical-injectors-*-angular-50"
  },
  {
    "url": "https://angular.dev/guide/di/hierarchical-dependency-injection",
    "title": "Hierarchical injectors • Angular",
    "chunk": "s a component. @Components are special in that they also include their own viewProviders, which is why the search starts at <#VIEW> belonging to <app-root>. This would not be the case for a directive matched at the same location. The ending location happens to be the same as the component itself, because it is the topmost component in this application. The EnvironmentInjector provided by the ApplicationConfig acts as the fallback injector when the injection token can't be found in the ElementInj",
    "id": "hierarchical-injectors-*-angular-51"
  },
  {
    "url": "https://angular.dev/guide/di/hierarchical-dependency-injection",
    "title": "Hierarchical injectors • Angular",
    "chunk": "ector hierarchies. Using the providers array Now, in the ChildComponent class, add a provider for FlowerService to demonstrate more complex resolution rules in the upcoming sections: src/app/child.component.ts @Component({ selector: 'app-child', templateUrl: './child.component.html', styleUrls: ['./child.component.css'], // use the providers array to provide a service providers: [{ provide: FlowerService, useValue: { emoji: '🌻' } }]})export class ChildComponent { // inject the service flower = ",
    "id": "hierarchical-injectors-*-angular-52"
  },
  {
    "url": "https://angular.dev/guide/di/hierarchical-dependency-injection",
    "title": "Hierarchical injectors • Angular",
    "chunk": "inject(FlowerService);} Now that the FlowerService is provided in the @Component() decorator, when the <app-child> requests the service, the injector has only to look as far as the ElementInjector in the <app-child>. It won't have to continue the search any further through the injector tree. The next step is to add a binding to the ChildComponent template. src/app/child.component.html <p>Emoji from FlowerService: {{flower.emoji}}</p> To render the new values, add <app-child> to the bottom of the",
    "id": "hierarchical-injectors-*-angular-53"
  },
  {
    "url": "https://angular.dev/guide/di/hierarchical-dependency-injection",
    "title": "Hierarchical injectors • Angular",
    "chunk": " AppComponent template so the view also displays the sunflower: Child ComponentEmoji from FlowerService: 🌻 In the logical tree, this is represented as follows: <app-root @ApplicationConfig @Inject(FlowerService) flower=>\"🌺\"> <#VIEW> <p>Emoji from FlowerService: {{flower.emoji}} (🌺)</p> <app-child @Provide(FlowerService=\"🌻\") @Inject(FlowerService)=>\"🌻\"> <!-- search ends here --> <#VIEW> <!-- search starts here --> <h2>Child Component</h2> <p>Emoji from FlowerService: {{flower.emoji}} (🌻)</p",
    "id": "hierarchical-injectors-*-angular-54"
  },
  {
    "url": "https://angular.dev/guide/di/hierarchical-dependency-injection",
    "title": "Hierarchical injectors • Angular",
    "chunk": "> </#VIEW> </app-child> </#VIEW></app-root> When <app-child> requests the FlowerService, the injector begins its search at the <#VIEW> belonging to <app-child> (<#VIEW> is included because it is injected from @Component()) and ends with <app-child>. In this case, the FlowerService is resolved in the providers array with sunflower 🌻 of the <app-child>. The injector doesn't have to look any further in the injector tree. It stops as soon as it finds the FlowerService and never sees the red hibiscu",
    "id": "hierarchical-injectors-*-angular-55"
  },
  {
    "url": "https://angular.dev/guide/di/hierarchical-dependency-injection",
    "title": "Hierarchical injectors • Angular",
    "chunk": "s 🌺. Using the viewProviders array Use the viewProviders array as another way to provide services in the @Component() decorator. Using viewProviders makes services visible in the <#VIEW>. HELPFUL: The steps are the same as using the providers array, with the exception of using the viewProviders array instead. For step-by-step instructions, continue with this section. If you can set it up on your own, skip ahead to Modifying service availability. For demonstration, we are building an AnimalServi",
    "id": "hierarchical-injectors-*-angular-56"
  },
  {
    "url": "https://angular.dev/guide/di/hierarchical-dependency-injection",
    "title": "Hierarchical injectors • Angular",
    "chunk": "ce to demonstrate viewProviders. First, create an AnimalService with an emoji property of whale 🐳: src/app/animal.service.ts import { Injectable } from '@angular/core';@Injectable({ providedIn: 'root'})export class AnimalService { emoji = '🐳';} Following the same pattern as with the FlowerService, inject the AnimalService in the AppComponent class: src/app/app.component.ts export class AppComponent { public flower = inject(FlowerService); public animal = inject(AnimalService);} HELPFUL: You ca",
    "id": "hierarchical-injectors-*-angular-57"
  },
  {
    "url": "https://angular.dev/guide/di/hierarchical-dependency-injection",
    "title": "Hierarchical injectors • Angular",
    "chunk": "n leave all the FlowerService related code in place as it will allow a comparison with the AnimalService. Add a viewProviders array and inject the AnimalService in the <app-child> class, too, but give emoji a different value. Here, it has a value of dog 🐶. src/app/child.component.ts @Component({ selector: 'app-child', templateUrl: './child.component.html', styleUrls: ['./child.component.css'], // provide services providers: [{ provide: FlowerService, useValue: { emoji: '🌻' } }], viewProviders:",
    "id": "hierarchical-injectors-*-angular-58"
  },
  {
    "url": "https://angular.dev/guide/di/hierarchical-dependency-injection",
    "title": "Hierarchical injectors • Angular",
    "chunk": " [{ provide: AnimalService, useValue: { emoji: '🐶' } }]})export class ChildComponent { // inject services flower = inject(FlowerService); animal = inject(AnimalService)...} Add bindings to the ChildComponent and the AppComponent templates. In the ChildComponent template, add the following binding: src/app/child.component.html <p>Emoji from AnimalService: {{animal.emoji}}</p> Additionally, add the same to the AppComponent template: src/app/app.component.html <p>Emoji from AnimalService: {{animal",
    "id": "hierarchical-injectors-*-angular-59"
  },
  {
    "url": "https://angular.dev/guide/di/hierarchical-dependency-injection",
    "title": "Hierarchical injectors • Angular",
    "chunk": ".emoji}}</p>s Now you should see both values in the browser: AppComponentEmoji from AnimalService: 🐳Child ComponentEmoji from AnimalService: 🐶 The logic tree for this example of viewProviders is as follows: <app-root @ApplicationConfig @Inject(AnimalService) animal=>\"🐳\"> <#VIEW> <app-child> <#VIEW @Provide(AnimalService=\"🐶\") @Inject(AnimalService=>\"🐶\")> <!-- ^^using viewProviders means AnimalService is available in <#VIEW>--> <p>Emoji from AnimalService: {{animal.emoji}} (🐶)</p> </#VIEW> <",
    "id": "hierarchical-injectors-*-angular-60"
  },
  {
    "url": "https://angular.dev/guide/di/hierarchical-dependency-injection",
    "title": "Hierarchical injectors • Angular",
    "chunk": "/app-child> </#VIEW></app-root> Just as with the FlowerService example, the AnimalService is provided in the <app-child> @Component() decorator. This means that since the injector first looks in the ElementInjector of the component, it finds the AnimalService value of dog 🐶. It doesn't need to continue searching the ElementInjector tree, nor does it need to search the ModuleInjector. providers vs. viewProviders The viewProviders field is conceptually similar to providers, but there is one notab",
    "id": "hierarchical-injectors-*-angular-61"
  },
  {
    "url": "https://angular.dev/guide/di/hierarchical-dependency-injection",
    "title": "Hierarchical injectors • Angular",
    "chunk": "le difference. Configured providers in viewProviders are not visible to projected content that ends up as a logical children of the component. To see the difference between using providers and viewProviders, add another component to the example and call it InspectorComponent. InspectorComponent will be a child of the ChildComponent. In inspector.component.ts, inject the FlowerService and AnimalService during property initialization: src/app/inspector/inspector.component.ts export class Inspector",
    "id": "hierarchical-injectors-*-angular-62"
  },
  {
    "url": "https://angular.dev/guide/di/hierarchical-dependency-injection",
    "title": "Hierarchical injectors • Angular",
    "chunk": "Component { flower = inject(FlowerService); animal = inject(AnimalService);} You do not need a providers or viewProviders array. Next, in inspector.component.html, add the same markup from previous components: src/app/inspector/inspector.component.html <p>Emoji from FlowerService: {{flower.emoji}}</p><p>Emoji from AnimalService: {{animal.emoji}}</p> Remember to add the InspectorComponent to the ChildComponent imports array. src/app/child/child.component.ts @Component({ ... imports: [InspectorCom",
    "id": "hierarchical-injectors-*-angular-63"
  },
  {
    "url": "https://angular.dev/guide/di/hierarchical-dependency-injection",
    "title": "Hierarchical injectors • Angular",
    "chunk": "ponent]}) Next, add the following to child.component.html: src/app/child/child.component.html ...<div class=\"container\"> <h3>Content projection</h3> <ng-content></ng-content></div><h3>Inside the view</h3><app-inspector></app-inspector> <ng-content> allows you to project content, and <app-inspector> inside the ChildComponent template makes the InspectorComponent a child component of ChildComponent. Next, add the following to app.component.html to take advantage of content projection. src/app/app.",
    "id": "hierarchical-injectors-*-angular-64"
  },
  {
    "url": "https://angular.dev/guide/di/hierarchical-dependency-injection",
    "title": "Hierarchical injectors • Angular",
    "chunk": "component.html <app-child> <app-inspector></app-inspector></app-child> The browser now renders the following, omitting the previous examples for brevity: ...Content projectionEmoji from FlowerService: 🌻Emoji from AnimalService: 🐳Emoji from FlowerService: 🌻Emoji from AnimalService: 🐶 These four bindings demonstrate the difference between providers and viewProviders. Remember that the dog emoji 🐶 is declared inside the <#VIEW> of ChildComponent and isn't visible to the projected content. Inst",
    "id": "hierarchical-injectors-*-angular-65"
  },
  {
    "url": "https://angular.dev/guide/di/hierarchical-dependency-injection",
    "title": "Hierarchical injectors • Angular",
    "chunk": "ead, the projected content sees the whale 🐳. However, in the next output section though, the InspectorComponent is an actual child component of ChildComponent, InspectorComponent is inside the <#VIEW>, so when it asks for the AnimalService, it sees the dog 🐶. The AnimalService in the logical tree would look like this: <app-root @ApplicationConfig @Inject(AnimalService) animal=>\"🐳\"> <#VIEW> <app-child> <#VIEW @Provide(AnimalService=\"🐶\") @Inject(AnimalService=>\"🐶\")> <!-- ^^using viewProviders",
    "id": "hierarchical-injectors-*-angular-66"
  },
  {
    "url": "https://angular.dev/guide/di/hierarchical-dependency-injection",
    "title": "Hierarchical injectors • Angular",
    "chunk": " means AnimalService is available in <#VIEW>--> <p>Emoji from AnimalService: {{animal.emoji}} (🐶)</p> <div class=\"container\"> <h3>Content projection</h3> <app-inspector @Inject(AnimalService) animal=>\"🐳\"> <p>Emoji from AnimalService: {{animal.emoji}} (🐳)</p> </app-inspector> </div> <app-inspector> <#VIEW @Inject(AnimalService) animal=>\"🐶\"> <p>Emoji from AnimalService: {{animal.emoji}} (🐶)</p> </#VIEW> </app-inspector> </#VIEW> </app-child> </#VIEW></app-root> The projected content of <app-i",
    "id": "hierarchical-injectors-*-angular-67"
  },
  {
    "url": "https://angular.dev/guide/di/hierarchical-dependency-injection",
    "title": "Hierarchical injectors • Angular",
    "chunk": "nspector> sees the whale 🐳, not the dog 🐶, because the dog 🐶 is inside the <app-child> <#VIEW>. The <app-inspector> can only see the dog 🐶 if it is also within the <#VIEW>. Visibility of provided tokens Visibility decorators influence where the search for the injection token begins and ends in the logic tree. To do this, place visibility configuration at the point of injection, that is, when invoking inject(), rather than at a point of declaration. To alter where the injector starts looking ",
    "id": "hierarchical-injectors-*-angular-68"
  },
  {
    "url": "https://angular.dev/guide/di/hierarchical-dependency-injection",
    "title": "Hierarchical injectors • Angular",
    "chunk": "for FlowerService, add skipSelf to the <app-child> inject() invocation where FlowerService is injected. This invocation is a property initializer the <app-child> as shown in child.component.ts: flower = inject(FlowerService, { skipSelf: true }) With skipSelf, the <app-child> injector doesn't look to itself for the FlowerService. Instead, the injector starts looking for the FlowerService at the ElementInjector of the <app-root>, where it finds nothing. Then, it goes back to the <app-child> Module",
    "id": "hierarchical-injectors-*-angular-69"
  },
  {
    "url": "https://angular.dev/guide/di/hierarchical-dependency-injection",
    "title": "Hierarchical injectors • Angular",
    "chunk": "Injector and finds the red hibiscus 🌺 value, which is available because <app-child> and <app-root> share the same ModuleInjector. The UI renders the following: Emoji from FlowerService: 🌺 In a logical tree, this same idea might look like this: <app-root @ApplicationConfig @Inject(FlowerService) flower=>\"🌺\"> <#VIEW> <app-child @Provide(FlowerService=\"🌻\")> <#VIEW @Inject(FlowerService, SkipSelf)=>\"🌺\"> <!-- With SkipSelf, the injector looks to the next injector up the tree (app-root) --> </#VI",
    "id": "hierarchical-injectors-*-angular-70"
  },
  {
    "url": "https://angular.dev/guide/di/hierarchical-dependency-injection",
    "title": "Hierarchical injectors • Angular",
    "chunk": "EW> </app-child> </#VIEW></app-root> Though <app-child> provides the sunflower 🌻, the application renders the red hibiscus 🌺 because skipSelf causes the current injector (app-child) to skip itself and look to its parent. If you now add host (in addition to the skipSelf), the result will be null. This is because host limits the upper bound of the search to the app-child <#VIEW>. Here's the idea in the logical tree: <app-root @ApplicationConfig @Inject(FlowerService) flower=>\"🌺\"> <#VIEW> <!-- e",
    "id": "hierarchical-injectors-*-angular-71"
  },
  {
    "url": "https://angular.dev/guide/di/hierarchical-dependency-injection",
    "title": "Hierarchical injectors • Angular",
    "chunk": "nd search here with null--> <app-child @Provide(FlowerService=\"🌻\")> <!-- start search here --> <#VIEW inject(FlowerService, {skipSelf: true, host: true, optional:true})=>null> </#VIEW> </app-parent> </#VIEW></app-root> Here, the services and their values are the same, but host stops the injector from looking any further than the <#VIEW> for FlowerService, so it doesn't find it and returns null. skipSelf and viewProviders Remember, <app-child> provides the AnimalService in the viewProviders arra",
    "id": "hierarchical-injectors-*-angular-72"
  },
  {
    "url": "https://angular.dev/guide/di/hierarchical-dependency-injection",
    "title": "Hierarchical injectors • Angular",
    "chunk": "y with the value of dog 🐶. Because the injector has only to look at the ElementInjector of the <app-child> for the AnimalService, it never sees the whale 🐳. As in the FlowerService example, if you add skipSelf to the inject() of AnimalService, the injector won't look in the ElementInjector of the current <app-child> for the AnimalService. Instead, the injector will begin at the <app-root> ElementInjector. @Component({ selector: 'app-child', … viewProviders: [ { provide: AnimalService, useValue",
    "id": "hierarchical-injectors-*-angular-73"
  },
  {
    "url": "https://angular.dev/guide/di/hierarchical-dependency-injection",
    "title": "Hierarchical injectors • Angular",
    "chunk": ": { emoji: '🐶' } }, ],}) The logical tree looks like this with skipSelf in <app-child>: <app-root @ApplicationConfig @Inject(AnimalService=>\"🐳\")> <#VIEW><!-- search begins here --> <app-child> <#VIEW @Provide(AnimalService=\"🐶\") @Inject(AnimalService, SkipSelf=>\"🐳\")> <!--Add skipSelf --> </#VIEW> </app-child> </#VIEW></app-root> With skipSelf in the <app-child>, the injector begins its search for the AnimalService in the <app-root> ElementInjector and finds whale 🐳. host and viewProviders If",
    "id": "hierarchical-injectors-*-angular-74"
  },
  {
    "url": "https://angular.dev/guide/di/hierarchical-dependency-injection",
    "title": "Hierarchical injectors • Angular",
    "chunk": " you just use host for the injection of AnimalService, the result is dog 🐶 because the injector finds the AnimalService in the <app-child> <#VIEW> itself. The ChildComponent configures the viewProviders so that the dog emoji is provided as AnimalService value. You can also see host the inject(): @Component({ selector: 'app-child', … viewProviders: [ { provide: AnimalService, useValue: { emoji: '🐶' } }, ]})export class ChildComponent { animal = inject(AnimalService, { host: true })} host: true ",
    "id": "hierarchical-injectors-*-angular-75"
  },
  {
    "url": "https://angular.dev/guide/di/hierarchical-dependency-injection",
    "title": "Hierarchical injectors • Angular",
    "chunk": "causes the injector to look until it encounters the edge of the <#VIEW>. <app-root @ApplicationConfig @Inject(AnimalService=>\"🐳\")> <#VIEW> <app-child> <#VIEW @Provide(AnimalService=\"🐶\") inject(AnimalService, {host: true}=>\"🐶\")> <!-- host stops search here --> </#VIEW> </app-child> </#VIEW></app-root> Add a viewProviders array with a third animal, hedgehog 🦔, to the app.component.ts @Component() metadata: @Component({ selector: 'app-root', templateUrl: './app.component.html', styleUrls: [ './",
    "id": "hierarchical-injectors-*-angular-76"
  },
  {
    "url": "https://angular.dev/guide/di/hierarchical-dependency-injection",
    "title": "Hierarchical injectors • Angular",
    "chunk": "app.component.css' ], viewProviders: [ { provide: AnimalService, useValue: { emoji: '🦔' } }, ],}) Next, add skipSelf along with host to the inject() for the AnimalService injection in child.component.ts. Here are host and skipSelf in the animal property initialization: export class ChildComponent { animal = inject(AnimalService, { host: true, skipSelf: true });} When host and skipSelf were applied to the FlowerService, which is in the providers array, the result was null because skipSelf starts",
    "id": "hierarchical-injectors-*-angular-77"
  },
  {
    "url": "https://angular.dev/guide/di/hierarchical-dependency-injection",
    "title": "Hierarchical injectors • Angular",
    "chunk": " its search in the <app-child> injector, but host stops searching at <#VIEW> —where there is no FlowerService In the logical tree, you can see that the FlowerService is visible in <app-child>, not its <#VIEW>. However, the AnimalService, which is provided in the AppComponent viewProviders array, is visible. The logical tree representation shows why this is: <app-root @ApplicationConfig @Inject(AnimalService=>\"🐳\")> <#VIEW @Provide(AnimalService=\"🦔\") @Inject(AnimalService, @Optional)=>\"🦔\"> <!--",
    "id": "hierarchical-injectors-*-angular-78"
  },
  {
    "url": "https://angular.dev/guide/di/hierarchical-dependency-injection",
    "title": "Hierarchical injectors • Angular",
    "chunk": " ^^skipSelf starts here, host stops here^^ --> <app-child> <#VIEW @Provide(AnimalService=\"🐶\") inject(AnimalService, {skipSelf:true, host: true, optional: true})=>\"🦔\"> <!-- Add skipSelf ^^--> </#VIEW> </app-child> </#VIEW></app-root> skipSelf, causes the injector to start its search for the AnimalService at the <app-root>, not the <app-child>, where the request originates, and host stops the search at the <app-root> <#VIEW>. Since AnimalService is provided by way of the viewProviders array, the",
    "id": "hierarchical-injectors-*-angular-79"
  },
  {
    "url": "https://angular.dev/guide/di/hierarchical-dependency-injection",
    "title": "Hierarchical injectors • Angular",
    "chunk": " injector finds hedgehog 🦔 in the <#VIEW>. Example: ElementInjector use cases The ability to configure one or more providers at different levels opens up useful possibilities. Scenario: service isolation Architectural reasons may lead you to restrict access to a service to the application domain where it belongs. For example, consider we build a VillainsListComponent that displays a list of villains. It gets those villains from a VillainsService. If you provide VillainsService in the root AppMo",
    "id": "hierarchical-injectors-*-angular-80"
  },
  {
    "url": "https://angular.dev/guide/di/hierarchical-dependency-injection",
    "title": "Hierarchical injectors • Angular",
    "chunk": "dule, it will make VillainsService visible everywhere in the application. If you later modify the VillainsService, you could break something in other components that started depending this service by accident. Instead, you should provide the VillainsService in the providers metadata of the VillainsListComponent like this: src/app/villains-list.component.ts (metadata) @Component({ selector: 'app-villains-list', templateUrl: './villains-list.component.html', providers: [VillainsService]})export cl",
    "id": "hierarchical-injectors-*-angular-81"
  },
  {
    "url": "https://angular.dev/guide/di/hierarchical-dependency-injection",
    "title": "Hierarchical injectors • Angular",
    "chunk": "ass VillainsListComponent {} By providing VillainsService in the VillainsListComponent metadata and nowhere else, the service becomes available only in the VillainsListComponent and its subcomponent tree. VillainService is a singleton with respect to VillainsListComponent because that is where it is declared. As long as VillainsListComponent does not get destroyed it will be the same instance of VillainService but if there are multiple instances of VillainsListComponent, then each instance of Vi",
    "id": "hierarchical-injectors-*-angular-82"
  },
  {
    "url": "https://angular.dev/guide/di/hierarchical-dependency-injection",
    "title": "Hierarchical injectors • Angular",
    "chunk": "llainsListComponent will have its own instance of VillainService. Scenario: multiple edit sessions Many applications allow users to work on several open tasks at the same time. For example, in a tax preparation application, the preparer could be working on several tax returns, switching from one to the other throughout the day. To demonstrate that scenario, imagine a HeroListComponent that displays a list of super heroes. To open a hero's tax return, the preparer clicks on a hero name, which ope",
    "id": "hierarchical-injectors-*-angular-83"
  },
  {
    "url": "https://angular.dev/guide/di/hierarchical-dependency-injection",
    "title": "Hierarchical injectors • Angular",
    "chunk": "ns a component for editing that return. Each selected hero tax return opens in its own component and multiple returns can be open at the same time. Each tax return component has the following characteristics: Is its own tax return editing session Can change a tax return without affecting a return in another component Has the ability to save the changes to its tax return or cancel them Suppose that the HeroTaxReturnComponent had logic to manage and restore changes. That would be a straightforward",
    "id": "hierarchical-injectors-*-angular-84"
  },
  {
    "url": "https://angular.dev/guide/di/hierarchical-dependency-injection",
    "title": "Hierarchical injectors • Angular",
    "chunk": " task for a hero tax return. In the real world, with a rich tax return data model, the change management would be tricky. You could delegate that management to a helper service, as this example does. The HeroTaxReturnService caches a single HeroTaxReturn, tracks changes to that return, and can save or restore it. It also delegates to the application-wide singleton HeroService, which it gets by injection. src/app/hero-tax-return.service.ts import { Injectable } from '@angular/core';import { HeroT",
    "id": "hierarchical-injectors-*-angular-85"
  },
  {
    "url": "https://angular.dev/guide/di/hierarchical-dependency-injection",
    "title": "Hierarchical injectors • Angular",
    "chunk": "axReturn } from './hero';import { HeroesService } from './heroes.service';@Injectable()export class HeroTaxReturnService { private currentTaxReturn!: HeroTaxReturn; private originalTaxReturn!: HeroTaxReturn; private heroService = inject(HeroesService); set taxReturn(htr: HeroTaxReturn) { this.originalTaxReturn = htr; this.currentTaxReturn = htr.clone(); } get taxReturn(): HeroTaxReturn { return this.currentTaxReturn; } restoreTaxReturn() { this.taxReturn = this.originalTaxReturn; } saveTaxReturn",
    "id": "hierarchical-injectors-*-angular-86"
  },
  {
    "url": "https://angular.dev/guide/di/hierarchical-dependency-injection",
    "title": "Hierarchical injectors • Angular",
    "chunk": "() { this.taxReturn = this.currentTaxReturn; this.heroService.saveTaxReturn(this.currentTaxReturn).subscribe(); }} Here is the HeroTaxReturnComponent that makes use of HeroTaxReturnService. src/app/hero-tax-return.component.ts import { Component, EventEmitter, input, output } from '@angular/core';import { HeroTaxReturn } from './hero';import { HeroTaxReturnService } from './hero-tax-return.service';@Component({ selector: 'app-hero-tax-return', templateUrl: './hero-tax-return.component.html', sty",
    "id": "hierarchical-injectors-*-angular-87"
  },
  {
    "url": "https://angular.dev/guide/di/hierarchical-dependency-injection",
    "title": "Hierarchical injectors • Angular",
    "chunk": "leUrls: [ './hero-tax-return.component.css' ], providers: [ HeroTaxReturnService ]})export class HeroTaxReturnComponent { message = ''; close = output<void>(); get taxReturn(): HeroTaxReturn { return this.heroTaxReturnService.taxReturn; } taxReturn = input.required<HeroTaxReturn>(); constructor() { effect(() => { this.heroTaxReturnService.taxReturn = this.taxReturn(); }) } private heroTaxReturnService = inject(HeroTaxReturnService); onCanceled() { this.flashMessage('Canceled'); this.heroTaxRetur",
    "id": "hierarchical-injectors-*-angular-88"
  },
  {
    "url": "https://angular.dev/guide/di/hierarchical-dependency-injection",
    "title": "Hierarchical injectors • Angular",
    "chunk": "nService.restoreTaxReturn(); } onClose() { this.close.emit(); } onSaved() { this.flashMessage('Saved'); this.heroTaxReturnService.saveTaxReturn(); } flashMessage(msg: string) { this.message = msg; setTimeout(() => this.message = '', 500); }} The tax-return-to-edit arrives by way of the input property, which is implemented with getters and setters. The setter initializes the component's own instance of the HeroTaxReturnService with the incoming return. The getter always returns what that service ",
    "id": "hierarchical-injectors-*-angular-89"
  },
  {
    "url": "https://angular.dev/guide/di/hierarchical-dependency-injection",
    "title": "Hierarchical injectors • Angular",
    "chunk": "says is the current state of the hero. The component also asks the service to save and restore this tax return. This won't work if the service is an application-wide singleton. Every component would share the same service instance, and each component would overwrite the tax return that belonged to another hero. To prevent this, configure the component-level injector of HeroTaxReturnComponent to provide the service, using the providers property in the component metadata. src/app/hero-tax-return.c",
    "id": "hierarchical-injectors-*-angular-90"
  },
  {
    "url": "https://angular.dev/guide/di/hierarchical-dependency-injection",
    "title": "Hierarchical injectors • Angular",
    "chunk": "omponent.ts (providers) providers: [HeroTaxReturnService] The HeroTaxReturnComponent has its own provider of the HeroTaxReturnService. Recall that every component instance has its own injector. Providing the service at the component level ensures that every instance of the component gets a private instance of the service. This makes sure that no tax return gets overwritten. HELPFUL: The rest of the scenario code relies on other Angular features and techniques that you can learn about elsewhere i",
    "id": "hierarchical-injectors-*-angular-91"
  },
  {
    "url": "https://angular.dev/guide/di/hierarchical-dependency-injection",
    "title": "Hierarchical injectors • Angular",
    "chunk": "n the documentation. Scenario: specialized providers Another reason to provide a service again at another level is to substitute a more specialized implementation of that service, deeper in the component tree. For example, consider a Car component that includes tire service information and depends on other services to provide more details about the car. The root injector, marked as (A), uses generic providers for details about CarService and EngineService. Car component (A). Component (A) displa",
    "id": "hierarchical-injectors-*-angular-92"
  },
  {
    "url": "https://angular.dev/guide/di/hierarchical-dependency-injection",
    "title": "Hierarchical injectors • Angular",
    "chunk": "ys tire service data about a car and specifies generic services to provide more information about the car. Child component (B). Component (B) defines its own, specialized providers for CarService and EngineService that have special capabilities suitable for what's going on in component (B). Child component (C) as a child of Component (B). Component (C) defines its own, even more specialized provider for CarService. #mermaid-generated-diagram{font-family:\"trebuchet ms\",verdana,arial,sans-serif;fo",
    "id": "hierarchical-injectors-*-angular-93"
  },
  {
    "url": "https://angular.dev/guide/di/hierarchical-dependency-injection",
    "title": "Hierarchical injectors • Angular",
    "chunk": "nt-size:16px;fill:#333;}@keyframes edge-animation-frame{from{stroke-dashoffset:0;}}@keyframes dash{to{stroke-dashoffset:0;}}#mermaid-generated-diagram .edge-animation-slow{stroke-dasharray:9,5!important;stroke-dashoffset:900;animation:dash 50s linear infinite;stroke-linecap:round;}#mermaid-generated-diagram .edge-animation-fast{stroke-dasharray:9,5!important;stroke-dashoffset:900;animation:dash 20s linear infinite;stroke-linecap:round;}#mermaid-generated-diagram .error-icon{fill:hsl(220.58823529",
    "id": "hierarchical-injectors-*-angular-94"
  },
  {
    "url": "https://angular.dev/guide/di/hierarchical-dependency-injection",
    "title": "Hierarchical injectors • Angular",
    "chunk": "41, 100%, 98.3333333333%);}#mermaid-generated-diagram .error-text{fill:rgb(8.5000000002, 5.7500000001, 0);stroke:rgb(8.5000000002, 5.7500000001, 0);}#mermaid-generated-diagram .edge-thickness-normal{stroke-width:1px;}#mermaid-generated-diagram .edge-thickness-thick{stroke-width:3.5px;}#mermaid-generated-diagram .edge-pattern-solid{stroke-dasharray:0;}#mermaid-generated-diagram .edge-thickness-invisible{stroke-width:0;fill:none;}#mermaid-generated-diagram .edge-pattern-dashed{stroke-dasharray:3;}",
    "id": "hierarchical-injectors-*-angular-95"
  },
  {
    "url": "https://angular.dev/guide/di/hierarchical-dependency-injection",
    "title": "Hierarchical injectors • Angular",
    "chunk": "#mermaid-generated-diagram .edge-pattern-dotted{stroke-dasharray:2;}#mermaid-generated-diagram .marker{fill:#0b0b0b;stroke:#0b0b0b;}#mermaid-generated-diagram .marker.cross{stroke:#0b0b0b;}#mermaid-generated-diagram svg{font-family:\"trebuchet ms\",verdana,arial,sans-serif;font-size:16px;}#mermaid-generated-diagram p{margin:0;}#mermaid-generated-diagram .label{font-family:\"trebuchet ms\",verdana,arial,sans-serif;color:#333;}#mermaid-generated-diagram .cluster-label text{fill:rgb(8.5000000002, 5.750",
    "id": "hierarchical-injectors-*-angular-96"
  },
  {
    "url": "https://angular.dev/guide/di/hierarchical-dependency-injection",
    "title": "Hierarchical injectors • Angular",
    "chunk": "0000001, 0);}#mermaid-generated-diagram .cluster-label span{color:rgb(8.5000000002, 5.7500000001, 0);}#mermaid-generated-diagram .cluster-label span p{background-color:transparent;}#mermaid-generated-diagram .label text,#mermaid-generated-diagram span{fill:#333;color:#333;}#mermaid-generated-diagram .node rect,#mermaid-generated-diagram .node circle,#mermaid-generated-diagram .node ellipse,#mermaid-generated-diagram .node polygon,#mermaid-generated-diagram .node path{fill:#fff4dd;stroke:hsl(40.5",
    "id": "hierarchical-injectors-*-angular-97"
  },
  {
    "url": "https://angular.dev/guide/di/hierarchical-dependency-injection",
    "title": "Hierarchical injectors • Angular",
    "chunk": "882352941, 60%, 83.3333333333%);stroke-width:1px;}#mermaid-generated-diagram .rough-node .label text,#mermaid-generated-diagram .node .label text,#mermaid-generated-diagram .image-shape .label,#mermaid-generated-diagram .icon-shape .label{text-anchor:middle;}#mermaid-generated-diagram .node .katex path{fill:#000;stroke:#000;stroke-width:1px;}#mermaid-generated-diagram .rough-node .label,#mermaid-generated-diagram .node .label,#mermaid-generated-diagram .image-shape .label,#mermaid-generated-diag",
    "id": "hierarchical-injectors-*-angular-98"
  },
  {
    "url": "https://angular.dev/guide/di/hierarchical-dependency-injection",
    "title": "Hierarchical injectors • Angular",
    "chunk": "ram .icon-shape .label{text-align:center;}#mermaid-generated-diagram .node.clickable{cursor:pointer;}#mermaid-generated-diagram .root .anchor path{fill:#0b0b0b!important;stroke-width:0;stroke:#0b0b0b;}#mermaid-generated-diagram .arrowheadPath{fill:#0b0b0b;}#mermaid-generated-diagram .edgePath .path{stroke:#0b0b0b;stroke-width:2.0px;}#mermaid-generated-diagram .flowchart-link{stroke:#0b0b0b;fill:none;}#mermaid-generated-diagram .edgeLabel{background-color:hsl(-79.4117647059, 100%, 93.3333333333%)",
    "id": "hierarchical-injectors-*-angular-99"
  },
  {
    "url": "https://angular.dev/guide/di/hierarchical-dependency-injection",
    "title": "Hierarchical injectors • Angular",
    "chunk": ";text-align:center;}#mermaid-generated-diagram .edgeLabel p{background-color:hsl(-79.4117647059, 100%, 93.3333333333%);}#mermaid-generated-diagram .edgeLabel rect{opacity:0.5;background-color:hsl(-79.4117647059, 100%, 93.3333333333%);fill:hsl(-79.4117647059, 100%, 93.3333333333%);}#mermaid-generated-diagram .labelBkg{background-color:rgba(243.9999999999, 220.9999999998, 255, 0.5);}#mermaid-generated-diagram .cluster rect{fill:hsl(220.5882352941, 100%, 98.3333333333%);stroke:hsl(220.5882352941, 6",
    "id": "hierarchical-injectors-*-angular-100"
  },
  {
    "url": "https://angular.dev/guide/di/hierarchical-dependency-injection",
    "title": "Hierarchical injectors • Angular",
    "chunk": "0%, 88.3333333333%);stroke-width:1px;}#mermaid-generated-diagram .cluster text{fill:rgb(8.5000000002, 5.7500000001, 0);}#mermaid-generated-diagram .cluster span{color:rgb(8.5000000002, 5.7500000001, 0);}#mermaid-generated-diagram div.mermaidTooltip{position:absolute;text-align:center;max-width:200px;padding:2px;font-family:\"trebuchet ms\",verdana,arial,sans-serif;font-size:12px;background:hsl(220.5882352941, 100%, 98.3333333333%);border:1px solid hsl(220.5882352941, 60%, 88.3333333333%);border-ra",
    "id": "hierarchical-injectors-*-angular-101"
  },
  {
    "url": "https://angular.dev/guide/di/hierarchical-dependency-injection",
    "title": "Hierarchical injectors • Angular",
    "chunk": "dius:2px;pointer-events:none;z-index:100;}#mermaid-generated-diagram .flowchartTitleText{text-anchor:middle;font-size:18px;fill:#333;}#mermaid-generated-diagram rect.text{fill:none;stroke-width:0;}#mermaid-generated-diagram .icon-shape,#mermaid-generated-diagram .image-shape{background-color:hsl(-79.4117647059, 100%, 93.3333333333%);text-align:center;}#mermaid-generated-diagram .icon-shape p,#mermaid-generated-diagram .image-shape p{background-color:hsl(-79.4117647059, 100%, 93.3333333333%);padd",
    "id": "hierarchical-injectors-*-angular-102"
  },
  {
    "url": "https://angular.dev/guide/di/hierarchical-dependency-injection",
    "title": "Hierarchical injectors • Angular",
    "chunk": "ing:2px;}#mermaid-generated-diagram .icon-shape rect,#mermaid-generated-diagram .image-shape rect{opacity:0.5;background-color:hsl(-79.4117647059, 100%, 93.3333333333%);fill:hsl(-79.4117647059, 100%, 93.3333333333%);}#mermaid-generated-diagram :root{--mermaid-font-family:\"trebuchet ms\",verdana,arial,sans-serif;}#mermaid-generated-diagram .noShadow>*{filter:none!important;}#mermaid-generated-diagram .noShadow span{filter:none!important;}Component AComponent BComponent CBehind the scenes, each com",
    "id": "hierarchical-injectors-*-angular-103"
  },
  {
    "url": "https://angular.dev/guide/di/hierarchical-dependency-injection",
    "title": "Hierarchical injectors • Angular",
    "chunk": "ponent sets up its own injector with zero, one, or more providers defined for that component itself. When you resolve an instance of Car at the deepest component (C), its injector produces: An instance of Car resolved by injector (C) An Engine resolved by injector (B) Its Tires resolved by the root injector (A). #mermaid-generated-diagram{font-family:\"trebuchet ms\",verdana,arial,sans-serif;font-size:16px;fill:#333;}@keyframes edge-animation-frame{from{stroke-dashoffset:0;}}@keyframes dash{to{str",
    "id": "hierarchical-injectors-*-angular-104"
  },
  {
    "url": "https://angular.dev/guide/di/hierarchical-dependency-injection",
    "title": "Hierarchical injectors • Angular",
    "chunk": "oke-dashoffset:0;}}#mermaid-generated-diagram .edge-animation-slow{stroke-dasharray:9,5!important;stroke-dashoffset:900;animation:dash 50s linear infinite;stroke-linecap:round;}#mermaid-generated-diagram .edge-animation-fast{stroke-dasharray:9,5!important;stroke-dashoffset:900;animation:dash 20s linear infinite;stroke-linecap:round;}#mermaid-generated-diagram .error-icon{fill:hsl(220.5882352941, 100%, 98.3333333333%);}#mermaid-generated-diagram .error-text{fill:rgb(8.5000000002, 5.7500000001, 0)",
    "id": "hierarchical-injectors-*-angular-105"
  },
  {
    "url": "https://angular.dev/guide/di/hierarchical-dependency-injection",
    "title": "Hierarchical injectors • Angular",
    "chunk": ";stroke:rgb(8.5000000002, 5.7500000001, 0);}#mermaid-generated-diagram .edge-thickness-normal{stroke-width:1px;}#mermaid-generated-diagram .edge-thickness-thick{stroke-width:3.5px;}#mermaid-generated-diagram .edge-pattern-solid{stroke-dasharray:0;}#mermaid-generated-diagram .edge-thickness-invisible{stroke-width:0;fill:none;}#mermaid-generated-diagram .edge-pattern-dashed{stroke-dasharray:3;}#mermaid-generated-diagram .edge-pattern-dotted{stroke-dasharray:2;}#mermaid-generated-diagram .marker{fi",
    "id": "hierarchical-injectors-*-angular-106"
  },
  {
    "url": "https://angular.dev/guide/di/hierarchical-dependency-injection",
    "title": "Hierarchical injectors • Angular",
    "chunk": "ll:#0b0b0b;stroke:#0b0b0b;}#mermaid-generated-diagram .marker.cross{stroke:#0b0b0b;}#mermaid-generated-diagram svg{font-family:\"trebuchet ms\",verdana,arial,sans-serif;font-size:16px;}#mermaid-generated-diagram p{margin:0;}#mermaid-generated-diagram .label{font-family:\"trebuchet ms\",verdana,arial,sans-serif;color:#333;}#mermaid-generated-diagram .cluster-label text{fill:rgb(8.5000000002, 5.7500000001, 0);}#mermaid-generated-diagram .cluster-label span{color:rgb(8.5000000002, 5.7500000001, 0);}#me",
    "id": "hierarchical-injectors-*-angular-107"
  },
  {
    "url": "https://angular.dev/guide/di/hierarchical-dependency-injection",
    "title": "Hierarchical injectors • Angular",
    "chunk": "rmaid-generated-diagram .cluster-label span p{background-color:transparent;}#mermaid-generated-diagram .label text,#mermaid-generated-diagram span{fill:#333;color:#333;}#mermaid-generated-diagram .node rect,#mermaid-generated-diagram .node circle,#mermaid-generated-diagram .node ellipse,#mermaid-generated-diagram .node polygon,#mermaid-generated-diagram .node path{fill:#fff4dd;stroke:hsl(40.5882352941, 60%, 83.3333333333%);stroke-width:1px;}#mermaid-generated-diagram .rough-node .label text,#mer",
    "id": "hierarchical-injectors-*-angular-108"
  },
  {
    "url": "https://angular.dev/guide/di/hierarchical-dependency-injection",
    "title": "Hierarchical injectors • Angular",
    "chunk": "maid-generated-diagram .node .label text,#mermaid-generated-diagram .image-shape .label,#mermaid-generated-diagram .icon-shape .label{text-anchor:middle;}#mermaid-generated-diagram .node .katex path{fill:#000;stroke:#000;stroke-width:1px;}#mermaid-generated-diagram .rough-node .label,#mermaid-generated-diagram .node .label,#mermaid-generated-diagram .image-shape .label,#mermaid-generated-diagram .icon-shape .label{text-align:center;}#mermaid-generated-diagram .node.clickable{cursor:pointer;}#mer",
    "id": "hierarchical-injectors-*-angular-109"
  },
  {
    "url": "https://angular.dev/guide/di/hierarchical-dependency-injection",
    "title": "Hierarchical injectors • Angular",
    "chunk": "maid-generated-diagram .root .anchor path{fill:#0b0b0b!important;stroke-width:0;stroke:#0b0b0b;}#mermaid-generated-diagram .arrowheadPath{fill:#0b0b0b;}#mermaid-generated-diagram .edgePath .path{stroke:#0b0b0b;stroke-width:2.0px;}#mermaid-generated-diagram .flowchart-link{stroke:#0b0b0b;fill:none;}#mermaid-generated-diagram .edgeLabel{background-color:hsl(-79.4117647059, 100%, 93.3333333333%);text-align:center;}#mermaid-generated-diagram .edgeLabel p{background-color:hsl(-79.4117647059, 100%, 93",
    "id": "hierarchical-injectors-*-angular-110"
  },
  {
    "url": "https://angular.dev/guide/di/hierarchical-dependency-injection",
    "title": "Hierarchical injectors • Angular",
    "chunk": ".3333333333%);}#mermaid-generated-diagram .edgeLabel rect{opacity:0.5;background-color:hsl(-79.4117647059, 100%, 93.3333333333%);fill:hsl(-79.4117647059, 100%, 93.3333333333%);}#mermaid-generated-diagram .labelBkg{background-color:rgba(243.9999999999, 220.9999999998, 255, 0.5);}#mermaid-generated-diagram .cluster rect{fill:hsl(220.5882352941, 100%, 98.3333333333%);stroke:hsl(220.5882352941, 60%, 88.3333333333%);stroke-width:1px;}#mermaid-generated-diagram .cluster text{fill:rgb(8.5000000002, 5.7",
    "id": "hierarchical-injectors-*-angular-111"
  },
  {
    "url": "https://angular.dev/guide/di/hierarchical-dependency-injection",
    "title": "Hierarchical injectors • Angular",
    "chunk": "500000001, 0);}#mermaid-generated-diagram .cluster span{color:rgb(8.5000000002, 5.7500000001, 0);}#mermaid-generated-diagram div.mermaidTooltip{position:absolute;text-align:center;max-width:200px;padding:2px;font-family:\"trebuchet ms\",verdana,arial,sans-serif;font-size:12px;background:hsl(220.5882352941, 100%, 98.3333333333%);border:1px solid hsl(220.5882352941, 60%, 88.3333333333%);border-radius:2px;pointer-events:none;z-index:100;}#mermaid-generated-diagram .flowchartTitleText{text-anchor:midd",
    "id": "hierarchical-injectors-*-angular-112"
  },
  {
    "url": "https://angular.dev/guide/di/hierarchical-dependency-injection",
    "title": "Hierarchical injectors • Angular",
    "chunk": "le;font-size:18px;fill:#333;}#mermaid-generated-diagram rect.text{fill:none;stroke-width:0;}#mermaid-generated-diagram .icon-shape,#mermaid-generated-diagram .image-shape{background-color:hsl(-79.4117647059, 100%, 93.3333333333%);text-align:center;}#mermaid-generated-diagram .icon-shape p,#mermaid-generated-diagram .image-shape p{background-color:hsl(-79.4117647059, 100%, 93.3333333333%);padding:2px;}#mermaid-generated-diagram .icon-shape rect,#mermaid-generated-diagram .image-shape rect{opacity",
    "id": "hierarchical-injectors-*-angular-113"
  },
  {
    "url": "https://angular.dev/guide/di/hierarchical-dependency-injection",
    "title": "Hierarchical injectors • Angular",
    "chunk": ":0.5;background-color:hsl(-79.4117647059, 100%, 93.3333333333%);fill:hsl(-79.4117647059, 100%, 93.3333333333%);}#mermaid-generated-diagram :root{--mermaid-font-family:\"trebuchet ms\",verdana,arial,sans-serif;}(A) RootInjectorCarService, EngineService, TiresService(B) ParentInjectorCarService2, EngineService2(C) ChildInjectorCarService3(C) Car(B) Engine(A) Tires More on dependency injection DI Providers Social MediaBlogX (formerly Twitter)BlueskyYouTube Discord GitHub Stack Overflow Community Cont",
    "id": "hierarchical-injectors-*-angular-114"
  },
  {
    "url": "https://angular.dev/guide/di/hierarchical-dependency-injection",
    "title": "Hierarchical injectors • Angular",
    "chunk": "ribute Code of Conduct Report Issues Google's DevLibrary Angular Google Developer Experts ResourcesPress KitRoadmapLanguages简体中文版正體中文版日本語版한국어 Ελληνικά Super-powered by Google ©2010-2025. Code licensed under an MIT-style License . Documentation licensed under CC BY 4.0 .",
    "id": "hierarchical-injectors-*-angular-115"
  },
  {
    "url": "https://angular.dev/guide/di/lightweight-injection-tokens",
    "title": "Optimizing injection tokens • Angular",
    "chunk": "In-depth GuidesDependency Injection Optimizing client application size with lightweight injection tokens This page provides a conceptual overview of a dependency injection technique that is recommended for library developers. Designing your library with lightweight injection tokens helps optimize the bundle size of client applications that use your library. You can manage the dependency structure among your components and injectable services to optimize bundle size by using tree-shakable provide",
    "id": "optimizing-injection-tokens-*-angular-0"
  },
  {
    "url": "https://angular.dev/guide/di/lightweight-injection-tokens",
    "title": "Optimizing injection tokens • Angular",
    "chunk": "rs. This normally ensures that if a provided component or service is never actually used by the application, the compiler can remove its code from the bundle. Due to the way Angular stores injection tokens, it is possible that such an unused component or service can end up in the bundle anyway. This page describes a dependency injection design pattern that supports proper tree-shaking by using lightweight injection tokens. The lightweight injection token design pattern is especially important fo",
    "id": "optimizing-injection-tokens-*-angular-1"
  },
  {
    "url": "https://angular.dev/guide/di/lightweight-injection-tokens",
    "title": "Optimizing injection tokens • Angular",
    "chunk": "r library developers. It ensures that when an application uses only some of your library's capabilities, the unused code can be eliminated from the client's application bundle. When an application uses your library, there might be some services that your library supplies which the client application doesn't use. In this case, the application developer should expect that service to be tree-shaken, and not contribute to the size of the compiled application. Because the application developer cannot",
    "id": "optimizing-injection-tokens-*-angular-2"
  },
  {
    "url": "https://angular.dev/guide/di/lightweight-injection-tokens",
    "title": "Optimizing injection tokens • Angular",
    "chunk": " know about or remedy a tree-shaking problem in the library, it is the responsibility of the library developer to do so. To prevent the retention of unused components, your library should use the lightweight injection token design pattern. On this pagearrow_upward_alt Back to the top When tokens are retained To better explain the condition under which token retention occurs, consider a library that provides a library-card component. This component contains a body and can contain an optional head",
    "id": "optimizing-injection-tokens-*-angular-3"
  },
  {
    "url": "https://angular.dev/guide/di/lightweight-injection-tokens",
    "title": "Optimizing injection tokens • Angular",
    "chunk": "er: <lib-card>; <lib-header>…</lib-header>;</lib-card>; In a likely implementation, the <lib-card> component uses @ContentChild() or @ContentChildren() to get <lib-header> and <lib-body>, as in the following: @Component({ selector: 'lib-header', …,})class LibHeaderComponent {}@Component({ selector: 'lib-card', …,})class LibCardComponent { @ContentChild(LibHeaderComponent) header: LibHeaderComponent|null = null;} Because <lib-header> is optional, the element can appear in the template in its mini",
    "id": "optimizing-injection-tokens-*-angular-4"
  },
  {
    "url": "https://angular.dev/guide/di/lightweight-injection-tokens",
    "title": "Optimizing injection tokens • Angular",
    "chunk": "mal form, <lib-card></lib-card>. In this case, <lib-header> is not used and you would expect it to be tree-shaken, but that is not what happens. This is because LibCardComponent actually contains two references to the LibHeaderComponent: @ContentChild(LibHeaderComponent) header: LibHeaderComponent; One of these reference is in the type position-- that is, it specifies LibHeaderComponent as a type: header: LibHeaderComponent;. The other reference is in the value position-- that is, LibHeaderCompo",
    "id": "optimizing-injection-tokens-*-angular-5"
  },
  {
    "url": "https://angular.dev/guide/di/lightweight-injection-tokens",
    "title": "Optimizing injection tokens • Angular",
    "chunk": "nent is the value of the @ContentChild() parameter decorator: @ContentChild(LibHeaderComponent). The compiler handles token references in these positions differently: The compiler erases type position references after conversion from TypeScript, so they have no impact on tree-shaking. The compiler must keep value position references at runtime, which prevents the component from being tree-shaken. In the example, the compiler retains the LibHeaderComponent token that occurs in the value position.",
    "id": "optimizing-injection-tokens-*-angular-6"
  },
  {
    "url": "https://angular.dev/guide/di/lightweight-injection-tokens",
    "title": "Optimizing injection tokens • Angular",
    "chunk": " This prevents the referenced component from being tree-shaken, even if the application does not actually use <lib-header> anywhere. If LibHeaderComponent 's code, template, and styles combine to become too large, including it unnecessarily can significantly increase the size of the client application. When to use the lightweight injection token pattern The tree-shaking problem arises when a component is used as an injection token. There are two cases when that can happen: The token is used in t",
    "id": "optimizing-injection-tokens-*-angular-7"
  },
  {
    "url": "https://angular.dev/guide/di/lightweight-injection-tokens",
    "title": "Optimizing injection tokens • Angular",
    "chunk": "he value position of a content query. The token is used as a type specifier for constructor injection. In the following example, both uses of the OtherComponent token cause retention of OtherComponent, preventing it from being tree-shaken when it is not used: class MyComponent { constructor(@Optional() other: OtherComponent) {} @ContentChild(OtherComponent) other: OtherComponent|null;} Although tokens used only as type specifiers are removed when converted to JavaScript, all tokens used for depe",
    "id": "optimizing-injection-tokens-*-angular-8"
  },
  {
    "url": "https://angular.dev/guide/di/lightweight-injection-tokens",
    "title": "Optimizing injection tokens • Angular",
    "chunk": "ndency injection are needed at runtime. These effectively change constructor(@Optional() other: OtherComponent) to constructor(@Optional() @Inject(OtherComponent) other). The token is now in a value position, which causes the tree-shaker to keep the reference. HELPFUL: Libraries should use tree-shakable providers for all services, providing dependencies at the root level rather than in components or modules. Using lightweight injection tokens The lightweight injection token design pattern consis",
    "id": "optimizing-injection-tokens-*-angular-9"
  },
  {
    "url": "https://angular.dev/guide/di/lightweight-injection-tokens",
    "title": "Optimizing injection tokens • Angular",
    "chunk": "ts of using a small abstract class as an injection token, and providing the actual implementation at a later stage. The abstract class is retained, not tree-shaken, but it is small and has no material impact on the application size. The following example shows how this works for the LibHeaderComponent: abstract class LibHeaderToken {}@Component({ selector: 'lib-header', providers: [ {provide: LibHeaderToken, useExisting: LibHeaderComponent} ] …,})class LibHeaderComponent extends LibHeaderToken {",
    "id": "optimizing-injection-tokens-*-angular-10"
  },
  {
    "url": "https://angular.dev/guide/di/lightweight-injection-tokens",
    "title": "Optimizing injection tokens • Angular",
    "chunk": "}@Component({ selector: 'lib-card', …,})class LibCardComponent { @ContentChild(LibHeaderToken) header: LibHeaderToken|null = null;} In this example, the LibCardComponent implementation no longer refers to LibHeaderComponent in either the type position or the value position. This lets full tree-shaking of LibHeaderComponent take place. The LibHeaderToken is retained, but it is only a class declaration, with no concrete implementation. It is small and does not materially impact the application siz",
    "id": "optimizing-injection-tokens-*-angular-11"
  },
  {
    "url": "https://angular.dev/guide/di/lightweight-injection-tokens",
    "title": "Optimizing injection tokens • Angular",
    "chunk": "e when retained after compilation. Instead, LibHeaderComponent itself implements the abstract LibHeaderToken class. You can safely use that token as the provider in the component definition, allowing Angular to correctly inject the concrete type. To summarize, the lightweight injection token pattern consists of the following: A lightweight injection token that is represented as an abstract class. A component definition that implements the abstract class. Injection of the lightweight pattern, usi",
    "id": "optimizing-injection-tokens-*-angular-12"
  },
  {
    "url": "https://angular.dev/guide/di/lightweight-injection-tokens",
    "title": "Optimizing injection tokens • Angular",
    "chunk": "ng @ContentChild() or @ContentChildren(). A provider in the implementation of the lightweight injection token which associates the lightweight injection token with the implementation. Use the lightweight injection token for API definition A component that injects a lightweight injection token might need to invoke a method in the injected class. The token is now an abstract class. Since the injectable component implements that class, you must also declare an abstract method in the abstract lightw",
    "id": "optimizing-injection-tokens-*-angular-13"
  },
  {
    "url": "https://angular.dev/guide/di/lightweight-injection-tokens",
    "title": "Optimizing injection tokens • Angular",
    "chunk": "eight injection token class. The implementation of the method, with all its code overhead, resides in the injectable component that can be tree-shaken. This lets the parent communicate with the child, if it is present, in a type-safe manner. For example, the LibCardComponent now queries LibHeaderToken rather than LibHeaderComponent. The following example shows how the pattern lets LibCardComponent communicate with the LibHeaderComponent without actually referring to LibHeaderComponent: abstract ",
    "id": "optimizing-injection-tokens-*-angular-14"
  },
  {
    "url": "https://angular.dev/guide/di/lightweight-injection-tokens",
    "title": "Optimizing injection tokens • Angular",
    "chunk": "class LibHeaderToken { abstract doSomething(): void;}@Component({ selector: 'lib-header', providers: [ {provide: LibHeaderToken, useExisting: LibHeaderComponent} ] …,})class LibHeaderComponent extends LibHeaderToken { doSomething(): void { // Concrete implementation of `doSomething` }}@Component({ selector: 'lib-card', …,})class LibCardComponent implement AfterContentInit { @ContentChild(LibHeaderToken) header: LibHeaderToken|null = null; ngAfterContentInit(): void { if (this.header !== null) { ",
    "id": "optimizing-injection-tokens-*-angular-15"
  },
  {
    "url": "https://angular.dev/guide/di/lightweight-injection-tokens",
    "title": "Optimizing injection tokens • Angular",
    "chunk": "this.header?.doSomething(); } }} In this example, the parent queries the token to get the child component, and stores the resulting component reference if it is present. Before calling a method in the child, the parent component checks to see if the child component is present. If the child component has been tree-shaken, there is no runtime reference to it, and no call to its method. Naming your lightweight injection token Lightweight injection tokens are only useful with components. The Angular",
    "id": "optimizing-injection-tokens-*-angular-16"
  },
  {
    "url": "https://angular.dev/guide/di/lightweight-injection-tokens",
    "title": "Optimizing injection tokens • Angular",
    "chunk": " style guide suggests that you name components using the \"Component\" suffix. The example \"LibHeaderComponent\" follows this convention. You should maintain the relationship between the component and its token while still distinguishing between them. The recommended style is to use the component base name with the suffix \"Token\" to name your lightweight injection tokens: \"LibHeaderToken.\" Social MediaBlogX (formerly Twitter)BlueskyYouTube Discord GitHub Stack Overflow Community Contribute Code of ",
    "id": "optimizing-injection-tokens-*-angular-17"
  },
  {
    "url": "https://angular.dev/guide/di/lightweight-injection-tokens",
    "title": "Optimizing injection tokens • Angular",
    "chunk": "Conduct Report Issues Google's DevLibrary Angular Google Developer Experts ResourcesPress KitRoadmapLanguages简体中文版正體中文版日本語版한국어 Ελληνικά Super-powered by Google ©2010-2025. Code licensed under an MIT-style License . Documentation licensed under CC BY 4.0 .",
    "id": "optimizing-injection-tokens-*-angular-18"
  },
  {
    "url": "https://angular.dev/ecosystem/rxjs-interop",
    "title": "Signals interop • Angular",
    "chunk": "Extended EcosystemUsing RxJS with Angular RxJS interop with Angular signals The @angular/rxjs-interop package offers APIs that help you integrate RxJS and Angular signals. On this pagearrow_upward_alt Back to the top Create a signal from an RxJs Observable with toSignal Use the toSignal function to create a signal which tracks the value of an Observable. It behaves similarly to the async pipe in templates, but is more flexible and can be used anywhere in an application. import { Component } from",
    "id": "signals-interop-*-angular-0"
  },
  {
    "url": "https://angular.dev/ecosystem/rxjs-interop",
    "title": "Signals interop • Angular",
    "chunk": " '@angular/core';import { AsyncPipe } from '@angular/common';import { interval } from 'rxjs';import { toSignal } from '@angular/core/rxjs-interop';@Component({ template: `{{ counter() }}`,})export class Ticker { counterObservable = interval(1000); // Get a `Signal` representing the `counterObservable`'s value. counter = toSignal(this.counterObservable, {initialValue: 0});} Like the async pipe, toSignal subscribes to the Observable immediately, which may trigger side effects. The subscription cre",
    "id": "signals-interop-*-angular-1"
  },
  {
    "url": "https://angular.dev/ecosystem/rxjs-interop",
    "title": "Signals interop • Angular",
    "chunk": "ated by toSignal automatically unsubscribes from the given Observable when the component or service which calls toSignal is destroyed. IMPORTANT: toSignal creates a subscription. You should avoid calling it repeatedly for the same Observable, and instead reuse the signal it returns. Injection context toSignal by default needs to run in an injection context, such as during construction of a component or service. If an injection context is not available, you can manually specify the Injector to us",
    "id": "signals-interop-*-angular-2"
  },
  {
    "url": "https://angular.dev/ecosystem/rxjs-interop",
    "title": "Signals interop • Angular",
    "chunk": "e instead. Initial values Observables may not produce a value synchronously on subscription, but signals always require a current value. There are several ways to deal with this \"initial\" value of toSignal signals. The initialValue option As in the example above, you can specify an initialValue option with the value the signal should return before the Observable emits for the first time. undefined initial values If you don't provide an initialValue, the resulting signal will return undefined unt",
    "id": "signals-interop-*-angular-3"
  },
  {
    "url": "https://angular.dev/ecosystem/rxjs-interop",
    "title": "Signals interop • Angular",
    "chunk": "il the Observable emits. This is similar to the async pipe's behavior of returning null. The requireSync option Some Observables are guaranteed to emit synchronously, such as BehaviorSubject. In those cases, you can specify the requireSync: true option. When requiredSync is true, toSignal enforces that the Observable emits synchronously on subscription. This guarantees that the signal always has a value, and no undefined type or initial value is required. manualCleanup By default, toSignal autom",
    "id": "signals-interop-*-angular-4"
  },
  {
    "url": "https://angular.dev/ecosystem/rxjs-interop",
    "title": "Signals interop • Angular",
    "chunk": "atically unsubscribes from the Observable when the component or service that creates it is destroyed. To override this behavior, you can pass the manualCleanup option. You can use this setting for Observables that complete themselves naturally. Error and Completion If an Observable used in toSignal produces an error, that error is thrown when the signal is read. If an Observable used in toSignal completes, the signal continues to return the most recently emitted value before completion. Create a",
    "id": "signals-interop-*-angular-5"
  },
  {
    "url": "https://angular.dev/ecosystem/rxjs-interop",
    "title": "Signals interop • Angular",
    "chunk": "n RxJS Observable from a signal with toObservable Use the toObservable utility to create an Observable which tracks the value of a signal. The signal's value is monitored with an effect which emits the value to the Observable when it changes. import { Component, signal } from '@angular/core';import { toObservable } from '@angular/core/rxjs-interop';@Component(...)export class SearchResults { query: Signal<string> = inject(QueryService).query; query$ = toObservable(this.query); results$ = this.qu",
    "id": "signals-interop-*-angular-6"
  },
  {
    "url": "https://angular.dev/ecosystem/rxjs-interop",
    "title": "Signals interop • Angular",
    "chunk": "ery$.pipe( switchMap(query => this.http.get('/search?q=' + query )) );} As the query signal changes, the query$ Observable emits the latest query and triggers a new HTTP request. Injection context toObservable by default needs to run in an injection context, such as during construction of a component or service. If an injection context is not available, you can manually specify the Injector to use instead. Timing of toObservable toObservable uses an effect to track the value of the signal in a R",
    "id": "signals-interop-*-angular-7"
  },
  {
    "url": "https://angular.dev/ecosystem/rxjs-interop",
    "title": "Signals interop • Angular",
    "chunk": "eplaySubject. On subscription, the first value (if available) may be emitted synchronously, and all subsequent values will be asynchronous. Unlike Observables, signals never provide a synchronous notification of changes. Even if you update a signal's value multiple times, toObservable will only emit the value after the signal stabilizes. const obs$ = toObservable(mySignal);obs$.subscribe(value => console.log(value));mySignal.set(1);mySignal.set(2);mySignal.set(3); Here, only the last value (3) w",
    "id": "signals-interop-*-angular-8"
  },
  {
    "url": "https://angular.dev/ecosystem/rxjs-interop",
    "title": "Signals interop • Angular",
    "chunk": "ill be logged. Social MediaBlogX (formerly Twitter)BlueskyYouTube Discord GitHub Stack Overflow Community Contribute Code of Conduct Report Issues Google's DevLibrary Angular Google Developer Experts ResourcesPress KitRoadmapLanguages简体中文版正體中文版日本語版한국어 Ελληνικά Super-powered by Google ©2010-2025. Code licensed under an MIT-style License . Documentation licensed under CC BY 4.0 .",
    "id": "signals-interop-*-angular-9"
  },
  {
    "url": "https://angular.dev/ecosystem/rxjs-interop/output-interop",
    "title": "Component output interop • Angular",
    "chunk": "Extended EcosystemUsing RxJS with Angular RxJS interop with component and directive outputs TIP: This guide assumes you're familiar with component and directive outputs. The @angular/rxjs-interop package offers two APIs related to component and directive outputs. On this pagearrow_upward_alt Back to the top Creating an output based on an RxJs Observable The outputFromObservable lets you create a component or directive output that emits based on an RxJS observable: import {Directive} from '@angul",
    "id": "component-output-interop-*-angular-0"
  },
  {
    "url": "https://angular.dev/ecosystem/rxjs-interop/output-interop",
    "title": "Component output interop • Angular",
    "chunk": "ar/core';import {outputFromObservable} from '@angular/core/rxjs-interop';@Directive({/*...*/})class Draggable { pointerMoves$: Observable<PointerMovements> = listenToPointerMoves(); // Whenever `pointerMoves$` emits, the `pointerMove` event fires. pointerMove = outputFromObservable(this.pointerMoves$);} The outputFromObservable function has special meaning to the Angular compiler. You may only call outputFromObservable in component and directive property initializers. When you subscribe to the o",
    "id": "component-output-interop-*-angular-1"
  },
  {
    "url": "https://angular.dev/ecosystem/rxjs-interop/output-interop",
    "title": "Component output interop • Angular",
    "chunk": "utput, Angular automatically forwards the subscription to the underlying observable. Angular stops forwarding values when the component or directive is destroyed. HELPFUL: Consider using output() directly if you can emit values imperatively. Creating an RxJS Observable from a component or directive output The outputToObservable function lets you create an RxJS observable from a component output. import {outputToObservable} from '@angular/core/rxjs-interop';@Component(/*...*/)class CustomSlider {",
    "id": "component-output-interop-*-angular-2"
  },
  {
    "url": "https://angular.dev/ecosystem/rxjs-interop/output-interop",
    "title": "Component output interop • Angular",
    "chunk": " valueChange = output<number>();}// Instance reference to `CustomSlider`.const slider: CustomSlider = createSlider();outputToObservable(slider.valueChange) // Observable<number> .pipe(...) .subscribe(...); HELPFUL: Consider using the subscribe method on OutputRef directly if it meets your needs. Social MediaBlogX (formerly Twitter)BlueskyYouTube Discord GitHub Stack Overflow Community Contribute Code of Conduct Report Issues Google's DevLibrary Angular Google Developer Experts ResourcesPress Kit",
    "id": "component-output-interop-*-angular-3"
  },
  {
    "url": "https://angular.dev/ecosystem/rxjs-interop/output-interop",
    "title": "Component output interop • Angular",
    "chunk": "RoadmapLanguages简体中文版正體中文版日本語版한국어 Ελληνικά Super-powered by Google ©2010-2025. Code licensed under an MIT-style License . Documentation licensed under CC BY 4.0 .",
    "id": "component-output-interop-*-angular-4"
  },
  {
    "url": "https://angular.dev/guide/http",
    "title": "HTTP Client • Overview • Angular",
    "chunk": "In-depth GuidesHTTP Client Understanding communicating with backend services using HTTP Most front-end applications need to communicate with a server over the HTTP protocol, to download or upload data and access other back-end services. Angular provides a client HTTP API for Angular applications, the HttpClient service class in @angular/common/http. On this pagearrow_upward_alt Back to the top HTTP client service features The HTTP client service offers the following major features: The ability t",
    "id": "http-client-*-overview-*-angular-0"
  },
  {
    "url": "https://angular.dev/guide/http",
    "title": "HTTP Client • Overview • Angular",
    "chunk": "o request typed response values Streamlined error handling Request and response interception Robust testing utilities What's next Setting up HttpClient Making HTTP requests Social MediaBlogX (formerly Twitter)BlueskyYouTube Discord GitHub Stack Overflow Community Contribute Code of Conduct Report Issues Google's DevLibrary Angular Google Developer Experts ResourcesPress KitRoadmapLanguages简体中文版正體中文版日本語版한국어 Ελληνικά Super-powered by Google ©2010-2025. Code licensed under an MIT-style License . Do",
    "id": "http-client-*-overview-*-angular-1"
  },
  {
    "url": "https://angular.dev/guide/http",
    "title": "HTTP Client • Overview • Angular",
    "chunk": "cumentation licensed under CC BY 4.0 .",
    "id": "http-client-*-overview-*-angular-2"
  },
  {
    "url": "https://angular.dev/guide/http/setup",
    "title": "Setting up HttpClient • Angular",
    "chunk": "In-depth GuidesHTTP Client Setting up HttpClient Before you can use HttpClient in your app, you must configure it using dependency injection. On this pagearrow_upward_alt Back to the top Providing HttpClient through dependency injection HttpClient is provided using the provideHttpClient helper function, which most apps include in the application providers in app.config.ts. export const appConfig: ApplicationConfig = { providers: [ provideHttpClient(), ]}; If your app is using NgModule-based boot",
    "id": "setting-up-httpclient-*-angular-0"
  },
  {
    "url": "https://angular.dev/guide/http/setup",
    "title": "Setting up HttpClient • Angular",
    "chunk": "strap instead, you can include provideHttpClient in the providers of your app's NgModule: @NgModule({ providers: [ provideHttpClient(), ], // ... other application configuration})export class AppModule {} You can then inject the HttpClient service as a dependency of your components, services, or other classes: @Injectable({providedIn: 'root'})export class ConfigService { private http = inject(HttpClient); // This service can now make HTTP requests via `this.http`.} Configuring features of HttpCl",
    "id": "setting-up-httpclient-*-angular-1"
  },
  {
    "url": "https://angular.dev/guide/http/setup",
    "title": "Setting up HttpClient • Angular",
    "chunk": "ient provideHttpClient accepts a list of optional feature configurations, to enable or configure the behavior of different aspects of the client. This section details the optional features and their usages. withFetch export const appConfig: ApplicationConfig = { providers: [ provideHttpClient( withFetch(), ), ]}; By default, HttpClient uses the XMLHttpRequest API to make requests. The withFetch feature switches the client to use the fetch API instead. fetch is a more modern API and is available ",
    "id": "setting-up-httpclient-*-angular-2"
  },
  {
    "url": "https://angular.dev/guide/http/setup",
    "title": "Setting up HttpClient • Angular",
    "chunk": "in a few environments where XMLHttpRequest is not supported. It does have a few limitations, such as not producing upload progress events. withInterceptors(...) withInterceptors configures the set of interceptor functions which will process requests made through HttpClient. See the interceptor guide for more information. withInterceptorsFromDi() withInterceptorsFromDi includes the older style of class-based interceptors in the HttpClient configuration. See the interceptor guide for more informat",
    "id": "setting-up-httpclient-*-angular-3"
  },
  {
    "url": "https://angular.dev/guide/http/setup",
    "title": "Setting up HttpClient • Angular",
    "chunk": "ion. HELPFUL: Functional interceptors (through withInterceptors) have more predictable ordering and we recommend them over DI-based interceptors. withRequestsMadeViaParent() By default, when you configure HttpClient using provideHttpClient within a given injector, this configuration overrides any configuration for HttpClient which may be present in the parent injector. When you add withRequestsMadeViaParent(), HttpClient is configured to instead pass requests up to the HttpClient instance in the",
    "id": "setting-up-httpclient-*-angular-4"
  },
  {
    "url": "https://angular.dev/guide/http/setup",
    "title": "Setting up HttpClient • Angular",
    "chunk": " parent injector, once they've passed through any configured interceptors at this level. This is useful if you want to add interceptors in a child injector, while still sending the request through the parent injector's interceptors as well. CRITICAL: You must configure an instance of HttpClient above the current injector, or this option is not valid and you'll get a runtime error when you try to use it. withJsonpSupport() Including withJsonpSupport enables the .jsonp() method on HttpClient, whic",
    "id": "setting-up-httpclient-*-angular-5"
  },
  {
    "url": "https://angular.dev/guide/http/setup",
    "title": "Setting up HttpClient • Angular",
    "chunk": "h makes a GET request via the JSONP convention for cross-domain loading of data. HELPFUL: Prefer using CORS to make cross-domain requests instead of JSONP when possible. withXsrfConfiguration(...) Including this option allows for customization of HttpClient's built-in XSRF security functionality. See the security guide for more information. withNoXsrfProtection() Including this option disables HttpClient's built-in XSRF security functionality. See the security guide for more information. HttpCli",
    "id": "setting-up-httpclient-*-angular-6"
  },
  {
    "url": "https://angular.dev/guide/http/setup",
    "title": "Setting up HttpClient • Angular",
    "chunk": "entModule-based configuration Some applications may configure HttpClient using the older API based on NgModules. This table lists the NgModules available from @angular/common/http and how they relate to the provider configuration functions above. NgModule provideHttpClient() equivalent HttpClientModule provideHttpClient(withInterceptorsFromDi()) HttpClientJsonpModule withJsonpSupport() HttpClientXsrfModule.withOptions(...) withXsrfConfiguration(...) HttpClientXsrfModule.disable() withNoXsrfProte",
    "id": "setting-up-httpclient-*-angular-7"
  },
  {
    "url": "https://angular.dev/guide/http/setup",
    "title": "Setting up HttpClient • Angular",
    "chunk": "ction() Use caution when using HttpClientModule in multiple injectors When HttpClientModule is present in multiple injectors, the behavior of interceptors is poorly defined and depends on the exact options and provider/import ordering. Prefer provideHttpClient for multi-injector configurations, as it has more stable behavior. See the withRequestsMadeViaParent feature above. Social MediaBlogX (formerly Twitter)BlueskyYouTube Discord GitHub Stack Overflow Community Contribute Code of Conduct Repor",
    "id": "setting-up-httpclient-*-angular-8"
  },
  {
    "url": "https://angular.dev/guide/http/setup",
    "title": "Setting up HttpClient • Angular",
    "chunk": "t Issues Google's DevLibrary Angular Google Developer Experts ResourcesPress KitRoadmapLanguages简体中文版正體中文版日本語版한국어 Ελληνικά Super-powered by Google ©2010-2025. Code licensed under an MIT-style License . Documentation licensed under CC BY 4.0 .",
    "id": "setting-up-httpclient-*-angular-9"
  },
  {
    "url": "https://angular.dev/guide/http/making-requests",
    "title": "Making requests • Angular",
    "chunk": "In-depth GuidesHTTP Client Making HTTP requests HttpClient has methods corresponding to the different HTTP verbs used to make requests, both to load data and to apply mutations on the server. Each method returns an RxJS Observable which, when subscribed, sends the request and then emits the results when the server responds. NOTE: Observables created by HttpClient may be subscribed any number of times and will make a new backend request for each subscription. Through an options object passed to t",
    "id": "making-requests-*-angular-0"
  },
  {
    "url": "https://angular.dev/guide/http/making-requests",
    "title": "Making requests • Angular",
    "chunk": "he request method, various properties of the request and the returned response type can be adjusted. On this pagearrow_upward_alt Back to the top Fetching JSON data Fetching data from a backend often requires making a GET request using the HttpClient.get() method. This method takes two arguments: the string endpoint URL from which to fetch, and an optional options object to configure the request. For example, to fetch configuration data from a hypothetical API using the HttpClient.get() method: ",
    "id": "making-requests-*-angular-1"
  },
  {
    "url": "https://angular.dev/guide/http/making-requests",
    "title": "Making requests • Angular",
    "chunk": "http.get<Config>('/api/config').subscribe(config => { // process the configuration.}); Note the generic type argument which specifies that the data returned by the server will be of type Config. This argument is optional, and if you omit it then the returned data will have type Object. TIP: When dealing with data of uncertain structure and potential undefined or null values, consider using the unknown type instead of Object as the response type. CRITICAL: The generic type of request methods is a",
    "id": "making-requests-*-angular-2"
  },
  {
    "url": "https://angular.dev/guide/http/making-requests",
    "title": "Making requests • Angular",
    "chunk": " type assertion about the data returned by the server. HttpClient does not verify that the actual return data matches this type. Fetching other types of data By default, HttpClient assumes that servers will return JSON data. When interacting with a non-JSON API, you can tell HttpClient what response type to expect and return when making the request. This is done with the responseType option. responseType value Returned response type 'json' (default) JSON data of the given generic type 'text' str",
    "id": "making-requests-*-angular-3"
  },
  {
    "url": "https://angular.dev/guide/http/making-requests",
    "title": "Making requests • Angular",
    "chunk": "ing data 'arraybuffer' ArrayBuffer containing the raw response bytes 'blob' Blob instance For example, you can ask HttpClient to download the raw bytes of a .jpeg image into an ArrayBuffer: http.get('/images/dog.jpg', {responseType: 'arraybuffer'}).subscribe(buffer => { console.log('The image is ' + buffer.byteLength + ' bytes large');}); Literal value for responseType Because the value of responseType affects the type returned by HttpClient, it must have a literal type and not a string type. Th",
    "id": "making-requests-*-angular-4"
  },
  {
    "url": "https://angular.dev/guide/http/making-requests",
    "title": "Making requests • Angular",
    "chunk": "is happens automatically if the options object passed to the request method is a literal object, but if you're extracting the request options out into a variable or helper method you might need to explicitly specify it as a literal, such as responseType: 'text' as const. Mutating server state Server APIs which perform mutations often require making POST requests with a request body specifying the new state or the change to be made. The HttpClient.post() method behaves similarly to get(), and acc",
    "id": "making-requests-*-angular-5"
  },
  {
    "url": "https://angular.dev/guide/http/making-requests",
    "title": "Making requests • Angular",
    "chunk": "epts an additional body argument before its options: http.post<Config>('/api/config', newConfig).subscribe(config => { console.log('Updated config:', config);}); Many different types of values can be provided as the request's body, and HttpClient will serialize them accordingly: body type Serialized as string Plain text number, boolean, array, or plain object JSON ArrayBuffer raw data from the buffer Blob raw data with the Blob's content type FormData multipart/form-data encoded data HttpParams ",
    "id": "making-requests-*-angular-6"
  },
  {
    "url": "https://angular.dev/guide/http/making-requests",
    "title": "Making requests • Angular",
    "chunk": "or URLSearchParams application/x-www-form-urlencoded formatted string IMPORTANT: Remember to .subscribe() to mutation request Observables in order to actually fire the request. Setting URL parameters Specify request parameters that should be included in the request URL using the params option. Passing an object literal is the simplest way of configuring URL parameters: http.get('/api/config', { params: {filter: 'all'},}).subscribe(config => { // ...}); Alternatively, pass an instance of HttpPara",
    "id": "making-requests-*-angular-7"
  },
  {
    "url": "https://angular.dev/guide/http/making-requests",
    "title": "Making requests • Angular",
    "chunk": "ms if you need more control over the construction or serialization of the parameters. IMPORTANT: Instances of HttpParams are immutable and cannot be directly changed. Instead, mutation methods such as append() return a new instance of HttpParams with the mutation applied. const baseParams = new HttpParams().set('filter', 'all');http.get('/api/config', { params: baseParams.set('details', 'enabled'),}).subscribe(config => { // ...}); You can instantiate HttpParams with a custom HttpParameterCodec ",
    "id": "making-requests-*-angular-8"
  },
  {
    "url": "https://angular.dev/guide/http/making-requests",
    "title": "Making requests • Angular",
    "chunk": "that determines how HttpClient will encode the parameters into the URL. Setting request headers Specify request headers that should be included in the request using the headers option. Passing an object literal is the simplest way of configuring request headers: http.get('/api/config', { headers: { 'X-Debug-Level': 'verbose', }}).subscribe(config => { // ...}); Alternatively, pass an instance of HttpHeaders if you need more control over the construction of headers IMPORTANT: Instances of HttpHea",
    "id": "making-requests-*-angular-9"
  },
  {
    "url": "https://angular.dev/guide/http/making-requests",
    "title": "Making requests • Angular",
    "chunk": "ders are immutable and cannot be directly changed. Instead, mutation methods such as append() return a new instance of HttpHeaders with the mutation applied. const baseHeaders = new HttpHeaders().set('X-Debug-Level', 'minimal');http.get<Config>('/api/config', { headers: baseHeaders.set('X-Debug-Level', 'verbose'),}).subscribe(config => { // ...}); Interacting with the server response events For convenience, HttpClient by default returns an Observable of the data returned by the server (the respo",
    "id": "making-requests-*-angular-10"
  },
  {
    "url": "https://angular.dev/guide/http/making-requests",
    "title": "Making requests • Angular",
    "chunk": "nse body). Occasionally it's desirable to examine the actual response, for example to retrieve specific response headers. To access the entire response, set the observe option to 'response': http.get<Config>('/api/config', {observe: 'response'}).subscribe(res => { console.log('Response status:', res.status); console.log('Body:', res.body);}); Literal value for observe Because the value of observe affects the type returned by HttpClient, it must have a literal type and not a string type. This hap",
    "id": "making-requests-*-angular-11"
  },
  {
    "url": "https://angular.dev/guide/http/making-requests",
    "title": "Making requests • Angular",
    "chunk": "pens automatically if the options object passed to the request method is a literal object, but if you're extracting the request options out into a variable or helper method you might need to explicitly specify it as a literal, such as observe: 'response' as const. Receiving raw progress events In addition to the response body or response object, HttpClient can also return a stream of raw events corresponding to specific moments in the request lifecycle. These events include when the request is s",
    "id": "making-requests-*-angular-12"
  },
  {
    "url": "https://angular.dev/guide/http/making-requests",
    "title": "Making requests • Angular",
    "chunk": "ent, when the response header is returned, and when the body is complete. These events can also include progress events which report upload and download status for large request or response bodies. Progress events are disabled by default (as they have a performance cost) but can be enabled with the reportProgress option. NOTE: The optional fetch implementation of HttpClient does not report upload progress events. To observe the event stream, set the observe option to 'events': http.post('/api/up",
    "id": "making-requests-*-angular-13"
  },
  {
    "url": "https://angular.dev/guide/http/making-requests",
    "title": "Making requests • Angular",
    "chunk": "load', myData, { reportProgress: true, observe: 'events',}).subscribe(event => { switch (event.type) { case HttpEventType.UploadProgress: console.log('Uploaded ' + event.loaded + ' out of ' + event.total + ' bytes'); break; case HttpEventType.Response: console.log('Finished uploading!'); break; }}); Literal value for observe Because the value of observe affects the type returned by HttpClient, it must have a literal type and not a string type. This happens automatically if the options object pas",
    "id": "making-requests-*-angular-14"
  },
  {
    "url": "https://angular.dev/guide/http/making-requests",
    "title": "Making requests • Angular",
    "chunk": "sed to the request method is a literal object, but if you're extracting the request options out into a variable or helper method you might need to explicitly specify it as a literal, such as observe: 'events' as const. Each HttpEvent reported in the event stream has a type which distinguishes what the event represents: type value Event meaning HttpEventType.Sent The request has been dispatched to the server HttpEventType.UploadProgress An HttpUploadProgressEvent reporting progress on uploading t",
    "id": "making-requests-*-angular-15"
  },
  {
    "url": "https://angular.dev/guide/http/making-requests",
    "title": "Making requests • Angular",
    "chunk": "he request body HttpEventType.ResponseHeader The head of the response has been received, including status and headers HttpEventType.DownloadProgress An HttpDownloadProgressEvent reporting progress on downloading the response body HttpEventType.Response The entire response has been received, including the response body HttpEventType.User A custom event from an Http interceptor. Handling request failure There are two ways an HTTP request can fail: A network or connection error can prevent the requ",
    "id": "making-requests-*-angular-16"
  },
  {
    "url": "https://angular.dev/guide/http/making-requests",
    "title": "Making requests • Angular",
    "chunk": "est from reaching the backend server. The backend can receive the request but fail to process it, and return an error response. HttpClient captures both kinds of errors in an HttpErrorResponse which it returns through the Observable's error channel. Network errors have a status code of 0 and an error which is an instance of ProgressEvent. Backend errors have the failing status code returned by the backend, and the error response as the error. Inspect the response to identify the error's cause an",
    "id": "making-requests-*-angular-17"
  },
  {
    "url": "https://angular.dev/guide/http/making-requests",
    "title": "Making requests • Angular",
    "chunk": "d the appropriate action to handle the error. The RxJS library offers several operators which can be useful for error handling. You can use the catchError operator to transform an error response into a value for the UI. This value can tell the UI to display an error page or value, and capture the error's cause if necessary. Sometimes transient errors such as network interruptions can cause a request to fail unexpectedly, and simply retrying the request will allow it to succeed. RxJS provides sev",
    "id": "making-requests-*-angular-18"
  },
  {
    "url": "https://angular.dev/guide/http/making-requests",
    "title": "Making requests • Angular",
    "chunk": "eral retry operators which automatically re-subscribe to a failed Observable under certain conditions. For example, the retry() operator will automatically attempt to re-subscribe a specified number of times. Http Observables Each request method on HttpClient constructs and returns an Observable of the requested response type. Understanding how these Observables work is important when using HttpClient. HttpClient produces what RxJS calls \"cold\" Observables, meaning that no actual request happens",
    "id": "making-requests-*-angular-19"
  },
  {
    "url": "https://angular.dev/guide/http/making-requests",
    "title": "Making requests • Angular",
    "chunk": " until the Observable is subscribed. Only then is the request actually dispatched to the server. Subscribing to the same Observable multiple times will trigger multiple backend requests. Each subscription is independent. TIP: You can think of HttpClient Observables as blueprints for actual server requests. Once subscribed, unsubscribing will abort the in-progress request. This is very useful if the Observable is subscribed via the async pipe, as it will automatically cancel the request if the us",
    "id": "making-requests-*-angular-20"
  },
  {
    "url": "https://angular.dev/guide/http/making-requests",
    "title": "Making requests • Angular",
    "chunk": "er navigates away from the current page. Additionally, if you use the Observable with an RxJS combinator like switchMap, this cancellation will clean up any stale requests. Once the response returns, Observables from HttpClient usually complete (although interceptors can influence this). Because of the automatic completion, there is usually no risk of memory leaks if HttpClient subscriptions are not cleaned up. However, as with any async operation, we strongly recommend that you clean up subscri",
    "id": "making-requests-*-angular-21"
  },
  {
    "url": "https://angular.dev/guide/http/making-requests",
    "title": "Making requests • Angular",
    "chunk": "ptions when the component using them is destroyed, as the subscription callback may otherwise run and encounter errors when it attempts to interact with the destroyed component. TIP: Using the async pipe or the toSignal operation to subscribe to Observables ensures that subscriptions are disposed properly. Best practices While HttpClient can be injected and used directly from components, generally we recommend you create reusable, injectable services which isolate and encapsulate data access log",
    "id": "making-requests-*-angular-22"
  },
  {
    "url": "https://angular.dev/guide/http/making-requests",
    "title": "Making requests • Angular",
    "chunk": "ic. For example, this UserService encapsulates the logic to request data for a user by their id: @Injectable({providedIn: 'root'})export class UserService { private http = inject(HttpClient); getUser(id: string): Observable<User> { return this.http.get<User>(`/api/user/${id}`); }} Within a component, you can combine @if with the async pipe to render the UI for the data only after it's finished loading: import { AsyncPipe } from '@angular/common';@Component({ imports: [AsyncPipe], template: ` @if",
    "id": "making-requests-*-angular-23"
  },
  {
    "url": "https://angular.dev/guide/http/making-requests",
    "title": "Making requests • Angular",
    "chunk": " (user$ | async; as user) { <p>Name: {{ user.name }}</p> <p>Biography: {{ user.biography }}</p> } `,})export class UserProfileComponent { userId = input.required<string>(); user$!: Observable<User>; private userService = inject(UserService); constructor(): void { effect(() => { this.user$ = this.userService.getUser(this.userId()); }); }} Social MediaBlogX (formerly Twitter)BlueskyYouTube Discord GitHub Stack Overflow Community Contribute Code of Conduct Report Issues Google's DevLibrary Angular ",
    "id": "making-requests-*-angular-24"
  },
  {
    "url": "https://angular.dev/guide/http/making-requests",
    "title": "Making requests • Angular",
    "chunk": "Google Developer Experts ResourcesPress KitRoadmapLanguages简体中文版正體中文版日本語版한국어 Ελληνικά Super-powered by Google ©2010-2025. Code licensed under an MIT-style License . Documentation licensed under CC BY 4.0 .",
    "id": "making-requests-*-angular-25"
  },
  {
    "url": "https://angular.dev/guide/http/interceptors",
    "title": "Intercepting requests and responses • Angular",
    "chunk": "In-depth GuidesHTTP Client Interceptors HttpClient supports a form of middleware known as interceptors. TL;DR: Interceptors are middleware that allows common patterns around retrying, caching, logging, and authentication to be abstracted away from individual requests. HttpClient supports two kinds of interceptors: functional and DI-based. Our recommendation is to use functional interceptors because they have more predictable behavior, especially in complex setups. Our examples in this guide use ",
    "id": "intercepting-requests-and-responses-*-angular-0"
  },
  {
    "url": "https://angular.dev/guide/http/interceptors",
    "title": "Intercepting requests and responses • Angular",
    "chunk": "functional interceptors, and we cover DI-based interceptors in their own section at the end. On this pagearrow_upward_alt Back to the top Interceptors Interceptors are generally functions which you can run for each request, and have broad capabilities to affect the contents and overall flow of requests and responses. You can install multiple interceptors, which form an interceptor chain where each interceptor processes the request or response before forwarding it to the next interceptor in the c",
    "id": "intercepting-requests-and-responses-*-angular-1"
  },
  {
    "url": "https://angular.dev/guide/http/interceptors",
    "title": "Intercepting requests and responses • Angular",
    "chunk": "hain. You can use interceptors to implement a variety of common patterns, such as: Adding authentication headers to outgoing requests to a particular API. Retrying failed requests with exponential backoff. Caching responses for a period of time, or until invalidated by mutations. Customizing the parsing of responses. Measuring server response times and log them. Driving UI elements such as a loading spinner while network operations are in progress. Collecting and batch requests made within a cer",
    "id": "intercepting-requests-and-responses-*-angular-2"
  },
  {
    "url": "https://angular.dev/guide/http/interceptors",
    "title": "Intercepting requests and responses • Angular",
    "chunk": "tain timeframe. Automatically failing requests after a configurable deadline or timeout. Regularly polling the server and refreshing results. Defining an interceptor The basic form of an interceptor is a function which receives the outgoing HttpRequest and a next function representing the next processing step in the interceptor chain. For example, this loggingInterceptor will log the outgoing request URL to console.log before forwarding the request: export function loggingInterceptor(req: HttpRe",
    "id": "intercepting-requests-and-responses-*-angular-3"
  },
  {
    "url": "https://angular.dev/guide/http/interceptors",
    "title": "Intercepting requests and responses • Angular",
    "chunk": "quest<unknown>, next: HttpHandlerFn): Observable<HttpEvent<unknown>> { console.log(req.url); return next(req);} In order for this interceptor to actually intercept requests, you must configure HttpClient to use it. Configuring interceptors You declare the set of interceptors to use when configuring HttpClient through dependency injection, by using the withInterceptors feature: bootstrapApplication(AppComponent, {providers: [ provideHttpClient( withInterceptors([loggingInterceptor, cachingInterce",
    "id": "intercepting-requests-and-responses-*-angular-4"
  },
  {
    "url": "https://angular.dev/guide/http/interceptors",
    "title": "Intercepting requests and responses • Angular",
    "chunk": "ptor]), )]}); The interceptors you configure are chained together in the order that you've listed them in the providers. In the above example, the loggingInterceptor would process the request and then forward it to the cachingInterceptor. Intercepting response events An interceptor may transform the Observable stream of HttpEvents returned by next in order to access or manipulate the response. Because this stream includes all response events, inspecting the .type of each event may be necessary i",
    "id": "intercepting-requests-and-responses-*-angular-5"
  },
  {
    "url": "https://angular.dev/guide/http/interceptors",
    "title": "Intercepting requests and responses • Angular",
    "chunk": "n order to identify the final response object. export function loggingInterceptor(req: HttpRequest<unknown>, next: HttpHandlerFn): Observable<HttpEvent<unknown>> { return next(req).pipe(tap(event => { if (event.type === HttpEventType.Response) { console.log(req.url, 'returned a response with status', event.status); } }));} TIP: Interceptors naturally associate responses with their outgoing requests, because they transform the response stream in a closure that captures the request object. Modifyi",
    "id": "intercepting-requests-and-responses-*-angular-6"
  },
  {
    "url": "https://angular.dev/guide/http/interceptors",
    "title": "Intercepting requests and responses • Angular",
    "chunk": "ng requests Most aspects of HttpRequest and HttpResponse instances are immutable, and interceptors cannot directly modify them. Instead, interceptors apply mutations by cloning these objects using the .clone() operation, and specifying which properties should be mutated in the new instance. This might involve performing immutable updates on the value itself (like HttpHeaders or HttpParams). For example, to add a header to a request: const reqWithHeader = req.clone({ headers: req.headers.set('X-N",
    "id": "intercepting-requests-and-responses-*-angular-7"
  },
  {
    "url": "https://angular.dev/guide/http/interceptors",
    "title": "Intercepting requests and responses • Angular",
    "chunk": "ew-Header', 'new header value'),}); This immutability allows most interceptors to be idempotent if the same HttpRequest is submitted to the interceptor chain multiple times. This can happen for a few reasons, including when a request is retried after failure. CRITICAL: The body of a request or response is not protected from deep mutations. If an interceptor must mutate the body, take care to handle running multiple times on the same request. Dependency injection in interceptors Interceptors are ",
    "id": "intercepting-requests-and-responses-*-angular-8"
  },
  {
    "url": "https://angular.dev/guide/http/interceptors",
    "title": "Intercepting requests and responses • Angular",
    "chunk": "run in the injection context of the injector which registered them, and can use Angular's inject API to retrieve dependencies. For example, suppose an application has a service called AuthService, which creates authentication tokens for outgoing requests. An interceptor can inject and use this service: export function authInterceptor(req: HttpRequest<unknown>, next: HttpHandlerFn) { // Inject the current `AuthService` and use it to get an authentication token: const authToken = inject(AuthServic",
    "id": "intercepting-requests-and-responses-*-angular-9"
  },
  {
    "url": "https://angular.dev/guide/http/interceptors",
    "title": "Intercepting requests and responses • Angular",
    "chunk": "e).getAuthToken(); // Clone the request to add the authentication header. const newReq = req.clone({ headers: req.headers.append('X-Authentication-Token', authToken), }); return next(newReq);} Request and response metadata Often it's useful to include information in a request that's not sent to the backend, but is specifically meant for interceptors. HttpRequests have a .context object which stores this kind of metadata as an instance of HttpContext. This object functions as a typed map, with ke",
    "id": "intercepting-requests-and-responses-*-angular-10"
  },
  {
    "url": "https://angular.dev/guide/http/interceptors",
    "title": "Intercepting requests and responses • Angular",
    "chunk": "ys of type HttpContextToken. To illustrate how this system works, let's use metadata to control whether a caching interceptor is enabled for a given request. Defining context tokens To store whether the caching interceptor should cache a particular request in that request's .context map, define a new HttpContextToken to act as a key: export const CACHING_ENABLED = new HttpContextToken<boolean>(() => true); The provided function creates the default value for the token for requests that haven't ex",
    "id": "intercepting-requests-and-responses-*-angular-11"
  },
  {
    "url": "https://angular.dev/guide/http/interceptors",
    "title": "Intercepting requests and responses • Angular",
    "chunk": "plicitly set a value for it. Using a function ensures that if the token's value is an object or array, each request gets its own instance. Reading the token in an interceptor An interceptor can then read the token and choose to apply caching logic or not based on its value: export function cachingInterceptor(req: HttpRequest<unknown>, next: HttpHandlerFn): Observable<HttpEvent<unknown>> { if (req.context.get(CACHING_ENABLED)) { // apply caching logic return ...; } else { // caching has been disa",
    "id": "intercepting-requests-and-responses-*-angular-12"
  },
  {
    "url": "https://angular.dev/guide/http/interceptors",
    "title": "Intercepting requests and responses • Angular",
    "chunk": "bled for this request return next(req); }} Setting context tokens when making a request When making a request via the HttpClient API, you can provide values for HttpContextTokens: const data$ = http.get('/sensitive/data', { context: new HttpContext().set(CACHING_ENABLED, false),}); Interceptors can read these values from the HttpContext of the request. The request context is mutable Unlike other properties of HttpRequests, the associated HttpContext is mutable. If an interceptor changes the cont",
    "id": "intercepting-requests-and-responses-*-angular-13"
  },
  {
    "url": "https://angular.dev/guide/http/interceptors",
    "title": "Intercepting requests and responses • Angular",
    "chunk": "ext of a request that is later retried, the same interceptor will observe the context mutation when it runs again. This is useful for passing state across multiple retries if needed. Synthetic responses Most interceptors will simply invoke the next handler while transforming either the request or the response, but this is not strictly a requirement. This section discusses several of the ways in which an interceptor may incorporate more advanced behavior. Interceptors are not required to invoke n",
    "id": "intercepting-requests-and-responses-*-angular-14"
  },
  {
    "url": "https://angular.dev/guide/http/interceptors",
    "title": "Intercepting requests and responses • Angular",
    "chunk": "ext. They may instead choose to construct responses through some other mechanism, such as from a cache or by sending the request through an alternate mechanism. Constructing a response is possible using the HttpResponse constructor: const resp = new HttpResponse({ body: 'response body',}); DI-based interceptors HttpClient also supports interceptors which are defined as injectable classes and configured through the DI system. The capabilities of DI-based interceptors are identical to those of fun",
    "id": "intercepting-requests-and-responses-*-angular-15"
  },
  {
    "url": "https://angular.dev/guide/http/interceptors",
    "title": "Intercepting requests and responses • Angular",
    "chunk": "ctional interceptors, but the configuration mechanism is different. A DI-based interceptor is an injectable class which implements the HttpInterceptor interface: @Injectable()export class LoggingInterceptor implements HttpInterceptor { intercept(req: HttpRequest<any>, handler: HttpHandler): Observable<HttpEvent<any>> { console.log('Request URL: ' + req.url); return handler.handle(req); }} DI-based interceptors are configured through a dependency injection multi-provider: bootstrapApplication(App",
    "id": "intercepting-requests-and-responses-*-angular-16"
  },
  {
    "url": "https://angular.dev/guide/http/interceptors",
    "title": "Intercepting requests and responses • Angular",
    "chunk": "Component, {providers: [ provideHttpClient( // DI-based interceptors must be explicitly enabled. withInterceptorsFromDi(), ), {provide: HTTP_INTERCEPTORS, useClass: LoggingInterceptor, multi: true},]}); DI-based interceptors run in the order that their providers are registered. In an app with an extensive and hierarchical DI configuration, this order can be very hard to predict. Social MediaBlogX (formerly Twitter)BlueskyYouTube Discord GitHub Stack Overflow Community Contribute Code of Conduct ",
    "id": "intercepting-requests-and-responses-*-angular-17"
  },
  {
    "url": "https://angular.dev/guide/http/interceptors",
    "title": "Intercepting requests and responses • Angular",
    "chunk": "Report Issues Google's DevLibrary Angular Google Developer Experts ResourcesPress KitRoadmapLanguages简体中文版正體中文版日本語版한국어 Ελληνικά Super-powered by Google ©2010-2025. Code licensed under an MIT-style License . Documentation licensed under CC BY 4.0 .",
    "id": "intercepting-requests-and-responses-*-angular-18"
  },
  {
    "url": "https://angular.dev/guide/http/testing",
    "title": "Testing • Angular",
    "chunk": "In-depth GuidesHTTP Client Test requests As for any external dependency, you must mock the HTTP backend so your tests can simulate interaction with a remote server. The @angular/common/http/testing library provides tools to capture requests made by the application, make assertions about them, and mock the responses to emulate your backend's behavior. The testing library is designed for a pattern in which the app executes code and makes requests first. The test then expects that certain requests ",
    "id": "testing-*-angular-0"
  },
  {
    "url": "https://angular.dev/guide/http/testing",
    "title": "Testing • Angular",
    "chunk": "have or have not been made, performs assertions against those requests, and finally provides responses by \"flushing\" each expected request. At the end, tests can verify that the app made no unexpected requests. On this pagearrow_upward_alt Back to the top Setup for testing To begin testing usage of HttpClient, configure TestBed and include provideHttpClient() and provideHttpClientTesting() in your test's setup. This configures HttpClient to use a test backend instead of the real network. It also",
    "id": "testing-*-angular-1"
  },
  {
    "url": "https://angular.dev/guide/http/testing",
    "title": "Testing • Angular",
    "chunk": " provides HttpTestingController, which you'll use to interact with the test backend, set expectations about which requests have been made, and flush responses to those requests. HttpTestingController can be injected from TestBed once configured. Keep in mind to provide provideHttpClient() before provideHttpClientTesting(), as provideHttpClientTesting() will overwrite parts of provideHttpCient(). Doing it the other way around can potentially break your tests. TestBed.configureTestingModule({ prov",
    "id": "testing-*-angular-2"
  },
  {
    "url": "https://angular.dev/guide/http/testing",
    "title": "Testing • Angular",
    "chunk": "iders: [ // ... other test providers provideHttpClient(), provideHttpClientTesting(), ],});const httpTesting = TestBed.inject(HttpTestingController); Now when your tests make requests, they will hit the testing backend instead of the normal one. You can use httpTesting to make assertions about those requests. Expecting and answering requests For example, you can write a test that expects a GET request to occur and provides a mock response: TestBed.configureTestingModule({ providers: [ ConfigServ",
    "id": "testing-*-angular-3"
  },
  {
    "url": "https://angular.dev/guide/http/testing",
    "title": "Testing • Angular",
    "chunk": "ice, provideHttpClient(), provideHttpClientTesting(), ],});const httpTesting = TestBed.inject(HttpTestingController);// Load `ConfigService` and request the current configuration.const service = TestBed.inject(ConfigService);const config$ = this.configService.getConfig<Config>();// `firstValueFrom` subscribes to the `Observable`, which makes the HTTP request,// and creates a `Promise` of the response.const configPromise = firstValueFrom(config$);// At this point, the request is pending, and we c",
    "id": "testing-*-angular-4"
  },
  {
    "url": "https://angular.dev/guide/http/testing",
    "title": "Testing • Angular",
    "chunk": "an assert it was made// via the `HttpTestingController`:const req = httpTesting.expectOne('/api/config', 'Request to load the configuration');// We can assert various properties of the request if desired.expect(req.request.method).toBe('GET');// Flushing the request causes it to complete, delivering the result.req.flush(DEFAULT_CONFIG);// We can then assert that the response was successfully delivered by the `ConfigService`:expect(await configPromise).toEqual(DEFAULT_CONFIG);// Finally, we can a",
    "id": "testing-*-angular-5"
  },
  {
    "url": "https://angular.dev/guide/http/testing",
    "title": "Testing • Angular",
    "chunk": "ssert that no other requests were made.httpTesting.verify(); NOTE: expectOne will fail if the test has made more than one request which matches the given criteria. As an alternative to asserting on req.method, you could instead use an expanded form of expectOne to also match the request method: const req = httpTesting.expectOne({ method: 'GET', url: '/api/config',}, 'Request to load the configuration'); HELPFUL: The expectation APIs match against the full URL of requests, including any query par",
    "id": "testing-*-angular-6"
  },
  {
    "url": "https://angular.dev/guide/http/testing",
    "title": "Testing • Angular",
    "chunk": "ameters. The last step, verifying that no requests remain outstanding, is common enough for you to move it into an afterEach() step: afterEach(() => { // Verify that none of the tests make any extra HTTP requests. TestBed.inject(HttpTestingController).verify();}); Handling more than one request at once If you need to respond to duplicate requests in your test, use the match() API instead of expectOne(). It takes the same arguments but returns an array of matching requests. Once returned, these r",
    "id": "testing-*-angular-7"
  },
  {
    "url": "https://angular.dev/guide/http/testing",
    "title": "Testing • Angular",
    "chunk": "equests are removed from future matching and you are responsible for flushing and verifying them. const allGetRequests = httpTesting.match({method: 'GET'});for (const req of allGetRequests) { // Handle responding to each request.} Advanced matching All matching functions accept a predicate function for custom matching logic: // Look for one request that has a request body.const requestsWithBody = httpTesting.expectOne(req => req.body !== null); The expectNone function asserts that no requests ma",
    "id": "testing-*-angular-8"
  },
  {
    "url": "https://angular.dev/guide/http/testing",
    "title": "Testing • Angular",
    "chunk": "tch the given criteria. // Assert that no mutation requests have been issued.httpTesting.expectNone(req => req.method !== 'GET'); Testing error handling You should test your app's responses when HTTP requests fail. Backend errors To test handling of backend errors (when the server returns a non-successful status code), flush requests with an error response that emulates what your backend would return when a request fails. const req = httpTesting.expectOne('/api/config');req.flush('Failed!', {sta",
    "id": "testing-*-angular-9"
  },
  {
    "url": "https://angular.dev/guide/http/testing",
    "title": "Testing • Angular",
    "chunk": "tus: 500, statusText: 'Internal Server Error'});// Assert that the application successfully handled the backend error. Network errors Requests can also fail due to network errors, which surface as ProgressEvent errors. These can be delivered with the error() method: const req = httpTesting.expectOne('/api/config');req.error(new ProgressEvent('network error!'));// Assert that the application successfully handled the network error. Testing an Interceptor You should test that your interceptors work",
    "id": "testing-*-angular-10"
  },
  {
    "url": "https://angular.dev/guide/http/testing",
    "title": "Testing • Angular",
    "chunk": " under the desired circumstances. For example, an application may be required to add an authentication token generated by a service to each outgoing request. This behavior can be enforced with the use of an interceptor: export function authInterceptor(request: HttpRequest<unknown>, next: HttpHandlerFn): Observable<HttpEvent<unknown>> { const authService = inject(AuthService); const clonedRequest = request.clone({ headers: request.headers.append('X-Authentication-Token', authService.getAuthToken(",
    "id": "testing-*-angular-11"
  },
  {
    "url": "https://angular.dev/guide/http/testing",
    "title": "Testing • Angular",
    "chunk": ")), }); return next(clonedRequest);} The TestBed configuration for this interceptor should rely on the withInterceptors feature. TestBed.configureTestingModule({ providers: [ AuthService, // Testing one interceptor at a time is recommended. provideHttpClient(withInterceptors([authInterceptor])), provideHttpClientTesting(), ],}); The HttpTestingController can retrieve the request instance which can then be inspected to ensure that the request was modified. const service = TestBed.inject(AuthServi",
    "id": "testing-*-angular-12"
  },
  {
    "url": "https://angular.dev/guide/http/testing",
    "title": "Testing • Angular",
    "chunk": "ce);const req = httpTesting.expectOne('/api/config');expect(req.request.headers.get('X-Authentication-Token')).toEqual(service.getAuthToken()); A similar interceptor could be implemented with class based interceptors: @Injectable()export class AuthInterceptor implements HttpInterceptor { private authService = inject(AuthService); intercept(request: HttpRequest<unknown>, next: HttpHandler): Observable<HttpEvent<unknown>> { const clonedRequest = request.clone({ headers: request.headers.append('X-A",
    "id": "testing-*-angular-13"
  },
  {
    "url": "https://angular.dev/guide/http/testing",
    "title": "Testing • Angular",
    "chunk": "uthentication-Token', this.authService.getAuthToken()), }); return next.handle(clonedRequest); }} In order to test it, the TestBed configuration should instead be: TestBed.configureTestingModule({ providers: [ AuthService, provideHttpClient(withInterceptorsFromDi()), provideHttpClientTesting(), // We rely on the HTTP_INTERCEPTORS token to register the AuthInterceptor as an HttpInterceptor { provide: HTTP_INTERCEPTORS, useClass: AuthInterceptor, multi: true }, ],}); Social MediaBlogX (formerly Tw",
    "id": "testing-*-angular-14"
  },
  {
    "url": "https://angular.dev/guide/http/testing",
    "title": "Testing • Angular",
    "chunk": "itter)BlueskyYouTube Discord GitHub Stack Overflow Community Contribute Code of Conduct Report Issues Google's DevLibrary Angular Google Developer Experts ResourcesPress KitRoadmapLanguages简体中文版正體中文版日本語版한국어 Ελληνικά Super-powered by Google ©2010-2025. Code licensed under an MIT-style License . Documentation licensed under CC BY 4.0 .",
    "id": "testing-*-angular-15"
  },
  {
    "url": "https://angular.dev/guide/forms",
    "title": "Forms • Overview • Angular",
    "chunk": "In-depth GuidesForms Forms in Angular Handling user input with forms is the cornerstone of many common applications. Applications use forms to enable users to log in, to update a profile, to enter sensitive information, and to perform many other data-entry tasks. Angular provides two different approaches to handling user input through forms: reactive and template-driven. Both capture user input events from the view, validate the user input, create a form model and data model to update, and provi",
    "id": "forms-*-overview-*-angular-0"
  },
  {
    "url": "https://angular.dev/guide/forms",
    "title": "Forms • Overview • Angular",
    "chunk": "de a way to track changes. This guide provides information to help you decide which type of form works best for your situation. It introduces the common building blocks used by both approaches. It also summarizes the key differences between the two approaches, and demonstrates those differences in the context of setup, data flow, and testing. On this pagearrow_upward_alt Back to the top Choosing an approach Reactive forms and template-driven forms process and manage form data differently. Each a",
    "id": "forms-*-overview-*-angular-1"
  },
  {
    "url": "https://angular.dev/guide/forms",
    "title": "Forms • Overview • Angular",
    "chunk": "pproach offers different advantages. Forms Details Reactive forms Provide direct, explicit access to the underlying form's object model. Compared to template-driven forms, they are more robust: they're more scalable, reusable, and testable. If forms are a key part of your application, or you're already using reactive patterns for building your application, use reactive forms. Template-driven forms Rely on directives in the template to create and manipulate the underlying object model. They are u",
    "id": "forms-*-overview-*-angular-2"
  },
  {
    "url": "https://angular.dev/guide/forms",
    "title": "Forms • Overview • Angular",
    "chunk": "seful for adding a simple form to an app, such as an email list signup form. They're straightforward to add to an app, but they don't scale as well as reactive forms. If you have very basic form requirements and logic that can be managed solely in the template, template-driven forms could be a good fit. Key differences The following table summarizes the key differences between reactive and template-driven forms. Reactive Template-driven Setup of form model Explicit, created in component class Im",
    "id": "forms-*-overview-*-angular-3"
  },
  {
    "url": "https://angular.dev/guide/forms",
    "title": "Forms • Overview • Angular",
    "chunk": "plicit, created by directives Data model Structured and immutable Unstructured and mutable Data flow Synchronous Asynchronous Form validation Functions Directives Scalability If forms are a central part of your application, scalability is very important. Being able to reuse form models across components is critical. Reactive forms are more scalable than template-driven forms. They provide direct access to the underlying form API, and use synchronous data flow between the view and the data model,",
    "id": "forms-*-overview-*-angular-4"
  },
  {
    "url": "https://angular.dev/guide/forms",
    "title": "Forms • Overview • Angular",
    "chunk": " which makes creating large-scale forms easier. Reactive forms require less setup for testing, and testing does not require deep understanding of change detection to properly test form updates and validation. Template-driven forms focus on simple scenarios and are not as reusable. They abstract away the underlying form API, and use asynchronous data flow between the view and the data model. The abstraction of template-driven forms also affects testing. Tests are deeply reliant on manual change d",
    "id": "forms-*-overview-*-angular-5"
  },
  {
    "url": "https://angular.dev/guide/forms",
    "title": "Forms • Overview • Angular",
    "chunk": "etection execution to run properly, and require more setup. Setting up the form model Both reactive and template-driven forms track value changes between the form input elements that users interact with and the form data in your component model. The two approaches share underlying building blocks, but differ in how you create and manage the common form-control instances. Common form foundation classes Both reactive and template-driven forms are built on the following base classes. Base classes D",
    "id": "forms-*-overview-*-angular-6"
  },
  {
    "url": "https://angular.dev/guide/forms",
    "title": "Forms • Overview • Angular",
    "chunk": "etails FormControl Tracks the value and validation status of an individual form control. FormGroup Tracks the same values and status for a collection of form controls. FormArray Tracks the same values and status for an array of form controls. ControlValueAccessor Creates a bridge between Angular FormControl instances and built-in DOM elements. Setup in reactive forms With reactive forms, you define the form model directly in the component class. The [formControl] directive links the explicitly c",
    "id": "forms-*-overview-*-angular-7"
  },
  {
    "url": "https://angular.dev/guide/forms",
    "title": "Forms • Overview • Angular",
    "chunk": "reated FormControl instance to a specific form element in the view, using an internal value accessor. The following component implements an input field for a single control, using reactive forms. In this example, the form model is the FormControl instance. import {Component} from '@angular/core';import {FormControl, ReactiveFormsModule} from '@angular/forms';@Component({ selector: 'app-reactive-favorite-color', template: ` Favorite Color: <input type=\"text\" [formControl]=\"favoriteColorControl\"> ",
    "id": "forms-*-overview-*-angular-8"
  },
  {
    "url": "https://angular.dev/guide/forms",
    "title": "Forms • Overview • Angular",
    "chunk": "`, imports: [ReactiveFormsModule],})export class FavoriteColorReactiveComponent { favoriteColorControl = new FormControl('');} IMPORTANT: In reactive forms, the form model is the source of truth; it provides the value and status of the form element at any given point in time, through the [formControl] directive on the <input> element. Setup in template-driven forms In template-driven forms, the form model is implicit, rather than explicit. The directive NgModel creates and manages a FormControl ",
    "id": "forms-*-overview-*-angular-9"
  },
  {
    "url": "https://angular.dev/guide/forms",
    "title": "Forms • Overview • Angular",
    "chunk": "instance for a given form element. The following component implements the same input field for a single control, using template-driven forms. import {Component} from '@angular/core';import {FormsModule} from '@angular/forms';@Component({ selector: 'app-template-favorite-color', template: ` Favorite Color: <input type=\"text\" [(ngModel)]=\"favoriteColor\"> `, imports: [FormsModule],})export class FavoriteColorTemplateComponent { favoriteColor = '';} IMPORTANT: In a template-driven form the source of",
    "id": "forms-*-overview-*-angular-10"
  },
  {
    "url": "https://angular.dev/guide/forms",
    "title": "Forms • Overview • Angular",
    "chunk": " truth is the template. The NgModel directive automatically manages the FormControl instance for you. Data flow in forms When an application contains a form, Angular must keep the view in sync with the component model and the component model in sync with the view. As users change values and make selections through the view, the new values must be reflected in the data model. Similarly, when the program logic changes values in the data model, those values must be reflected in the view. Reactive a",
    "id": "forms-*-overview-*-angular-11"
  },
  {
    "url": "https://angular.dev/guide/forms",
    "title": "Forms • Overview • Angular",
    "chunk": "nd template-driven forms differ in how they handle data flowing from the user or from programmatic changes. The following diagrams illustrate both kinds of data flow for each type of form, using the favorite-color input field defined above. Data flow in reactive forms In reactive forms each form element in the view is directly linked to the form model (a FormControl instance). Updates from the view to the model and from the model to the view are synchronous and do not depend on how the UI is ren",
    "id": "forms-*-overview-*-angular-12"
  },
  {
    "url": "https://angular.dev/guide/forms",
    "title": "Forms • Overview • Angular",
    "chunk": "dered. The view-to-model diagram shows how data flows when an input field's value is changed from the view through the following steps. The user types a value into the input element, in this case the favorite color Blue. The form input element emits an \"input\" event with the latest value. The ControlValueAccessor listening for events on the form input element immediately relays the new value to the FormControl instance. The FormControl instance emits the new value through the valueChanges observ",
    "id": "forms-*-overview-*-angular-13"
  },
  {
    "url": "https://angular.dev/guide/forms",
    "title": "Forms • Overview • Angular",
    "chunk": "able. Any subscribers to the valueChanges observable receive the new value. #mermaid-generated-diagram{font-family:\"trebuchet ms\",verdana,arial,sans-serif;font-size:16px;fill:#333;}@keyframes edge-animation-frame{from{stroke-dashoffset:0;}}@keyframes dash{to{stroke-dashoffset:0;}}#mermaid-generated-diagram .edge-animation-slow{stroke-dasharray:9,5!important;stroke-dashoffset:900;animation:dash 50s linear infinite;stroke-linecap:round;}#mermaid-generated-diagram .edge-animation-fast{stroke-dashar",
    "id": "forms-*-overview-*-angular-14"
  },
  {
    "url": "https://angular.dev/guide/forms",
    "title": "Forms • Overview • Angular",
    "chunk": "ray:9,5!important;stroke-dashoffset:900;animation:dash 20s linear infinite;stroke-linecap:round;}#mermaid-generated-diagram .error-icon{fill:hsl(220.5882352941, 100%, 98.3333333333%);}#mermaid-generated-diagram .error-text{fill:rgb(8.5000000002, 5.7500000001, 0);stroke:rgb(8.5000000002, 5.7500000001, 0);}#mermaid-generated-diagram .edge-thickness-normal{stroke-width:1px;}#mermaid-generated-diagram .edge-thickness-thick{stroke-width:3.5px;}#mermaid-generated-diagram .edge-pattern-solid{stroke-das",
    "id": "forms-*-overview-*-angular-15"
  },
  {
    "url": "https://angular.dev/guide/forms",
    "title": "Forms • Overview • Angular",
    "chunk": "harray:0;}#mermaid-generated-diagram .edge-thickness-invisible{stroke-width:0;fill:none;}#mermaid-generated-diagram .edge-pattern-dashed{stroke-dasharray:3;}#mermaid-generated-diagram .edge-pattern-dotted{stroke-dasharray:2;}#mermaid-generated-diagram .marker{fill:#0b0b0b;stroke:#0b0b0b;}#mermaid-generated-diagram .marker.cross{stroke:#0b0b0b;}#mermaid-generated-diagram svg{font-family:\"trebuchet ms\",verdana,arial,sans-serif;font-size:16px;}#mermaid-generated-diagram p{margin:0;}#mermaid-generat",
    "id": "forms-*-overview-*-angular-16"
  },
  {
    "url": "https://angular.dev/guide/forms",
    "title": "Forms • Overview • Angular",
    "chunk": "ed-diagram .label{font-family:\"trebuchet ms\",verdana,arial,sans-serif;color:#333;}#mermaid-generated-diagram .cluster-label text{fill:rgb(8.5000000002, 5.7500000001, 0);}#mermaid-generated-diagram .cluster-label span{color:rgb(8.5000000002, 5.7500000001, 0);}#mermaid-generated-diagram .cluster-label span p{background-color:transparent;}#mermaid-generated-diagram .label text,#mermaid-generated-diagram span{fill:#333;color:#333;}#mermaid-generated-diagram .node rect,#mermaid-generated-diagram .nod",
    "id": "forms-*-overview-*-angular-17"
  },
  {
    "url": "https://angular.dev/guide/forms",
    "title": "Forms • Overview • Angular",
    "chunk": "e circle,#mermaid-generated-diagram .node ellipse,#mermaid-generated-diagram .node polygon,#mermaid-generated-diagram .node path{fill:#fff4dd;stroke:hsl(40.5882352941, 60%, 83.3333333333%);stroke-width:1px;}#mermaid-generated-diagram .rough-node .label text,#mermaid-generated-diagram .node .label text,#mermaid-generated-diagram .image-shape .label,#mermaid-generated-diagram .icon-shape .label{text-anchor:middle;}#mermaid-generated-diagram .node .katex path{fill:#000;stroke:#000;stroke-width:1px;",
    "id": "forms-*-overview-*-angular-18"
  },
  {
    "url": "https://angular.dev/guide/forms",
    "title": "Forms • Overview • Angular",
    "chunk": "}#mermaid-generated-diagram .rough-node .label,#mermaid-generated-diagram .node .label,#mermaid-generated-diagram .image-shape .label,#mermaid-generated-diagram .icon-shape .label{text-align:center;}#mermaid-generated-diagram .node.clickable{cursor:pointer;}#mermaid-generated-diagram .root .anchor path{fill:#0b0b0b!important;stroke-width:0;stroke:#0b0b0b;}#mermaid-generated-diagram .arrowheadPath{fill:#0b0b0b;}#mermaid-generated-diagram .edgePath .path{stroke:#0b0b0b;stroke-width:2.0px;}#mermaid",
    "id": "forms-*-overview-*-angular-19"
  },
  {
    "url": "https://angular.dev/guide/forms",
    "title": "Forms • Overview • Angular",
    "chunk": "-generated-diagram .flowchart-link{stroke:#0b0b0b;fill:none;}#mermaid-generated-diagram .edgeLabel{background-color:hsl(-79.4117647059, 100%, 93.3333333333%);text-align:center;}#mermaid-generated-diagram .edgeLabel p{background-color:hsl(-79.4117647059, 100%, 93.3333333333%);}#mermaid-generated-diagram .edgeLabel rect{opacity:0.5;background-color:hsl(-79.4117647059, 100%, 93.3333333333%);fill:hsl(-79.4117647059, 100%, 93.3333333333%);}#mermaid-generated-diagram .labelBkg{background-color:rgba(24",
    "id": "forms-*-overview-*-angular-20"
  },
  {
    "url": "https://angular.dev/guide/forms",
    "title": "Forms • Overview • Angular",
    "chunk": "3.9999999999, 220.9999999998, 255, 0.5);}#mermaid-generated-diagram .cluster rect{fill:hsl(220.5882352941, 100%, 98.3333333333%);stroke:hsl(220.5882352941, 60%, 88.3333333333%);stroke-width:1px;}#mermaid-generated-diagram .cluster text{fill:rgb(8.5000000002, 5.7500000001, 0);}#mermaid-generated-diagram .cluster span{color:rgb(8.5000000002, 5.7500000001, 0);}#mermaid-generated-diagram div.mermaidTooltip{position:absolute;text-align:center;max-width:200px;padding:2px;font-family:\"trebuchet ms\",ver",
    "id": "forms-*-overview-*-angular-21"
  },
  {
    "url": "https://angular.dev/guide/forms",
    "title": "Forms • Overview • Angular",
    "chunk": "dana,arial,sans-serif;font-size:12px;background:hsl(220.5882352941, 100%, 98.3333333333%);border:1px solid hsl(220.5882352941, 60%, 88.3333333333%);border-radius:2px;pointer-events:none;z-index:100;}#mermaid-generated-diagram .flowchartTitleText{text-anchor:middle;font-size:18px;fill:#333;}#mermaid-generated-diagram rect.text{fill:none;stroke-width:0;}#mermaid-generated-diagram .icon-shape,#mermaid-generated-diagram .image-shape{background-color:hsl(-79.4117647059, 100%, 93.3333333333%);text-ali",
    "id": "forms-*-overview-*-angular-22"
  },
  {
    "url": "https://angular.dev/guide/forms",
    "title": "Forms • Overview • Angular",
    "chunk": "gn:center;}#mermaid-generated-diagram .icon-shape p,#mermaid-generated-diagram .image-shape p{background-color:hsl(-79.4117647059, 100%, 93.3333333333%);padding:2px;}#mermaid-generated-diagram .icon-shape rect,#mermaid-generated-diagram .image-shape rect{opacity:0.5;background-color:hsl(-79.4117647059, 100%, 93.3333333333%);fill:hsl(-79.4117647059, 100%, 93.3333333333%);}#mermaid-generated-diagram :root{--mermaid-font-family:\"trebuchet ms\",verdana,arial,sans-serif;}Types in the input boxFires th",
    "id": "forms-*-overview-*-angular-23"
  },
  {
    "url": "https://angular.dev/guide/forms",
    "title": "Forms • Overview • Angular",
    "chunk": "e 'input' eventCalls setValue() on the FormControlFires a 'valueChanges' event to observersUser<input>ControlValueAccessorFormControlObserversThe model-to-view diagram shows how a programmatic change to the model is propagated to the view through the following steps. The user calls the favoriteColorControl.setValue() method, which updates the FormControl value. The FormControl instance emits the new value through the valueChanges observable. Any subscribers to the valueChanges observable receive",
    "id": "forms-*-overview-*-angular-24"
  },
  {
    "url": "https://angular.dev/guide/forms",
    "title": "Forms • Overview • Angular",
    "chunk": " the new value. The control value accessor on the form input element updates the element with the new value. #mermaid-generated-diagram{font-family:\"trebuchet ms\",verdana,arial,sans-serif;font-size:16px;fill:#333;}@keyframes edge-animation-frame{from{stroke-dashoffset:0;}}@keyframes dash{to{stroke-dashoffset:0;}}#mermaid-generated-diagram .edge-animation-slow{stroke-dasharray:9,5!important;stroke-dashoffset:900;animation:dash 50s linear infinite;stroke-linecap:round;}#mermaid-generated-diagram .",
    "id": "forms-*-overview-*-angular-25"
  },
  {
    "url": "https://angular.dev/guide/forms",
    "title": "Forms • Overview • Angular",
    "chunk": "edge-animation-fast{stroke-dasharray:9,5!important;stroke-dashoffset:900;animation:dash 20s linear infinite;stroke-linecap:round;}#mermaid-generated-diagram .error-icon{fill:hsl(220.5882352941, 100%, 98.3333333333%);}#mermaid-generated-diagram .error-text{fill:rgb(8.5000000002, 5.7500000001, 0);stroke:rgb(8.5000000002, 5.7500000001, 0);}#mermaid-generated-diagram .edge-thickness-normal{stroke-width:1px;}#mermaid-generated-diagram .edge-thickness-thick{stroke-width:3.5px;}#mermaid-generated-diagr",
    "id": "forms-*-overview-*-angular-26"
  },
  {
    "url": "https://angular.dev/guide/forms",
    "title": "Forms • Overview • Angular",
    "chunk": "am .edge-pattern-solid{stroke-dasharray:0;}#mermaid-generated-diagram .edge-thickness-invisible{stroke-width:0;fill:none;}#mermaid-generated-diagram .edge-pattern-dashed{stroke-dasharray:3;}#mermaid-generated-diagram .edge-pattern-dotted{stroke-dasharray:2;}#mermaid-generated-diagram .marker{fill:#0b0b0b;stroke:#0b0b0b;}#mermaid-generated-diagram .marker.cross{stroke:#0b0b0b;}#mermaid-generated-diagram svg{font-family:\"trebuchet ms\",verdana,arial,sans-serif;font-size:16px;}#mermaid-generated-dia",
    "id": "forms-*-overview-*-angular-27"
  },
  {
    "url": "https://angular.dev/guide/forms",
    "title": "Forms • Overview • Angular",
    "chunk": "gram p{margin:0;}#mermaid-generated-diagram .label{font-family:\"trebuchet ms\",verdana,arial,sans-serif;color:#333;}#mermaid-generated-diagram .cluster-label text{fill:rgb(8.5000000002, 5.7500000001, 0);}#mermaid-generated-diagram .cluster-label span{color:rgb(8.5000000002, 5.7500000001, 0);}#mermaid-generated-diagram .cluster-label span p{background-color:transparent;}#mermaid-generated-diagram .label text,#mermaid-generated-diagram span{fill:#333;color:#333;}#mermaid-generated-diagram .node rec",
    "id": "forms-*-overview-*-angular-28"
  },
  {
    "url": "https://angular.dev/guide/forms",
    "title": "Forms • Overview • Angular",
    "chunk": "t,#mermaid-generated-diagram .node circle,#mermaid-generated-diagram .node ellipse,#mermaid-generated-diagram .node polygon,#mermaid-generated-diagram .node path{fill:#fff4dd;stroke:hsl(40.5882352941, 60%, 83.3333333333%);stroke-width:1px;}#mermaid-generated-diagram .rough-node .label text,#mermaid-generated-diagram .node .label text,#mermaid-generated-diagram .image-shape .label,#mermaid-generated-diagram .icon-shape .label{text-anchor:middle;}#mermaid-generated-diagram .node .katex path{fill:#",
    "id": "forms-*-overview-*-angular-29"
  },
  {
    "url": "https://angular.dev/guide/forms",
    "title": "Forms • Overview • Angular",
    "chunk": "000;stroke:#000;stroke-width:1px;}#mermaid-generated-diagram .rough-node .label,#mermaid-generated-diagram .node .label,#mermaid-generated-diagram .image-shape .label,#mermaid-generated-diagram .icon-shape .label{text-align:center;}#mermaid-generated-diagram .node.clickable{cursor:pointer;}#mermaid-generated-diagram .root .anchor path{fill:#0b0b0b!important;stroke-width:0;stroke:#0b0b0b;}#mermaid-generated-diagram .arrowheadPath{fill:#0b0b0b;}#mermaid-generated-diagram .edgePath .path{stroke:#0b",
    "id": "forms-*-overview-*-angular-30"
  },
  {
    "url": "https://angular.dev/guide/forms",
    "title": "Forms • Overview • Angular",
    "chunk": "0b0b;stroke-width:2.0px;}#mermaid-generated-diagram .flowchart-link{stroke:#0b0b0b;fill:none;}#mermaid-generated-diagram .edgeLabel{background-color:hsl(-79.4117647059, 100%, 93.3333333333%);text-align:center;}#mermaid-generated-diagram .edgeLabel p{background-color:hsl(-79.4117647059, 100%, 93.3333333333%);}#mermaid-generated-diagram .edgeLabel rect{opacity:0.5;background-color:hsl(-79.4117647059, 100%, 93.3333333333%);fill:hsl(-79.4117647059, 100%, 93.3333333333%);}#mermaid-generated-diagram .",
    "id": "forms-*-overview-*-angular-31"
  },
  {
    "url": "https://angular.dev/guide/forms",
    "title": "Forms • Overview • Angular",
    "chunk": "labelBkg{background-color:rgba(243.9999999999, 220.9999999998, 255, 0.5);}#mermaid-generated-diagram .cluster rect{fill:hsl(220.5882352941, 100%, 98.3333333333%);stroke:hsl(220.5882352941, 60%, 88.3333333333%);stroke-width:1px;}#mermaid-generated-diagram .cluster text{fill:rgb(8.5000000002, 5.7500000001, 0);}#mermaid-generated-diagram .cluster span{color:rgb(8.5000000002, 5.7500000001, 0);}#mermaid-generated-diagram div.mermaidTooltip{position:absolute;text-align:center;max-width:200px;padding:2",
    "id": "forms-*-overview-*-angular-32"
  },
  {
    "url": "https://angular.dev/guide/forms",
    "title": "Forms • Overview • Angular",
    "chunk": "px;font-family:\"trebuchet ms\",verdana,arial,sans-serif;font-size:12px;background:hsl(220.5882352941, 100%, 98.3333333333%);border:1px solid hsl(220.5882352941, 60%, 88.3333333333%);border-radius:2px;pointer-events:none;z-index:100;}#mermaid-generated-diagram .flowchartTitleText{text-anchor:middle;font-size:18px;fill:#333;}#mermaid-generated-diagram rect.text{fill:none;stroke-width:0;}#mermaid-generated-diagram .icon-shape,#mermaid-generated-diagram .image-shape{background-color:hsl(-79.411764705",
    "id": "forms-*-overview-*-angular-33"
  },
  {
    "url": "https://angular.dev/guide/forms",
    "title": "Forms • Overview • Angular",
    "chunk": "9, 100%, 93.3333333333%);text-align:center;}#mermaid-generated-diagram .icon-shape p,#mermaid-generated-diagram .image-shape p{background-color:hsl(-79.4117647059, 100%, 93.3333333333%);padding:2px;}#mermaid-generated-diagram .icon-shape rect,#mermaid-generated-diagram .image-shape rect{opacity:0.5;background-color:hsl(-79.4117647059, 100%, 93.3333333333%);fill:hsl(-79.4117647059, 100%, 93.3333333333%);}#mermaid-generated-diagram :root{--mermaid-font-family:\"trebuchet ms\",verdana,arial,sans-seri",
    "id": "forms-*-overview-*-angular-34"
  },
  {
    "url": "https://angular.dev/guide/forms",
    "title": "Forms • Overview • Angular",
    "chunk": "f;}Calls setValue() on the FormControlNotifies the ControlValueAccessorFires a 'valueChanges' event to observersUpdates the value of the <input>User<input>ControlValueAccessorFormControlObservers Data flow in template-driven forms In template-driven forms, each form element is linked to a directive that manages the form model internally. The view-to-model diagram shows how data flows when an input field's value is changed from the view through the following steps. The user types Blue into the in",
    "id": "forms-*-overview-*-angular-35"
  },
  {
    "url": "https://angular.dev/guide/forms",
    "title": "Forms • Overview • Angular",
    "chunk": "put element. The input element emits an \"input\" event with the value Blue. The control value accessor attached to the input triggers the setValue() method on the FormControl instance. The FormControl instance emits the new value through the valueChanges observable. Any subscribers to the valueChanges observable receive the new value. The control value accessor also calls the NgModel.viewToModelUpdate() method which emits an ngModelChange event. Because the component template uses two-way data bi",
    "id": "forms-*-overview-*-angular-36"
  },
  {
    "url": "https://angular.dev/guide/forms",
    "title": "Forms • Overview • Angular",
    "chunk": "nding for the favoriteColor property, the favoriteColor property in the component is updated to the value emitted by the ngModelChange event (Blue). #mermaid-generated-diagram{font-family:\"trebuchet ms\",verdana,arial,sans-serif;font-size:16px;fill:#333;}@keyframes edge-animation-frame{from{stroke-dashoffset:0;}}@keyframes dash{to{stroke-dashoffset:0;}}#mermaid-generated-diagram .edge-animation-slow{stroke-dasharray:9,5!important;stroke-dashoffset:900;animation:dash 50s linear infinite;stroke-lin",
    "id": "forms-*-overview-*-angular-37"
  },
  {
    "url": "https://angular.dev/guide/forms",
    "title": "Forms • Overview • Angular",
    "chunk": "ecap:round;}#mermaid-generated-diagram .edge-animation-fast{stroke-dasharray:9,5!important;stroke-dashoffset:900;animation:dash 20s linear infinite;stroke-linecap:round;}#mermaid-generated-diagram .error-icon{fill:hsl(220.5882352941, 100%, 98.3333333333%);}#mermaid-generated-diagram .error-text{fill:rgb(8.5000000002, 5.7500000001, 0);stroke:rgb(8.5000000002, 5.7500000001, 0);}#mermaid-generated-diagram .edge-thickness-normal{stroke-width:1px;}#mermaid-generated-diagram .edge-thickness-thick{stro",
    "id": "forms-*-overview-*-angular-38"
  },
  {
    "url": "https://angular.dev/guide/forms",
    "title": "Forms • Overview • Angular",
    "chunk": "ke-width:3.5px;}#mermaid-generated-diagram .edge-pattern-solid{stroke-dasharray:0;}#mermaid-generated-diagram .edge-thickness-invisible{stroke-width:0;fill:none;}#mermaid-generated-diagram .edge-pattern-dashed{stroke-dasharray:3;}#mermaid-generated-diagram .edge-pattern-dotted{stroke-dasharray:2;}#mermaid-generated-diagram .marker{fill:#0b0b0b;stroke:#0b0b0b;}#mermaid-generated-diagram .marker.cross{stroke:#0b0b0b;}#mermaid-generated-diagram svg{font-family:\"trebuchet ms\",verdana,arial,sans-seri",
    "id": "forms-*-overview-*-angular-39"
  },
  {
    "url": "https://angular.dev/guide/forms",
    "title": "Forms • Overview • Angular",
    "chunk": "f;font-size:16px;}#mermaid-generated-diagram p{margin:0;}#mermaid-generated-diagram .label{font-family:\"trebuchet ms\",verdana,arial,sans-serif;color:#333;}#mermaid-generated-diagram .cluster-label text{fill:rgb(8.5000000002, 5.7500000001, 0);}#mermaid-generated-diagram .cluster-label span{color:rgb(8.5000000002, 5.7500000001, 0);}#mermaid-generated-diagram .cluster-label span p{background-color:transparent;}#mermaid-generated-diagram .label text,#mermaid-generated-diagram span{fill:#333;color:#3",
    "id": "forms-*-overview-*-angular-40"
  },
  {
    "url": "https://angular.dev/guide/forms",
    "title": "Forms • Overview • Angular",
    "chunk": "33;}#mermaid-generated-diagram .node rect,#mermaid-generated-diagram .node circle,#mermaid-generated-diagram .node ellipse,#mermaid-generated-diagram .node polygon,#mermaid-generated-diagram .node path{fill:#fff4dd;stroke:hsl(40.5882352941, 60%, 83.3333333333%);stroke-width:1px;}#mermaid-generated-diagram .rough-node .label text,#mermaid-generated-diagram .node .label text,#mermaid-generated-diagram .image-shape .label,#mermaid-generated-diagram .icon-shape .label{text-anchor:middle;}#mermaid-ge",
    "id": "forms-*-overview-*-angular-41"
  },
  {
    "url": "https://angular.dev/guide/forms",
    "title": "Forms • Overview • Angular",
    "chunk": "nerated-diagram .node .katex path{fill:#000;stroke:#000;stroke-width:1px;}#mermaid-generated-diagram .rough-node .label,#mermaid-generated-diagram .node .label,#mermaid-generated-diagram .image-shape .label,#mermaid-generated-diagram .icon-shape .label{text-align:center;}#mermaid-generated-diagram .node.clickable{cursor:pointer;}#mermaid-generated-diagram .root .anchor path{fill:#0b0b0b!important;stroke-width:0;stroke:#0b0b0b;}#mermaid-generated-diagram .arrowheadPath{fill:#0b0b0b;}#mermaid-gene",
    "id": "forms-*-overview-*-angular-42"
  },
  {
    "url": "https://angular.dev/guide/forms",
    "title": "Forms • Overview • Angular",
    "chunk": "rated-diagram .edgePath .path{stroke:#0b0b0b;stroke-width:2.0px;}#mermaid-generated-diagram .flowchart-link{stroke:#0b0b0b;fill:none;}#mermaid-generated-diagram .edgeLabel{background-color:hsl(-79.4117647059, 100%, 93.3333333333%);text-align:center;}#mermaid-generated-diagram .edgeLabel p{background-color:hsl(-79.4117647059, 100%, 93.3333333333%);}#mermaid-generated-diagram .edgeLabel rect{opacity:0.5;background-color:hsl(-79.4117647059, 100%, 93.3333333333%);fill:hsl(-79.4117647059, 100%, 93.33",
    "id": "forms-*-overview-*-angular-43"
  },
  {
    "url": "https://angular.dev/guide/forms",
    "title": "Forms • Overview • Angular",
    "chunk": "33333333%);}#mermaid-generated-diagram .labelBkg{background-color:rgba(243.9999999999, 220.9999999998, 255, 0.5);}#mermaid-generated-diagram .cluster rect{fill:hsl(220.5882352941, 100%, 98.3333333333%);stroke:hsl(220.5882352941, 60%, 88.3333333333%);stroke-width:1px;}#mermaid-generated-diagram .cluster text{fill:rgb(8.5000000002, 5.7500000001, 0);}#mermaid-generated-diagram .cluster span{color:rgb(8.5000000002, 5.7500000001, 0);}#mermaid-generated-diagram div.mermaidTooltip{position:absolute;tex",
    "id": "forms-*-overview-*-angular-44"
  },
  {
    "url": "https://angular.dev/guide/forms",
    "title": "Forms • Overview • Angular",
    "chunk": "t-align:center;max-width:200px;padding:2px;font-family:\"trebuchet ms\",verdana,arial,sans-serif;font-size:12px;background:hsl(220.5882352941, 100%, 98.3333333333%);border:1px solid hsl(220.5882352941, 60%, 88.3333333333%);border-radius:2px;pointer-events:none;z-index:100;}#mermaid-generated-diagram .flowchartTitleText{text-anchor:middle;font-size:18px;fill:#333;}#mermaid-generated-diagram rect.text{fill:none;stroke-width:0;}#mermaid-generated-diagram .icon-shape,#mermaid-generated-diagram .image-",
    "id": "forms-*-overview-*-angular-45"
  },
  {
    "url": "https://angular.dev/guide/forms",
    "title": "Forms • Overview • Angular",
    "chunk": "shape{background-color:hsl(-79.4117647059, 100%, 93.3333333333%);text-align:center;}#mermaid-generated-diagram .icon-shape p,#mermaid-generated-diagram .image-shape p{background-color:hsl(-79.4117647059, 100%, 93.3333333333%);padding:2px;}#mermaid-generated-diagram .icon-shape rect,#mermaid-generated-diagram .image-shape rect{opacity:0.5;background-color:hsl(-79.4117647059, 100%, 93.3333333333%);fill:hsl(-79.4117647059, 100%, 93.3333333333%);}#mermaid-generated-diagram :root{--mermaid-font-famil",
    "id": "forms-*-overview-*-angular-46"
  },
  {
    "url": "https://angular.dev/guide/forms",
    "title": "Forms • Overview • Angular",
    "chunk": "y:\"trebuchet ms\",verdana,arial,sans-serif;}Types in the input boxFires the 'input' eventCalls setValue() on the FormControlFires a 'valueChanges' event to observersCalls viewToModelUpdate()Emits an ngModelChange eventUpdates the value of the two-way bound propertyUser<input>ControlValueAccessorFormControlNgModelObserversComponentTwo-way bindingThe model-to-view diagram shows how data flows from model to view when the favoriteColor changes from Blue to Red, through the following steps The favorit",
    "id": "forms-*-overview-*-angular-47"
  },
  {
    "url": "https://angular.dev/guide/forms",
    "title": "Forms • Overview • Angular",
    "chunk": "eColor value is updated in the component. Change detection begins. During change detection, the ngOnChanges lifecycle hook is called on the NgModel directive instance because the value of one of its inputs has changed. The ngOnChanges() method queues an async task to set the value for the internal FormControl instance. Change detection completes. On the next tick, the task to set the FormControl instance value is executed. The FormControl instance emits the latest value through the valueChanges ",
    "id": "forms-*-overview-*-angular-48"
  },
  {
    "url": "https://angular.dev/guide/forms",
    "title": "Forms • Overview • Angular",
    "chunk": "observable. Any subscribers to the valueChanges observable receive the new value. The control value accessor updates the form input element in the view with the latest favoriteColor value. #mermaid-generated-diagram{font-family:\"trebuchet ms\",verdana,arial,sans-serif;font-size:16px;fill:#333;}@keyframes edge-animation-frame{from{stroke-dashoffset:0;}}@keyframes dash{to{stroke-dashoffset:0;}}#mermaid-generated-diagram .edge-animation-slow{stroke-dasharray:9,5!important;stroke-dashoffset:900;anima",
    "id": "forms-*-overview-*-angular-49"
  },
  {
    "url": "https://angular.dev/guide/forms",
    "title": "Forms • Overview • Angular",
    "chunk": "tion:dash 50s linear infinite;stroke-linecap:round;}#mermaid-generated-diagram .edge-animation-fast{stroke-dasharray:9,5!important;stroke-dashoffset:900;animation:dash 20s linear infinite;stroke-linecap:round;}#mermaid-generated-diagram .error-icon{fill:hsl(220.5882352941, 100%, 98.3333333333%);}#mermaid-generated-diagram .error-text{fill:rgb(8.5000000002, 5.7500000001, 0);stroke:rgb(8.5000000002, 5.7500000001, 0);}#mermaid-generated-diagram .edge-thickness-normal{stroke-width:1px;}#mermaid-gene",
    "id": "forms-*-overview-*-angular-50"
  },
  {
    "url": "https://angular.dev/guide/forms",
    "title": "Forms • Overview • Angular",
    "chunk": "rated-diagram .edge-thickness-thick{stroke-width:3.5px;}#mermaid-generated-diagram .edge-pattern-solid{stroke-dasharray:0;}#mermaid-generated-diagram .edge-thickness-invisible{stroke-width:0;fill:none;}#mermaid-generated-diagram .edge-pattern-dashed{stroke-dasharray:3;}#mermaid-generated-diagram .edge-pattern-dotted{stroke-dasharray:2;}#mermaid-generated-diagram .marker{fill:#0b0b0b;stroke:#0b0b0b;}#mermaid-generated-diagram .marker.cross{stroke:#0b0b0b;}#mermaid-generated-diagram svg{font-famil",
    "id": "forms-*-overview-*-angular-51"
  },
  {
    "url": "https://angular.dev/guide/forms",
    "title": "Forms • Overview • Angular",
    "chunk": "y:\"trebuchet ms\",verdana,arial,sans-serif;font-size:16px;}#mermaid-generated-diagram p{margin:0;}#mermaid-generated-diagram .label{font-family:\"trebuchet ms\",verdana,arial,sans-serif;color:#333;}#mermaid-generated-diagram .cluster-label text{fill:rgb(8.5000000002, 5.7500000001, 0);}#mermaid-generated-diagram .cluster-label span{color:rgb(8.5000000002, 5.7500000001, 0);}#mermaid-generated-diagram .cluster-label span p{background-color:transparent;}#mermaid-generated-diagram .label text,#mermaid-g",
    "id": "forms-*-overview-*-angular-52"
  },
  {
    "url": "https://angular.dev/guide/forms",
    "title": "Forms • Overview • Angular",
    "chunk": "enerated-diagram span{fill:#333;color:#333;}#mermaid-generated-diagram .node rect,#mermaid-generated-diagram .node circle,#mermaid-generated-diagram .node ellipse,#mermaid-generated-diagram .node polygon,#mermaid-generated-diagram .node path{fill:#fff4dd;stroke:hsl(40.5882352941, 60%, 83.3333333333%);stroke-width:1px;}#mermaid-generated-diagram .rough-node .label text,#mermaid-generated-diagram .node .label text,#mermaid-generated-diagram .image-shape .label,#mermaid-generated-diagram .icon-shap",
    "id": "forms-*-overview-*-angular-53"
  },
  {
    "url": "https://angular.dev/guide/forms",
    "title": "Forms • Overview • Angular",
    "chunk": "e .label{text-anchor:middle;}#mermaid-generated-diagram .node .katex path{fill:#000;stroke:#000;stroke-width:1px;}#mermaid-generated-diagram .rough-node .label,#mermaid-generated-diagram .node .label,#mermaid-generated-diagram .image-shape .label,#mermaid-generated-diagram .icon-shape .label{text-align:center;}#mermaid-generated-diagram .node.clickable{cursor:pointer;}#mermaid-generated-diagram .root .anchor path{fill:#0b0b0b!important;stroke-width:0;stroke:#0b0b0b;}#mermaid-generated-diagram .a",
    "id": "forms-*-overview-*-angular-54"
  },
  {
    "url": "https://angular.dev/guide/forms",
    "title": "Forms • Overview • Angular",
    "chunk": "rrowheadPath{fill:#0b0b0b;}#mermaid-generated-diagram .edgePath .path{stroke:#0b0b0b;stroke-width:2.0px;}#mermaid-generated-diagram .flowchart-link{stroke:#0b0b0b;fill:none;}#mermaid-generated-diagram .edgeLabel{background-color:hsl(-79.4117647059, 100%, 93.3333333333%);text-align:center;}#mermaid-generated-diagram .edgeLabel p{background-color:hsl(-79.4117647059, 100%, 93.3333333333%);}#mermaid-generated-diagram .edgeLabel rect{opacity:0.5;background-color:hsl(-79.4117647059, 100%, 93.333333333",
    "id": "forms-*-overview-*-angular-55"
  },
  {
    "url": "https://angular.dev/guide/forms",
    "title": "Forms • Overview • Angular",
    "chunk": "3%);fill:hsl(-79.4117647059, 100%, 93.3333333333%);}#mermaid-generated-diagram .labelBkg{background-color:rgba(243.9999999999, 220.9999999998, 255, 0.5);}#mermaid-generated-diagram .cluster rect{fill:hsl(220.5882352941, 100%, 98.3333333333%);stroke:hsl(220.5882352941, 60%, 88.3333333333%);stroke-width:1px;}#mermaid-generated-diagram .cluster text{fill:rgb(8.5000000002, 5.7500000001, 0);}#mermaid-generated-diagram .cluster span{color:rgb(8.5000000002, 5.7500000001, 0);}#mermaid-generated-diagram ",
    "id": "forms-*-overview-*-angular-56"
  },
  {
    "url": "https://angular.dev/guide/forms",
    "title": "Forms • Overview • Angular",
    "chunk": "div.mermaidTooltip{position:absolute;text-align:center;max-width:200px;padding:2px;font-family:\"trebuchet ms\",verdana,arial,sans-serif;font-size:12px;background:hsl(220.5882352941, 100%, 98.3333333333%);border:1px solid hsl(220.5882352941, 60%, 88.3333333333%);border-radius:2px;pointer-events:none;z-index:100;}#mermaid-generated-diagram .flowchartTitleText{text-anchor:middle;font-size:18px;fill:#333;}#mermaid-generated-diagram rect.text{fill:none;stroke-width:0;}#mermaid-generated-diagram .icon-",
    "id": "forms-*-overview-*-angular-57"
  },
  {
    "url": "https://angular.dev/guide/forms",
    "title": "Forms • Overview • Angular",
    "chunk": "shape,#mermaid-generated-diagram .image-shape{background-color:hsl(-79.4117647059, 100%, 93.3333333333%);text-align:center;}#mermaid-generated-diagram .icon-shape p,#mermaid-generated-diagram .image-shape p{background-color:hsl(-79.4117647059, 100%, 93.3333333333%);padding:2px;}#mermaid-generated-diagram .icon-shape rect,#mermaid-generated-diagram .image-shape rect{opacity:0.5;background-color:hsl(-79.4117647059, 100%, 93.3333333333%);fill:hsl(-79.4117647059, 100%, 93.3333333333%);}#mermaid-gene",
    "id": "forms-*-overview-*-angular-58"
  },
  {
    "url": "https://angular.dev/guide/forms",
    "title": "Forms • Overview • Angular",
    "chunk": "rated-diagram :root{--mermaid-font-family:\"trebuchet ms\",verdana,arial,sans-serif;}Updates the property valueTriggers CDAsync actions trigger a second round of Change DetectionSecond Change DetectionFires a 'valueChanges' event to observersControlValueAccessor receives valueChanges eventSets the value in the controlFormControlObserversControlValueAccessor<input>First Change DetectionAsynchronously sets FormControl valueNgModelFormControlComponentProperty bound to NgModel NOTE: NgModel triggers a",
    "id": "forms-*-overview-*-angular-59"
  },
  {
    "url": "https://angular.dev/guide/forms",
    "title": "Forms • Overview • Angular",
    "chunk": " second change detection to avoid ExpressionChangedAfterItHasBeenChecked errors, because the value change originates in an input binding. Mutability of the data model The change-tracking method plays a role in the efficiency of your application. Forms Details Reactive forms Keep the data model pure by providing it as an immutable data structure. Each time a change is triggered on the data model, the FormControl instance returns a new data model rather than updating the existing data model. This ",
    "id": "forms-*-overview-*-angular-60"
  },
  {
    "url": "https://angular.dev/guide/forms",
    "title": "Forms • Overview • Angular",
    "chunk": "gives you the ability to track unique changes to the data model through the control's observable. Change detection is more efficient because it only needs to update on unique changes. Because data updates follow reactive patterns, you can integrate with observable operators to transform data. Template-driven forms Rely on mutability with two-way data binding to update the data model in the component as changes are made in the template. Because there are no unique changes to track on the data mod",
    "id": "forms-*-overview-*-angular-61"
  },
  {
    "url": "https://angular.dev/guide/forms",
    "title": "Forms • Overview • Angular",
    "chunk": "el when using two-way data binding, change detection is less efficient at determining when updates are required. The difference is demonstrated in the previous examples that use the favorite-color input element. With reactive forms, the FormControl instance always returns a new value when the control's value is updated With template-driven forms, the favorite color property is always modified to its new value Form validation Validation is an integral part of managing any set of forms. Whether yo",
    "id": "forms-*-overview-*-angular-62"
  },
  {
    "url": "https://angular.dev/guide/forms",
    "title": "Forms • Overview • Angular",
    "chunk": "u're checking for required fields or querying an external API for an existing username, Angular provides a set of built-in validators as well as the ability to create custom validators. Forms Details Reactive forms Define custom validators as functions that receive a control to validate Template-driven forms Tied to template directives, and must provide custom validator directives that wrap validation functions For more information, see Form Validation. Testing Testing plays a large part in comp",
    "id": "forms-*-overview-*-angular-63"
  },
  {
    "url": "https://angular.dev/guide/forms",
    "title": "Forms • Overview • Angular",
    "chunk": "lex applications. A simpler testing strategy is useful when validating that your forms function correctly. Reactive forms and template-driven forms have different levels of reliance on rendering the UI to perform assertions based on form control and form field changes. The following examples demonstrate the process of testing forms with reactive and template-driven forms. Testing reactive forms Reactive forms provide a relatively straightforward testing strategy because they provide synchronous ",
    "id": "forms-*-overview-*-angular-64"
  },
  {
    "url": "https://angular.dev/guide/forms",
    "title": "Forms • Overview • Angular",
    "chunk": "access to the form and data models, and they can be tested without rendering the UI. In these tests, status and data are queried and manipulated through the control without interacting with the change detection cycle. The following tests use the favorite-color components from previous examples to verify the view-to-model and model-to-view data flows for a reactive form. Verifying view-to-model data flow The first example performs the following steps to verify the view-to-model data flow. Query t",
    "id": "forms-*-overview-*-angular-65"
  },
  {
    "url": "https://angular.dev/guide/forms",
    "title": "Forms • Overview • Angular",
    "chunk": "he view for the form input element, and create a custom \"input\" event for the test. Set the new value for the input to Red, and dispatch the \"input\" event on the form input element. Assert that the component's favoriteColorControl value matches the value from the input. Favorite color test - view to model import {ComponentFixture, TestBed, waitForAsync} from '@angular/core/testing';import {createNewEvent} from '../../shared/utils';import {FavoriteColorReactiveComponent} from './favorite-color.co",
    "id": "forms-*-overview-*-angular-66"
  },
  {
    "url": "https://angular.dev/guide/forms",
    "title": "Forms • Overview • Angular",
    "chunk": "mponent';describe('Favorite Color Component', () => { let component: FavoriteColorReactiveComponent; let fixture: ComponentFixture<FavoriteColorReactiveComponent>; beforeEach(waitForAsync(() => { TestBed.configureTestingModule({ declarations: [FavoriteColorReactiveComponent], }); })); beforeEach(() => { fixture = TestBed.createComponent(FavoriteColorReactiveComponent); component = fixture.componentInstance; fixture.detectChanges(); }); it('should create', () => { expect(component).toBeTruthy(); ",
    "id": "forms-*-overview-*-angular-67"
  },
  {
    "url": "https://angular.dev/guide/forms",
    "title": "Forms • Overview • Angular",
    "chunk": "}); it('should update the value of the input field', () => { const input = fixture.nativeElement.querySelector('input'); const event = createNewEvent('input'); input.value = 'Red'; input.dispatchEvent(event); expect(fixture.componentInstance.favoriteColorControl.value).toEqual('Red'); }); it('should update the value in the control', () => { component.favoriteColorControl.setValue('Blue'); const input = fixture.nativeElement.querySelector('input'); expect(input.value).toBe('Blue'); });}); The nex",
    "id": "forms-*-overview-*-angular-68"
  },
  {
    "url": "https://angular.dev/guide/forms",
    "title": "Forms • Overview • Angular",
    "chunk": "t example performs the following steps to verify the model-to-view data flow. Use the favoriteColorControl, a FormControl instance, to set the new value. Query the view for the form input element. Assert that the new value set on the control matches the value in the input. Favorite color test - model to view import {ComponentFixture, TestBed, waitForAsync} from '@angular/core/testing';import {createNewEvent} from '../../shared/utils';import {FavoriteColorReactiveComponent} from './favorite-color",
    "id": "forms-*-overview-*-angular-69"
  },
  {
    "url": "https://angular.dev/guide/forms",
    "title": "Forms • Overview • Angular",
    "chunk": ".component';describe('Favorite Color Component', () => { let component: FavoriteColorReactiveComponent; let fixture: ComponentFixture<FavoriteColorReactiveComponent>; beforeEach(waitForAsync(() => { TestBed.configureTestingModule({ declarations: [FavoriteColorReactiveComponent], }); })); beforeEach(() => { fixture = TestBed.createComponent(FavoriteColorReactiveComponent); component = fixture.componentInstance; fixture.detectChanges(); }); it('should create', () => { expect(component).toBeTruthy(",
    "id": "forms-*-overview-*-angular-70"
  },
  {
    "url": "https://angular.dev/guide/forms",
    "title": "Forms • Overview • Angular",
    "chunk": "); }); it('should update the value of the input field', () => { const input = fixture.nativeElement.querySelector('input'); const event = createNewEvent('input'); input.value = 'Red'; input.dispatchEvent(event); expect(fixture.componentInstance.favoriteColorControl.value).toEqual('Red'); }); it('should update the value in the control', () => { component.favoriteColorControl.setValue('Blue'); const input = fixture.nativeElement.querySelector('input'); expect(input.value).toBe('Blue'); });}); Test",
    "id": "forms-*-overview-*-angular-71"
  },
  {
    "url": "https://angular.dev/guide/forms",
    "title": "Forms • Overview • Angular",
    "chunk": "ing template-driven forms Writing tests with template-driven forms requires a detailed knowledge of the change detection process and an understanding of how directives run on each cycle to ensure that elements are queried, tested, or changed at the correct time. The following tests use the favorite color components mentioned earlier to verify the data flows from view to model and model to view for a template-driven form. The following test verifies the data flow from view to model. Favorite colo",
    "id": "forms-*-overview-*-angular-72"
  },
  {
    "url": "https://angular.dev/guide/forms",
    "title": "Forms • Overview • Angular",
    "chunk": "r test - view to model import {ComponentFixture, fakeAsync, TestBed, tick, waitForAsync} from '@angular/core/testing';import {createNewEvent} from '../../shared/utils';import {FavoriteColorTemplateComponent} from './favorite-color.component';describe('FavoriteColorComponent', () => { let component: FavoriteColorTemplateComponent; let fixture: ComponentFixture<FavoriteColorTemplateComponent>; beforeEach(waitForAsync(() => { TestBed.configureTestingModule({ declarations: [FavoriteColorTemplateComp",
    "id": "forms-*-overview-*-angular-73"
  },
  {
    "url": "https://angular.dev/guide/forms",
    "title": "Forms • Overview • Angular",
    "chunk": "onent], }); })); beforeEach(() => { fixture = TestBed.createComponent(FavoriteColorTemplateComponent); component = fixture.componentInstance; fixture.detectChanges(); }); it('should create', () => { expect(component).toBeTruthy(); }); it('should update the favorite color on the input field', fakeAsync(() => { component.favoriteColor = 'Blue'; fixture.detectChanges(); tick(); const input = fixture.nativeElement.querySelector('input'); expect(input.value).toBe('Blue'); })); it('should update the f",
    "id": "forms-*-overview-*-angular-74"
  },
  {
    "url": "https://angular.dev/guide/forms",
    "title": "Forms • Overview • Angular",
    "chunk": "avorite color in the component', fakeAsync(() => { const input = fixture.nativeElement.querySelector('input'); const event = createNewEvent('input'); input.value = 'Red'; input.dispatchEvent(event); fixture.detectChanges(); expect(component.favoriteColor).toEqual('Red'); }));}); Here are the steps performed in the view to model test. Query the view for the form input element, and create a custom \"input\" event for the test. Set the new value for the input to Red, and dispatch the \"input\" event on",
    "id": "forms-*-overview-*-angular-75"
  },
  {
    "url": "https://angular.dev/guide/forms",
    "title": "Forms • Overview • Angular",
    "chunk": " the form input element. Run change detection through the test fixture. Assert that the component favoriteColor property value matches the value from the input. The following test verifies the data flow from model to view. Favorite color test - model to view import {ComponentFixture, fakeAsync, TestBed, tick, waitForAsync} from '@angular/core/testing';import {createNewEvent} from '../../shared/utils';import {FavoriteColorTemplateComponent} from './favorite-color.component';describe('FavoriteColo",
    "id": "forms-*-overview-*-angular-76"
  },
  {
    "url": "https://angular.dev/guide/forms",
    "title": "Forms • Overview • Angular",
    "chunk": "rComponent', () => { let component: FavoriteColorTemplateComponent; let fixture: ComponentFixture<FavoriteColorTemplateComponent>; beforeEach(waitForAsync(() => { TestBed.configureTestingModule({ declarations: [FavoriteColorTemplateComponent], }); })); beforeEach(() => { fixture = TestBed.createComponent(FavoriteColorTemplateComponent); component = fixture.componentInstance; fixture.detectChanges(); }); it('should create', () => { expect(component).toBeTruthy(); }); it('should update the favorit",
    "id": "forms-*-overview-*-angular-77"
  },
  {
    "url": "https://angular.dev/guide/forms",
    "title": "Forms • Overview • Angular",
    "chunk": "e color on the input field', fakeAsync(() => { component.favoriteColor = 'Blue'; fixture.detectChanges(); tick(); const input = fixture.nativeElement.querySelector('input'); expect(input.value).toBe('Blue'); })); it('should update the favorite color in the component', fakeAsync(() => { const input = fixture.nativeElement.querySelector('input'); const event = createNewEvent('input'); input.value = 'Red'; input.dispatchEvent(event); fixture.detectChanges(); expect(component.favoriteColor).toEqual(",
    "id": "forms-*-overview-*-angular-78"
  },
  {
    "url": "https://angular.dev/guide/forms",
    "title": "Forms • Overview • Angular",
    "chunk": "'Red'); }));}); Here are the steps performed in the model to view test. Use the component instance to set the value of the favoriteColor property. Run change detection through the test fixture. Use the tick() method to simulate the passage of time within the fakeAsync() task. Query the view for the form input element. Assert that the input value matches the value of the favoriteColor property in the component instance. Next steps To learn more about reactive forms, see the following guides: Reac",
    "id": "forms-*-overview-*-angular-79"
  },
  {
    "url": "https://angular.dev/guide/forms",
    "title": "Forms • Overview • Angular",
    "chunk": "tive forms Form validation Dynamic forms To learn more about template-driven forms, see the following guides: Template Driven Forms tutorial Form validation NgForm directive API reference Social MediaBlogX (formerly Twitter)BlueskyYouTube Discord GitHub Stack Overflow Community Contribute Code of Conduct Report Issues Google's DevLibrary Angular Google Developer Experts ResourcesPress KitRoadmapLanguages简体中文版正體中文版日本語版한국어 Ελληνικά Super-powered by Google ©2010-2025. Code licensed under an MIT-sty",
    "id": "forms-*-overview-*-angular-80"
  },
  {
    "url": "https://angular.dev/guide/forms",
    "title": "Forms • Overview • Angular",
    "chunk": "le License . Documentation licensed under CC BY 4.0 . In-depth GuidesForms Forms in Angular Handling user input with forms is the cornerstone of many common applications.",
    "id": "forms-*-overview-*-angular-81"
  },
  {
    "url": "https://angular.dev/guide/forms/reactive-forms",
    "title": "Reactive forms • Angular",
    "chunk": "In-depth GuidesForms Reactive forms Reactive forms provide a model-driven approach to handling form inputs whose values change over time. This guide shows you how to create and update a basic form control, progress to using multiple controls in a group, validate form values, and create dynamic forms where you can add or remove controls at run time. On this pagearrow_upward_alt Back to the top Overview of reactive forms Reactive forms use an explicit and immutable approach to managing the state o",
    "id": "reactive-forms-*-angular-0"
  },
  {
    "url": "https://angular.dev/guide/forms/reactive-forms",
    "title": "Reactive forms • Angular",
    "chunk": "f a form at a given point in time. Each change to the form state returns a new state, which maintains the integrity of the model between changes. Reactive forms are built around observable streams, where form inputs and values are provided as streams of input values, which can be accessed synchronously. Reactive forms also provide a straightforward path to testing because you are assured that your data is consistent and predictable when requested. Any consumers of the streams have access to mani",
    "id": "reactive-forms-*-angular-1"
  },
  {
    "url": "https://angular.dev/guide/forms/reactive-forms",
    "title": "Reactive forms • Angular",
    "chunk": "pulate that data safely. Reactive forms differ from template-driven forms in distinct ways. Reactive forms provide synchronous access to the data model, immutability with observable operators, and change tracking through observable streams. Template-driven forms let direct access modify data in your template, but are less explicit than reactive forms because they rely on directives embedded in the template, along with mutable data to track changes asynchronously. See the Forms Overview for detai",
    "id": "reactive-forms-*-angular-2"
  },
  {
    "url": "https://angular.dev/guide/forms/reactive-forms",
    "title": "Reactive forms • Angular",
    "chunk": "led comparisons between the two paradigms. Adding a basic form control There are three steps to using form controls. Generate a new component and register the reactive forms module. This module declares the reactive-form directives that you need to use reactive forms. Instantiate a new FormControl. Register the FormControl in the template. You can then display the form by adding the component to the template. The following examples show how to add a single form control. In the example, the user ",
    "id": "reactive-forms-*-angular-3"
  },
  {
    "url": "https://angular.dev/guide/forms/reactive-forms",
    "title": "Reactive forms • Angular",
    "chunk": "enters their name into an input field, captures that input value, and displays the current value of the form control element. Generate a new component and import the ReactiveFormsModule Use the CLI command ng generate component to generate a component in your project and import ReactiveFormsModule from the @angular/forms package and add it to your Component's imports array. src/app/name-editor/name-editor.component.ts (excerpt) import {Component} from '@angular/core';import {FormControl, Reactiv",
    "id": "reactive-forms-*-angular-4"
  },
  {
    "url": "https://angular.dev/guide/forms/reactive-forms",
    "title": "Reactive forms • Angular",
    "chunk": "eFormsModule} from '@angular/forms';@Component({ selector: 'app-name-editor', templateUrl: './name-editor.component.html', styleUrls: ['./name-editor.component.css'], imports: [ReactiveFormsModule],})export class NameEditorComponent { name = new FormControl(''); updateName() { this.name.setValue('Nancy'); }} Declare a FormControl instance Use the constructor of FormControl to set its initial value, which in this case is an empty string. By creating these controls in your component class, you get",
    "id": "reactive-forms-*-angular-5"
  },
  {
    "url": "https://angular.dev/guide/forms/reactive-forms",
    "title": "Reactive forms • Angular",
    "chunk": " immediate access to listen for, update, and validate the state of the form input. src/app/name-editor/name-editor.component.ts import {Component} from '@angular/core';import {FormControl, ReactiveFormsModule} from '@angular/forms';@Component({ selector: 'app-name-editor', templateUrl: './name-editor.component.html', styleUrls: ['./name-editor.component.css'], imports: [ReactiveFormsModule],})export class NameEditorComponent { name = new FormControl(''); updateName() { this.name.setValue('Nancy'",
    "id": "reactive-forms-*-angular-6"
  },
  {
    "url": "https://angular.dev/guide/forms/reactive-forms",
    "title": "Reactive forms • Angular",
    "chunk": "); }} Register the control in the template After you create the control in the component class, you must associate it with a form control element in the template. Update the template with the form control using the formControl binding provided by FormControlDirective, which is also included in the ReactiveFormsModule. src/app/name-editor/name-editor.component.html <label for=\"name\">Name: </label><input id=\"name\" type=\"text\" [formControl]=\"name\"><p>Value: {{ name.value }}</p><button type=\"button\"",
    "id": "reactive-forms-*-angular-7"
  },
  {
    "url": "https://angular.dev/guide/forms/reactive-forms",
    "title": "Reactive forms • Angular",
    "chunk": " (click)=\"updateName()\">Update Name</button> Using the template binding syntax, the form control is now registered to the name input element in the template. The form control and DOM element communicate with each other: the view reflects changes in the model, and the model reflects changes in the view. Display the component The FormControl assigned to the name property is displayed when the <app-name-editor> component is added to a template. src/app/app.component.html (name editor) <h1>Reactive ",
    "id": "reactive-forms-*-angular-8"
  },
  {
    "url": "https://angular.dev/guide/forms/reactive-forms",
    "title": "Reactive forms • Angular",
    "chunk": "Forms</h1><app-name-editor /><app-profile-editor /> Displaying a form control value You can display the value in the following ways. Through the valueChanges observable where you can listen for changes in the form's value in the template using AsyncPipe or in the component class using the subscribe() method With the value property, which gives you a snapshot of the current value The following example shows you how to display the current value using interpolation in the template. src/app/name-edi",
    "id": "reactive-forms-*-angular-9"
  },
  {
    "url": "https://angular.dev/guide/forms/reactive-forms",
    "title": "Reactive forms • Angular",
    "chunk": "tor/name-editor.component.html (control value) <label for=\"name\">Name: </label><input id=\"name\" type=\"text\" [formControl]=\"name\"><p>Value: {{ name.value }}</p><button type=\"button\" (click)=\"updateName()\">Update Name</button> The displayed value changes as you update the form control element. Reactive forms provide access to information about a given control through properties and methods provided with each instance. These properties and methods of the underlying AbstractControl class are used to",
    "id": "reactive-forms-*-angular-10"
  },
  {
    "url": "https://angular.dev/guide/forms/reactive-forms",
    "title": "Reactive forms • Angular",
    "chunk": " control form state and determine when to display messages when handling input validation. Read about other FormControl properties and methods in the API Reference. Replacing a form control value Reactive forms have methods to change a control's value programmatically, which gives you the flexibility to update the value without user interaction. A form control instance provides a setValue() method that updates the value of the form control and validates the structure of the value provided agains",
    "id": "reactive-forms-*-angular-11"
  },
  {
    "url": "https://angular.dev/guide/forms/reactive-forms",
    "title": "Reactive forms • Angular",
    "chunk": "t the control's structure. For example, when retrieving form data from a backend API or service, use the setValue() method to update the control to its new value, replacing the old value entirely. The following example adds a method to the component class to update the value of the control to Nancy using the setValue() method. src/app/name-editor/name-editor.component.ts (update value) import {Component} from '@angular/core';import {FormControl, ReactiveFormsModule} from '@angular/forms';@Compon",
    "id": "reactive-forms-*-angular-12"
  },
  {
    "url": "https://angular.dev/guide/forms/reactive-forms",
    "title": "Reactive forms • Angular",
    "chunk": "ent({ selector: 'app-name-editor', templateUrl: './name-editor.component.html', styleUrls: ['./name-editor.component.css'], imports: [ReactiveFormsModule],})export class NameEditorComponent { name = new FormControl(''); updateName() { this.name.setValue('Nancy'); }} Update the template with a button to simulate a name update. When you click the Update Name button, the value entered in the form control element is reflected as its current value. src/app/name-editor/name-editor.component.html (upda",
    "id": "reactive-forms-*-angular-13"
  },
  {
    "url": "https://angular.dev/guide/forms/reactive-forms",
    "title": "Reactive forms • Angular",
    "chunk": "te value) <label for=\"name\">Name: </label><input id=\"name\" type=\"text\" [formControl]=\"name\"><p>Value: {{ name.value }}</p><button type=\"button\" (click)=\"updateName()\">Update Name</button> The form model is the source of truth for the control, so when you click the button, the value of the input is changed within the component class, overriding its current value. HELPFUL: In this example, you're using a single control. When using the setValue() method with a form group or form array instance, the",
    "id": "reactive-forms-*-angular-14"
  },
  {
    "url": "https://angular.dev/guide/forms/reactive-forms",
    "title": "Reactive forms • Angular",
    "chunk": " value needs to match the structure of the group or array. Grouping form controls Forms typically contain several related controls. Reactive forms provide two ways of grouping multiple related controls into a single input form. Form groups Details Form group Defines a form with a fixed set of controls that you can manage together. Form group basics are discussed in this section. You can also nest form groups to create more complex forms. Form array Defines a dynamic form, where you can add and r",
    "id": "reactive-forms-*-angular-15"
  },
  {
    "url": "https://angular.dev/guide/forms/reactive-forms",
    "title": "Reactive forms • Angular",
    "chunk": "emove controls at run time. You can also nest form arrays to create more complex forms. For more about this option, see Creating dynamic forms. Just as a form control instance gives you control over a single input field, a form group instance tracks the form state of a group of form control instances (for example, a form). Each control in a form group instance is tracked by name when creating the form group. The following example shows how to manage multiple form control instances in a single gr",
    "id": "reactive-forms-*-angular-16"
  },
  {
    "url": "https://angular.dev/guide/forms/reactive-forms",
    "title": "Reactive forms • Angular",
    "chunk": "oup. Generate a ProfileEditor component and import the FormGroup and FormControl classes from the @angular/forms package. ng generate component ProfileEditor src/app/profile-editor/profile-editor.component.ts (imports) import {Component} from '@angular/core';import {FormGroup, FormControl, ReactiveFormsModule} from '@angular/forms';@Component({ selector: 'app-profile-editor', templateUrl: './profile-editor.component.html', styleUrls: ['./profile-editor.component.css'], imports: [ReactiveFormsMod",
    "id": "reactive-forms-*-angular-17"
  },
  {
    "url": "https://angular.dev/guide/forms/reactive-forms",
    "title": "Reactive forms • Angular",
    "chunk": "ule],})export class ProfileEditorComponent { profileForm = new FormGroup({ firstName: new FormControl(''), lastName: new FormControl(''), address: new FormGroup({ street: new FormControl(''), city: new FormControl(''), state: new FormControl(''), zip: new FormControl(''), }), }); updateProfile() { this.profileForm.patchValue({ firstName: 'Nancy', address: { street: '123 Drew Street', }, }); }} To add a form group to this component, take the following steps. Create a FormGroup instance. Associate",
    "id": "reactive-forms-*-angular-18"
  },
  {
    "url": "https://angular.dev/guide/forms/reactive-forms",
    "title": "Reactive forms • Angular",
    "chunk": " the FormGroup model and view. Save the form data. Create a FormGroup instance Create a property in the component class named profileForm and set the property to a new form group instance. To initialize the form group, provide the constructor with an object of named keys mapped to their control. For the profile form, add two form control instances with the names firstName and lastName src/app/profile-editor/profile-editor.component.ts (form group) import {Component} from '@angular/core';import {",
    "id": "reactive-forms-*-angular-19"
  },
  {
    "url": "https://angular.dev/guide/forms/reactive-forms",
    "title": "Reactive forms • Angular",
    "chunk": "FormGroup, FormControl, ReactiveFormsModule} from '@angular/forms';@Component({ selector: 'app-profile-editor', templateUrl: './profile-editor.component.html', styleUrls: ['./profile-editor.component.css'], imports: [ReactiveFormsModule],})export class ProfileEditorComponent { profileForm = new FormGroup({ firstName: new FormControl(''), lastName: new FormControl(''), address: new FormGroup({ street: new FormControl(''), city: new FormControl(''), state: new FormControl(''), zip: new FormControl",
    "id": "reactive-forms-*-angular-20"
  },
  {
    "url": "https://angular.dev/guide/forms/reactive-forms",
    "title": "Reactive forms • Angular",
    "chunk": "(''), }), }); updateProfile() { this.profileForm.patchValue({ firstName: 'Nancy', address: { street: '123 Drew Street', }, }); }} The individual form controls are now collected within a group. A FormGroup instance provides its model value as an object reduced from the values of each control in the group. A form group instance has the same properties (such as value and untouched) and methods (such as setValue()) as a form control instance. Associate the FormGroup model and view A form group track",
    "id": "reactive-forms-*-angular-21"
  },
  {
    "url": "https://angular.dev/guide/forms/reactive-forms",
    "title": "Reactive forms • Angular",
    "chunk": "s the status and changes for each of its controls, so if one of the controls changes, the parent control also emits a new status or value change. The model for the group is maintained from its members. After you define the model, you must update the template to reflect the model in the view. src/app/profile-editor/profile-editor.component.html (template form group) <form [formGroup]=\"profileForm\"> <label for=\"first-name\">First Name: </label> <input id=\"first-name\" type=\"text\" formControlName=\"fi",
    "id": "reactive-forms-*-angular-22"
  },
  {
    "url": "https://angular.dev/guide/forms/reactive-forms",
    "title": "Reactive forms • Angular",
    "chunk": "rstName\" /> <label for=\"last-name\">Last Name: </label> <input id=\"last-name\" type=\"text\" formControlName=\"lastName\" /> <div formGroupName=\"address\"> <h2>Address</h2> <label for=\"street\">Street: </label> <input id=\"street\" type=\"text\" formControlName=\"street\" /> <label for=\"city\">City: </label> <input id=\"city\" type=\"text\" formControlName=\"city\" /> <label for=\"state\">State: </label> <input id=\"state\" type=\"text\" formControlName=\"state\" /> <label for=\"zip\">Zip Code: </label> <input id=\"zip\" type=\"",
    "id": "reactive-forms-*-angular-23"
  },
  {
    "url": "https://angular.dev/guide/forms/reactive-forms",
    "title": "Reactive forms • Angular",
    "chunk": "text\" formControlName=\"zip\" /> </div> <div formArrayName=\"aliases\"> <h2>Aliases</h2> <button type=\"button\" (click)=\"addAlias()\">+ Add another alias</button> @for(alias of aliases.controls; track $index; let i = $index) { <div> <!-- The repeated alias template --> <label for=\"alias-{{ i }}\">Alias: </label> <input id=\"alias-{{ i }}\" type=\"text\" [formControlName]=\"i\" /> </div> } </div></form><p>Form Value: {{ profileForm.value | json }}</p><button type=\"button\" (click)=\"updateProfile()\">Update Prof",
    "id": "reactive-forms-*-angular-24"
  },
  {
    "url": "https://angular.dev/guide/forms/reactive-forms",
    "title": "Reactive forms • Angular",
    "chunk": "ile</button> Just as a form group contains a group of controls, the profileForm FormGroup is bound to the form element with the FormGroup directive, creating a communication layer between the model and the form containing the inputs. The formControlName input provided by the FormControlName directive binds each individual input to the form control defined in FormGroup. The form controls communicate with their respective elements. They also communicate changes to the form group instance, which pr",
    "id": "reactive-forms-*-angular-25"
  },
  {
    "url": "https://angular.dev/guide/forms/reactive-forms",
    "title": "Reactive forms • Angular",
    "chunk": "ovides the source of truth for the model value. Save form data The ProfileEditor component accepts input from the user, but in a real scenario you want to capture the form value and make it available for further processing outside the component. The FormGroup directive listens for the submit event emitted by the form element and emits an ngSubmit event that you can bind to a callback function. Add an ngSubmit event listener to the form tag with the onSubmit() callback method. src/app/profile-edi",
    "id": "reactive-forms-*-angular-26"
  },
  {
    "url": "https://angular.dev/guide/forms/reactive-forms",
    "title": "Reactive forms • Angular",
    "chunk": "tor/profile-editor.component.html (submit event) <form [formGroup]=\"profileForm\" (ngSubmit)=\"onSubmit()\"> <label for=\"first-name\">First Name: </label> <input id=\"first-name\" type=\"text\" formControlName=\"firstName\" required /> <label for=\"last-name\">Last Name: </label> <input id=\"last-name\" type=\"text\" formControlName=\"lastName\" /> <div formGroupName=\"address\"> <h2>Address</h2> <label for=\"street\">Street: </label> <input id=\"street\" type=\"text\" formControlName=\"street\" /> <label for=\"city\">City: ",
    "id": "reactive-forms-*-angular-27"
  },
  {
    "url": "https://angular.dev/guide/forms/reactive-forms",
    "title": "Reactive forms • Angular",
    "chunk": "</label> <input id=\"city\" type=\"text\" formControlName=\"city\" /> <label for=\"state\">State: </label> <input id=\"state\" type=\"text\" formControlName=\"state\" /> <label for=\"zip\">Zip Code: </label> <input id=\"zip\" type=\"text\" formControlName=\"zip\" /> </div> <div formArrayName=\"aliases\"> <h2>Aliases</h2> <button type=\"button\" (click)=\"addAlias()\">+ Add another alias</button> @for (alias of aliases.controls; track $index; let i = $index) { <div> <!-- The repeated alias template --> <label for=\"alias-{{ ",
    "id": "reactive-forms-*-angular-28"
  },
  {
    "url": "https://angular.dev/guide/forms/reactive-forms",
    "title": "Reactive forms • Angular",
    "chunk": "i }}\">Alias:</label> <input id=\"alias-{{ i }}\" type=\"text\" [formControlName]=\"i\" /> </div> } </div> <p>Complete the form to enable button.</p> <button type=\"submit\" [disabled]=\"!profileForm.valid\">Submit</button></form><hr><p>Form Value: {{ profileForm.value | json }}</p><p>Form Status: {{ profileForm.status }}</p><button type=\"button\" (click)=\"updateProfile()\">Update Profile</button> The onSubmit() method in the ProfileEditor component captures the current value of profileForm. Use EventEmitter",
    "id": "reactive-forms-*-angular-29"
  },
  {
    "url": "https://angular.dev/guide/forms/reactive-forms",
    "title": "Reactive forms • Angular",
    "chunk": " to keep the form encapsulated and to provide the form value outside the component. The following example uses console.warn to log a message to the browser console. src/app/profile-editor/profile-editor.component.ts (submit method) import {Component, inject} from '@angular/core';import {FormBuilder, ReactiveFormsModule} from '@angular/forms';import {Validators} from '@angular/forms';import {FormArray} from '@angular/forms';import {JsonPipe} from '@angular/common';@Component({ selector: 'app-prof",
    "id": "reactive-forms-*-angular-30"
  },
  {
    "url": "https://angular.dev/guide/forms/reactive-forms",
    "title": "Reactive forms • Angular",
    "chunk": "ile-editor', templateUrl: './profile-editor.component.html', styleUrls: ['./profile-editor.component.css'], imports: [ReactiveFormsModule, JsonPipe],})export class ProfileEditorComponent { private formBuilder = inject(FormBuilder); profileForm = this.formBuilder.group({ firstName: ['', Validators.required], lastName: [''], address: this.formBuilder.group({ street: [''], city: [''], state: [''], zip: [''], }), aliases: this.formBuilder.array([this.formBuilder.control('')]), }); get aliases() { re",
    "id": "reactive-forms-*-angular-31"
  },
  {
    "url": "https://angular.dev/guide/forms/reactive-forms",
    "title": "Reactive forms • Angular",
    "chunk": "turn this.profileForm.get('aliases') as FormArray; } updateProfile() { this.profileForm.patchValue({ firstName: 'Nancy', address: { street: '123 Drew Street', }, }); } addAlias() { this.aliases.push(this.formBuilder.control('')); } onSubmit() { // TODO: Use EventEmitter with form value console.warn(this.profileForm.value); }} The submit event is emitted by the form tag using the built-in DOM event. You trigger the event by clicking a button with submit type. This lets the user press the Enter ke",
    "id": "reactive-forms-*-angular-32"
  },
  {
    "url": "https://angular.dev/guide/forms/reactive-forms",
    "title": "Reactive forms • Angular",
    "chunk": "y to submit the completed form. Use a button element to add a button to the bottom of the form to trigger the form submission. src/app/profile-editor/profile-editor.component.html (submit button) <form [formGroup]=\"profileForm\" (ngSubmit)=\"onSubmit()\"> <label for=\"first-name\">First Name: </label> <input id=\"first-name\" type=\"text\" formControlName=\"firstName\" required /> <label for=\"last-name\">Last Name: </label> <input id=\"last-name\" type=\"text\" formControlName=\"lastName\" /> <div formGroupName=\"",
    "id": "reactive-forms-*-angular-33"
  },
  {
    "url": "https://angular.dev/guide/forms/reactive-forms",
    "title": "Reactive forms • Angular",
    "chunk": "address\"> <h2>Address</h2> <label for=\"street\">Street: </label> <input id=\"street\" type=\"text\" formControlName=\"street\" /> <label for=\"city\">City: </label> <input id=\"city\" type=\"text\" formControlName=\"city\" /> <label for=\"state\">State: </label> <input id=\"state\" type=\"text\" formControlName=\"state\" /> <label for=\"zip\">Zip Code: </label> <input id=\"zip\" type=\"text\" formControlName=\"zip\" /> </div> <div formArrayName=\"aliases\"> <h2>Aliases</h2> <button type=\"button\" (click)=\"addAlias()\">+ Add anoth",
    "id": "reactive-forms-*-angular-34"
  },
  {
    "url": "https://angular.dev/guide/forms/reactive-forms",
    "title": "Reactive forms • Angular",
    "chunk": "er alias</button> @for (alias of aliases.controls; track $index; let i = $index) { <div> <!-- The repeated alias template --> <label for=\"alias-{{ i }}\">Alias:</label> <input id=\"alias-{{ i }}\" type=\"text\" [formControlName]=\"i\" /> </div> } </div> <p>Complete the form to enable button.</p> <button type=\"submit\" [disabled]=\"!profileForm.valid\">Submit</button></form><hr><p>Form Value: {{ profileForm.value | json }}</p><p>Form Status: {{ profileForm.status }}</p><button type=\"button\" (click)=\"update",
    "id": "reactive-forms-*-angular-35"
  },
  {
    "url": "https://angular.dev/guide/forms/reactive-forms",
    "title": "Reactive forms • Angular",
    "chunk": "Profile()\">Update Profile</button> The button in the preceding snippet also has a disabled binding attached to it to disable the button when profileForm is invalid. You aren't performing any validation yet, so the button is always enabled. Basic form validation is covered in the Validating form input section. Display the component To display the ProfileEditor component that contains the form, add it to a component template. src/app/app.component.html (profile editor) <h1>Reactive Forms</h1><app-",
    "id": "reactive-forms-*-angular-36"
  },
  {
    "url": "https://angular.dev/guide/forms/reactive-forms",
    "title": "Reactive forms • Angular",
    "chunk": "name-editor /><app-profile-editor /> ProfileEditor lets you manage the form control instances for the firstName and lastName controls within the form group instance. Creating nested form groups Form groups can accept both individual form control instances and other form group instances as children. This makes composing complex form models easier to maintain and logically group together. When building complex forms, managing the different areas of information is easier in smaller sections. Using ",
    "id": "reactive-forms-*-angular-37"
  },
  {
    "url": "https://angular.dev/guide/forms/reactive-forms",
    "title": "Reactive forms • Angular",
    "chunk": "a nested form group instance lets you break large forms groups into smaller, more manageable ones. To make more complex forms, use the following steps. Create a nested group. Group the nested form in the template. Some types of information naturally fall into the same group. A name and address are typical examples of such nested groups, and are used in the following examples. To create a nested group in `profileForm`, add a nested `address` element to the form group instance. src/app/profile-edi",
    "id": "reactive-forms-*-angular-38"
  },
  {
    "url": "https://angular.dev/guide/forms/reactive-forms",
    "title": "Reactive forms • Angular",
    "chunk": "tor/profile-editor.component.ts (nested form group) import {Component} from '@angular/core';import {FormGroup, FormControl, ReactiveFormsModule} from '@angular/forms';@Component({ selector: 'app-profile-editor', templateUrl: './profile-editor.component.html', styleUrls: ['./profile-editor.component.css'], imports: [ReactiveFormsModule],})export class ProfileEditorComponent { profileForm = new FormGroup({ firstName: new FormControl(''), lastName: new FormControl(''), address: new FormGroup({ stre",
    "id": "reactive-forms-*-angular-39"
  },
  {
    "url": "https://angular.dev/guide/forms/reactive-forms",
    "title": "Reactive forms • Angular",
    "chunk": "et: new FormControl(''), city: new FormControl(''), state: new FormControl(''), zip: new FormControl(''), }), }); updateProfile() { this.profileForm.patchValue({ firstName: 'Nancy', address: { street: '123 Drew Street', }, }); }} In this example, address group combines the current firstName and lastName controls with the new street, city, state, and zip controls. Even though the address element in the form group is a child of the overall profileForm element in the form group, the same rules appl",
    "id": "reactive-forms-*-angular-40"
  },
  {
    "url": "https://angular.dev/guide/forms/reactive-forms",
    "title": "Reactive forms • Angular",
    "chunk": "y with value and status changes. Changes in status and value from the nested form group propagate to the parent form group, maintaining consistency with the overall model. Group the nested form in the template After you update the model in the component class, update the template to connect the form group instance and its input elements. Add the address form group containing the street, city, state, and zip fields to the ProfileEditor template. src/app/profile-editor/profile-editor.component.htm",
    "id": "reactive-forms-*-angular-41"
  },
  {
    "url": "https://angular.dev/guide/forms/reactive-forms",
    "title": "Reactive forms • Angular",
    "chunk": "l (template nested form group) <form [formGroup]=\"profileForm\"> <label for=\"first-name\">First Name: </label> <input id=\"first-name\" type=\"text\" formControlName=\"firstName\" /> <label for=\"last-name\">Last Name: </label> <input id=\"last-name\" type=\"text\" formControlName=\"lastName\" /> <div formGroupName=\"address\"> <h2>Address</h2> <label for=\"street\">Street: </label> <input id=\"street\" type=\"text\" formControlName=\"street\" /> <label for=\"city\">City: </label> <input id=\"city\" type=\"text\" formControlNa",
    "id": "reactive-forms-*-angular-42"
  },
  {
    "url": "https://angular.dev/guide/forms/reactive-forms",
    "title": "Reactive forms • Angular",
    "chunk": "me=\"city\" /> <label for=\"state\">State: </label> <input id=\"state\" type=\"text\" formControlName=\"state\" /> <label for=\"zip\">Zip Code: </label> <input id=\"zip\" type=\"text\" formControlName=\"zip\" /> </div> <div formArrayName=\"aliases\"> <h2>Aliases</h2> <button type=\"button\" (click)=\"addAlias()\">+ Add another alias</button> @for(alias of aliases.controls; track $index; let i = $index) { <div> <!-- The repeated alias template --> <label for=\"alias-{{ i }}\">Alias: </label> <input id=\"alias-{{ i }}\" type",
    "id": "reactive-forms-*-angular-43"
  },
  {
    "url": "https://angular.dev/guide/forms/reactive-forms",
    "title": "Reactive forms • Angular",
    "chunk": "=\"text\" [formControlName]=\"i\" /> </div> } </div></form><p>Form Value: {{ profileForm.value | json }}</p><button type=\"button\" (click)=\"updateProfile()\">Update Profile</button> The ProfileEditor form is displayed as one group, but the model is broken down further to represent the logical grouping areas. Display the value for the form group instance in the component template using the value property and JsonPipe. Updating parts of the data model When updating the value for a form group instance th",
    "id": "reactive-forms-*-angular-44"
  },
  {
    "url": "https://angular.dev/guide/forms/reactive-forms",
    "title": "Reactive forms • Angular",
    "chunk": "at contains multiple controls, you might only want to update parts of the model. This section covers how to update specific parts of a form control data model. There are two ways to update the model value: Methods Details setValue() Set a new value for an individual control. The setValue() method strictly adheres to the structure of the form group and replaces the entire value for the control. patchValue() Replace any properties defined in the object that have changed in the form model. The stri",
    "id": "reactive-forms-*-angular-45"
  },
  {
    "url": "https://angular.dev/guide/forms/reactive-forms",
    "title": "Reactive forms • Angular",
    "chunk": "ct checks of the setValue() method help catch nesting errors in complex forms, while patchValue() fails silently on those errors. In ProfileEditorComponent, use the updateProfile method with the following example to update the first name and street address for the user. src/app/profile-editor/profile-editor.component.ts (patch value) import {Component} from '@angular/core';import {FormGroup, FormControl, ReactiveFormsModule} from '@angular/forms';@Component({ selector: 'app-profile-editor', temp",
    "id": "reactive-forms-*-angular-46"
  },
  {
    "url": "https://angular.dev/guide/forms/reactive-forms",
    "title": "Reactive forms • Angular",
    "chunk": "lateUrl: './profile-editor.component.html', styleUrls: ['./profile-editor.component.css'], imports: [ReactiveFormsModule],})export class ProfileEditorComponent { profileForm = new FormGroup({ firstName: new FormControl(''), lastName: new FormControl(''), address: new FormGroup({ street: new FormControl(''), city: new FormControl(''), state: new FormControl(''), zip: new FormControl(''), }), }); updateProfile() { this.profileForm.patchValue({ firstName: 'Nancy', address: { street: '123 Drew Stree",
    "id": "reactive-forms-*-angular-47"
  },
  {
    "url": "https://angular.dev/guide/forms/reactive-forms",
    "title": "Reactive forms • Angular",
    "chunk": "t', }, }); }} Simulate an update by adding a button to the template to update the user profile on demand. src/app/profile-editor/profile-editor.component.html (update value) <form [formGroup]=\"profileForm\"> <label for=\"first-name\">First Name: </label> <input id=\"first-name\" type=\"text\" formControlName=\"firstName\" /> <label for=\"last-name\">Last Name: </label> <input id=\"last-name\" type=\"text\" formControlName=\"lastName\" /> <div formGroupName=\"address\"> <h2>Address</h2> <label for=\"street\">Street: ",
    "id": "reactive-forms-*-angular-48"
  },
  {
    "url": "https://angular.dev/guide/forms/reactive-forms",
    "title": "Reactive forms • Angular",
    "chunk": "</label> <input id=\"street\" type=\"text\" formControlName=\"street\" /> <label for=\"city\">City: </label> <input id=\"city\" type=\"text\" formControlName=\"city\" /> <label for=\"state\">State: </label> <input id=\"state\" type=\"text\" formControlName=\"state\" /> <label for=\"zip\">Zip Code: </label> <input id=\"zip\" type=\"text\" formControlName=\"zip\" /> </div> <div formArrayName=\"aliases\"> <h2>Aliases</h2> <button type=\"button\" (click)=\"addAlias()\">+ Add another alias</button> @for(alias of aliases.controls; track",
    "id": "reactive-forms-*-angular-49"
  },
  {
    "url": "https://angular.dev/guide/forms/reactive-forms",
    "title": "Reactive forms • Angular",
    "chunk": " $index; let i = $index) { <div> <!-- The repeated alias template --> <label for=\"alias-{{ i }}\">Alias: </label> <input id=\"alias-{{ i }}\" type=\"text\" [formControlName]=\"i\" /> </div> } </div></form><p>Form Value: {{ profileForm.value | json }}</p><button type=\"button\" (click)=\"updateProfile()\">Update Profile</button> When a user clicks the button, the profileForm model is updated with new values for firstName and street. Notice that street is provided in an object inside the address property. Th",
    "id": "reactive-forms-*-angular-50"
  },
  {
    "url": "https://angular.dev/guide/forms/reactive-forms",
    "title": "Reactive forms • Angular",
    "chunk": "is is necessary because the patchValue() method applies the update against the model structure. PatchValue() only updates properties that the form model defines. Using the FormBuilder service to generate controls Creating form control instances manually can become repetitive when dealing with multiple forms. The FormBuilder service provides convenient methods for generating controls. Use the following steps to take advantage of this service. Import the FormBuilder class. Inject the FormBuilder s",
    "id": "reactive-forms-*-angular-51"
  },
  {
    "url": "https://angular.dev/guide/forms/reactive-forms",
    "title": "Reactive forms • Angular",
    "chunk": "ervice. Generate the form contents. The following examples show how to refactor the ProfileEditor component to use the form builder service to create form control and form group instances. Import the FormBuilder class Import the FormBuilder class from the @angular/forms package. src/app/profile-editor/profile-editor.component.ts (import) import {Component, inject} from '@angular/core';import {FormBuilder, ReactiveFormsModule} from '@angular/forms';import {FormArray} from '@angular/forms';@Compon",
    "id": "reactive-forms-*-angular-52"
  },
  {
    "url": "https://angular.dev/guide/forms/reactive-forms",
    "title": "Reactive forms • Angular",
    "chunk": "ent({ selector: 'app-profile-editor', templateUrl: './profile-editor.component.html', styleUrls: ['./profile-editor.component.css'], imports: [ReactiveFormsModule],})export class ProfileEditorComponent { private formBuilder = inject(FormBuilder); profileForm = this.formBuilder.group({ firstName: [''], lastName: [''], address: this.formBuilder.group({ street: [''], city: [''], state: [''], zip: [''], }), aliases: this.formBuilder.array([this.formBuilder.control('')]), }); get aliases() { return t",
    "id": "reactive-forms-*-angular-53"
  },
  {
    "url": "https://angular.dev/guide/forms/reactive-forms",
    "title": "Reactive forms • Angular",
    "chunk": "his.profileForm.get('aliases') as FormArray; } updateProfile() { this.profileForm.patchValue({ firstName: 'Nancy', address: { street: '123 Drew Street', }, }); } addAlias() { this.aliases.push(this.formBuilder.control('')); }} Inject the FormBuilder service The FormBuilder service is an injectable provider from the reactive forms module. Use the inject() function to inject this dependency in your component. src/app/profile-editor/profile-editor.component.ts (property init) import {Component, inj",
    "id": "reactive-forms-*-angular-54"
  },
  {
    "url": "https://angular.dev/guide/forms/reactive-forms",
    "title": "Reactive forms • Angular",
    "chunk": "ect} from '@angular/core';import {FormBuilder, ReactiveFormsModule} from '@angular/forms';import {FormArray} from '@angular/forms';@Component({ selector: 'app-profile-editor', templateUrl: './profile-editor.component.html', styleUrls: ['./profile-editor.component.css'], imports: [ReactiveFormsModule],})export class ProfileEditorComponent { private formBuilder = inject(FormBuilder); profileForm = this.formBuilder.group({ firstName: [''], lastName: [''], address: this.formBuilder.group({ street: [",
    "id": "reactive-forms-*-angular-55"
  },
  {
    "url": "https://angular.dev/guide/forms/reactive-forms",
    "title": "Reactive forms • Angular",
    "chunk": "''], city: [''], state: [''], zip: [''], }), aliases: this.formBuilder.array([this.formBuilder.control('')]), }); get aliases() { return this.profileForm.get('aliases') as FormArray; } updateProfile() { this.profileForm.patchValue({ firstName: 'Nancy', address: { street: '123 Drew Street', }, }); } addAlias() { this.aliases.push(this.formBuilder.control('')); }} Generate form controls The FormBuilder service has three methods: control(), group(), and array(). These are factory methods for genera",
    "id": "reactive-forms-*-angular-56"
  },
  {
    "url": "https://angular.dev/guide/forms/reactive-forms",
    "title": "Reactive forms • Angular",
    "chunk": "ting instances in your component classes including form controls, form groups, and form arrays. Use the group method to create the profileForm controls. src/app/profile-editor/profile-editor.component.ts (form builder) import {Component, inject} from '@angular/core';import {FormBuilder, ReactiveFormsModule} from '@angular/forms';import {FormArray} from '@angular/forms';@Component({ selector: 'app-profile-editor', templateUrl: './profile-editor.component.html', styleUrls: ['./profile-editor.compo",
    "id": "reactive-forms-*-angular-57"
  },
  {
    "url": "https://angular.dev/guide/forms/reactive-forms",
    "title": "Reactive forms • Angular",
    "chunk": "nent.css'], imports: [ReactiveFormsModule],})export class ProfileEditorComponent { private formBuilder = inject(FormBuilder); profileForm = this.formBuilder.group({ firstName: [''], lastName: [''], address: this.formBuilder.group({ street: [''], city: [''], state: [''], zip: [''], }), aliases: this.formBuilder.array([this.formBuilder.control('')]), }); get aliases() { return this.profileForm.get('aliases') as FormArray; } updateProfile() { this.profileForm.patchValue({ firstName: 'Nancy', addres",
    "id": "reactive-forms-*-angular-58"
  },
  {
    "url": "https://angular.dev/guide/forms/reactive-forms",
    "title": "Reactive forms • Angular",
    "chunk": "s: { street: '123 Drew Street', }, }); } addAlias() { this.aliases.push(this.formBuilder.control('')); }} In the preceding example, you use the group() method with the same object to define the properties in the model. The value for each control name is an array containing the initial value as the first item in the array. TIP: You can define the control with just the initial value, but if your controls need sync or async validation, add sync and async validators as the second and third items in ",
    "id": "reactive-forms-*-angular-59"
  },
  {
    "url": "https://angular.dev/guide/forms/reactive-forms",
    "title": "Reactive forms • Angular",
    "chunk": "the array. Compare using the form builder to creating the instances manually. src/app/profile-editor/profile-editor.component.ts (instances) import {Component} from '@angular/core';import {FormGroup, FormControl, ReactiveFormsModule} from '@angular/forms';@Component({ selector: 'app-profile-editor', templateUrl: './profile-editor.component.html', styleUrls: ['./profile-editor.component.css'], imports: [ReactiveFormsModule],})export class ProfileEditorComponent { profileForm = new FormGroup({ fir",
    "id": "reactive-forms-*-angular-60"
  },
  {
    "url": "https://angular.dev/guide/forms/reactive-forms",
    "title": "Reactive forms • Angular",
    "chunk": "stName: new FormControl(''), lastName: new FormControl(''), address: new FormGroup({ street: new FormControl(''), city: new FormControl(''), state: new FormControl(''), zip: new FormControl(''), }), }); updateProfile() { this.profileForm.patchValue({ firstName: 'Nancy', address: { street: '123 Drew Street', }, }); }} src/app/profile-editor/profile-editor.component.ts (form builder) import {Component, inject} from '@angular/core';import {FormBuilder, ReactiveFormsModule} from '@angular/forms';imp",
    "id": "reactive-forms-*-angular-61"
  },
  {
    "url": "https://angular.dev/guide/forms/reactive-forms",
    "title": "Reactive forms • Angular",
    "chunk": "ort {FormArray} from '@angular/forms';@Component({ selector: 'app-profile-editor', templateUrl: './profile-editor.component.html', styleUrls: ['./profile-editor.component.css'], imports: [ReactiveFormsModule],})export class ProfileEditorComponent { private formBuilder = inject(FormBuilder); profileForm = this.formBuilder.group({ firstName: [''], lastName: [''], address: this.formBuilder.group({ street: [''], city: [''], state: [''], zip: [''], }), aliases: this.formBuilder.array([this.formBuilde",
    "id": "reactive-forms-*-angular-62"
  },
  {
    "url": "https://angular.dev/guide/forms/reactive-forms",
    "title": "Reactive forms • Angular",
    "chunk": "r.control('')]), }); get aliases() { return this.profileForm.get('aliases') as FormArray; } updateProfile() { this.profileForm.patchValue({ firstName: 'Nancy', address: { street: '123 Drew Street', }, }); } addAlias() { this.aliases.push(this.formBuilder.control('')); }} Validating form input Form validation is used to ensure that user input is complete and correct. This section covers adding a single validator to a form control and displaying the overall form status. Form validation is covered ",
    "id": "reactive-forms-*-angular-63"
  },
  {
    "url": "https://angular.dev/guide/forms/reactive-forms",
    "title": "Reactive forms • Angular",
    "chunk": "more extensively in the Form Validation guide. Use the following steps to add form validation. Import a validator function in your form component. Add the validator to the field in the form. Add logic to handle the validation status. The most common validation is making a field required. The following example shows how to add a required validation to the firstName control and display the result of validation. Import a validator function Reactive forms include a set of validator functions for com",
    "id": "reactive-forms-*-angular-64"
  },
  {
    "url": "https://angular.dev/guide/forms/reactive-forms",
    "title": "Reactive forms • Angular",
    "chunk": "mon use cases. These functions receive a control to validate against and return an error object or a null value based on the validation check. Import the Validators class from the @angular/forms package. src/app/profile-editor/profile-editor.component.ts (import) import {Component, inject} from '@angular/core';import {FormBuilder, ReactiveFormsModule} from '@angular/forms';import {Validators} from '@angular/forms';import {FormArray} from '@angular/forms';import {JsonPipe} from '@angular/common';",
    "id": "reactive-forms-*-angular-65"
  },
  {
    "url": "https://angular.dev/guide/forms/reactive-forms",
    "title": "Reactive forms • Angular",
    "chunk": "@Component({ selector: 'app-profile-editor', templateUrl: './profile-editor.component.html', styleUrls: ['./profile-editor.component.css'], imports: [ReactiveFormsModule, JsonPipe],})export class ProfileEditorComponent { private formBuilder = inject(FormBuilder); profileForm = this.formBuilder.group({ firstName: ['', Validators.required], lastName: [''], address: this.formBuilder.group({ street: [''], city: [''], state: [''], zip: [''], }), aliases: this.formBuilder.array([this.formBuilder.contr",
    "id": "reactive-forms-*-angular-66"
  },
  {
    "url": "https://angular.dev/guide/forms/reactive-forms",
    "title": "Reactive forms • Angular",
    "chunk": "ol('')]), }); get aliases() { return this.profileForm.get('aliases') as FormArray; } updateProfile() { this.profileForm.patchValue({ firstName: 'Nancy', address: { street: '123 Drew Street', }, }); } addAlias() { this.aliases.push(this.formBuilder.control('')); } onSubmit() { // TODO: Use EventEmitter with form value console.warn(this.profileForm.value); }} Make a field required In the ProfileEditor component, add the Validators.required static method as the second item in the array for the firs",
    "id": "reactive-forms-*-angular-67"
  },
  {
    "url": "https://angular.dev/guide/forms/reactive-forms",
    "title": "Reactive forms • Angular",
    "chunk": "tName control. src/app/profile-editor/profile-editor.component.ts (required validator) import {Component, inject} from '@angular/core';import {FormBuilder, ReactiveFormsModule} from '@angular/forms';import {Validators} from '@angular/forms';import {FormArray} from '@angular/forms';import {JsonPipe} from '@angular/common';@Component({ selector: 'app-profile-editor', templateUrl: './profile-editor.component.html', styleUrls: ['./profile-editor.component.css'], imports: [ReactiveFormsModule, JsonPi",
    "id": "reactive-forms-*-angular-68"
  },
  {
    "url": "https://angular.dev/guide/forms/reactive-forms",
    "title": "Reactive forms • Angular",
    "chunk": "pe],})export class ProfileEditorComponent { private formBuilder = inject(FormBuilder); profileForm = this.formBuilder.group({ firstName: ['', Validators.required], lastName: [''], address: this.formBuilder.group({ street: [''], city: [''], state: [''], zip: [''], }), aliases: this.formBuilder.array([this.formBuilder.control('')]), }); get aliases() { return this.profileForm.get('aliases') as FormArray; } updateProfile() { this.profileForm.patchValue({ firstName: 'Nancy', address: { street: '123 ",
    "id": "reactive-forms-*-angular-69"
  },
  {
    "url": "https://angular.dev/guide/forms/reactive-forms",
    "title": "Reactive forms • Angular",
    "chunk": "Drew Street', }, }); } addAlias() { this.aliases.push(this.formBuilder.control('')); } onSubmit() { // TODO: Use EventEmitter with form value console.warn(this.profileForm.value); }} Display form status When you add a required field to the form control, its initial status is invalid. This invalid status propagates to the parent form group element, making its status invalid. Access the current status of the form group instance through its status property. Display the current status of profileForm",
    "id": "reactive-forms-*-angular-70"
  },
  {
    "url": "https://angular.dev/guide/forms/reactive-forms",
    "title": "Reactive forms • Angular",
    "chunk": " using interpolation. src/app/profile-editor/profile-editor.component.html (display status) <form [formGroup]=\"profileForm\" (ngSubmit)=\"onSubmit()\"> <label for=\"first-name\">First Name: </label> <input id=\"first-name\" type=\"text\" formControlName=\"firstName\" required /> <label for=\"last-name\">Last Name: </label> <input id=\"last-name\" type=\"text\" formControlName=\"lastName\" /> <div formGroupName=\"address\"> <h2>Address</h2> <label for=\"street\">Street: </label> <input id=\"street\" type=\"text\" formContr",
    "id": "reactive-forms-*-angular-71"
  },
  {
    "url": "https://angular.dev/guide/forms/reactive-forms",
    "title": "Reactive forms • Angular",
    "chunk": "olName=\"street\" /> <label for=\"city\">City: </label> <input id=\"city\" type=\"text\" formControlName=\"city\" /> <label for=\"state\">State: </label> <input id=\"state\" type=\"text\" formControlName=\"state\" /> <label for=\"zip\">Zip Code: </label> <input id=\"zip\" type=\"text\" formControlName=\"zip\" /> </div> <div formArrayName=\"aliases\"> <h2>Aliases</h2> <button type=\"button\" (click)=\"addAlias()\">+ Add another alias</button> @for (alias of aliases.controls; track $index; let i = $index) { <div> <!-- The repeat",
    "id": "reactive-forms-*-angular-72"
  },
  {
    "url": "https://angular.dev/guide/forms/reactive-forms",
    "title": "Reactive forms • Angular",
    "chunk": "ed alias template --> <label for=\"alias-{{ i }}\">Alias:</label> <input id=\"alias-{{ i }}\" type=\"text\" [formControlName]=\"i\" /> </div> } </div> <p>Complete the form to enable button.</p> <button type=\"submit\" [disabled]=\"!profileForm.valid\">Submit</button></form><hr><p>Form Value: {{ profileForm.value | json }}</p><p>Form Status: {{ profileForm.status }}</p><button type=\"button\" (click)=\"updateProfile()\">Update Profile</button> The Submit button is disabled because profileForm is invalid due to t",
    "id": "reactive-forms-*-angular-73"
  },
  {
    "url": "https://angular.dev/guide/forms/reactive-forms",
    "title": "Reactive forms • Angular",
    "chunk": "he required firstName form control. After you fill out the firstName input, the form becomes valid and the Submit button is enabled. For more on form validation, visit the Form Validation guide. Creating dynamic forms FormArray is an alternative to FormGroup for managing any number of unnamed controls. As with form group instances, you can dynamically insert and remove controls from form array instances, and the form array instance value and validation status is calculated from its child control",
    "id": "reactive-forms-*-angular-74"
  },
  {
    "url": "https://angular.dev/guide/forms/reactive-forms",
    "title": "Reactive forms • Angular",
    "chunk": "s. However, you don't need to define a key for each control by name, so this is a great option if you don't know the number of child values in advance. To define a dynamic form, take the following steps. Import the FormArray class. Define a FormArray control. Access the FormArray control with a getter method. Display the form array in a template. The following example shows you how to manage an array of aliases in ProfileEditor. Import the FormArray class Import the FormArray class from @angular",
    "id": "reactive-forms-*-angular-75"
  },
  {
    "url": "https://angular.dev/guide/forms/reactive-forms",
    "title": "Reactive forms • Angular",
    "chunk": "/forms to use for type information. The FormBuilder service is ready to create a FormArray instance. src/app/profile-editor/profile-editor.component.ts (import) import {Component, inject} from '@angular/core';import {FormBuilder, ReactiveFormsModule} from '@angular/forms';import {FormArray} from '@angular/forms';@Component({ selector: 'app-profile-editor', templateUrl: './profile-editor.component.html', styleUrls: ['./profile-editor.component.css'], imports: [ReactiveFormsModule],})export class ",
    "id": "reactive-forms-*-angular-76"
  },
  {
    "url": "https://angular.dev/guide/forms/reactive-forms",
    "title": "Reactive forms • Angular",
    "chunk": "ProfileEditorComponent { private formBuilder = inject(FormBuilder); profileForm = this.formBuilder.group({ firstName: [''], lastName: [''], address: this.formBuilder.group({ street: [''], city: [''], state: [''], zip: [''], }), aliases: this.formBuilder.array([this.formBuilder.control('')]), }); get aliases() { return this.profileForm.get('aliases') as FormArray; } updateProfile() { this.profileForm.patchValue({ firstName: 'Nancy', address: { street: '123 Drew Street', }, }); } addAlias() { this",
    "id": "reactive-forms-*-angular-77"
  },
  {
    "url": "https://angular.dev/guide/forms/reactive-forms",
    "title": "Reactive forms • Angular",
    "chunk": ".aliases.push(this.formBuilder.control('')); }} Define a FormArray control You can initialize a form array with any number of controls, from zero to many, by defining them in an array. Add an aliases property to the form group instance for profileForm to define the form array. Use the FormBuilder.array() method to define the array, and the FormBuilder.control() method to populate the array with an initial control. src/app/profile-editor/profile-editor.component.ts (aliases form array) import {Co",
    "id": "reactive-forms-*-angular-78"
  },
  {
    "url": "https://angular.dev/guide/forms/reactive-forms",
    "title": "Reactive forms • Angular",
    "chunk": "mponent, inject} from '@angular/core';import {FormBuilder, ReactiveFormsModule} from '@angular/forms';import {Validators} from '@angular/forms';import {FormArray} from '@angular/forms';import {JsonPipe} from '@angular/common';@Component({ selector: 'app-profile-editor', templateUrl: './profile-editor.component.html', styleUrls: ['./profile-editor.component.css'], imports: [ReactiveFormsModule, JsonPipe],})export class ProfileEditorComponent { private formBuilder = inject(FormBuilder); profileFor",
    "id": "reactive-forms-*-angular-79"
  },
  {
    "url": "https://angular.dev/guide/forms/reactive-forms",
    "title": "Reactive forms • Angular",
    "chunk": "m = this.formBuilder.group({ firstName: ['', Validators.required], lastName: [''], address: this.formBuilder.group({ street: [''], city: [''], state: [''], zip: [''], }), aliases: this.formBuilder.array([this.formBuilder.control('')]), }); get aliases() { return this.profileForm.get('aliases') as FormArray; } updateProfile() { this.profileForm.patchValue({ firstName: 'Nancy', address: { street: '123 Drew Street', }, }); } addAlias() { this.aliases.push(this.formBuilder.control('')); } onSubmit()",
    "id": "reactive-forms-*-angular-80"
  },
  {
    "url": "https://angular.dev/guide/forms/reactive-forms",
    "title": "Reactive forms • Angular",
    "chunk": " { // TODO: Use EventEmitter with form value console.warn(this.profileForm.value); }} The aliases control in the form group instance is now populated with a single control until more controls are added dynamically. Access the FormArray control A getter provides access to the aliases in the form array instance compared to repeating the profileForm.get() method to get each instance. The form array instance represents an undefined number of controls in an array. It's convenient to access a control ",
    "id": "reactive-forms-*-angular-81"
  },
  {
    "url": "https://angular.dev/guide/forms/reactive-forms",
    "title": "Reactive forms • Angular",
    "chunk": "through a getter, and this approach is straightforward to repeat for additional controls. Use the getter syntax to create an aliases class property to retrieve the alias's form array control from the parent form group. src/app/profile-editor/profile-editor.component.ts (aliases getter) import {Component, inject} from '@angular/core';import {FormBuilder, ReactiveFormsModule} from '@angular/forms';import {Validators} from '@angular/forms';import {FormArray} from '@angular/forms';import {JsonPipe} ",
    "id": "reactive-forms-*-angular-82"
  },
  {
    "url": "https://angular.dev/guide/forms/reactive-forms",
    "title": "Reactive forms • Angular",
    "chunk": "from '@angular/common';@Component({ selector: 'app-profile-editor', templateUrl: './profile-editor.component.html', styleUrls: ['./profile-editor.component.css'], imports: [ReactiveFormsModule, JsonPipe],})export class ProfileEditorComponent { private formBuilder = inject(FormBuilder); profileForm = this.formBuilder.group({ firstName: ['', Validators.required], lastName: [''], address: this.formBuilder.group({ street: [''], city: [''], state: [''], zip: [''], }), aliases: this.formBuilder.array(",
    "id": "reactive-forms-*-angular-83"
  },
  {
    "url": "https://angular.dev/guide/forms/reactive-forms",
    "title": "Reactive forms • Angular",
    "chunk": "[this.formBuilder.control('')]), }); get aliases() { return this.profileForm.get('aliases') as FormArray; } updateProfile() { this.profileForm.patchValue({ firstName: 'Nancy', address: { street: '123 Drew Street', }, }); } addAlias() { this.aliases.push(this.formBuilder.control('')); } onSubmit() { // TODO: Use EventEmitter with form value console.warn(this.profileForm.value); }} Because the returned control is of the type AbstractControl, you need to provide an explicit type to access the metho",
    "id": "reactive-forms-*-angular-84"
  },
  {
    "url": "https://angular.dev/guide/forms/reactive-forms",
    "title": "Reactive forms • Angular",
    "chunk": "d syntax for the form array instance. Define a method to dynamically insert an alias control into the alias's form array. The FormArray.push() method inserts the control as a new item in the array. src/app/profile-editor/profile-editor.component.ts (add alias) import {Component, inject} from '@angular/core';import {FormBuilder, ReactiveFormsModule} from '@angular/forms';import {Validators} from '@angular/forms';import {FormArray} from '@angular/forms';import {JsonPipe} from '@angular/common';@Co",
    "id": "reactive-forms-*-angular-85"
  },
  {
    "url": "https://angular.dev/guide/forms/reactive-forms",
    "title": "Reactive forms • Angular",
    "chunk": "mponent({ selector: 'app-profile-editor', templateUrl: './profile-editor.component.html', styleUrls: ['./profile-editor.component.css'], imports: [ReactiveFormsModule, JsonPipe],})export class ProfileEditorComponent { private formBuilder = inject(FormBuilder); profileForm = this.formBuilder.group({ firstName: ['', Validators.required], lastName: [''], address: this.formBuilder.group({ street: [''], city: [''], state: [''], zip: [''], }), aliases: this.formBuilder.array([this.formBuilder.control(",
    "id": "reactive-forms-*-angular-86"
  },
  {
    "url": "https://angular.dev/guide/forms/reactive-forms",
    "title": "Reactive forms • Angular",
    "chunk": "'')]), }); get aliases() { return this.profileForm.get('aliases') as FormArray; } updateProfile() { this.profileForm.patchValue({ firstName: 'Nancy', address: { street: '123 Drew Street', }, }); } addAlias() { this.aliases.push(this.formBuilder.control('')); } onSubmit() { // TODO: Use EventEmitter with form value console.warn(this.profileForm.value); }} In the template, each control is displayed as a separate input field. Display the form array in the template To attach the aliases from your fo",
    "id": "reactive-forms-*-angular-87"
  },
  {
    "url": "https://angular.dev/guide/forms/reactive-forms",
    "title": "Reactive forms • Angular",
    "chunk": "rm model, you must add it to the template. Similar to the formGroupName input provided by FormGroupNameDirective, formArrayName binds communication from the form array instance to the template with FormArrayNameDirective. Add the following template HTML after the <div> closing the formGroupName element. src/app/profile-editor/profile-editor.component.html (aliases form array template) <form [formGroup]=\"profileForm\" (ngSubmit)=\"onSubmit()\"> <label for=\"first-name\">First Name: </label> <input id=",
    "id": "reactive-forms-*-angular-88"
  },
  {
    "url": "https://angular.dev/guide/forms/reactive-forms",
    "title": "Reactive forms • Angular",
    "chunk": "\"first-name\" type=\"text\" formControlName=\"firstName\" required /> <label for=\"last-name\">Last Name: </label> <input id=\"last-name\" type=\"text\" formControlName=\"lastName\" /> <div formGroupName=\"address\"> <h2>Address</h2> <label for=\"street\">Street: </label> <input id=\"street\" type=\"text\" formControlName=\"street\" /> <label for=\"city\">City: </label> <input id=\"city\" type=\"text\" formControlName=\"city\" /> <label for=\"state\">State: </label> <input id=\"state\" type=\"text\" formControlName=\"state\" /> <labe",
    "id": "reactive-forms-*-angular-89"
  },
  {
    "url": "https://angular.dev/guide/forms/reactive-forms",
    "title": "Reactive forms • Angular",
    "chunk": "l for=\"zip\">Zip Code: </label> <input id=\"zip\" type=\"text\" formControlName=\"zip\" /> </div> <div formArrayName=\"aliases\"> <h2>Aliases</h2> <button type=\"button\" (click)=\"addAlias()\">+ Add another alias</button> @for (alias of aliases.controls; track $index; let i = $index) { <div> <!-- The repeated alias template --> <label for=\"alias-{{ i }}\">Alias:</label> <input id=\"alias-{{ i }}\" type=\"text\" [formControlName]=\"i\" /> </div> } </div> <p>Complete the form to enable button.</p> <button type=\"subm",
    "id": "reactive-forms-*-angular-90"
  },
  {
    "url": "https://angular.dev/guide/forms/reactive-forms",
    "title": "Reactive forms • Angular",
    "chunk": "it\" [disabled]=\"!profileForm.valid\">Submit</button></form><hr><p>Form Value: {{ profileForm.value | json }}</p><p>Form Status: {{ profileForm.status }}</p><button type=\"button\" (click)=\"updateProfile()\">Update Profile</button> The @for block iterates over each form control instance provided by the aliases form array instance. Because form array elements are unnamed, you assign the index to the i variable and pass it to each control to bind it to the formControlName input. Each time a new alias i",
    "id": "reactive-forms-*-angular-91"
  },
  {
    "url": "https://angular.dev/guide/forms/reactive-forms",
    "title": "Reactive forms • Angular",
    "chunk": "nstance is added, the new form array instance is provided its control based on the index. This lets you track each individual control when calculating the status and value of the root control. Add an alias Initially, the form contains one Alias field. To add another field, click the Add Alias button. You can also validate the array of aliases reported by the form model displayed by Form Value at the bottom of the template. Instead of a form control instance for each alias, you can compose anothe",
    "id": "reactive-forms-*-angular-92"
  },
  {
    "url": "https://angular.dev/guide/forms/reactive-forms",
    "title": "Reactive forms • Angular",
    "chunk": "r form group instance with additional fields. The process of defining a control for each item is the same. Reactive forms API summary The following table lists the base classes and services used to create and manage reactive form controls. For complete syntax details, see the API reference documentation for the Forms package. Classes Class Details AbstractControl The abstract base class for the concrete form control classes FormControl, FormGroup, and FormArray. It provides their common behavior",
    "id": "reactive-forms-*-angular-93"
  },
  {
    "url": "https://angular.dev/guide/forms/reactive-forms",
    "title": "Reactive forms • Angular",
    "chunk": "s and properties. FormControl Manages the value and validity status of an individual form control. It corresponds to an HTML form control such as <input> or <select>. FormGroup Manages the value and validity state of a group of AbstractControl instances. The group's properties include its child controls. The top-level form in your component is FormGroup. FormArray Manages the value and validity state of a numerically indexed array of AbstractControl instances. FormBuilder An injectable service t",
    "id": "reactive-forms-*-angular-94"
  },
  {
    "url": "https://angular.dev/guide/forms/reactive-forms",
    "title": "Reactive forms • Angular",
    "chunk": "hat provides factory methods for creating control instances. FormRecord Tracks the value and validity state of a collection of FormControl instances, each of which has the same value type. Directives Directive Details FormControlDirective Syncs a standalone FormControl instance to a form control element. FormControlName Syncs FormControl in an existing FormGroup instance to a form control element by name. FormGroupDirective Syncs an existing FormGroup instance to a DOM element. FormGroupName Syn",
    "id": "reactive-forms-*-angular-95"
  },
  {
    "url": "https://angular.dev/guide/forms/reactive-forms",
    "title": "Reactive forms • Angular",
    "chunk": "cs a nested FormGroup instance to a DOM element. FormArrayName Syncs a nested FormArray instance to a DOM element. Social MediaBlogX (formerly Twitter)BlueskyYouTube Discord GitHub Stack Overflow Community Contribute Code of Conduct Report Issues Google's DevLibrary Angular Google Developer Experts ResourcesPress KitRoadmapLanguages简体中文版正體中文版日本語版한국어 Ελληνικά Super-powered by Google ©2010-2025. Code licensed under an MIT-style License . Documentation licensed under CC BY 4.0 .",
    "id": "reactive-forms-*-angular-96"
  },
  {
    "url": "https://angular.dev/guide/forms/typed-forms",
    "title": "Strictly typed reactive forms • Angular",
    "chunk": "In-depth GuidesForms Typed Forms As of Angular 14, reactive forms are strictly typed by default. As background for this guide, you should already be familiar with Angular Reactive Forms. On this pagearrow_upward_alt Back to the top Overview of Typed Forms With Angular reactive forms, you explicitly specify a form model. As a simple example, consider this basic user login form: const login = new FormGroup({ email: new FormControl(''), password: new FormControl(''),}); Angular provides many APIs f",
    "id": "strictly-typed-reactive-forms-*-angular-0"
  },
  {
    "url": "https://angular.dev/guide/forms/typed-forms",
    "title": "Strictly typed reactive forms • Angular",
    "chunk": "or interacting with this FormGroup. For example, you may call login.value, login.controls, login.patchValue, etc. (For a full API reference, see the API documentation.) In previous Angular versions, most of these APIs included any somewhere in their types, and interacting with the structure of the controls, or the values themselves, was not type-safe. For example: you could write the following invalid code: const emailDomain = login.value.email.domain; With strictly typed reactive forms, the abo",
    "id": "strictly-typed-reactive-forms-*-angular-1"
  },
  {
    "url": "https://angular.dev/guide/forms/typed-forms",
    "title": "Strictly typed reactive forms • Angular",
    "chunk": "ve code does not compile, because there is no domain property on email. In addition to the added safety, the types enable a variety of other improvements, such as better autocomplete in IDEs, and an explicit way to specify form structure. These improvements currently apply only to reactive forms (not template-driven forms). Untyped Forms Non-typed forms are still supported, and will continue to work as before. To use them, you must import the Untyped symbols from @angular/forms: const login = ne",
    "id": "strictly-typed-reactive-forms-*-angular-2"
  },
  {
    "url": "https://angular.dev/guide/forms/typed-forms",
    "title": "Strictly typed reactive forms • Angular",
    "chunk": "w UntypedFormGroup({ email: new UntypedFormControl(''), password: new UntypedFormControl(''),}); Each Untyped symbol has exactly the same semantics as in previous Angular version. By removing the Untyped prefixes, you can incrementally enable the types. FormControl: Getting Started The simplest possible form consists of a single control: const email = new FormControl('angularrox@gmail.com'); This control will be automatically inferred to have the type FormControl<string|null>. TypeScript will au",
    "id": "strictly-typed-reactive-forms-*-angular-3"
  },
  {
    "url": "https://angular.dev/guide/forms/typed-forms",
    "title": "Strictly typed reactive forms • Angular",
    "chunk": "tomatically enforce this type throughout the FormControl API, such as email.value, email.valueChanges, email.setValue(...), etc. Nullability You might wonder: why does the type of this control include null? This is because the control can become null at any time, by calling reset: const email = new FormControl('angularrox@gmail.com');email.reset();console.log(email.value); // null TypeScript will enforce that you always handle the possibility that the control has become null. If you want to make",
    "id": "strictly-typed-reactive-forms-*-angular-4"
  },
  {
    "url": "https://angular.dev/guide/forms/typed-forms",
    "title": "Strictly typed reactive forms • Angular",
    "chunk": " this control non-nullable, you may use the nonNullable option. This will cause the control to reset to its initial value, instead of null: const email = new FormControl('angularrox@gmail.com', {nonNullable: true});email.reset();console.log(email.value); // angularrox@gmail.com To reiterate, this option affects the runtime behavior of your form when .reset() is called, and should be flipped with care. Specifying an Explicit Type It is possible to specify the type, instead of relying on inference",
    "id": "strictly-typed-reactive-forms-*-angular-5"
  },
  {
    "url": "https://angular.dev/guide/forms/typed-forms",
    "title": "Strictly typed reactive forms • Angular",
    "chunk": ". Consider a control that is initialized to null. Because the initial value is null, TypeScript will infer FormControl<null>, which is narrower than we want. const email = new FormControl(null);email.setValue('angularrox@gmail.com'); // Error! To prevent this, we explicitly specify the type as string|null: const email = new FormControl<string|null>(null);email.setValue('angularrox@gmail.com'); FormArray: Dynamic, Homogenous Collections A FormArray contains an open-ended list of controls. The typ",
    "id": "strictly-typed-reactive-forms-*-angular-6"
  },
  {
    "url": "https://angular.dev/guide/forms/typed-forms",
    "title": "Strictly typed reactive forms • Angular",
    "chunk": "e parameter corresponds to the type of each inner control: const names = new FormArray([new FormControl('Alex')]);names.push(new FormControl('Jess')); This FormArray will have the inner controls type FormControl<string|null>. If you want to have multiple different element types inside the array, you must use UntypedFormArray, because TypeScript cannot infer which element type will occur at which position. FormGroup and FormRecord Angular provides the FormGroup type for forms with an enumerated s",
    "id": "strictly-typed-reactive-forms-*-angular-7"
  },
  {
    "url": "https://angular.dev/guide/forms/typed-forms",
    "title": "Strictly typed reactive forms • Angular",
    "chunk": "et of keys, and a type called FormRecord, for open-ended or dynamic groups. Partial Values Consider again a login form: const login = new FormGroup({ email: new FormControl('', {nonNullable: true}), password: new FormControl('', {nonNullable: true}),}); On any FormGroup, it is possible to disable controls. Any disabled control will not appear in the group's value. As a consequence, the type of login.value is Partial<{email: string, password: string}>. The Partial in this type means that each mem",
    "id": "strictly-typed-reactive-forms-*-angular-8"
  },
  {
    "url": "https://angular.dev/guide/forms/typed-forms",
    "title": "Strictly typed reactive forms • Angular",
    "chunk": "ber might be undefined. More specifically, the type of login.value.email is string|undefined, and TypeScript will enforce that you handle the possibly undefined value (if you have strictNullChecks enabled). If you want to access the value including disabled controls, and thus bypass possible undefined fields, you can use login.getRawValue(). Optional Controls and Dynamic Groups Some forms have controls that may or may not be present, which can be added and removed at runtime. You can represent t",
    "id": "strictly-typed-reactive-forms-*-angular-9"
  },
  {
    "url": "https://angular.dev/guide/forms/typed-forms",
    "title": "Strictly typed reactive forms • Angular",
    "chunk": "hese controls using optional fields: interface LoginForm { email: FormControl<string>; password?: FormControl<string>;}const login = new FormGroup<LoginForm>({ email: new FormControl('', {nonNullable: true}), password: new FormControl('', {nonNullable: true}),});login.removeControl('password'); In this form, we explicitly specify the type, which allows us to make the password control optional. TypeScript will enforce that only optional controls can be added or removed. FormRecord Some FormGroup ",
    "id": "strictly-typed-reactive-forms-*-angular-10"
  },
  {
    "url": "https://angular.dev/guide/forms/typed-forms",
    "title": "Strictly typed reactive forms • Angular",
    "chunk": "usages do not fit the above pattern because the keys are not known ahead of time. The FormRecord class is designed for that case: const addresses = new FormRecord<FormControl<string|null>>({});addresses.addControl('Andrew', new FormControl('2340 Folsom St')); Any control of type string|null can be added to this FormRecord. If you need a FormGroup that is both dynamic (open-ended) and heterogeneous (the controls are different types), no improved type safety is possible, and you should use Untyped",
    "id": "strictly-typed-reactive-forms-*-angular-11"
  },
  {
    "url": "https://angular.dev/guide/forms/typed-forms",
    "title": "Strictly typed reactive forms • Angular",
    "chunk": "FormGroup. A FormRecord can also be built with the FormBuilder: const addresses = fb.record({'Andrew': '2340 Folsom St'}); FormBuilder and NonNullableFormBuilder The FormBuilder class has been upgraded to support the new types as well, in the same manner as the above examples. Additionally, an additional builder is available: NonNullableFormBuilder. This type is shorthand for specifying {nonNullable: true} on every control, and can eliminate significant boilerplate from large non-nullable forms.",
    "id": "strictly-typed-reactive-forms-*-angular-12"
  },
  {
    "url": "https://angular.dev/guide/forms/typed-forms",
    "title": "Strictly typed reactive forms • Angular",
    "chunk": " You can access it using the nonNullable property on a FormBuilder: const fb = new FormBuilder();const login = fb.nonNullable.group({ email: '', password: '',}); On the above example, both inner controls will be non-nullable (i.e. nonNullable will be set). You can also inject it using the name NonNullableFormBuilder. Social MediaBlogX (formerly Twitter)BlueskyYouTube Discord GitHub Stack Overflow Community Contribute Code of Conduct Report Issues Google's DevLibrary Angular Google Developer Expe",
    "id": "strictly-typed-reactive-forms-*-angular-13"
  },
  {
    "url": "https://angular.dev/guide/forms/typed-forms",
    "title": "Strictly typed reactive forms • Angular",
    "chunk": "rts ResourcesPress KitRoadmapLanguages简体中文版正體中文版日本語版한국어 Ελληνικά Super-powered by Google ©2010-2025. Code licensed under an MIT-style License . Documentation licensed under CC BY 4.0 .",
    "id": "strictly-typed-reactive-forms-*-angular-14"
  },
  {
    "url": "https://angular.dev/guide/forms/template-driven-forms",
    "title": "Template-driven forms • Angular",
    "chunk": "In-depth GuidesForms Building a template-driven form This tutorial shows you how to create a template-driven form. The control elements in the form are bound to data properties that have input validation. The input validation helps maintain data integrity and styling to improve the user experience. Template-driven forms use two-way data binding to update the data model in the component as changes are made in the template and vice versa. Template vs Reactive forms Angular supports two design appr",
    "id": "template-driven-forms-*-angular-0"
  },
  {
    "url": "https://angular.dev/guide/forms/template-driven-forms",
    "title": "Template-driven forms • Angular",
    "chunk": "oaches for interactive forms. Template-driven forms allow you to use form-specific directives in your Angular template. Reactive forms provide a model-driven approach to building forms. Template-driven forms are a great choice for small or simple forms, while reactive forms are more scalable and suitable for complex forms. For a comparison of the two approaches, see Choosing an approach You can build almost any kind of form with an Angular template —login forms, contact forms, and pretty much an",
    "id": "template-driven-forms-*-angular-1"
  },
  {
    "url": "https://angular.dev/guide/forms/template-driven-forms",
    "title": "Template-driven forms • Angular",
    "chunk": "y business form. You can lay out the controls creatively and bind them to the data in your object model. You can specify validation rules and display validation errors, conditionally allow input from specific controls, trigger built-in visual feedback, and much more. On this pagearrow_upward_alt Back to the top Objectives This tutorial teaches you how to do the following: Build an Angular form with a component and template Use ngModel to create two-way data bindings for reading and writing input",
    "id": "template-driven-forms-*-angular-2"
  },
  {
    "url": "https://angular.dev/guide/forms/template-driven-forms",
    "title": "Template-driven forms • Angular",
    "chunk": "-control values Provide visual feedback using special CSS classes that track the state of the controls Display validation errors to users and conditionally allow input from form controls based on the form status Share information across HTML elements using template reference variables Build a template-driven form Template-driven forms rely on directives defined in the FormsModule. Directives Details NgModel Reconciles value changes in the attached form element with changes in the data model, all",
    "id": "template-driven-forms-*-angular-3"
  },
  {
    "url": "https://angular.dev/guide/forms/template-driven-forms",
    "title": "Template-driven forms • Angular",
    "chunk": "owing you to respond to user input with input validation and error handling. NgForm Creates a top-level FormGroup instance and binds it to a <form> element to track aggregated form value and validation status. As soon as you import FormsModule, this directive becomes active by default on all <form> tags. You don't need to add a special selector. NgModelGroup Creates and binds a FormGroup instance to a DOM element. Step overview In the course of this tutorial, you bind a sample form to data and h",
    "id": "template-driven-forms-*-angular-4"
  },
  {
    "url": "https://angular.dev/guide/forms/template-driven-forms",
    "title": "Template-driven forms • Angular",
    "chunk": "andle user input using the following steps. Build the basic form. Define a sample data model Include required infrastructure such as the FormsModule Bind form controls to data properties using the ngModel directive and two-way data-binding syntax. Examine how ngModel reports control states using CSS classes Name controls to make them accessible to ngModel Track input validity and control status using ngModel. Add custom CSS to provide visual feedback on the status Show and hide validation-error ",
    "id": "template-driven-forms-*-angular-5"
  },
  {
    "url": "https://angular.dev/guide/forms/template-driven-forms",
    "title": "Template-driven forms • Angular",
    "chunk": "messages Respond to a native HTML button-click event by adding to the model data. Handle form submission using the ngSubmit output property of the form. Disable the Submit button until the form is valid After submit, swap out the finished form for different content on the page Build the form The provided sample application creates the Actor class which defines the data model reflected in the form. src/app/actor.ts export class Actor { constructor( public id: number, public name: string, public s",
    "id": "template-driven-forms-*-angular-6"
  },
  {
    "url": "https://angular.dev/guide/forms/template-driven-forms",
    "title": "Template-driven forms • Angular",
    "chunk": "kill: string, public studio?: string, ) {}} The form layout and details are defined in the ActorFormComponent class. src/app/actor-form/actor-form.component.ts (v1) import {Component} from '@angular/core';import {Actor} from '../actor';import {FormsModule} from '@angular/forms';import {JsonPipe} from '@angular/common';@Component({ selector: 'app-actor-form', templateUrl: './actor-form.component.html', imports: [FormsModule, JsonPipe],})export class ActorFormComponent { skills = ['Method Acting',",
    "id": "template-driven-forms-*-angular-7"
  },
  {
    "url": "https://angular.dev/guide/forms/template-driven-forms",
    "title": "Template-driven forms • Angular",
    "chunk": " 'Singing', 'Dancing', 'Swordfighting']; model = new Actor(18, 'Tom Cruise', this.skills[3], 'CW Productions'); submitted = false; onSubmit() { this.submitted = true; } newActor() { this.model = new Actor(42, '', ''); } heroine(): Actor { const myActress = new Actor(42, 'Marilyn Monroe', 'Singing'); console.log('My actress is called ' + myActress.name); // \"My actress is called Marilyn\" return myActress; } //////// NOT SHOWN IN DOCS //////// // Reveal in html: // Name via form.controls = {{showF",
    "id": "template-driven-forms-*-angular-8"
  },
  {
    "url": "https://angular.dev/guide/forms/template-driven-forms",
    "title": "Template-driven forms • Angular",
    "chunk": "ormControls(actorForm)}} showFormControls(form: any) { return form && form.controls.name && form.controls.name.value; // Tom Cruise } /////////////////////////////} The component's selector value of \"app-actor-form\" means you can drop this form in a parent template using the <app-actor-form> tag. The following code creates a new actor instance, so that the initial form can show an example actor. import {Component} from '@angular/core';import {Actor} from '../actor';import {FormsModule} from '@an",
    "id": "template-driven-forms-*-angular-9"
  },
  {
    "url": "https://angular.dev/guide/forms/template-driven-forms",
    "title": "Template-driven forms • Angular",
    "chunk": "gular/forms';import {JsonPipe} from '@angular/common';@Component({ selector: 'app-actor-form', templateUrl: './actor-form.component.html', imports: [FormsModule, JsonPipe],})export class ActorFormComponent { skills = ['Method Acting', 'Singing', 'Dancing', 'Swordfighting']; model = new Actor(18, 'Tom Cruise', this.skills[3], 'CW Productions'); submitted = false; onSubmit() { this.submitted = true; } newActor() { this.model = new Actor(42, '', ''); } heroine(): Actor { const myActress = new Actor",
    "id": "template-driven-forms-*-angular-10"
  },
  {
    "url": "https://angular.dev/guide/forms/template-driven-forms",
    "title": "Template-driven forms • Angular",
    "chunk": "(42, 'Marilyn Monroe', 'Singing'); console.log('My actress is called ' + myActress.name); // \"My actress is called Marilyn\" return myActress; } //////// NOT SHOWN IN DOCS //////// // Reveal in html: // Name via form.controls = {{showFormControls(actorForm)}} showFormControls(form: any) { return form && form.controls.name && form.controls.name.value; // Tom Cruise } /////////////////////////////} This demo uses dummy data for model and skills. In a real app, you would inject a data service to get",
    "id": "template-driven-forms-*-angular-11"
  },
  {
    "url": "https://angular.dev/guide/forms/template-driven-forms",
    "title": "Template-driven forms • Angular",
    "chunk": " and save real data, or expose these properties as inputs and outputs. The component enables the Forms feature by importing the FormsModule module. import {Component} from '@angular/core';import {Actor} from '../actor';import {FormsModule} from '@angular/forms';import {JsonPipe} from '@angular/common';@Component({ selector: 'app-actor-form', templateUrl: './actor-form.component.html', imports: [FormsModule, JsonPipe],})export class ActorFormComponent { skills = ['Method Acting', 'Singing', 'Danc",
    "id": "template-driven-forms-*-angular-12"
  },
  {
    "url": "https://angular.dev/guide/forms/template-driven-forms",
    "title": "Template-driven forms • Angular",
    "chunk": "ing', 'Swordfighting']; model = new Actor(18, 'Tom Cruise', this.skills[3], 'CW Productions'); submitted = false; onSubmit() { this.submitted = true; } newActor() { this.model = new Actor(42, '', ''); } heroine(): Actor { const myActress = new Actor(42, 'Marilyn Monroe', 'Singing'); console.log('My actress is called ' + myActress.name); // \"My actress is called Marilyn\" return myActress; } //////// NOT SHOWN IN DOCS //////// // Reveal in html: // Name via form.controls = {{showFormControls(actor",
    "id": "template-driven-forms-*-angular-13"
  },
  {
    "url": "https://angular.dev/guide/forms/template-driven-forms",
    "title": "Template-driven forms • Angular",
    "chunk": "Form)}} showFormControls(form: any) { return form && form.controls.name && form.controls.name.value; // Tom Cruise } /////////////////////////////} The form is displayed in the application layout defined by the root component's template. src/app/app.component.html <app-actor-form /> The initial template defines the layout for a form with two form groups and a submit button. The form groups correspond to two properties of the Actor data model, name and studio. Each group has a label and a box for",
    "id": "template-driven-forms-*-angular-14"
  },
  {
    "url": "https://angular.dev/guide/forms/template-driven-forms",
    "title": "Template-driven forms • Angular",
    "chunk": " user input. The Name <input> control element has the HTML5 required attribute The Studio <input> control element does not because studio is optional The Submit button has some classes on it for styling. At this point, the form layout is all plain HTML5, with no bindings or directives. The sample form uses some style classes from Twitter Bootstrap: container, form-group, form-control, and btn. To use these styles, the application's style sheet imports the library. src/styles.css @import url('htt",
    "id": "template-driven-forms-*-angular-15"
  },
  {
    "url": "https://angular.dev/guide/forms/template-driven-forms",
    "title": "Template-driven forms • Angular",
    "chunk": "ps://unpkg.com/bootstrap@3.3.7/dist/css/bootstrap.min.css'); The form requires that an actor's skill is chosen from a predefined list of skills maintained internally in ActorFormComponent. The Angular @for loop iterates over the data values to populate the <select> element. src/app/actor-form/actor-form.component.html (skills) <div class=\"container\"> <div [hidden]=\"submitted\"> <h1>Actor Form</h1> <form (ngSubmit)=\"onSubmit()\" #actorForm=\"ngForm\"> <div class=\"form-group\"> <label for=\"name\">Name</",
    "id": "template-driven-forms-*-angular-16"
  },
  {
    "url": "https://angular.dev/guide/forms/template-driven-forms",
    "title": "Template-driven forms • Angular",
    "chunk": "label> <input type=\"text\" class=\"form-control\" id=\"name\" required [(ngModel)]=\"model.name\" name=\"name\" #name=\"ngModel\"> <div [hidden]=\"name.valid || name.pristine\" class=\"alert alert-danger\"> Name is required </div> </div> <div class=\"form-group\"> <label for=\"studio\">Studio Affiliation</label> <input type=\"text\" class=\"form-control\" id=\"studio\" [(ngModel)]=\"model.studio\" name=\"studio\"> </div> <div class=\"form-group\"> <label for=\"skill\">Skill</label> <select class=\"form-control\" id=\"skill\" requir",
    "id": "template-driven-forms-*-angular-17"
  },
  {
    "url": "https://angular.dev/guide/forms/template-driven-forms",
    "title": "Template-driven forms • Angular",
    "chunk": "ed [(ngModel)]=\"model.skill\" name=\"skill\" #skill=\"ngModel\"> @for (skill of skills; track $index) { <option [value]=\"skill\">{{ skill }}</option> } </select> <div [hidden]=\"skill.valid || skill.pristine\" class=\"alert alert-danger\"> skill is required </div> </div> <button type=\"submit\" class=\"btn btn-success\" [disabled]=\"!actorForm.form.valid\">Submit</button> <button type=\"button\" class=\"btn btn-default\" (click)=\"newActor(); actorForm.reset()\">New Actor</button> <em>with</em> reset <button type=\"bu",
    "id": "template-driven-forms-*-angular-18"
  },
  {
    "url": "https://angular.dev/guide/forms/template-driven-forms",
    "title": "Template-driven forms • Angular",
    "chunk": "tton\" class=\"btn btn-default\" (click)=\"newActor()\">New Actor</button> <em>without</em> reset <!-- NOT SHOWN IN DOCS --> <div> <hr> Name via form.controls = {{ showFormControls(actorForm) }} </div> <!-- - --> </form> </div> <div [hidden]=\"!submitted\"> <h2>You submitted the following:</h2> <div class=\"row\"> <div class=\"col-xs-3\">Name</div> <div class=\"col-xs-9\">{{ model.name }}</div> </div> <div class=\"row\"> <div class=\"col-xs-3\">Studio</div> <div class=\"col-xs-9\">{{ model.studio }}</div> </div> <",
    "id": "template-driven-forms-*-angular-19"
  },
  {
    "url": "https://angular.dev/guide/forms/template-driven-forms",
    "title": "Template-driven forms • Angular",
    "chunk": "div class=\"row\"> <div class=\"col-xs-3\">Skill</div> <div class=\"col-xs-9\">{{ model.skill }}</div> </div> <br> <button type=\"button\" class=\"btn btn-primary\" (click)=\"submitted=false\"> Edit </button> </div></div><!-- ==================================================== --> <div> <form> <!-- ... all of the form ... --> </form> </div><!-- ==================================================== --><hr><style> .no-style .ng-valid { border-left: 1px solid #CCC} .no-style .ng-invalid { border-left: 1px soli",
    "id": "template-driven-forms-*-angular-20"
  },
  {
    "url": "https://angular.dev/guide/forms/template-driven-forms",
    "title": "Template-driven forms • Angular",
    "chunk": "d #CCC}</style><div class=\"no-style\" style=\"margin-left: 4px\"> <div class=\"container\"> <h1>Actor Form</h1> <form> <div class=\"form-group\"> <label for=\"name\">Name</label> <input type=\"text\" class=\"form-control\" id=\"name\" required> </div> <div class=\"form-group\"> <label for=\"studio\">Studio</label> <input type=\"text\" class=\"form-control\" id=\"studio\"> </div> <div class=\"form-group\"> <label for=\"skill\">Skill</label> <select class=\"form-control\" id=\"skill\" required> @for(skill of skills; track $index)",
    "id": "template-driven-forms-*-angular-21"
  },
  {
    "url": "https://angular.dev/guide/forms/template-driven-forms",
    "title": "Template-driven forms • Angular",
    "chunk": " { <option [value]=\"skill\">{{ skill }}</option> } </select> </div> <button type=\"submit\" class=\"btn btn-success\">Submit</button> </form> </div> <!-- ==================================================== --> <hr> <div class=\"container\"> <h1>Actor Form</h1> <form #actorForm=\"ngForm\"> {{ model | json }} <div class=\"form-group\"> <label for=\"name\">Name</label> <input type=\"text\" class=\"form-control\" id=\"name\" required [(ngModel)]=\"model.name\" name=\"name\"> </div> <div class=\"form-group\"> <label for=\"st",
    "id": "template-driven-forms-*-angular-22"
  },
  {
    "url": "https://angular.dev/guide/forms/template-driven-forms",
    "title": "Template-driven forms • Angular",
    "chunk": "udio\">Studio</label> <input type=\"text\" class=\"form-control\" id=\"studio\" [(ngModel)]=\"model.studio\" name=\"studio\"> </div> <div class=\"form-group\"> <label for=\"skill\">Skill</label> <select class=\"form-control\" id=\"skill\" required [(ngModel)]=\"model.skill\" name=\"skill\"> @for (skill of skills; track $index) { <option [value]=\"skill\">{{ skill }}</option> } </select> </div> <button type=\"submit\" class=\"btn btn-success\">Submit</button> </form> </div> <!-- EXTRA MATERIAL FOR DOCUMENTATION --> <hr> <inp",
    "id": "template-driven-forms-*-angular-23"
  },
  {
    "url": "https://angular.dev/guide/forms/template-driven-forms",
    "title": "Template-driven forms • Angular",
    "chunk": "ut type=\"text\" class=\"form-control\" id=\"name\" required [(ngModel)]=\"model.name\" name=\"name\"> TODO: remove this: {{ model.name}} <hr> <input type=\"text\" class=\"form-control\" id=\"name\" required [ngModel]=\"model.name\" name=\"name\" (ngModelChange)=\"model.name = $event\"> TODO: remove this: {{ model.name}}</div> If you run the application right now, you see the list of skills in the selection control. The input elements are not yet bound to data values or events, so they are still blank and have no beh",
    "id": "template-driven-forms-*-angular-24"
  },
  {
    "url": "https://angular.dev/guide/forms/template-driven-forms",
    "title": "Template-driven forms • Angular",
    "chunk": "avior. Bind input controls to data properties The next step is to bind the input controls to the corresponding Actor properties with two-way data binding, so that they respond to user input by updating the data model, and also respond to programmatic changes in the data by updating the display. The ngModel directive declared in the FormsModule lets you bind controls in your template-driven form to properties in your data model. When you include the directive using the syntax for two-way data bin",
    "id": "template-driven-forms-*-angular-25"
  },
  {
    "url": "https://angular.dev/guide/forms/template-driven-forms",
    "title": "Template-driven forms • Angular",
    "chunk": "ding, [(ngModel)], Angular can track the value and user interaction of the control and keep the view synced with the model. Edit the template file actor-form.component.html. Find the <input> tag next to the Name label. Add the ngModel directive, using two-way data binding syntax [(ngModel)]=\"...\". src/app/actor-form/actor-form.component.html (excerpt) <div class=\"container\"> <div [hidden]=\"submitted\"> <h1>Actor Form</h1> <form (ngSubmit)=\"onSubmit()\" #actorForm=\"ngForm\"> <div class=\"form-group\">",
    "id": "template-driven-forms-*-angular-26"
  },
  {
    "url": "https://angular.dev/guide/forms/template-driven-forms",
    "title": "Template-driven forms • Angular",
    "chunk": " <label for=\"name\">Name</label> <input type=\"text\" class=\"form-control\" id=\"name\" required [(ngModel)]=\"model.name\" name=\"name\" #name=\"ngModel\"> <div [hidden]=\"name.valid || name.pristine\" class=\"alert alert-danger\"> Name is required </div> </div> <div class=\"form-group\"> <label for=\"studio\">Studio Affiliation</label> <input type=\"text\" class=\"form-control\" id=\"studio\" [(ngModel)]=\"model.studio\" name=\"studio\"> </div> <div class=\"form-group\"> <label for=\"skill\">Skill</label> <select class=\"form-c",
    "id": "template-driven-forms-*-angular-27"
  },
  {
    "url": "https://angular.dev/guide/forms/template-driven-forms",
    "title": "Template-driven forms • Angular",
    "chunk": "ontrol\" id=\"skill\" required [(ngModel)]=\"model.skill\" name=\"skill\" #skill=\"ngModel\"> @for (skill of skills; track $index) { <option [value]=\"skill\">{{ skill }}</option> } </select> <div [hidden]=\"skill.valid || skill.pristine\" class=\"alert alert-danger\"> skill is required </div> </div> <button type=\"submit\" class=\"btn btn-success\" [disabled]=\"!actorForm.form.valid\">Submit</button> <button type=\"button\" class=\"btn btn-default\" (click)=\"newActor(); actorForm.reset()\">New Actor</button> <em>with</e",
    "id": "template-driven-forms-*-angular-28"
  },
  {
    "url": "https://angular.dev/guide/forms/template-driven-forms",
    "title": "Template-driven forms • Angular",
    "chunk": "m> reset <button type=\"button\" class=\"btn btn-default\" (click)=\"newActor()\">New Actor</button> <em>without</em> reset <!-- NOT SHOWN IN DOCS --> <div> <hr> Name via form.controls = {{ showFormControls(actorForm) }} </div> <!-- - --> </form> </div> <div [hidden]=\"!submitted\"> <h2>You submitted the following:</h2> <div class=\"row\"> <div class=\"col-xs-3\">Name</div> <div class=\"col-xs-9\">{{ model.name }}</div> </div> <div class=\"row\"> <div class=\"col-xs-3\">Studio</div> <div class=\"col-xs-9\">{{ model",
    "id": "template-driven-forms-*-angular-29"
  },
  {
    "url": "https://angular.dev/guide/forms/template-driven-forms",
    "title": "Template-driven forms • Angular",
    "chunk": ".studio }}</div> </div> <div class=\"row\"> <div class=\"col-xs-3\">Skill</div> <div class=\"col-xs-9\">{{ model.skill }}</div> </div> <br> <button type=\"button\" class=\"btn btn-primary\" (click)=\"submitted=false\"> Edit </button> </div></div><!-- ==================================================== --> <div> <form> <!-- ... all of the form ... --> </form> </div><!-- ==================================================== --><hr><style> .no-style .ng-valid { border-left: 1px solid #CCC} .no-style .ng-invali",
    "id": "template-driven-forms-*-angular-30"
  },
  {
    "url": "https://angular.dev/guide/forms/template-driven-forms",
    "title": "Template-driven forms • Angular",
    "chunk": "d { border-left: 1px solid #CCC}</style><div class=\"no-style\" style=\"margin-left: 4px\"> <div class=\"container\"> <h1>Actor Form</h1> <form> <div class=\"form-group\"> <label for=\"name\">Name</label> <input type=\"text\" class=\"form-control\" id=\"name\" required> </div> <div class=\"form-group\"> <label for=\"studio\">Studio</label> <input type=\"text\" class=\"form-control\" id=\"studio\"> </div> <div class=\"form-group\"> <label for=\"skill\">Skill</label> <select class=\"form-control\" id=\"skill\" required> @for(skill",
    "id": "template-driven-forms-*-angular-31"
  },
  {
    "url": "https://angular.dev/guide/forms/template-driven-forms",
    "title": "Template-driven forms • Angular",
    "chunk": " of skills; track $index) { <option [value]=\"skill\">{{ skill }}</option> } </select> </div> <button type=\"submit\" class=\"btn btn-success\">Submit</button> </form> </div> <!-- ==================================================== --> <hr> <div class=\"container\"> <h1>Actor Form</h1> <form #actorForm=\"ngForm\"> {{ model | json }} <div class=\"form-group\"> <label for=\"name\">Name</label> <input type=\"text\" class=\"form-control\" id=\"name\" required [(ngModel)]=\"model.name\" name=\"name\"> </div> <div class=\"fo",
    "id": "template-driven-forms-*-angular-32"
  },
  {
    "url": "https://angular.dev/guide/forms/template-driven-forms",
    "title": "Template-driven forms • Angular",
    "chunk": "rm-group\"> <label for=\"studio\">Studio</label> <input type=\"text\" class=\"form-control\" id=\"studio\" [(ngModel)]=\"model.studio\" name=\"studio\"> </div> <div class=\"form-group\"> <label for=\"skill\">Skill</label> <select class=\"form-control\" id=\"skill\" required [(ngModel)]=\"model.skill\" name=\"skill\"> @for (skill of skills; track $index) { <option [value]=\"skill\">{{ skill }}</option> } </select> </div> <button type=\"submit\" class=\"btn btn-success\">Submit</button> </form> </div> <!-- EXTRA MATERIAL FOR DO",
    "id": "template-driven-forms-*-angular-33"
  },
  {
    "url": "https://angular.dev/guide/forms/template-driven-forms",
    "title": "Template-driven forms • Angular",
    "chunk": "CUMENTATION --> <hr> <input type=\"text\" class=\"form-control\" id=\"name\" required [(ngModel)]=\"model.name\" name=\"name\"> TODO: remove this: {{ model.name}} <hr> <input type=\"text\" class=\"form-control\" id=\"name\" required [ngModel]=\"model.name\" name=\"name\" (ngModelChange)=\"model.name = $event\"> TODO: remove this: {{ model.name}}</div> HELPFUL: This example has a temporary diagnostic interpolation after each input tag, {{model.name}}, to show the current data value of the corresponding property. The c",
    "id": "template-driven-forms-*-angular-34"
  },
  {
    "url": "https://angular.dev/guide/forms/template-driven-forms",
    "title": "Template-driven forms • Angular",
    "chunk": "omment reminds you to remove the diagnostic lines when you have finished observing the two-way data binding at work. Access the overall form status When you imported the FormsModule in your component, Angular automatically created and attached an NgForm directive to the <form> tag in the template (because NgForm has the selector form that matches <form> elements). To get access to the NgForm and the overall form status, declare a template reference variable. Edit the template file actor-form.com",
    "id": "template-driven-forms-*-angular-35"
  },
  {
    "url": "https://angular.dev/guide/forms/template-driven-forms",
    "title": "Template-driven forms • Angular",
    "chunk": "ponent.html. Update the <form> tag with a template reference variable, #actorForm, and set its value as follows. src/app/actor-form/actor-form.component.html (excerpt) <div class=\"container\"> <div [hidden]=\"submitted\"> <h1>Actor Form</h1> <form (ngSubmit)=\"onSubmit()\" #actorForm=\"ngForm\"> <div class=\"form-group\"> <label for=\"name\">Name</label> <input type=\"text\" class=\"form-control\" id=\"name\" required [(ngModel)]=\"model.name\" name=\"name\" #name=\"ngModel\"> <div [hidden]=\"name.valid || name.pristin",
    "id": "template-driven-forms-*-angular-36"
  },
  {
    "url": "https://angular.dev/guide/forms/template-driven-forms",
    "title": "Template-driven forms • Angular",
    "chunk": "e\" class=\"alert alert-danger\"> Name is required </div> </div> <div class=\"form-group\"> <label for=\"studio\">Studio Affiliation</label> <input type=\"text\" class=\"form-control\" id=\"studio\" [(ngModel)]=\"model.studio\" name=\"studio\"> </div> <div class=\"form-group\"> <label for=\"skill\">Skill</label> <select class=\"form-control\" id=\"skill\" required [(ngModel)]=\"model.skill\" name=\"skill\" #skill=\"ngModel\"> @for (skill of skills; track $index) { <option [value]=\"skill\">{{ skill }}</option> } </select> <div ",
    "id": "template-driven-forms-*-angular-37"
  },
  {
    "url": "https://angular.dev/guide/forms/template-driven-forms",
    "title": "Template-driven forms • Angular",
    "chunk": "[hidden]=\"skill.valid || skill.pristine\" class=\"alert alert-danger\"> skill is required </div> </div> <button type=\"submit\" class=\"btn btn-success\" [disabled]=\"!actorForm.form.valid\">Submit</button> <button type=\"button\" class=\"btn btn-default\" (click)=\"newActor(); actorForm.reset()\">New Actor</button> <em>with</em> reset <button type=\"button\" class=\"btn btn-default\" (click)=\"newActor()\">New Actor</button> <em>without</em> reset <!-- NOT SHOWN IN DOCS --> <div> <hr> Name via form.controls = {{ sh",
    "id": "template-driven-forms-*-angular-38"
  },
  {
    "url": "https://angular.dev/guide/forms/template-driven-forms",
    "title": "Template-driven forms • Angular",
    "chunk": "owFormControls(actorForm) }} </div> <!-- - --> </form> </div> <div [hidden]=\"!submitted\"> <h2>You submitted the following:</h2> <div class=\"row\"> <div class=\"col-xs-3\">Name</div> <div class=\"col-xs-9\">{{ model.name }}</div> </div> <div class=\"row\"> <div class=\"col-xs-3\">Studio</div> <div class=\"col-xs-9\">{{ model.studio }}</div> </div> <div class=\"row\"> <div class=\"col-xs-3\">Skill</div> <div class=\"col-xs-9\">{{ model.skill }}</div> </div> <br> <button type=\"button\" class=\"btn btn-primary\" (click",
    "id": "template-driven-forms-*-angular-39"
  },
  {
    "url": "https://angular.dev/guide/forms/template-driven-forms",
    "title": "Template-driven forms • Angular",
    "chunk": ")=\"submitted=false\"> Edit </button> </div></div><!-- ==================================================== --> <div> <form> <!-- ... all of the form ... --> </form> </div><!-- ==================================================== --><hr><style> .no-style .ng-valid { border-left: 1px solid #CCC} .no-style .ng-invalid { border-left: 1px solid #CCC}</style><div class=\"no-style\" style=\"margin-left: 4px\"> <div class=\"container\"> <h1>Actor Form</h1> <form> <div class=\"form-group\"> <label for=\"name\">Name",
    "id": "template-driven-forms-*-angular-40"
  },
  {
    "url": "https://angular.dev/guide/forms/template-driven-forms",
    "title": "Template-driven forms • Angular",
    "chunk": "</label> <input type=\"text\" class=\"form-control\" id=\"name\" required> </div> <div class=\"form-group\"> <label for=\"studio\">Studio</label> <input type=\"text\" class=\"form-control\" id=\"studio\"> </div> <div class=\"form-group\"> <label for=\"skill\">Skill</label> <select class=\"form-control\" id=\"skill\" required> @for(skill of skills; track $index) { <option [value]=\"skill\">{{ skill }}</option> } </select> </div> <button type=\"submit\" class=\"btn btn-success\">Submit</button> </form> </div> <!-- ============",
    "id": "template-driven-forms-*-angular-41"
  },
  {
    "url": "https://angular.dev/guide/forms/template-driven-forms",
    "title": "Template-driven forms • Angular",
    "chunk": "======================================== --> <hr> <div class=\"container\"> <h1>Actor Form</h1> <form #actorForm=\"ngForm\"> {{ model | json }} <div class=\"form-group\"> <label for=\"name\">Name</label> <input type=\"text\" class=\"form-control\" id=\"name\" required [(ngModel)]=\"model.name\" name=\"name\"> </div> <div class=\"form-group\"> <label for=\"studio\">Studio</label> <input type=\"text\" class=\"form-control\" id=\"studio\" [(ngModel)]=\"model.studio\" name=\"studio\"> </div> <div class=\"form-group\"> <label for=\"sk",
    "id": "template-driven-forms-*-angular-42"
  },
  {
    "url": "https://angular.dev/guide/forms/template-driven-forms",
    "title": "Template-driven forms • Angular",
    "chunk": "ill\">Skill</label> <select class=\"form-control\" id=\"skill\" required [(ngModel)]=\"model.skill\" name=\"skill\"> @for (skill of skills; track $index) { <option [value]=\"skill\">{{ skill }}</option> } </select> </div> <button type=\"submit\" class=\"btn btn-success\">Submit</button> </form> </div> <!-- EXTRA MATERIAL FOR DOCUMENTATION --> <hr> <input type=\"text\" class=\"form-control\" id=\"name\" required [(ngModel)]=\"model.name\" name=\"name\"> TODO: remove this: {{ model.name}} <hr> <input type=\"text\" class=\"fo",
    "id": "template-driven-forms-*-angular-43"
  },
  {
    "url": "https://angular.dev/guide/forms/template-driven-forms",
    "title": "Template-driven forms • Angular",
    "chunk": "rm-control\" id=\"name\" required [ngModel]=\"model.name\" name=\"name\" (ngModelChange)=\"model.name = $event\"> TODO: remove this: {{ model.name}}</div> The actorForm template variable is now a reference to the NgForm directive instance that governs the form as a whole. Run the app. Start typing in the Name input box. As you add and delete characters, you can see them appear and disappear from the data model. The diagnostic line that shows interpolated values demonstrates that values are really flowing",
    "id": "template-driven-forms-*-angular-44"
  },
  {
    "url": "https://angular.dev/guide/forms/template-driven-forms",
    "title": "Template-driven forms • Angular",
    "chunk": " from the input box to the model and back again. Naming control elements When you use [(ngModel)] on an element, you must define a name attribute for that element. Angular uses the assigned name to register the element with the NgForm directive attached to the parent <form> element. The example added a name attribute to the <input> element and set it to \"name\", which makes sense for the actor's name. Any unique value will do, but using a descriptive name is helpful. Add similar [(ngModel)] bindi",
    "id": "template-driven-forms-*-angular-45"
  },
  {
    "url": "https://angular.dev/guide/forms/template-driven-forms",
    "title": "Template-driven forms • Angular",
    "chunk": "ngs and name attributes to Studio and Skill. You can now remove the diagnostic messages that show interpolated values. To confirm that two-way data binding works for the entire actor model, add a new text binding with the json pipe at the top to the component's template, which serializes the data to a string. After these revisions, the form template should look like the following: src/app/actor-form/actor-form.component.html (excerpt) <div class=\"container\"> <div [hidden]=\"submitted\"> <h1>Actor ",
    "id": "template-driven-forms-*-angular-46"
  },
  {
    "url": "https://angular.dev/guide/forms/template-driven-forms",
    "title": "Template-driven forms • Angular",
    "chunk": "Form</h1> <form (ngSubmit)=\"onSubmit()\" #actorForm=\"ngForm\"> <div class=\"form-group\"> <label for=\"name\">Name</label> <input type=\"text\" class=\"form-control\" id=\"name\" required [(ngModel)]=\"model.name\" name=\"name\" #name=\"ngModel\"> <div [hidden]=\"name.valid || name.pristine\" class=\"alert alert-danger\"> Name is required </div> </div> <div class=\"form-group\"> <label for=\"studio\">Studio Affiliation</label> <input type=\"text\" class=\"form-control\" id=\"studio\" [(ngModel)]=\"model.studio\" name=\"studio\"> <",
    "id": "template-driven-forms-*-angular-47"
  },
  {
    "url": "https://angular.dev/guide/forms/template-driven-forms",
    "title": "Template-driven forms • Angular",
    "chunk": "/div> <div class=\"form-group\"> <label for=\"skill\">Skill</label> <select class=\"form-control\" id=\"skill\" required [(ngModel)]=\"model.skill\" name=\"skill\" #skill=\"ngModel\"> @for (skill of skills; track $index) { <option [value]=\"skill\">{{ skill }}</option> } </select> <div [hidden]=\"skill.valid || skill.pristine\" class=\"alert alert-danger\"> skill is required </div> </div> <button type=\"submit\" class=\"btn btn-success\" [disabled]=\"!actorForm.form.valid\">Submit</button> <button type=\"button\" class=\"bt",
    "id": "template-driven-forms-*-angular-48"
  },
  {
    "url": "https://angular.dev/guide/forms/template-driven-forms",
    "title": "Template-driven forms • Angular",
    "chunk": "n btn-default\" (click)=\"newActor(); actorForm.reset()\">New Actor</button> <em>with</em> reset <button type=\"button\" class=\"btn btn-default\" (click)=\"newActor()\">New Actor</button> <em>without</em> reset <!-- NOT SHOWN IN DOCS --> <div> <hr> Name via form.controls = {{ showFormControls(actorForm) }} </div> <!-- - --> </form> </div> <div [hidden]=\"!submitted\"> <h2>You submitted the following:</h2> <div class=\"row\"> <div class=\"col-xs-3\">Name</div> <div class=\"col-xs-9\">{{ model.name }}</div> </div",
    "id": "template-driven-forms-*-angular-49"
  },
  {
    "url": "https://angular.dev/guide/forms/template-driven-forms",
    "title": "Template-driven forms • Angular",
    "chunk": "> <div class=\"row\"> <div class=\"col-xs-3\">Studio</div> <div class=\"col-xs-9\">{{ model.studio }}</div> </div> <div class=\"row\"> <div class=\"col-xs-3\">Skill</div> <div class=\"col-xs-9\">{{ model.skill }}</div> </div> <br> <button type=\"button\" class=\"btn btn-primary\" (click)=\"submitted=false\"> Edit </button> </div></div><!-- ==================================================== --> <div> <form> <!-- ... all of the form ... --> </form> </div><!-- ==================================================== -",
    "id": "template-driven-forms-*-angular-50"
  },
  {
    "url": "https://angular.dev/guide/forms/template-driven-forms",
    "title": "Template-driven forms • Angular",
    "chunk": "-><hr><style> .no-style .ng-valid { border-left: 1px solid #CCC} .no-style .ng-invalid { border-left: 1px solid #CCC}</style><div class=\"no-style\" style=\"margin-left: 4px\"> <div class=\"container\"> <h1>Actor Form</h1> <form> <div class=\"form-group\"> <label for=\"name\">Name</label> <input type=\"text\" class=\"form-control\" id=\"name\" required> </div> <div class=\"form-group\"> <label for=\"studio\">Studio</label> <input type=\"text\" class=\"form-control\" id=\"studio\"> </div> <div class=\"form-group\"> <label f",
    "id": "template-driven-forms-*-angular-51"
  },
  {
    "url": "https://angular.dev/guide/forms/template-driven-forms",
    "title": "Template-driven forms • Angular",
    "chunk": "or=\"skill\">Skill</label> <select class=\"form-control\" id=\"skill\" required> @for(skill of skills; track $index) { <option [value]=\"skill\">{{ skill }}</option> } </select> </div> <button type=\"submit\" class=\"btn btn-success\">Submit</button> </form> </div> <!-- ==================================================== --> <hr> <div class=\"container\"> <h1>Actor Form</h1> <form #actorForm=\"ngForm\"> {{ model | json }} <div class=\"form-group\"> <label for=\"name\">Name</label> <input type=\"text\" class=\"form-co",
    "id": "template-driven-forms-*-angular-52"
  },
  {
    "url": "https://angular.dev/guide/forms/template-driven-forms",
    "title": "Template-driven forms • Angular",
    "chunk": "ntrol\" id=\"name\" required [(ngModel)]=\"model.name\" name=\"name\"> </div> <div class=\"form-group\"> <label for=\"studio\">Studio</label> <input type=\"text\" class=\"form-control\" id=\"studio\" [(ngModel)]=\"model.studio\" name=\"studio\"> </div> <div class=\"form-group\"> <label for=\"skill\">Skill</label> <select class=\"form-control\" id=\"skill\" required [(ngModel)]=\"model.skill\" name=\"skill\"> @for (skill of skills; track $index) { <option [value]=\"skill\">{{ skill }}</option> } </select> </div> <button type=\"subm",
    "id": "template-driven-forms-*-angular-53"
  },
  {
    "url": "https://angular.dev/guide/forms/template-driven-forms",
    "title": "Template-driven forms • Angular",
    "chunk": "it\" class=\"btn btn-success\">Submit</button> </form> </div> <!-- EXTRA MATERIAL FOR DOCUMENTATION --> <hr> <input type=\"text\" class=\"form-control\" id=\"name\" required [(ngModel)]=\"model.name\" name=\"name\"> TODO: remove this: {{ model.name}} <hr> <input type=\"text\" class=\"form-control\" id=\"name\" required [ngModel]=\"model.name\" name=\"name\" (ngModelChange)=\"model.name = $event\"> TODO: remove this: {{ model.name}}</div> You'll notice that: Each <input> element has an id property. This is used by the <l",
    "id": "template-driven-forms-*-angular-54"
  },
  {
    "url": "https://angular.dev/guide/forms/template-driven-forms",
    "title": "Template-driven forms • Angular",
    "chunk": "abel> element's for attribute to match the label to its input control. This is a standard HTML feature. Each <input> element also has the required name property that Angular uses to register the control with the form. When you have observed the effects, you can delete the {{ model | json }} text binding. Track form states Angular applies the ng-submitted class to form elements after the form has been submitted. This class can be used to change the form's style after it has been submitted. Track ",
    "id": "template-driven-forms-*-angular-55"
  },
  {
    "url": "https://angular.dev/guide/forms/template-driven-forms",
    "title": "Template-driven forms • Angular",
    "chunk": "control states Adding the NgModel directive to a control adds class names to the control that describe its state. These classes can be used to change a control's style based on its state. The following table describes the class names that Angular applies based on the control's state. States Class if true Class if false The control has been visited. ng-touched ng-untouched The control's value has changed. ng-dirty ng-pristine The control's value is valid. ng-valid ng-invalid Angular also applies ",
    "id": "template-driven-forms-*-angular-56"
  },
  {
    "url": "https://angular.dev/guide/forms/template-driven-forms",
    "title": "Template-driven forms • Angular",
    "chunk": "the ng-submitted class to form elements upon submission, but not to the controls inside the form element. You use these CSS classes to define the styles for your control based on its status. Observe control states To see how the classes are added and removed by the framework, open the browser's developer tools and inspect the <input> element that represents the actor name. Using your browser's developer tools, find the <input> element that corresponds to the Name input box. You can see that the ",
    "id": "template-driven-forms-*-angular-57"
  },
  {
    "url": "https://angular.dev/guide/forms/template-driven-forms",
    "title": "Template-driven forms • Angular",
    "chunk": "element has multiple CSS classes in addition to \"form-control\". When you first bring it up, the classes indicate that it has a valid value, that the value has not been changed since initialization or reset, and that the control has not been visited since initialization or reset. <input class=\"form-control ng-untouched ng-pristine ng-valid\">; Take the following actions on the Name <input> box, and observe which classes appear. Look but don't touch. The classes indicate that it is untouched, prist",
    "id": "template-driven-forms-*-angular-58"
  },
  {
    "url": "https://angular.dev/guide/forms/template-driven-forms",
    "title": "Template-driven forms • Angular",
    "chunk": "ine, and valid. Click inside the name box, then click outside it. The control has now been visited, and the element has the ng-touched class instead of the ng-untouched class. Add slashes to the end of the name. It is now touched and dirty. Erase the name. This makes the value invalid, so the ng-invalid class replaces the ng-valid class. Create visual feedback for states The ng-valid/ng-invalid pair is particularly interesting, because you want to send a strong visual signal when the values are ",
    "id": "template-driven-forms-*-angular-59"
  },
  {
    "url": "https://angular.dev/guide/forms/template-driven-forms",
    "title": "Template-driven forms • Angular",
    "chunk": "invalid. You also want to mark required fields. You can mark required fields and invalid data at the same time with a colored bar on the left of the input box. To change the appearance in this way, take the following steps. Add definitions for the ng-* CSS classes. Add these class definitions to a new forms.css file. Add the new file to the project as a sibling to index.html: src/assets/forms.css .ng-valid[required], .ng-valid.required { border-left: 5px solid #42A948; /* green */}.ng-invalid:no",
    "id": "template-driven-forms-*-angular-60"
  },
  {
    "url": "https://angular.dev/guide/forms/template-driven-forms",
    "title": "Template-driven forms • Angular",
    "chunk": "t(form) { border-left: 5px solid #a94442; /* red */} In the index.html file, update the <head> tag to include the new style sheet. src/index.html (styles) <!DOCTYPE html><html lang=\"en\"> <head> <title>Hero Form</title> <base href=\"/\"> <meta charset=\"UTF-8\"> <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\"> <link rel=\"stylesheet\" href=\"https://unpkg.com/bootstrap@3.3.7/dist/css/bootstrap.min.css\"> <link rel=\"stylesheet\" href=\"assets/forms.css\"> </head> <body> <app-root></app-ro",
    "id": "template-driven-forms-*-angular-61"
  },
  {
    "url": "https://angular.dev/guide/forms/template-driven-forms",
    "title": "Template-driven forms • Angular",
    "chunk": "ot> </body></html> Show and hide validation error messages The Name input box is required and clearing it turns the bar red. That indicates that something is wrong, but the user doesn't know what is wrong or what to do about it. You can provide a helpful message by checking for and responding to the control's state. The Skill select box is also required, but it doesn't need this kind of error handling because the selection box already constrains the selection to valid values. To define and show ",
    "id": "template-driven-forms-*-angular-62"
  },
  {
    "url": "https://angular.dev/guide/forms/template-driven-forms",
    "title": "Template-driven forms • Angular",
    "chunk": "an error message when appropriate, take the following steps. Add a local reference to the input Extend the input tag with a template reference variable that you can use to access the input box's Angular control from within the template. In the example, the variable is #name=\"ngModel\". The template reference variable (#name) is set to \"ngModel\" because that is the value of the NgModel.exportAs property. This property tells Angular how to link a reference variable to a directive. Add the error mes",
    "id": "template-driven-forms-*-angular-63"
  },
  {
    "url": "https://angular.dev/guide/forms/template-driven-forms",
    "title": "Template-driven forms • Angular",
    "chunk": "sage Add a <div> that contains a suitable error message. Make the error message conditional Show or hide the error message by binding properties of the name control to the message <div> element's hidden property. src/app/actor-form/actor-form.component.html (hidden-error-msg) <div class=\"container\"> <div [hidden]=\"submitted\"> <h1>Actor Form</h1> <form (ngSubmit)=\"onSubmit()\" #actorForm=\"ngForm\"> <div class=\"form-group\"> <label for=\"name\">Name</label> <input type=\"text\" class=\"form-control\" id=\"n",
    "id": "template-driven-forms-*-angular-64"
  },
  {
    "url": "https://angular.dev/guide/forms/template-driven-forms",
    "title": "Template-driven forms • Angular",
    "chunk": "ame\" required [(ngModel)]=\"model.name\" name=\"name\" #name=\"ngModel\"> <div [hidden]=\"name.valid || name.pristine\" class=\"alert alert-danger\"> Name is required </div> </div> <div class=\"form-group\"> <label for=\"studio\">Studio Affiliation</label> <input type=\"text\" class=\"form-control\" id=\"studio\" [(ngModel)]=\"model.studio\" name=\"studio\"> </div> <div class=\"form-group\"> <label for=\"skill\">Skill</label> <select class=\"form-control\" id=\"skill\" required [(ngModel)]=\"model.skill\" name=\"skill\" #skill=\"ng",
    "id": "template-driven-forms-*-angular-65"
  },
  {
    "url": "https://angular.dev/guide/forms/template-driven-forms",
    "title": "Template-driven forms • Angular",
    "chunk": "Model\"> @for (skill of skills; track $index) { <option [value]=\"skill\">{{ skill }}</option> } </select> <div [hidden]=\"skill.valid || skill.pristine\" class=\"alert alert-danger\"> skill is required </div> </div> <button type=\"submit\" class=\"btn btn-success\" [disabled]=\"!actorForm.form.valid\">Submit</button> <button type=\"button\" class=\"btn btn-default\" (click)=\"newActor(); actorForm.reset()\">New Actor</button> <em>with</em> reset <button type=\"button\" class=\"btn btn-default\" (click)=\"newActor()\">N",
    "id": "template-driven-forms-*-angular-66"
  },
  {
    "url": "https://angular.dev/guide/forms/template-driven-forms",
    "title": "Template-driven forms • Angular",
    "chunk": "ew Actor</button> <em>without</em> reset <!-- NOT SHOWN IN DOCS --> <div> <hr> Name via form.controls = {{ showFormControls(actorForm) }} </div> <!-- - --> </form> </div> <div [hidden]=\"!submitted\"> <h2>You submitted the following:</h2> <div class=\"row\"> <div class=\"col-xs-3\">Name</div> <div class=\"col-xs-9\">{{ model.name }}</div> </div> <div class=\"row\"> <div class=\"col-xs-3\">Studio</div> <div class=\"col-xs-9\">{{ model.studio }}</div> </div> <div class=\"row\"> <div class=\"col-xs-3\">Skill</div> <",
    "id": "template-driven-forms-*-angular-67"
  },
  {
    "url": "https://angular.dev/guide/forms/template-driven-forms",
    "title": "Template-driven forms • Angular",
    "chunk": "div class=\"col-xs-9\">{{ model.skill }}</div> </div> <br> <button type=\"button\" class=\"btn btn-primary\" (click)=\"submitted=false\"> Edit </button> </div></div><!-- ==================================================== --> <div> <form> <!-- ... all of the form ... --> </form> </div><!-- ==================================================== --><hr><style> .no-style .ng-valid { border-left: 1px solid #CCC} .no-style .ng-invalid { border-left: 1px solid #CCC}</style><div class=\"no-style\" style=\"margin-l",
    "id": "template-driven-forms-*-angular-68"
  },
  {
    "url": "https://angular.dev/guide/forms/template-driven-forms",
    "title": "Template-driven forms • Angular",
    "chunk": "eft: 4px\"> <div class=\"container\"> <h1>Actor Form</h1> <form> <div class=\"form-group\"> <label for=\"name\">Name</label> <input type=\"text\" class=\"form-control\" id=\"name\" required> </div> <div class=\"form-group\"> <label for=\"studio\">Studio</label> <input type=\"text\" class=\"form-control\" id=\"studio\"> </div> <div class=\"form-group\"> <label for=\"skill\">Skill</label> <select class=\"form-control\" id=\"skill\" required> @for(skill of skills; track $index) { <option [value]=\"skill\">{{ skill }}</option> } </",
    "id": "template-driven-forms-*-angular-69"
  },
  {
    "url": "https://angular.dev/guide/forms/template-driven-forms",
    "title": "Template-driven forms • Angular",
    "chunk": "select> </div> <button type=\"submit\" class=\"btn btn-success\">Submit</button> </form> </div> <!-- ==================================================== --> <hr> <div class=\"container\"> <h1>Actor Form</h1> <form #actorForm=\"ngForm\"> {{ model | json }} <div class=\"form-group\"> <label for=\"name\">Name</label> <input type=\"text\" class=\"form-control\" id=\"name\" required [(ngModel)]=\"model.name\" name=\"name\"> </div> <div class=\"form-group\"> <label for=\"studio\">Studio</label> <input type=\"text\" class=\"form-",
    "id": "template-driven-forms-*-angular-70"
  },
  {
    "url": "https://angular.dev/guide/forms/template-driven-forms",
    "title": "Template-driven forms • Angular",
    "chunk": "control\" id=\"studio\" [(ngModel)]=\"model.studio\" name=\"studio\"> </div> <div class=\"form-group\"> <label for=\"skill\">Skill</label> <select class=\"form-control\" id=\"skill\" required [(ngModel)]=\"model.skill\" name=\"skill\"> @for (skill of skills; track $index) { <option [value]=\"skill\">{{ skill }}</option> } </select> </div> <button type=\"submit\" class=\"btn btn-success\">Submit</button> </form> </div> <!-- EXTRA MATERIAL FOR DOCUMENTATION --> <hr> <input type=\"text\" class=\"form-control\" id=\"name\" requir",
    "id": "template-driven-forms-*-angular-71"
  },
  {
    "url": "https://angular.dev/guide/forms/template-driven-forms",
    "title": "Template-driven forms • Angular",
    "chunk": "ed [(ngModel)]=\"model.name\" name=\"name\"> TODO: remove this: {{ model.name}} <hr> <input type=\"text\" class=\"form-control\" id=\"name\" required [ngModel]=\"model.name\" name=\"name\" (ngModelChange)=\"model.name = $event\"> TODO: remove this: {{ model.name}}</div> Add a conditional error message to name Add a conditional error message to the name input box, as in the following example. src/app/actor-form/actor-form.component.html (excerpt) <div class=\"container\"> <div [hidden]=\"submitted\"> <h1>Actor Form<",
    "id": "template-driven-forms-*-angular-72"
  },
  {
    "url": "https://angular.dev/guide/forms/template-driven-forms",
    "title": "Template-driven forms • Angular",
    "chunk": "/h1> <form (ngSubmit)=\"onSubmit()\" #actorForm=\"ngForm\"> <div class=\"form-group\"> <label for=\"name\">Name</label> <input type=\"text\" class=\"form-control\" id=\"name\" required [(ngModel)]=\"model.name\" name=\"name\" #name=\"ngModel\"> <div [hidden]=\"name.valid || name.pristine\" class=\"alert alert-danger\"> Name is required </div> </div> <div class=\"form-group\"> <label for=\"studio\">Studio Affiliation</label> <input type=\"text\" class=\"form-control\" id=\"studio\" [(ngModel)]=\"model.studio\" name=\"studio\"> </div>",
    "id": "template-driven-forms-*-angular-73"
  },
  {
    "url": "https://angular.dev/guide/forms/template-driven-forms",
    "title": "Template-driven forms • Angular",
    "chunk": " <div class=\"form-group\"> <label for=\"skill\">Skill</label> <select class=\"form-control\" id=\"skill\" required [(ngModel)]=\"model.skill\" name=\"skill\" #skill=\"ngModel\"> @for (skill of skills; track $index) { <option [value]=\"skill\">{{ skill }}</option> } </select> <div [hidden]=\"skill.valid || skill.pristine\" class=\"alert alert-danger\"> skill is required </div> </div> <button type=\"submit\" class=\"btn btn-success\" [disabled]=\"!actorForm.form.valid\">Submit</button> <button type=\"button\" class=\"btn btn",
    "id": "template-driven-forms-*-angular-74"
  },
  {
    "url": "https://angular.dev/guide/forms/template-driven-forms",
    "title": "Template-driven forms • Angular",
    "chunk": "-default\" (click)=\"newActor(); actorForm.reset()\">New Actor</button> <em>with</em> reset <button type=\"button\" class=\"btn btn-default\" (click)=\"newActor()\">New Actor</button> <em>without</em> reset <!-- NOT SHOWN IN DOCS --> <div> <hr> Name via form.controls = {{ showFormControls(actorForm) }} </div> <!-- - --> </form> </div> <div [hidden]=\"!submitted\"> <h2>You submitted the following:</h2> <div class=\"row\"> <div class=\"col-xs-3\">Name</div> <div class=\"col-xs-9\">{{ model.name }}</div> </div> <di",
    "id": "template-driven-forms-*-angular-75"
  },
  {
    "url": "https://angular.dev/guide/forms/template-driven-forms",
    "title": "Template-driven forms • Angular",
    "chunk": "v class=\"row\"> <div class=\"col-xs-3\">Studio</div> <div class=\"col-xs-9\">{{ model.studio }}</div> </div> <div class=\"row\"> <div class=\"col-xs-3\">Skill</div> <div class=\"col-xs-9\">{{ model.skill }}</div> </div> <br> <button type=\"button\" class=\"btn btn-primary\" (click)=\"submitted=false\"> Edit </button> </div></div><!-- ==================================================== --> <div> <form> <!-- ... all of the form ... --> </form> </div><!-- ==================================================== --><hr",
    "id": "template-driven-forms-*-angular-76"
  },
  {
    "url": "https://angular.dev/guide/forms/template-driven-forms",
    "title": "Template-driven forms • Angular",
    "chunk": "><style> .no-style .ng-valid { border-left: 1px solid #CCC} .no-style .ng-invalid { border-left: 1px solid #CCC}</style><div class=\"no-style\" style=\"margin-left: 4px\"> <div class=\"container\"> <h1>Actor Form</h1> <form> <div class=\"form-group\"> <label for=\"name\">Name</label> <input type=\"text\" class=\"form-control\" id=\"name\" required> </div> <div class=\"form-group\"> <label for=\"studio\">Studio</label> <input type=\"text\" class=\"form-control\" id=\"studio\"> </div> <div class=\"form-group\"> <label for=\"s",
    "id": "template-driven-forms-*-angular-77"
  },
  {
    "url": "https://angular.dev/guide/forms/template-driven-forms",
    "title": "Template-driven forms • Angular",
    "chunk": "kill\">Skill</label> <select class=\"form-control\" id=\"skill\" required> @for(skill of skills; track $index) { <option [value]=\"skill\">{{ skill }}</option> } </select> </div> <button type=\"submit\" class=\"btn btn-success\">Submit</button> </form> </div> <!-- ==================================================== --> <hr> <div class=\"container\"> <h1>Actor Form</h1> <form #actorForm=\"ngForm\"> {{ model | json }} <div class=\"form-group\"> <label for=\"name\">Name</label> <input type=\"text\" class=\"form-control",
    "id": "template-driven-forms-*-angular-78"
  },
  {
    "url": "https://angular.dev/guide/forms/template-driven-forms",
    "title": "Template-driven forms • Angular",
    "chunk": "\" id=\"name\" required [(ngModel)]=\"model.name\" name=\"name\"> </div> <div class=\"form-group\"> <label for=\"studio\">Studio</label> <input type=\"text\" class=\"form-control\" id=\"studio\" [(ngModel)]=\"model.studio\" name=\"studio\"> </div> <div class=\"form-group\"> <label for=\"skill\">Skill</label> <select class=\"form-control\" id=\"skill\" required [(ngModel)]=\"model.skill\" name=\"skill\"> @for (skill of skills; track $index) { <option [value]=\"skill\">{{ skill }}</option> } </select> </div> <button type=\"submit\" c",
    "id": "template-driven-forms-*-angular-79"
  },
  {
    "url": "https://angular.dev/guide/forms/template-driven-forms",
    "title": "Template-driven forms • Angular",
    "chunk": "lass=\"btn btn-success\">Submit</button> </form> </div> <!-- EXTRA MATERIAL FOR DOCUMENTATION --> <hr> <input type=\"text\" class=\"form-control\" id=\"name\" required [(ngModel)]=\"model.name\" name=\"name\"> TODO: remove this: {{ model.name}} <hr> <input type=\"text\" class=\"form-control\" id=\"name\" required [ngModel]=\"model.name\" name=\"name\" (ngModelChange)=\"model.name = $event\"> TODO: remove this: {{ model.name}}</div> In this example, you hide the message when the control is either valid or pristine. Pris",
    "id": "template-driven-forms-*-angular-80"
  },
  {
    "url": "https://angular.dev/guide/forms/template-driven-forms",
    "title": "Template-driven forms • Angular",
    "chunk": "tine means the user hasn't changed the value since it was displayed in this form. If you ignore the pristine state, you would hide the message only when the value is valid. If you arrive in this component with a new, blank actor or an invalid actor, you'll see the error message immediately, before you've done anything. You might want the message to display only when the user makes an invalid change. Hiding the message while the control is in the pristine state achieves that goal. You'll see the ",
    "id": "template-driven-forms-*-angular-81"
  },
  {
    "url": "https://angular.dev/guide/forms/template-driven-forms",
    "title": "Template-driven forms • Angular",
    "chunk": "significance of this choice when you add a new actor to the form in the next step. Add a new actor This exercise shows how you can respond to a native HTML button-click event by adding to the model data. To let form users add a new actor, you will add a New Actor button that responds to a click event. In the template, place a \"New Actor\" <button> element at the bottom of the form. In the component file, add the actor-creation method to the actor data model. src/app/actor-form/actor-form.componen",
    "id": "template-driven-forms-*-angular-82"
  },
  {
    "url": "https://angular.dev/guide/forms/template-driven-forms",
    "title": "Template-driven forms • Angular",
    "chunk": "t.ts (New Actor method) import {Component} from '@angular/core';import {Actor} from '../actor';import {FormsModule} from '@angular/forms';import {JsonPipe} from '@angular/common';@Component({ selector: 'app-actor-form', templateUrl: './actor-form.component.html', imports: [FormsModule, JsonPipe],})export class ActorFormComponent { skills = ['Method Acting', 'Singing', 'Dancing', 'Swordfighting']; model = new Actor(18, 'Tom Cruise', this.skills[3], 'CW Productions'); submitted = false; onSubmit()",
    "id": "template-driven-forms-*-angular-83"
  },
  {
    "url": "https://angular.dev/guide/forms/template-driven-forms",
    "title": "Template-driven forms • Angular",
    "chunk": " { this.submitted = true; } newActor() { this.model = new Actor(42, '', ''); } heroine(): Actor { const myActress = new Actor(42, 'Marilyn Monroe', 'Singing'); console.log('My actress is called ' + myActress.name); // \"My actress is called Marilyn\" return myActress; } //////// NOT SHOWN IN DOCS //////// // Reveal in html: // Name via form.controls = {{showFormControls(actorForm)}} showFormControls(form: any) { return form && form.controls.name && form.controls.name.value; // Tom Cruise } ///////",
    "id": "template-driven-forms-*-angular-84"
  },
  {
    "url": "https://angular.dev/guide/forms/template-driven-forms",
    "title": "Template-driven forms • Angular",
    "chunk": "//////////////////////} Bind the button's click event to an actor-creation method, newActor(). src/app/actor-form/actor-form.component.html (New Actor button) <div class=\"container\"> <div [hidden]=\"submitted\"> <h1>Actor Form</h1> <form (ngSubmit)=\"onSubmit()\" #actorForm=\"ngForm\"> <div class=\"form-group\"> <label for=\"name\">Name</label> <input type=\"text\" class=\"form-control\" id=\"name\" required [(ngModel)]=\"model.name\" name=\"name\" #name=\"ngModel\"> <div [hidden]=\"name.valid || name.pristine\" class=",
    "id": "template-driven-forms-*-angular-85"
  },
  {
    "url": "https://angular.dev/guide/forms/template-driven-forms",
    "title": "Template-driven forms • Angular",
    "chunk": "\"alert alert-danger\"> Name is required </div> </div> <div class=\"form-group\"> <label for=\"studio\">Studio Affiliation</label> <input type=\"text\" class=\"form-control\" id=\"studio\" [(ngModel)]=\"model.studio\" name=\"studio\"> </div> <div class=\"form-group\"> <label for=\"skill\">Skill</label> <select class=\"form-control\" id=\"skill\" required [(ngModel)]=\"model.skill\" name=\"skill\" #skill=\"ngModel\"> @for (skill of skills; track $index) { <option [value]=\"skill\">{{ skill }}</option> } </select> <div [hidden]=",
    "id": "template-driven-forms-*-angular-86"
  },
  {
    "url": "https://angular.dev/guide/forms/template-driven-forms",
    "title": "Template-driven forms • Angular",
    "chunk": "\"skill.valid || skill.pristine\" class=\"alert alert-danger\"> skill is required </div> </div> <button type=\"submit\" class=\"btn btn-success\" [disabled]=\"!actorForm.form.valid\">Submit</button> <button type=\"button\" class=\"btn btn-default\" (click)=\"newActor(); actorForm.reset()\">New Actor</button> <em>with</em> reset <button type=\"button\" class=\"btn btn-default\" (click)=\"newActor()\">New Actor</button> <em>without</em> reset <!-- NOT SHOWN IN DOCS --> <div> <hr> Name via form.controls = {{ showFormCon",
    "id": "template-driven-forms-*-angular-87"
  },
  {
    "url": "https://angular.dev/guide/forms/template-driven-forms",
    "title": "Template-driven forms • Angular",
    "chunk": "trols(actorForm) }} </div> <!-- - --> </form> </div> <div [hidden]=\"!submitted\"> <h2>You submitted the following:</h2> <div class=\"row\"> <div class=\"col-xs-3\">Name</div> <div class=\"col-xs-9\">{{ model.name }}</div> </div> <div class=\"row\"> <div class=\"col-xs-3\">Studio</div> <div class=\"col-xs-9\">{{ model.studio }}</div> </div> <div class=\"row\"> <div class=\"col-xs-3\">Skill</div> <div class=\"col-xs-9\">{{ model.skill }}</div> </div> <br> <button type=\"button\" class=\"btn btn-primary\" (click)=\"submit",
    "id": "template-driven-forms-*-angular-88"
  },
  {
    "url": "https://angular.dev/guide/forms/template-driven-forms",
    "title": "Template-driven forms • Angular",
    "chunk": "ted=false\"> Edit </button> </div></div><!-- ==================================================== --> <div> <form> <!-- ... all of the form ... --> </form> </div><!-- ==================================================== --><hr><style> .no-style .ng-valid { border-left: 1px solid #CCC} .no-style .ng-invalid { border-left: 1px solid #CCC}</style><div class=\"no-style\" style=\"margin-left: 4px\"> <div class=\"container\"> <h1>Actor Form</h1> <form> <div class=\"form-group\"> <label for=\"name\">Name</label> ",
    "id": "template-driven-forms-*-angular-89"
  },
  {
    "url": "https://angular.dev/guide/forms/template-driven-forms",
    "title": "Template-driven forms • Angular",
    "chunk": "<input type=\"text\" class=\"form-control\" id=\"name\" required> </div> <div class=\"form-group\"> <label for=\"studio\">Studio</label> <input type=\"text\" class=\"form-control\" id=\"studio\"> </div> <div class=\"form-group\"> <label for=\"skill\">Skill</label> <select class=\"form-control\" id=\"skill\" required> @for(skill of skills; track $index) { <option [value]=\"skill\">{{ skill }}</option> } </select> </div> <button type=\"submit\" class=\"btn btn-success\">Submit</button> </form> </div> <!-- =====================",
    "id": "template-driven-forms-*-angular-90"
  },
  {
    "url": "https://angular.dev/guide/forms/template-driven-forms",
    "title": "Template-driven forms • Angular",
    "chunk": "=============================== --> <hr> <div class=\"container\"> <h1>Actor Form</h1> <form #actorForm=\"ngForm\"> {{ model | json }} <div class=\"form-group\"> <label for=\"name\">Name</label> <input type=\"text\" class=\"form-control\" id=\"name\" required [(ngModel)]=\"model.name\" name=\"name\"> </div> <div class=\"form-group\"> <label for=\"studio\">Studio</label> <input type=\"text\" class=\"form-control\" id=\"studio\" [(ngModel)]=\"model.studio\" name=\"studio\"> </div> <div class=\"form-group\"> <label for=\"skill\">Skil",
    "id": "template-driven-forms-*-angular-91"
  },
  {
    "url": "https://angular.dev/guide/forms/template-driven-forms",
    "title": "Template-driven forms • Angular",
    "chunk": "l</label> <select class=\"form-control\" id=\"skill\" required [(ngModel)]=\"model.skill\" name=\"skill\"> @for (skill of skills; track $index) { <option [value]=\"skill\">{{ skill }}</option> } </select> </div> <button type=\"submit\" class=\"btn btn-success\">Submit</button> </form> </div> <!-- EXTRA MATERIAL FOR DOCUMENTATION --> <hr> <input type=\"text\" class=\"form-control\" id=\"name\" required [(ngModel)]=\"model.name\" name=\"name\"> TODO: remove this: {{ model.name}} <hr> <input type=\"text\" class=\"form-contro",
    "id": "template-driven-forms-*-angular-92"
  },
  {
    "url": "https://angular.dev/guide/forms/template-driven-forms",
    "title": "Template-driven forms • Angular",
    "chunk": "l\" id=\"name\" required [ngModel]=\"model.name\" name=\"name\" (ngModelChange)=\"model.name = $event\"> TODO: remove this: {{ model.name}}</div> Run the application again and click the New Actor button. The form clears, and the required bars to the left of the input box are red, indicating invalid name and skill properties. Notice that the error messages are hidden. This is because the form is pristine; you haven't changed anything yet. Enter a name and click New Actor again. Now the application display",
    "id": "template-driven-forms-*-angular-93"
  },
  {
    "url": "https://angular.dev/guide/forms/template-driven-forms",
    "title": "Template-driven forms • Angular",
    "chunk": "s a Name is required error message, because the input box is no longer pristine. The form remembers that you entered a name before clicking New Actor. To restore the pristine state of the form controls, clear all of the flags imperatively by calling the form's reset() method after calling the newActor() method. src/app/actor-form/actor-form.component.html (Reset the form) <div class=\"container\"> <div [hidden]=\"submitted\"> <h1>Actor Form</h1> <form (ngSubmit)=\"onSubmit()\" #actorForm=\"ngForm\"> <di",
    "id": "template-driven-forms-*-angular-94"
  },
  {
    "url": "https://angular.dev/guide/forms/template-driven-forms",
    "title": "Template-driven forms • Angular",
    "chunk": "v class=\"form-group\"> <label for=\"name\">Name</label> <input type=\"text\" class=\"form-control\" id=\"name\" required [(ngModel)]=\"model.name\" name=\"name\" #name=\"ngModel\"> <div [hidden]=\"name.valid || name.pristine\" class=\"alert alert-danger\"> Name is required </div> </div> <div class=\"form-group\"> <label for=\"studio\">Studio Affiliation</label> <input type=\"text\" class=\"form-control\" id=\"studio\" [(ngModel)]=\"model.studio\" name=\"studio\"> </div> <div class=\"form-group\"> <label for=\"skill\">Skill</label> ",
    "id": "template-driven-forms-*-angular-95"
  },
  {
    "url": "https://angular.dev/guide/forms/template-driven-forms",
    "title": "Template-driven forms • Angular",
    "chunk": "<select class=\"form-control\" id=\"skill\" required [(ngModel)]=\"model.skill\" name=\"skill\" #skill=\"ngModel\"> @for (skill of skills; track $index) { <option [value]=\"skill\">{{ skill }}</option> } </select> <div [hidden]=\"skill.valid || skill.pristine\" class=\"alert alert-danger\"> skill is required </div> </div> <button type=\"submit\" class=\"btn btn-success\" [disabled]=\"!actorForm.form.valid\">Submit</button> <button type=\"button\" class=\"btn btn-default\" (click)=\"newActor(); actorForm.reset()\">New Actor",
    "id": "template-driven-forms-*-angular-96"
  },
  {
    "url": "https://angular.dev/guide/forms/template-driven-forms",
    "title": "Template-driven forms • Angular",
    "chunk": "</button> <em>with</em> reset <button type=\"button\" class=\"btn btn-default\" (click)=\"newActor()\">New Actor</button> <em>without</em> reset <!-- NOT SHOWN IN DOCS --> <div> <hr> Name via form.controls = {{ showFormControls(actorForm) }} </div> <!-- - --> </form> </div> <div [hidden]=\"!submitted\"> <h2>You submitted the following:</h2> <div class=\"row\"> <div class=\"col-xs-3\">Name</div> <div class=\"col-xs-9\">{{ model.name }}</div> </div> <div class=\"row\"> <div class=\"col-xs-3\">Studio</div> <div clas",
    "id": "template-driven-forms-*-angular-97"
  },
  {
    "url": "https://angular.dev/guide/forms/template-driven-forms",
    "title": "Template-driven forms • Angular",
    "chunk": "s=\"col-xs-9\">{{ model.studio }}</div> </div> <div class=\"row\"> <div class=\"col-xs-3\">Skill</div> <div class=\"col-xs-9\">{{ model.skill }}</div> </div> <br> <button type=\"button\" class=\"btn btn-primary\" (click)=\"submitted=false\"> Edit </button> </div></div><!-- ==================================================== --> <div> <form> <!-- ... all of the form ... --> </form> </div><!-- ==================================================== --><hr><style> .no-style .ng-valid { border-left: 1px solid #CCC}",
    "id": "template-driven-forms-*-angular-98"
  },
  {
    "url": "https://angular.dev/guide/forms/template-driven-forms",
    "title": "Template-driven forms • Angular",
    "chunk": " .no-style .ng-invalid { border-left: 1px solid #CCC}</style><div class=\"no-style\" style=\"margin-left: 4px\"> <div class=\"container\"> <h1>Actor Form</h1> <form> <div class=\"form-group\"> <label for=\"name\">Name</label> <input type=\"text\" class=\"form-control\" id=\"name\" required> </div> <div class=\"form-group\"> <label for=\"studio\">Studio</label> <input type=\"text\" class=\"form-control\" id=\"studio\"> </div> <div class=\"form-group\"> <label for=\"skill\">Skill</label> <select class=\"form-control\" id=\"skill\"",
    "id": "template-driven-forms-*-angular-99"
  },
  {
    "url": "https://angular.dev/guide/forms/template-driven-forms",
    "title": "Template-driven forms • Angular",
    "chunk": " required> @for(skill of skills; track $index) { <option [value]=\"skill\">{{ skill }}</option> } </select> </div> <button type=\"submit\" class=\"btn btn-success\">Submit</button> </form> </div> <!-- ==================================================== --> <hr> <div class=\"container\"> <h1>Actor Form</h1> <form #actorForm=\"ngForm\"> {{ model | json }} <div class=\"form-group\"> <label for=\"name\">Name</label> <input type=\"text\" class=\"form-control\" id=\"name\" required [(ngModel)]=\"model.name\" name=\"name\"> ",
    "id": "template-driven-forms-*-angular-100"
  },
  {
    "url": "https://angular.dev/guide/forms/template-driven-forms",
    "title": "Template-driven forms • Angular",
    "chunk": "</div> <div class=\"form-group\"> <label for=\"studio\">Studio</label> <input type=\"text\" class=\"form-control\" id=\"studio\" [(ngModel)]=\"model.studio\" name=\"studio\"> </div> <div class=\"form-group\"> <label for=\"skill\">Skill</label> <select class=\"form-control\" id=\"skill\" required [(ngModel)]=\"model.skill\" name=\"skill\"> @for (skill of skills; track $index) { <option [value]=\"skill\">{{ skill }}</option> } </select> </div> <button type=\"submit\" class=\"btn btn-success\">Submit</button> </form> </div> <!-- ",
    "id": "template-driven-forms-*-angular-101"
  },
  {
    "url": "https://angular.dev/guide/forms/template-driven-forms",
    "title": "Template-driven forms • Angular",
    "chunk": "EXTRA MATERIAL FOR DOCUMENTATION --> <hr> <input type=\"text\" class=\"form-control\" id=\"name\" required [(ngModel)]=\"model.name\" name=\"name\"> TODO: remove this: {{ model.name}} <hr> <input type=\"text\" class=\"form-control\" id=\"name\" required [ngModel]=\"model.name\" name=\"name\" (ngModelChange)=\"model.name = $event\"> TODO: remove this: {{ model.name}}</div> Now clicking New Actor resets both the form and its control flags. Submit the form with ngSubmit The user should be able to submit this form after ",
    "id": "template-driven-forms-*-angular-102"
  },
  {
    "url": "https://angular.dev/guide/forms/template-driven-forms",
    "title": "Template-driven forms • Angular",
    "chunk": "filling it in. The Submit button at the bottom of the form does nothing on its own, but it does trigger a form-submit event because of its type (type=\"submit\"). To respond to this event, take the following steps. Listen to ngOnSubmit Bind the form's ngSubmit event property to the actor-form component's onSubmit() method. src/app/actor-form/actor-form.component.html (ngSubmit) <div class=\"container\"> <div [hidden]=\"submitted\"> <h1>Actor Form</h1> <form (ngSubmit)=\"onSubmit()\" #actorForm=\"ngForm\">",
    "id": "template-driven-forms-*-angular-103"
  },
  {
    "url": "https://angular.dev/guide/forms/template-driven-forms",
    "title": "Template-driven forms • Angular",
    "chunk": " <div class=\"form-group\"> <label for=\"name\">Name</label> <input type=\"text\" class=\"form-control\" id=\"name\" required [(ngModel)]=\"model.name\" name=\"name\" #name=\"ngModel\"> <div [hidden]=\"name.valid || name.pristine\" class=\"alert alert-danger\"> Name is required </div> </div> <div class=\"form-group\"> <label for=\"studio\">Studio Affiliation</label> <input type=\"text\" class=\"form-control\" id=\"studio\" [(ngModel)]=\"model.studio\" name=\"studio\"> </div> <div class=\"form-group\"> <label for=\"skill\">Skill</lab",
    "id": "template-driven-forms-*-angular-104"
  },
  {
    "url": "https://angular.dev/guide/forms/template-driven-forms",
    "title": "Template-driven forms • Angular",
    "chunk": "el> <select class=\"form-control\" id=\"skill\" required [(ngModel)]=\"model.skill\" name=\"skill\" #skill=\"ngModel\"> @for (skill of skills; track $index) { <option [value]=\"skill\">{{ skill }}</option> } </select> <div [hidden]=\"skill.valid || skill.pristine\" class=\"alert alert-danger\"> skill is required </div> </div> <button type=\"submit\" class=\"btn btn-success\" [disabled]=\"!actorForm.form.valid\">Submit</button> <button type=\"button\" class=\"btn btn-default\" (click)=\"newActor(); actorForm.reset()\">New A",
    "id": "template-driven-forms-*-angular-105"
  },
  {
    "url": "https://angular.dev/guide/forms/template-driven-forms",
    "title": "Template-driven forms • Angular",
    "chunk": "ctor</button> <em>with</em> reset <button type=\"button\" class=\"btn btn-default\" (click)=\"newActor()\">New Actor</button> <em>without</em> reset <!-- NOT SHOWN IN DOCS --> <div> <hr> Name via form.controls = {{ showFormControls(actorForm) }} </div> <!-- - --> </form> </div> <div [hidden]=\"!submitted\"> <h2>You submitted the following:</h2> <div class=\"row\"> <div class=\"col-xs-3\">Name</div> <div class=\"col-xs-9\">{{ model.name }}</div> </div> <div class=\"row\"> <div class=\"col-xs-3\">Studio</div> <div ",
    "id": "template-driven-forms-*-angular-106"
  },
  {
    "url": "https://angular.dev/guide/forms/template-driven-forms",
    "title": "Template-driven forms • Angular",
    "chunk": "class=\"col-xs-9\">{{ model.studio }}</div> </div> <div class=\"row\"> <div class=\"col-xs-3\">Skill</div> <div class=\"col-xs-9\">{{ model.skill }}</div> </div> <br> <button type=\"button\" class=\"btn btn-primary\" (click)=\"submitted=false\"> Edit </button> </div></div><!-- ==================================================== --> <div> <form> <!-- ... all of the form ... --> </form> </div><!-- ==================================================== --><hr><style> .no-style .ng-valid { border-left: 1px solid #",
    "id": "template-driven-forms-*-angular-107"
  },
  {
    "url": "https://angular.dev/guide/forms/template-driven-forms",
    "title": "Template-driven forms • Angular",
    "chunk": "CCC} .no-style .ng-invalid { border-left: 1px solid #CCC}</style><div class=\"no-style\" style=\"margin-left: 4px\"> <div class=\"container\"> <h1>Actor Form</h1> <form> <div class=\"form-group\"> <label for=\"name\">Name</label> <input type=\"text\" class=\"form-control\" id=\"name\" required> </div> <div class=\"form-group\"> <label for=\"studio\">Studio</label> <input type=\"text\" class=\"form-control\" id=\"studio\"> </div> <div class=\"form-group\"> <label for=\"skill\">Skill</label> <select class=\"form-control\" id=\"sk",
    "id": "template-driven-forms-*-angular-108"
  },
  {
    "url": "https://angular.dev/guide/forms/template-driven-forms",
    "title": "Template-driven forms • Angular",
    "chunk": "ill\" required> @for(skill of skills; track $index) { <option [value]=\"skill\">{{ skill }}</option> } </select> </div> <button type=\"submit\" class=\"btn btn-success\">Submit</button> </form> </div> <!-- ==================================================== --> <hr> <div class=\"container\"> <h1>Actor Form</h1> <form #actorForm=\"ngForm\"> {{ model | json }} <div class=\"form-group\"> <label for=\"name\">Name</label> <input type=\"text\" class=\"form-control\" id=\"name\" required [(ngModel)]=\"model.name\" name=\"nam",
    "id": "template-driven-forms-*-angular-109"
  },
  {
    "url": "https://angular.dev/guide/forms/template-driven-forms",
    "title": "Template-driven forms • Angular",
    "chunk": "e\"> </div> <div class=\"form-group\"> <label for=\"studio\">Studio</label> <input type=\"text\" class=\"form-control\" id=\"studio\" [(ngModel)]=\"model.studio\" name=\"studio\"> </div> <div class=\"form-group\"> <label for=\"skill\">Skill</label> <select class=\"form-control\" id=\"skill\" required [(ngModel)]=\"model.skill\" name=\"skill\"> @for (skill of skills; track $index) { <option [value]=\"skill\">{{ skill }}</option> } </select> </div> <button type=\"submit\" class=\"btn btn-success\">Submit</button> </form> </div> <",
    "id": "template-driven-forms-*-angular-110"
  },
  {
    "url": "https://angular.dev/guide/forms/template-driven-forms",
    "title": "Template-driven forms • Angular",
    "chunk": "!-- EXTRA MATERIAL FOR DOCUMENTATION --> <hr> <input type=\"text\" class=\"form-control\" id=\"name\" required [(ngModel)]=\"model.name\" name=\"name\"> TODO: remove this: {{ model.name}} <hr> <input type=\"text\" class=\"form-control\" id=\"name\" required [ngModel]=\"model.name\" name=\"name\" (ngModelChange)=\"model.name = $event\"> TODO: remove this: {{ model.name}}</div> Bind the disabled property Use the template reference variable, #actorForm to access the form that contains the Submit button and create an eve",
    "id": "template-driven-forms-*-angular-111"
  },
  {
    "url": "https://angular.dev/guide/forms/template-driven-forms",
    "title": "Template-driven forms • Angular",
    "chunk": "nt binding. You will bind the form property that indicates its overall validity to the Submit button's disabled property. src/app/actor-form/actor-form.component.html (submit-button) <div class=\"container\"> <div [hidden]=\"submitted\"> <h1>Actor Form</h1> <form (ngSubmit)=\"onSubmit()\" #actorForm=\"ngForm\"> <div class=\"form-group\"> <label for=\"name\">Name</label> <input type=\"text\" class=\"form-control\" id=\"name\" required [(ngModel)]=\"model.name\" name=\"name\" #name=\"ngModel\"> <div [hidden]=\"name.valid ",
    "id": "template-driven-forms-*-angular-112"
  },
  {
    "url": "https://angular.dev/guide/forms/template-driven-forms",
    "title": "Template-driven forms • Angular",
    "chunk": "|| name.pristine\" class=\"alert alert-danger\"> Name is required </div> </div> <div class=\"form-group\"> <label for=\"studio\">Studio Affiliation</label> <input type=\"text\" class=\"form-control\" id=\"studio\" [(ngModel)]=\"model.studio\" name=\"studio\"> </div> <div class=\"form-group\"> <label for=\"skill\">Skill</label> <select class=\"form-control\" id=\"skill\" required [(ngModel)]=\"model.skill\" name=\"skill\" #skill=\"ngModel\"> @for (skill of skills; track $index) { <option [value]=\"skill\">{{ skill }}</option> } ",
    "id": "template-driven-forms-*-angular-113"
  },
  {
    "url": "https://angular.dev/guide/forms/template-driven-forms",
    "title": "Template-driven forms • Angular",
    "chunk": "</select> <div [hidden]=\"skill.valid || skill.pristine\" class=\"alert alert-danger\"> skill is required </div> </div> <button type=\"submit\" class=\"btn btn-success\" [disabled]=\"!actorForm.form.valid\">Submit</button> <button type=\"button\" class=\"btn btn-default\" (click)=\"newActor(); actorForm.reset()\">New Actor</button> <em>with</em> reset <button type=\"button\" class=\"btn btn-default\" (click)=\"newActor()\">New Actor</button> <em>without</em> reset <!-- NOT SHOWN IN DOCS --> <div> <hr> Name via form.c",
    "id": "template-driven-forms-*-angular-114"
  },
  {
    "url": "https://angular.dev/guide/forms/template-driven-forms",
    "title": "Template-driven forms • Angular",
    "chunk": "ontrols = {{ showFormControls(actorForm) }} </div> <!-- - --> </form> </div> <div [hidden]=\"!submitted\"> <h2>You submitted the following:</h2> <div class=\"row\"> <div class=\"col-xs-3\">Name</div> <div class=\"col-xs-9\">{{ model.name }}</div> </div> <div class=\"row\"> <div class=\"col-xs-3\">Studio</div> <div class=\"col-xs-9\">{{ model.studio }}</div> </div> <div class=\"row\"> <div class=\"col-xs-3\">Skill</div> <div class=\"col-xs-9\">{{ model.skill }}</div> </div> <br> <button type=\"button\" class=\"btn btn-",
    "id": "template-driven-forms-*-angular-115"
  },
  {
    "url": "https://angular.dev/guide/forms/template-driven-forms",
    "title": "Template-driven forms • Angular",
    "chunk": "primary\" (click)=\"submitted=false\"> Edit </button> </div></div><!-- ==================================================== --> <div> <form> <!-- ... all of the form ... --> </form> </div><!-- ==================================================== --><hr><style> .no-style .ng-valid { border-left: 1px solid #CCC} .no-style .ng-invalid { border-left: 1px solid #CCC}</style><div class=\"no-style\" style=\"margin-left: 4px\"> <div class=\"container\"> <h1>Actor Form</h1> <form> <div class=\"form-group\"> <label ",
    "id": "template-driven-forms-*-angular-116"
  },
  {
    "url": "https://angular.dev/guide/forms/template-driven-forms",
    "title": "Template-driven forms • Angular",
    "chunk": "for=\"name\">Name</label> <input type=\"text\" class=\"form-control\" id=\"name\" required> </div> <div class=\"form-group\"> <label for=\"studio\">Studio</label> <input type=\"text\" class=\"form-control\" id=\"studio\"> </div> <div class=\"form-group\"> <label for=\"skill\">Skill</label> <select class=\"form-control\" id=\"skill\" required> @for(skill of skills; track $index) { <option [value]=\"skill\">{{ skill }}</option> } </select> </div> <button type=\"submit\" class=\"btn btn-success\">Submit</button> </form> </div> <!",
    "id": "template-driven-forms-*-angular-117"
  },
  {
    "url": "https://angular.dev/guide/forms/template-driven-forms",
    "title": "Template-driven forms • Angular",
    "chunk": "-- ==================================================== --> <hr> <div class=\"container\"> <h1>Actor Form</h1> <form #actorForm=\"ngForm\"> {{ model | json }} <div class=\"form-group\"> <label for=\"name\">Name</label> <input type=\"text\" class=\"form-control\" id=\"name\" required [(ngModel)]=\"model.name\" name=\"name\"> </div> <div class=\"form-group\"> <label for=\"studio\">Studio</label> <input type=\"text\" class=\"form-control\" id=\"studio\" [(ngModel)]=\"model.studio\" name=\"studio\"> </div> <div class=\"form-group\">",
    "id": "template-driven-forms-*-angular-118"
  },
  {
    "url": "https://angular.dev/guide/forms/template-driven-forms",
    "title": "Template-driven forms • Angular",
    "chunk": " <label for=\"skill\">Skill</label> <select class=\"form-control\" id=\"skill\" required [(ngModel)]=\"model.skill\" name=\"skill\"> @for (skill of skills; track $index) { <option [value]=\"skill\">{{ skill }}</option> } </select> </div> <button type=\"submit\" class=\"btn btn-success\">Submit</button> </form> </div> <!-- EXTRA MATERIAL FOR DOCUMENTATION --> <hr> <input type=\"text\" class=\"form-control\" id=\"name\" required [(ngModel)]=\"model.name\" name=\"name\"> TODO: remove this: {{ model.name}} <hr> <input type=\"",
    "id": "template-driven-forms-*-angular-119"
  },
  {
    "url": "https://angular.dev/guide/forms/template-driven-forms",
    "title": "Template-driven forms • Angular",
    "chunk": "text\" class=\"form-control\" id=\"name\" required [ngModel]=\"model.name\" name=\"name\" (ngModelChange)=\"model.name = $event\"> TODO: remove this: {{ model.name}}</div> Run the application Notice that the button is enabled —although it doesn't do anything useful yet. Delete the Name value This violates the \"required\" rule, so it displays the error message —and notice that it also disables the Submit button. You didn't have to explicitly wire the button's enabled state to the form's validity. The FormsMo",
    "id": "template-driven-forms-*-angular-120"
  },
  {
    "url": "https://angular.dev/guide/forms/template-driven-forms",
    "title": "Template-driven forms • Angular",
    "chunk": "dule did this automatically when you defined a template reference variable on the enhanced form element, then referred to that variable in the button control. Respond to form submission To show a response to form submission, you can hide the data entry area and display something else in its place. Wrap the form Wrap the entire form in a <div> and bind its hidden property to the ActorFormComponent.submitted property. src/app/actor-form/actor-form.component.html (excerpt) <div class=\"container\"> <",
    "id": "template-driven-forms-*-angular-121"
  },
  {
    "url": "https://angular.dev/guide/forms/template-driven-forms",
    "title": "Template-driven forms • Angular",
    "chunk": "div [hidden]=\"submitted\"> <h1>Actor Form</h1> <form (ngSubmit)=\"onSubmit()\" #actorForm=\"ngForm\"> <div class=\"form-group\"> <label for=\"name\">Name</label> <input type=\"text\" class=\"form-control\" id=\"name\" required [(ngModel)]=\"model.name\" name=\"name\" #name=\"ngModel\"> <div [hidden]=\"name.valid || name.pristine\" class=\"alert alert-danger\"> Name is required </div> </div> <div class=\"form-group\"> <label for=\"studio\">Studio Affiliation</label> <input type=\"text\" class=\"form-control\" id=\"studio\" [(ngMod",
    "id": "template-driven-forms-*-angular-122"
  },
  {
    "url": "https://angular.dev/guide/forms/template-driven-forms",
    "title": "Template-driven forms • Angular",
    "chunk": "el)]=\"model.studio\" name=\"studio\"> </div> <div class=\"form-group\"> <label for=\"skill\">Skill</label> <select class=\"form-control\" id=\"skill\" required [(ngModel)]=\"model.skill\" name=\"skill\" #skill=\"ngModel\"> @for (skill of skills; track $index) { <option [value]=\"skill\">{{ skill }}</option> } </select> <div [hidden]=\"skill.valid || skill.pristine\" class=\"alert alert-danger\"> skill is required </div> </div> <button type=\"submit\" class=\"btn btn-success\" [disabled]=\"!actorForm.form.valid\">Submit</but",
    "id": "template-driven-forms-*-angular-123"
  },
  {
    "url": "https://angular.dev/guide/forms/template-driven-forms",
    "title": "Template-driven forms • Angular",
    "chunk": "ton> <button type=\"button\" class=\"btn btn-default\" (click)=\"newActor(); actorForm.reset()\">New Actor</button> <em>with</em> reset <button type=\"button\" class=\"btn btn-default\" (click)=\"newActor()\">New Actor</button> <em>without</em> reset <!-- NOT SHOWN IN DOCS --> <div> <hr> Name via form.controls = {{ showFormControls(actorForm) }} </div> <!-- - --> </form> </div> <div [hidden]=\"!submitted\"> <h2>You submitted the following:</h2> <div class=\"row\"> <div class=\"col-xs-3\">Name</div> <div class=\"co",
    "id": "template-driven-forms-*-angular-124"
  },
  {
    "url": "https://angular.dev/guide/forms/template-driven-forms",
    "title": "Template-driven forms • Angular",
    "chunk": "l-xs-9\">{{ model.name }}</div> </div> <div class=\"row\"> <div class=\"col-xs-3\">Studio</div> <div class=\"col-xs-9\">{{ model.studio }}</div> </div> <div class=\"row\"> <div class=\"col-xs-3\">Skill</div> <div class=\"col-xs-9\">{{ model.skill }}</div> </div> <br> <button type=\"button\" class=\"btn btn-primary\" (click)=\"submitted=false\"> Edit </button> </div></div><!-- ==================================================== --> <div> <form> <!-- ... all of the form ... --> </form> </div><!-- ==================",
    "id": "template-driven-forms-*-angular-125"
  },
  {
    "url": "https://angular.dev/guide/forms/template-driven-forms",
    "title": "Template-driven forms • Angular",
    "chunk": "================================== --><hr><style> .no-style .ng-valid { border-left: 1px solid #CCC} .no-style .ng-invalid { border-left: 1px solid #CCC}</style><div class=\"no-style\" style=\"margin-left: 4px\"> <div class=\"container\"> <h1>Actor Form</h1> <form> <div class=\"form-group\"> <label for=\"name\">Name</label> <input type=\"text\" class=\"form-control\" id=\"name\" required> </div> <div class=\"form-group\"> <label for=\"studio\">Studio</label> <input type=\"text\" class=\"form-control\" id=\"studio\"> </di",
    "id": "template-driven-forms-*-angular-126"
  },
  {
    "url": "https://angular.dev/guide/forms/template-driven-forms",
    "title": "Template-driven forms • Angular",
    "chunk": "v> <div class=\"form-group\"> <label for=\"skill\">Skill</label> <select class=\"form-control\" id=\"skill\" required> @for(skill of skills; track $index) { <option [value]=\"skill\">{{ skill }}</option> } </select> </div> <button type=\"submit\" class=\"btn btn-success\">Submit</button> </form> </div> <!-- ==================================================== --> <hr> <div class=\"container\"> <h1>Actor Form</h1> <form #actorForm=\"ngForm\"> {{ model | json }} <div class=\"form-group\"> <label for=\"name\">Name</labe",
    "id": "template-driven-forms-*-angular-127"
  },
  {
    "url": "https://angular.dev/guide/forms/template-driven-forms",
    "title": "Template-driven forms • Angular",
    "chunk": "l> <input type=\"text\" class=\"form-control\" id=\"name\" required [(ngModel)]=\"model.name\" name=\"name\"> </div> <div class=\"form-group\"> <label for=\"studio\">Studio</label> <input type=\"text\" class=\"form-control\" id=\"studio\" [(ngModel)]=\"model.studio\" name=\"studio\"> </div> <div class=\"form-group\"> <label for=\"skill\">Skill</label> <select class=\"form-control\" id=\"skill\" required [(ngModel)]=\"model.skill\" name=\"skill\"> @for (skill of skills; track $index) { <option [value]=\"skill\">{{ skill }}</option> }",
    "id": "template-driven-forms-*-angular-128"
  },
  {
    "url": "https://angular.dev/guide/forms/template-driven-forms",
    "title": "Template-driven forms • Angular",
    "chunk": " </select> </div> <button type=\"submit\" class=\"btn btn-success\">Submit</button> </form> </div> <!-- EXTRA MATERIAL FOR DOCUMENTATION --> <hr> <input type=\"text\" class=\"form-control\" id=\"name\" required [(ngModel)]=\"model.name\" name=\"name\"> TODO: remove this: {{ model.name}} <hr> <input type=\"text\" class=\"form-control\" id=\"name\" required [ngModel]=\"model.name\" name=\"name\" (ngModelChange)=\"model.name = $event\"> TODO: remove this: {{ model.name}}</div> The main form is visible from the start because",
    "id": "template-driven-forms-*-angular-129"
  },
  {
    "url": "https://angular.dev/guide/forms/template-driven-forms",
    "title": "Template-driven forms • Angular",
    "chunk": " the submitted property is false until you submit the form, as this fragment from the ActorFormComponent shows: src/app/actor-form/actor-form.component.ts (submitted) import {Component} from '@angular/core';import {Actor} from '../actor';import {FormsModule} from '@angular/forms';import {JsonPipe} from '@angular/common';@Component({ selector: 'app-actor-form', templateUrl: './actor-form.component.html', imports: [FormsModule, JsonPipe],})export class ActorFormComponent { skills = ['Method Acting",
    "id": "template-driven-forms-*-angular-130"
  },
  {
    "url": "https://angular.dev/guide/forms/template-driven-forms",
    "title": "Template-driven forms • Angular",
    "chunk": "', 'Singing', 'Dancing', 'Swordfighting']; model = new Actor(18, 'Tom Cruise', this.skills[3], 'CW Productions'); submitted = false; onSubmit() { this.submitted = true; } newActor() { this.model = new Actor(42, '', ''); } heroine(): Actor { const myActress = new Actor(42, 'Marilyn Monroe', 'Singing'); console.log('My actress is called ' + myActress.name); // \"My actress is called Marilyn\" return myActress; } //////// NOT SHOWN IN DOCS //////// // Reveal in html: // Name via form.controls = {{sho",
    "id": "template-driven-forms-*-angular-131"
  },
  {
    "url": "https://angular.dev/guide/forms/template-driven-forms",
    "title": "Template-driven forms • Angular",
    "chunk": "wFormControls(actorForm)}} showFormControls(form: any) { return form && form.controls.name && form.controls.name.value; // Tom Cruise } /////////////////////////////} When you click the Submit button, the submitted flag becomes true and the form disappears. Add the submitted state To show something else while the form is in the submitted state, add the following HTML below the new <div> wrapper. src/app/actor-form/actor-form.component.html (excerpt) <div class=\"container\"> <div [hidden]=\"submitt",
    "id": "template-driven-forms-*-angular-132"
  },
  {
    "url": "https://angular.dev/guide/forms/template-driven-forms",
    "title": "Template-driven forms • Angular",
    "chunk": "ed\"> <h1>Actor Form</h1> <form (ngSubmit)=\"onSubmit()\" #actorForm=\"ngForm\"> <div class=\"form-group\"> <label for=\"name\">Name</label> <input type=\"text\" class=\"form-control\" id=\"name\" required [(ngModel)]=\"model.name\" name=\"name\" #name=\"ngModel\"> <div [hidden]=\"name.valid || name.pristine\" class=\"alert alert-danger\"> Name is required </div> </div> <div class=\"form-group\"> <label for=\"studio\">Studio Affiliation</label> <input type=\"text\" class=\"form-control\" id=\"studio\" [(ngModel)]=\"model.studio\" n",
    "id": "template-driven-forms-*-angular-133"
  },
  {
    "url": "https://angular.dev/guide/forms/template-driven-forms",
    "title": "Template-driven forms • Angular",
    "chunk": "ame=\"studio\"> </div> <div class=\"form-group\"> <label for=\"skill\">Skill</label> <select class=\"form-control\" id=\"skill\" required [(ngModel)]=\"model.skill\" name=\"skill\" #skill=\"ngModel\"> @for (skill of skills; track $index) { <option [value]=\"skill\">{{ skill }}</option> } </select> <div [hidden]=\"skill.valid || skill.pristine\" class=\"alert alert-danger\"> skill is required </div> </div> <button type=\"submit\" class=\"btn btn-success\" [disabled]=\"!actorForm.form.valid\">Submit</button> <button type=\"bu",
    "id": "template-driven-forms-*-angular-134"
  },
  {
    "url": "https://angular.dev/guide/forms/template-driven-forms",
    "title": "Template-driven forms • Angular",
    "chunk": "tton\" class=\"btn btn-default\" (click)=\"newActor(); actorForm.reset()\">New Actor</button> <em>with</em> reset <button type=\"button\" class=\"btn btn-default\" (click)=\"newActor()\">New Actor</button> <em>without</em> reset <!-- NOT SHOWN IN DOCS --> <div> <hr> Name via form.controls = {{ showFormControls(actorForm) }} </div> <!-- - --> </form> </div> <div [hidden]=\"!submitted\"> <h2>You submitted the following:</h2> <div class=\"row\"> <div class=\"col-xs-3\">Name</div> <div class=\"col-xs-9\">{{ model.name",
    "id": "template-driven-forms-*-angular-135"
  },
  {
    "url": "https://angular.dev/guide/forms/template-driven-forms",
    "title": "Template-driven forms • Angular",
    "chunk": " }}</div> </div> <div class=\"row\"> <div class=\"col-xs-3\">Studio</div> <div class=\"col-xs-9\">{{ model.studio }}</div> </div> <div class=\"row\"> <div class=\"col-xs-3\">Skill</div> <div class=\"col-xs-9\">{{ model.skill }}</div> </div> <br> <button type=\"button\" class=\"btn btn-primary\" (click)=\"submitted=false\"> Edit </button> </div></div><!-- ==================================================== --> <div> <form> <!-- ... all of the form ... --> </form> </div><!-- =======================================",
    "id": "template-driven-forms-*-angular-136"
  },
  {
    "url": "https://angular.dev/guide/forms/template-driven-forms",
    "title": "Template-driven forms • Angular",
    "chunk": "============= --><hr><style> .no-style .ng-valid { border-left: 1px solid #CCC} .no-style .ng-invalid { border-left: 1px solid #CCC}</style><div class=\"no-style\" style=\"margin-left: 4px\"> <div class=\"container\"> <h1>Actor Form</h1> <form> <div class=\"form-group\"> <label for=\"name\">Name</label> <input type=\"text\" class=\"form-control\" id=\"name\" required> </div> <div class=\"form-group\"> <label for=\"studio\">Studio</label> <input type=\"text\" class=\"form-control\" id=\"studio\"> </div> <div class=\"form-g",
    "id": "template-driven-forms-*-angular-137"
  },
  {
    "url": "https://angular.dev/guide/forms/template-driven-forms",
    "title": "Template-driven forms • Angular",
    "chunk": "roup\"> <label for=\"skill\">Skill</label> <select class=\"form-control\" id=\"skill\" required> @for(skill of skills; track $index) { <option [value]=\"skill\">{{ skill }}</option> } </select> </div> <button type=\"submit\" class=\"btn btn-success\">Submit</button> </form> </div> <!-- ==================================================== --> <hr> <div class=\"container\"> <h1>Actor Form</h1> <form #actorForm=\"ngForm\"> {{ model | json }} <div class=\"form-group\"> <label for=\"name\">Name</label> <input type=\"text\"",
    "id": "template-driven-forms-*-angular-138"
  },
  {
    "url": "https://angular.dev/guide/forms/template-driven-forms",
    "title": "Template-driven forms • Angular",
    "chunk": " class=\"form-control\" id=\"name\" required [(ngModel)]=\"model.name\" name=\"name\"> </div> <div class=\"form-group\"> <label for=\"studio\">Studio</label> <input type=\"text\" class=\"form-control\" id=\"studio\" [(ngModel)]=\"model.studio\" name=\"studio\"> </div> <div class=\"form-group\"> <label for=\"skill\">Skill</label> <select class=\"form-control\" id=\"skill\" required [(ngModel)]=\"model.skill\" name=\"skill\"> @for (skill of skills; track $index) { <option [value]=\"skill\">{{ skill }}</option> } </select> </div> <bu",
    "id": "template-driven-forms-*-angular-139"
  },
  {
    "url": "https://angular.dev/guide/forms/template-driven-forms",
    "title": "Template-driven forms • Angular",
    "chunk": "tton type=\"submit\" class=\"btn btn-success\">Submit</button> </form> </div> <!-- EXTRA MATERIAL FOR DOCUMENTATION --> <hr> <input type=\"text\" class=\"form-control\" id=\"name\" required [(ngModel)]=\"model.name\" name=\"name\"> TODO: remove this: {{ model.name}} <hr> <input type=\"text\" class=\"form-control\" id=\"name\" required [ngModel]=\"model.name\" name=\"name\" (ngModelChange)=\"model.name = $event\"> TODO: remove this: {{ model.name}}</div> This <div>, which shows a read-only actor with interpolation binding",
    "id": "template-driven-forms-*-angular-140"
  },
  {
    "url": "https://angular.dev/guide/forms/template-driven-forms",
    "title": "Template-driven forms • Angular",
    "chunk": "s, appears only while the component is in the submitted state. The alternative display includes an Edit button whose click event is bound to an expression that clears the submitted flag. Test the Edit button Click the Edit button to switch the display back to the editable form. Summary The Angular form discussed in this page takes advantage of the following framework features to provide support for data modification, validation, and more. An Angular HTML form template A form component class with",
    "id": "template-driven-forms-*-angular-141"
  },
  {
    "url": "https://angular.dev/guide/forms/template-driven-forms",
    "title": "Template-driven forms • Angular",
    "chunk": " a @Component decorator Handling form submission by binding to the NgForm.ngSubmit event property Template-reference variables such as #actorForm and #name [(ngModel)] syntax for two-way data binding The use of name attributes for validation and form-element change tracking The reference variable's valid property on input controls indicates whether a control is valid or should show error messages Controlling the Submit button's enabled state by binding to NgForm validity Custom CSS classes that ",
    "id": "template-driven-forms-*-angular-142"
  },
  {
    "url": "https://angular.dev/guide/forms/template-driven-forms",
    "title": "Template-driven forms • Angular",
    "chunk": "provide visual feedback to users about controls that are not valid Here's the code for the final version of the application: actor-form/actor-form.component.ts import {Component} from '@angular/core';import {Actor} from '../actor';import {FormsModule} from '@angular/forms';import {JsonPipe} from '@angular/common';@Component({ selector: 'app-actor-form', templateUrl: './actor-form.component.html', imports: [FormsModule, JsonPipe],})export class ActorFormComponent { skills = ['Method Acting', 'Sin",
    "id": "template-driven-forms-*-angular-143"
  },
  {
    "url": "https://angular.dev/guide/forms/template-driven-forms",
    "title": "Template-driven forms • Angular",
    "chunk": "ging', 'Dancing', 'Swordfighting']; model = new Actor(18, 'Tom Cruise', this.skills[3], 'CW Productions'); submitted = false; onSubmit() { this.submitted = true; } newActor() { this.model = new Actor(42, '', ''); } heroine(): Actor { const myActress = new Actor(42, 'Marilyn Monroe', 'Singing'); console.log('My actress is called ' + myActress.name); // \"My actress is called Marilyn\" return myActress; } //////// NOT SHOWN IN DOCS //////// // Reveal in html: // Name via form.controls = {{showFormCo",
    "id": "template-driven-forms-*-angular-144"
  },
  {
    "url": "https://angular.dev/guide/forms/template-driven-forms",
    "title": "Template-driven forms • Angular",
    "chunk": "ntrols(actorForm)}} showFormControls(form: any) { return form && form.controls.name && form.controls.name.value; // Tom Cruise } /////////////////////////////} actor-form/actor-form.component.html <div class=\"container\"> <div [hidden]=\"submitted\"> <h1>Actor Form</h1> <form (ngSubmit)=\"onSubmit()\" #actorForm=\"ngForm\"> <div class=\"form-group\"> <label for=\"name\">Name</label> <input type=\"text\" class=\"form-control\" id=\"name\" required [(ngModel)]=\"model.name\" name=\"name\" #name=\"ngModel\"> <div [hidden",
    "id": "template-driven-forms-*-angular-145"
  },
  {
    "url": "https://angular.dev/guide/forms/template-driven-forms",
    "title": "Template-driven forms • Angular",
    "chunk": "]=\"name.valid || name.pristine\" class=\"alert alert-danger\"> Name is required </div> </div> <div class=\"form-group\"> <label for=\"studio\">Studio Affiliation</label> <input type=\"text\" class=\"form-control\" id=\"studio\" [(ngModel)]=\"model.studio\" name=\"studio\"> </div> <div class=\"form-group\"> <label for=\"skill\">Skill</label> <select class=\"form-control\" id=\"skill\" required [(ngModel)]=\"model.skill\" name=\"skill\" #skill=\"ngModel\"> @for (skill of skills; track $index) { <option [value]=\"skill\">{{ skill ",
    "id": "template-driven-forms-*-angular-146"
  },
  {
    "url": "https://angular.dev/guide/forms/template-driven-forms",
    "title": "Template-driven forms • Angular",
    "chunk": "}}</option> } </select> <div [hidden]=\"skill.valid || skill.pristine\" class=\"alert alert-danger\"> skill is required </div> </div> <button type=\"submit\" class=\"btn btn-success\" [disabled]=\"!actorForm.form.valid\">Submit</button> <button type=\"button\" class=\"btn btn-default\" (click)=\"newActor(); actorForm.reset()\">New Actor</button> <em>with</em> reset <button type=\"button\" class=\"btn btn-default\" (click)=\"newActor()\">New Actor</button> <em>without</em> reset <!-- NOT SHOWN IN DOCS --> <div> <hr> N",
    "id": "template-driven-forms-*-angular-147"
  },
  {
    "url": "https://angular.dev/guide/forms/template-driven-forms",
    "title": "Template-driven forms • Angular",
    "chunk": "ame via form.controls = {{ showFormControls(actorForm) }} </div> <!-- - --> </form> </div> <div [hidden]=\"!submitted\"> <h2>You submitted the following:</h2> <div class=\"row\"> <div class=\"col-xs-3\">Name</div> <div class=\"col-xs-9\">{{ model.name }}</div> </div> <div class=\"row\"> <div class=\"col-xs-3\">Studio</div> <div class=\"col-xs-9\">{{ model.studio }}</div> </div> <div class=\"row\"> <div class=\"col-xs-3\">Skill</div> <div class=\"col-xs-9\">{{ model.skill }}</div> </div> <br> <button type=\"button\" c",
    "id": "template-driven-forms-*-angular-148"
  },
  {
    "url": "https://angular.dev/guide/forms/template-driven-forms",
    "title": "Template-driven forms • Angular",
    "chunk": "lass=\"btn btn-primary\" (click)=\"submitted=false\"> Edit </button> </div></div><!-- ==================================================== --> <div> <form> <!-- ... all of the form ... --> </form> </div><!-- ==================================================== --><hr><style> .no-style .ng-valid { border-left: 1px solid #CCC} .no-style .ng-invalid { border-left: 1px solid #CCC}</style><div class=\"no-style\" style=\"margin-left: 4px\"> <div class=\"container\"> <h1>Actor Form</h1> <form> <div class=\"form-g",
    "id": "template-driven-forms-*-angular-149"
  },
  {
    "url": "https://angular.dev/guide/forms/template-driven-forms",
    "title": "Template-driven forms • Angular",
    "chunk": "roup\"> <label for=\"name\">Name</label> <input type=\"text\" class=\"form-control\" id=\"name\" required> </div> <div class=\"form-group\"> <label for=\"studio\">Studio</label> <input type=\"text\" class=\"form-control\" id=\"studio\"> </div> <div class=\"form-group\"> <label for=\"skill\">Skill</label> <select class=\"form-control\" id=\"skill\" required> @for(skill of skills; track $index) { <option [value]=\"skill\">{{ skill }}</option> } </select> </div> <button type=\"submit\" class=\"btn btn-success\">Submit</button> </f",
    "id": "template-driven-forms-*-angular-150"
  },
  {
    "url": "https://angular.dev/guide/forms/template-driven-forms",
    "title": "Template-driven forms • Angular",
    "chunk": "orm> </div> <!-- ==================================================== --> <hr> <div class=\"container\"> <h1>Actor Form</h1> <form #actorForm=\"ngForm\"> {{ model | json }} <div class=\"form-group\"> <label for=\"name\">Name</label> <input type=\"text\" class=\"form-control\" id=\"name\" required [(ngModel)]=\"model.name\" name=\"name\"> </div> <div class=\"form-group\"> <label for=\"studio\">Studio</label> <input type=\"text\" class=\"form-control\" id=\"studio\" [(ngModel)]=\"model.studio\" name=\"studio\"> </div> <div class",
    "id": "template-driven-forms-*-angular-151"
  },
  {
    "url": "https://angular.dev/guide/forms/template-driven-forms",
    "title": "Template-driven forms • Angular",
    "chunk": "=\"form-group\"> <label for=\"skill\">Skill</label> <select class=\"form-control\" id=\"skill\" required [(ngModel)]=\"model.skill\" name=\"skill\"> @for (skill of skills; track $index) { <option [value]=\"skill\">{{ skill }}</option> } </select> </div> <button type=\"submit\" class=\"btn btn-success\">Submit</button> </form> </div> <!-- EXTRA MATERIAL FOR DOCUMENTATION --> <hr> <input type=\"text\" class=\"form-control\" id=\"name\" required [(ngModel)]=\"model.name\" name=\"name\"> TODO: remove this: {{ model.name}} <hr>",
    "id": "template-driven-forms-*-angular-152"
  },
  {
    "url": "https://angular.dev/guide/forms/template-driven-forms",
    "title": "Template-driven forms • Angular",
    "chunk": " <input type=\"text\" class=\"form-control\" id=\"name\" required [ngModel]=\"model.name\" name=\"name\" (ngModelChange)=\"model.name = $event\"> TODO: remove this: {{ model.name}}</div> actor.ts export class Actor { constructor( public id: number, public name: string, public skill: string, public studio?: string, ) {}} app.component.html <app-actor-form /> app.component.ts import {Component} from '@angular/core';import {ActorFormComponent} from './actor-form/actor-form.component';@Component({ selector: 'ap",
    "id": "template-driven-forms-*-angular-153"
  },
  {
    "url": "https://angular.dev/guide/forms/template-driven-forms",
    "title": "Template-driven forms • Angular",
    "chunk": "p-root', templateUrl: './app.component.html', imports: [ActorFormComponent],})export class AppComponent {} main.ts import {bootstrapApplication} from '@angular/platform-browser';import {AppComponent} from './app/app.component';import {provideZoneChangeDetection} from '@angular/core';bootstrapApplication(AppComponent, { providers: [provideZoneChangeDetection({eventCoalescing: true})],}).catch((err) => console.error(err)); forms.css .ng-valid[required], .ng-valid.required { border-left: 5px solid ",
    "id": "template-driven-forms-*-angular-154"
  },
  {
    "url": "https://angular.dev/guide/forms/template-driven-forms",
    "title": "Template-driven forms • Angular",
    "chunk": "#42A948; /* green */}.ng-invalid:not(form) { border-left: 5px solid #a94442; /* red */} Social MediaBlogX (formerly Twitter)BlueskyYouTube Discord GitHub Stack Overflow Community Contribute Code of Conduct Report Issues Google's DevLibrary Angular Google Developer Experts ResourcesPress KitRoadmapLanguages简体中文版正體中文版日本語版한국어 Ελληνικά Super-powered by Google ©2010-2025. Code licensed under an MIT-style License . Documentation licensed under CC BY 4.0 .",
    "id": "template-driven-forms-*-angular-155"
  },
  {
    "url": "https://angular.dev/guide/forms/form-validation",
    "title": "Validate form input • Angular",
    "chunk": "In-depth GuidesForms Validating form input You can improve overall data quality by validating user input for accuracy and completeness. This page shows how to validate user input from the UI and display useful validation messages, in both reactive and template-driven forms. On this pagearrow_upward_alt Back to the top Validating input in template-driven forms To add validation to a template-driven form, you add the same validation attributes as you would with native HTML form validation. Angular",
    "id": "validate-form-input-*-angular-0"
  },
  {
    "url": "https://angular.dev/guide/forms/form-validation",
    "title": "Validate form input • Angular",
    "chunk": " uses directives to match these attributes with validator functions in the framework. Every time the value of a form control changes, Angular runs validation and generates either a list of validation errors that results in an INVALID status, or null, which results in a VALID status. You can then inspect the control's state by exporting ngModel to a local template variable. The following example exports NgModel into a variable called name: template/actor-form-template.component.html (name) <div> ",
    "id": "validate-form-input-*-angular-1"
  },
  {
    "url": "https://angular.dev/guide/forms/form-validation",
    "title": "Validate form input • Angular",
    "chunk": "<h2>Template-Driven Form</h2> <form #actorForm=\"ngForm\" appUnambiguousRole> <div [hidden]=\"actorForm.submitted\"> <div class=\"cross-validation\" [class.cross-validation-error]=\"actorForm.hasError('unambiguousRole') && (actorForm.touched || actorForm.dirty)\"> <div class=\"form-group\"> <label for=\"name\">Name</label> <input type=\"text\" id=\"name\" name=\"name\" class=\"form-control\" required minlength=\"4\" appForbiddenName=\"bob\" [(ngModel)]=\"actor.name\" #name=\"ngModel\"> @if (name.invalid && (name.dirty || n",
    "id": "validate-form-input-*-angular-2"
  },
  {
    "url": "https://angular.dev/guide/forms/form-validation",
    "title": "Validate form input • Angular",
    "chunk": "ame.touched)) { <div class=\"alert\"> @if (name.hasError('required')) { <div> Name is required. </div> } @if (name.hasError('minlength')) { <div> Name must be at least 4 characters long. </div> } @if (name.hasError('forbiddenName')) { <div> Name cannot be Bob. </div> } </div> } </div> <div class=\"form-group\"> <label for=\"role\">Role</label> <input type=\"text\" id=\"role\" name=\"role\" #role=\"ngModel\" [(ngModel)]=\"actor.role\" [ngModelOptions]=\"{ updateOn: 'blur' }\" appUniqueRole> @if (role.pending) { <d",
    "id": "validate-form-input-*-angular-3"
  },
  {
    "url": "https://angular.dev/guide/forms/form-validation",
    "title": "Validate form input • Angular",
    "chunk": "iv>Validating...</div> } @if (role.invalid) { <div class=\"alert role-errors\"> @if (role.hasError('uniqueRole')) { <div> Role is already taken. </div> } </div> } </div> @if (actorForm.hasError('unambiguousRole') && (actorForm.touched || actorForm.dirty)) { <div class=\"cross-validation-error-message alert\"> Name cannot match role. </div> } </div> <div class=\"form-group\"> <label for=\"skill\">Skill</label> <select id=\"skill\" name=\"skill\" required [(ngModel)]=\"actor.skill\" #skill=\"ngModel\"> @for (skil",
    "id": "validate-form-input-*-angular-4"
  },
  {
    "url": "https://angular.dev/guide/forms/form-validation",
    "title": "Validate form input • Angular",
    "chunk": "l of skills; track $index) { <option [value]=\"skill\">{{ skill }}</option> } </select> @if (skill.errors && skill.touched) { <div class=\"alert\"> @if (skill.errors['required']) { <div>Skill is required.</div> } </div> } </div> <p>Complete the form to enable the Submit button.</p> <button type=\"submit\" [disabled]=\"actorForm.invalid\">Submit </button> <button type=\"button\" (click)=\"actorForm.resetForm({})\">Reset </button> </div> @if (actorForm.submitted) { <div class=\"submitted-message\"> <p>You've su",
    "id": "validate-form-input-*-angular-5"
  },
  {
    "url": "https://angular.dev/guide/forms/form-validation",
    "title": "Validate form input • Angular",
    "chunk": "bmitted your actor, {{ actorForm.value.name }}!</p> <button type=\"button\" (click)=\"actorForm.resetForm({})\">Add new actor</button> </div> } </form></div> Notice the following features illustrated by the example. The <input> element carries the HTML validation attributes: required and minlength. It also carries a custom validator directive, forbiddenName. For more information, see the Custom validators section. #name=\"ngModel\" exports NgModel into a local variable called name. NgModel mirrors man",
    "id": "validate-form-input-*-angular-6"
  },
  {
    "url": "https://angular.dev/guide/forms/form-validation",
    "title": "Validate form input • Angular",
    "chunk": "y of the properties of its underlying FormControl instance, so you can use this in the template to check for control states such as valid and dirty. For a full list of control properties, see the AbstractControl API reference. The outermost @if reveals a set of nested messages but only if the name is invalid and the control is either dirty or touched. Each nested @if can present a custom message for one of the possible validation errors. There are messages for required, minlength, and forbiddenN",
    "id": "validate-form-input-*-angular-7"
  },
  {
    "url": "https://angular.dev/guide/forms/form-validation",
    "title": "Validate form input • Angular",
    "chunk": "ame. HELPFUL: To prevent the validator from displaying errors before the user has a chance to edit the form, you should check for either the dirty or touched states in a control. When the user changes the value in the watched field, the control is marked as \"dirty\" When the user blurs the form control element, the control is marked as \"touched\" Validating input in reactive forms In a reactive form, the source of truth is the component class. Instead of adding validators through attributes in the",
    "id": "validate-form-input-*-angular-8"
  },
  {
    "url": "https://angular.dev/guide/forms/form-validation",
    "title": "Validate form input • Angular",
    "chunk": " template, you add validator functions directly to the form control model in the component class. Angular then calls these functions whenever the value of the control changes. Validator functions Validator functions can be either synchronous or asynchronous. Validator type Details Sync validators Synchronous functions that take a control instance and immediately return either a set of validation errors or null. Pass these in as the second argument when you instantiate a FormControl. Async valida",
    "id": "validate-form-input-*-angular-9"
  },
  {
    "url": "https://angular.dev/guide/forms/form-validation",
    "title": "Validate form input • Angular",
    "chunk": "tors Asynchronous functions that take a control instance and return a Promise or Observable that later emits a set of validation errors or null. Pass these in as the third argument when you instantiate a FormControl. For performance reasons, Angular only runs async validators if all sync validators pass. Each must complete before errors are set. Built-in validator functions You can choose to write your own validator functions, or you can use some of Angular's built-in validators. The same built-",
    "id": "validate-form-input-*-angular-10"
  },
  {
    "url": "https://angular.dev/guide/forms/form-validation",
    "title": "Validate form input • Angular",
    "chunk": "in validators that are available as attributes in template-driven forms, such as required and minlength, are all available to use as functions from the Validators class. For a full list of built-in validators, see the Validators API reference. To update the actor form to be a reactive form, use some of the same built-in validators —this time, in function form, as in the following example. reactive/actor-form-reactive.component.ts (validator functions) import {Component} from '@angular/core';impo",
    "id": "validate-form-input-*-angular-11"
  },
  {
    "url": "https://angular.dev/guide/forms/form-validation",
    "title": "Validate form input • Angular",
    "chunk": "rt {FormControl, FormGroup, Validators, ReactiveFormsModule} from '@angular/forms';import {forbiddenNameValidator} from '../shared/forbidden-name.directive';@Component({ selector: 'app-actor-form-reactive', templateUrl: './actor-form-reactive.component.html', styleUrls: ['./actor-form-reactive.component.css'], imports: [ReactiveFormsModule],})export class HeroFormReactiveComponent { skills = ['Method Acting', 'Singing', 'Dancing', 'Swordfighting']; actor = {name: 'Tom Cruise', role: 'Romeo', ski",
    "id": "validate-form-input-*-angular-12"
  },
  {
    "url": "https://angular.dev/guide/forms/form-validation",
    "title": "Validate form input • Angular",
    "chunk": "ll: this.skills[3]}; actorForm: FormGroup = new FormGroup({ name: new FormControl(this.actor.name, [ Validators.required, Validators.minLength(4), forbiddenNameValidator(/bob/i), // <-- Here's how you pass in the custom validator. ]), role: new FormControl(this.actor.role), skill: new FormControl(this.actor.skill, Validators.required), }); get name() { return this.actorForm.get('name'); } get skill() { return this.actorForm.get('skill'); }} In this example, the name control sets up two built-in ",
    "id": "validate-form-input-*-angular-13"
  },
  {
    "url": "https://angular.dev/guide/forms/form-validation",
    "title": "Validate form input • Angular",
    "chunk": "validators —Validators.required and Validators.minLength(4)— and one custom validator, forbiddenNameValidator. All of these validators are synchronous, so they are passed as the second argument. Notice that you can support multiple validators by passing the functions in as an array. This example also adds a few getter methods. In a reactive form, you can always access any form control through the get method on its parent group, but sometimes it's useful to define getters as shorthand for the tem",
    "id": "validate-form-input-*-angular-14"
  },
  {
    "url": "https://angular.dev/guide/forms/form-validation",
    "title": "Validate form input • Angular",
    "chunk": "plate. If you look at the template for the name input again, it is fairly similar to the template-driven example. reactive/actor-form-reactive.component.html (name with error msg) <div class=\"container\"> <h2>Reactive Form</h2> <form [formGroup]=\"actorForm\" #formDir=\"ngForm\"> <div [hidden]=\"formDir.submitted\"> <div class=\"cross-validation\" [class.cross-validation-error]=\"actorForm.hasError('unambiguousRole') && (actorForm.touched || actorForm.dirty)\"> <div class=\"form-group\"> <label for=\"name\">Na",
    "id": "validate-form-input-*-angular-15"
  },
  {
    "url": "https://angular.dev/guide/forms/form-validation",
    "title": "Validate form input • Angular",
    "chunk": "me</label> <input type=\"text\" id=\"name\" class=\"form-control\" formControlName=\"name\" required> @if (name.invalid && (name.dirty || name.touched)) { <div class=\"alert alert-danger\"> @if (name.hasError('required')) { <div> Name is required. </div> } @if (name.hasError('minlength')) { <div> Name must be at least 4 characters long. </div> } @if (name.hasError('forbiddenName')) { <div> Name cannot be Bob. </div> } </div> } </div> <div class=\"form-group\"> <label for=\"role\">Role</label> <input type=\"tex",
    "id": "validate-form-input-*-angular-16"
  },
  {
    "url": "https://angular.dev/guide/forms/form-validation",
    "title": "Validate form input • Angular",
    "chunk": "t\" id=\"role\" class=\"form-control\" formControlName=\"role\"> @if (role.pending) { <div>Validating...</div> } @if (role.invalid) { <div class=\"alert alert-danger role-errors\"> @if (role.hasError('uniqueRole')) { <div> Role is already taken. </div> } </div> } </div> @if (actorForm.hasError('unambiguousRole') && (actorForm.touched || actorForm.dirty)) { <div class=\"cross-validation-error-message alert alert-danger\"> Name cannot match role or audiences will be confused. </div> } </div> <div class=\"form",
    "id": "validate-form-input-*-angular-17"
  },
  {
    "url": "https://angular.dev/guide/forms/form-validation",
    "title": "Validate form input • Angular",
    "chunk": "-group\"> <label for=\"skill\">Skill</label> <select id=\"skill\" class=\"form-control\" formControlName=\"skill\" required> @for (skill of skills; track $index) { <option [value]=\"skill\">{{ skill }}</option> } </select> @if (skill.invalid && skill.touched) { <div class=\"alert alert-danger\"> @if (skill.hasError('required')) { <div>Skill is required.</div> } </div> } </div> <p>Complete the form to enable the Submit button.</p> <button type=\"submit\" class=\"btn btn-default\" [disabled]=\"actorForm.invalid\">Su",
    "id": "validate-form-input-*-angular-18"
  },
  {
    "url": "https://angular.dev/guide/forms/form-validation",
    "title": "Validate form input • Angular",
    "chunk": "bmit </button> <button type=\"button\" class=\"btn btn-default\" (click)=\"formDir.resetForm({})\">Reset </button> </div> </form> @if (formDir.submitted) { <div class=\"submitted-message\"> <p>You've submitted your actor, {{ actorForm.value.name }}!</p> <button type=\"button\" (click)=\"formDir.resetForm({})\">Add new actor</button> </div> }</div> This form differs from the template-driven version in that it no longer exports any directives. Instead, it uses the name getter defined in the component class. N",
    "id": "validate-form-input-*-angular-19"
  },
  {
    "url": "https://angular.dev/guide/forms/form-validation",
    "title": "Validate form input • Angular",
    "chunk": "otice that the required attribute is still present in the template. Although it's not necessary for validation, it should be retained for accessibility purposes. Defining custom validators The built-in validators don't always match the exact use case of your application, so you sometimes need to create a custom validator. Consider the forbiddenNameValidator function from the previous example. Here's what the definition of that function looks like. shared/forbidden-name.directive.ts (forbiddenNam",
    "id": "validate-form-input-*-angular-20"
  },
  {
    "url": "https://angular.dev/guide/forms/form-validation",
    "title": "Validate form input • Angular",
    "chunk": "eValidator) import {Directive, input} from '@angular/core';import { AbstractControl, NG_VALIDATORS, ValidationErrors, Validator, ValidatorFn,} from '@angular/forms';/** An actor's name can't match the given regular expression */export function forbiddenNameValidator(nameRe: RegExp): ValidatorFn { return (control: AbstractControl): ValidationErrors | null => { const forbidden = nameRe.test(control.value); return forbidden ? {forbiddenName: {value: control.value}} : null; };}@Directive({ selector:",
    "id": "validate-form-input-*-angular-21"
  },
  {
    "url": "https://angular.dev/guide/forms/form-validation",
    "title": "Validate form input • Angular",
    "chunk": " '[appForbiddenName]', providers: [{provide: NG_VALIDATORS, useExisting: ForbiddenValidatorDirective, multi: true}],})export class ForbiddenValidatorDirective implements Validator { forbiddenName = input<string>('', {alias: 'appForbiddenName'}); validate(control: AbstractControl): ValidationErrors | null { return this.forbiddenName ? forbiddenNameValidator(new RegExp(this.forbiddenName(), 'i'))(control) : null; }} The function is a factory that takes a regular expression to detect a specific for",
    "id": "validate-form-input-*-angular-22"
  },
  {
    "url": "https://angular.dev/guide/forms/form-validation",
    "title": "Validate form input • Angular",
    "chunk": "bidden name and returns a validator function. In this sample, the forbidden name is \"bob\", so the validator rejects any actor name containing \"bob\". Elsewhere it could reject \"alice\" or any name that the configuring regular expression matches. The forbiddenNameValidator factory returns the configured validator function. That function takes an Angular control object and returns either null if the control value is valid or a validation error object. The validation error object typically has a prop",
    "id": "validate-form-input-*-angular-23"
  },
  {
    "url": "https://angular.dev/guide/forms/form-validation",
    "title": "Validate form input • Angular",
    "chunk": "erty whose name is the validation key, 'forbiddenName', and whose value is an arbitrary dictionary of values that you could insert into an error message, {name}. Custom async validators are similar to sync validators, but they must instead return a Promise or observable that later emits null or a validation error object. In the case of an observable, the observable must complete, at which point the form uses the last value emitted for validation. Adding custom validators to reactive forms In rea",
    "id": "validate-form-input-*-angular-24"
  },
  {
    "url": "https://angular.dev/guide/forms/form-validation",
    "title": "Validate form input • Angular",
    "chunk": "ctive forms, add a custom validator by passing the function directly to the FormControl. reactive/actor-form-reactive.component.ts (validator functions) import {Component} from '@angular/core';import {FormControl, FormGroup, Validators, ReactiveFormsModule} from '@angular/forms';import {forbiddenNameValidator} from '../shared/forbidden-name.directive';@Component({ selector: 'app-actor-form-reactive', templateUrl: './actor-form-reactive.component.html', styleUrls: ['./actor-form-reactive.componen",
    "id": "validate-form-input-*-angular-25"
  },
  {
    "url": "https://angular.dev/guide/forms/form-validation",
    "title": "Validate form input • Angular",
    "chunk": "t.css'], imports: [ReactiveFormsModule],})export class HeroFormReactiveComponent { skills = ['Method Acting', 'Singing', 'Dancing', 'Swordfighting']; actor = {name: 'Tom Cruise', role: 'Romeo', skill: this.skills[3]}; actorForm: FormGroup = new FormGroup({ name: new FormControl(this.actor.name, [ Validators.required, Validators.minLength(4), forbiddenNameValidator(/bob/i), // <-- Here's how you pass in the custom validator. ]), role: new FormControl(this.actor.role), skill: new FormControl(this.",
    "id": "validate-form-input-*-angular-26"
  },
  {
    "url": "https://angular.dev/guide/forms/form-validation",
    "title": "Validate form input • Angular",
    "chunk": "actor.skill, Validators.required), }); get name() { return this.actorForm.get('name'); } get skill() { return this.actorForm.get('skill'); }} Adding custom validators to template-driven forms In template-driven forms, add a directive to the template, where the directive wraps the validator function. For example, the corresponding ForbiddenValidatorDirective serves as a wrapper around the forbiddenNameValidator. Angular recognizes the directive's role in the validation process because the directi",
    "id": "validate-form-input-*-angular-27"
  },
  {
    "url": "https://angular.dev/guide/forms/form-validation",
    "title": "Validate form input • Angular",
    "chunk": "ve registers itself with the NG_VALIDATORS provider, as shown in the following example. NG_VALIDATORS is a predefined provider with an extensible collection of validators. shared/forbidden-name.directive.ts (providers) import {Directive, input} from '@angular/core';import { AbstractControl, NG_VALIDATORS, ValidationErrors, Validator, ValidatorFn,} from '@angular/forms';/** An actor's name can't match the given regular expression */export function forbiddenNameValidator(nameRe: RegExp): Validator",
    "id": "validate-form-input-*-angular-28"
  },
  {
    "url": "https://angular.dev/guide/forms/form-validation",
    "title": "Validate form input • Angular",
    "chunk": "Fn { return (control: AbstractControl): ValidationErrors | null => { const forbidden = nameRe.test(control.value); return forbidden ? {forbiddenName: {value: control.value}} : null; };}@Directive({ selector: '[appForbiddenName]', providers: [{provide: NG_VALIDATORS, useExisting: ForbiddenValidatorDirective, multi: true}],})export class ForbiddenValidatorDirective implements Validator { forbiddenName = input<string>('', {alias: 'appForbiddenName'}); validate(control: AbstractControl): ValidationE",
    "id": "validate-form-input-*-angular-29"
  },
  {
    "url": "https://angular.dev/guide/forms/form-validation",
    "title": "Validate form input • Angular",
    "chunk": "rrors | null { return this.forbiddenName ? forbiddenNameValidator(new RegExp(this.forbiddenName(), 'i'))(control) : null; }} The directive class then implements the Validator interface, so that it can easily integrate with Angular forms. Here is the rest of the directive to help you get an idea of how it all comes together. shared/forbidden-name.directive.ts (directive) import {Directive, input} from '@angular/core';import { AbstractControl, NG_VALIDATORS, ValidationErrors, Validator, ValidatorF",
    "id": "validate-form-input-*-angular-30"
  },
  {
    "url": "https://angular.dev/guide/forms/form-validation",
    "title": "Validate form input • Angular",
    "chunk": "n,} from '@angular/forms';/** An actor's name can't match the given regular expression */export function forbiddenNameValidator(nameRe: RegExp): ValidatorFn { return (control: AbstractControl): ValidationErrors | null => { const forbidden = nameRe.test(control.value); return forbidden ? {forbiddenName: {value: control.value}} : null; };}@Directive({ selector: '[appForbiddenName]', providers: [{provide: NG_VALIDATORS, useExisting: ForbiddenValidatorDirective, multi: true}],})export class Forbidde",
    "id": "validate-form-input-*-angular-31"
  },
  {
    "url": "https://angular.dev/guide/forms/form-validation",
    "title": "Validate form input • Angular",
    "chunk": "nValidatorDirective implements Validator { forbiddenName = input<string>('', {alias: 'appForbiddenName'}); validate(control: AbstractControl): ValidationErrors | null { return this.forbiddenName ? forbiddenNameValidator(new RegExp(this.forbiddenName(), 'i'))(control) : null; }} Once the ForbiddenValidatorDirective is ready, you can add its selector, appForbiddenName, to any input element to activate it. For example: template/actor-form-template.component.html (forbidden-name-input) <div> <h2>Tem",
    "id": "validate-form-input-*-angular-32"
  },
  {
    "url": "https://angular.dev/guide/forms/form-validation",
    "title": "Validate form input • Angular",
    "chunk": "plate-Driven Form</h2> <form #actorForm=\"ngForm\" appUnambiguousRole> <div [hidden]=\"actorForm.submitted\"> <div class=\"cross-validation\" [class.cross-validation-error]=\"actorForm.hasError('unambiguousRole') && (actorForm.touched || actorForm.dirty)\"> <div class=\"form-group\"> <label for=\"name\">Name</label> <input type=\"text\" id=\"name\" name=\"name\" class=\"form-control\" required minlength=\"4\" appForbiddenName=\"bob\" [(ngModel)]=\"actor.name\" #name=\"ngModel\"> @if (name.invalid && (name.dirty || name.tou",
    "id": "validate-form-input-*-angular-33"
  },
  {
    "url": "https://angular.dev/guide/forms/form-validation",
    "title": "Validate form input • Angular",
    "chunk": "ched)) { <div class=\"alert\"> @if (name.hasError('required')) { <div> Name is required. </div> } @if (name.hasError('minlength')) { <div> Name must be at least 4 characters long. </div> } @if (name.hasError('forbiddenName')) { <div> Name cannot be Bob. </div> } </div> } </div> <div class=\"form-group\"> <label for=\"role\">Role</label> <input type=\"text\" id=\"role\" name=\"role\" #role=\"ngModel\" [(ngModel)]=\"actor.role\" [ngModelOptions]=\"{ updateOn: 'blur' }\" appUniqueRole> @if (role.pending) { <div>Vali",
    "id": "validate-form-input-*-angular-34"
  },
  {
    "url": "https://angular.dev/guide/forms/form-validation",
    "title": "Validate form input • Angular",
    "chunk": "dating...</div> } @if (role.invalid) { <div class=\"alert role-errors\"> @if (role.hasError('uniqueRole')) { <div> Role is already taken. </div> } </div> } </div> @if (actorForm.hasError('unambiguousRole') && (actorForm.touched || actorForm.dirty)) { <div class=\"cross-validation-error-message alert\"> Name cannot match role. </div> } </div> <div class=\"form-group\"> <label for=\"skill\">Skill</label> <select id=\"skill\" name=\"skill\" required [(ngModel)]=\"actor.skill\" #skill=\"ngModel\"> @for (skill of sk",
    "id": "validate-form-input-*-angular-35"
  },
  {
    "url": "https://angular.dev/guide/forms/form-validation",
    "title": "Validate form input • Angular",
    "chunk": "ills; track $index) { <option [value]=\"skill\">{{ skill }}</option> } </select> @if (skill.errors && skill.touched) { <div class=\"alert\"> @if (skill.errors['required']) { <div>Skill is required.</div> } </div> } </div> <p>Complete the form to enable the Submit button.</p> <button type=\"submit\" [disabled]=\"actorForm.invalid\">Submit </button> <button type=\"button\" (click)=\"actorForm.resetForm({})\">Reset </button> </div> @if (actorForm.submitted) { <div class=\"submitted-message\"> <p>You've submitted",
    "id": "validate-form-input-*-angular-36"
  },
  {
    "url": "https://angular.dev/guide/forms/form-validation",
    "title": "Validate form input • Angular",
    "chunk": " your actor, {{ actorForm.value.name }}!</p> <button type=\"button\" (click)=\"actorForm.resetForm({})\">Add new actor</button> </div> } </form></div> HELPFUL: Notice that the custom validation directive is instantiated with useExisting rather than useClass. The registered validator must be this instance of the ForbiddenValidatorDirective —the instance in the form with its forbiddenName property bound to \"bob\". If you were to replace useExisting with useClass, then you'd be registering a new class i",
    "id": "validate-form-input-*-angular-37"
  },
  {
    "url": "https://angular.dev/guide/forms/form-validation",
    "title": "Validate form input • Angular",
    "chunk": "nstance, one that doesn't have a forbiddenName. Control status CSS classes Angular automatically mirrors many control properties onto the form control element as CSS classes. Use these classes to style form control elements according to the state of the form. The following classes are currently supported. .ng-valid .ng-invalid .ng-pending .ng-pristine .ng-dirty .ng-untouched .ng-touched .ng-submitted (enclosing form element only) In the following example, the actor form uses the .ng-valid and .n",
    "id": "validate-form-input-*-angular-38"
  },
  {
    "url": "https://angular.dev/guide/forms/form-validation",
    "title": "Validate form input • Angular",
    "chunk": "g-invalid classes to set the color of each form control's border. forms.css (status classes) .ng-valid[required], .ng-valid.required { border-left: 5px solid #42A948; /* green */}.ng-invalid:not(form) { border-left: 5px solid #a94442; /* red */}.alert div { background-color: #fed3d3; color: #820000; padding: 1rem; margin-bottom: 1rem;}.form-group { margin-bottom: 1rem;}label { display: block; margin-bottom: .5rem;}select { width: 100%; padding: .5rem;} Cross-field validation A cross-field valida",
    "id": "validate-form-input-*-angular-39"
  },
  {
    "url": "https://angular.dev/guide/forms/form-validation",
    "title": "Validate form input • Angular",
    "chunk": "tor is a custom validator that compares the values of different fields in a form and accepts or rejects them in combination. For example, you might have a form that offers mutually incompatible options, so that if the user can choose A or B, but not both. Some field values might also depend on others; a user might be allowed to choose B only if A is also chosen. The following cross validation examples show how to do the following: Validate reactive or template-based form input based on the value",
    "id": "validate-form-input-*-angular-40"
  },
  {
    "url": "https://angular.dev/guide/forms/form-validation",
    "title": "Validate form input • Angular",
    "chunk": "s of two sibling controls, Show a descriptive error message after the user interacted with the form and the validation failed. The examples use cross-validation to ensure that actors do not reuse the same name in their role by filling out the Actor Form. The validators do this by checking that the actor names and roles do not match. Adding cross-validation to reactive forms The form has the following structure: const actorForm = new FormGroup({ 'name': new FormControl(), 'role': new FormControl(",
    "id": "validate-form-input-*-angular-41"
  },
  {
    "url": "https://angular.dev/guide/forms/form-validation",
    "title": "Validate form input • Angular",
    "chunk": "), 'skill': new FormControl()}); Notice that the name and role are sibling controls. To evaluate both controls in a single custom validator, you must perform the validation in a common ancestor control: the FormGroup. You query the FormGroup for its child controls so that you can compare their values. To add a validator to the FormGroup, pass the new validator in as the second argument on creation. const actorForm = new FormGroup({ 'name': new FormControl(), 'role': new FormControl(), 'skill': n",
    "id": "validate-form-input-*-angular-42"
  },
  {
    "url": "https://angular.dev/guide/forms/form-validation",
    "title": "Validate form input • Angular",
    "chunk": "ew FormControl()}, { validators: unambiguousRoleValidator }); The validator code is as follows. shared/unambiguous-role.directive.ts import {Directive} from '@angular/core';import { AbstractControl, NG_VALIDATORS, ValidationErrors, Validator, ValidatorFn,} from '@angular/forms';/** An actor's name can't match the actor's role */export const unambiguousRoleValidator: ValidatorFn = ( control: AbstractControl,): ValidationErrors | null => { const name = control.get('name'); const role = control.get",
    "id": "validate-form-input-*-angular-43"
  },
  {
    "url": "https://angular.dev/guide/forms/form-validation",
    "title": "Validate form input • Angular",
    "chunk": "('role'); return name && role && name.value === role.value ? {unambiguousRole: true} : null;};@Directive({ selector: '[appUnambiguousRole]', providers: [ {provide: NG_VALIDATORS, useExisting: UnambiguousRoleValidatorDirective, multi: true}, ],})export class UnambiguousRoleValidatorDirective implements Validator { validate(control: AbstractControl): ValidationErrors | null { return unambiguousRoleValidator(control); }} The unambiguousRoleValidator validator implements the ValidatorFn interface. I",
    "id": "validate-form-input-*-angular-44"
  },
  {
    "url": "https://angular.dev/guide/forms/form-validation",
    "title": "Validate form input • Angular",
    "chunk": "t takes an Angular control object as an argument and returns either null if the form is valid, or ValidationErrors otherwise. The validator retrieves the child controls by calling the FormGroup's get method, then compares the values of the name and role controls. If the values do not match, the role is unambiguous, both are valid, and the validator returns null. If they do match, the actor's role is ambiguous and the validator must mark the form as invalid by returning an error object. To provid",
    "id": "validate-form-input-*-angular-45"
  },
  {
    "url": "https://angular.dev/guide/forms/form-validation",
    "title": "Validate form input • Angular",
    "chunk": "e better user experience, the template shows an appropriate error message when the form is invalid. reactive/actor-form-template.component.html <div class=\"container\"> <h2>Reactive Form</h2> <form [formGroup]=\"actorForm\" #formDir=\"ngForm\"> <div [hidden]=\"formDir.submitted\"> <div class=\"cross-validation\" [class.cross-validation-error]=\"actorForm.hasError('unambiguousRole') && (actorForm.touched || actorForm.dirty)\"> <div class=\"form-group\"> <label for=\"name\">Name</label> <input type=\"text\" id=\"na",
    "id": "validate-form-input-*-angular-46"
  },
  {
    "url": "https://angular.dev/guide/forms/form-validation",
    "title": "Validate form input • Angular",
    "chunk": "me\" class=\"form-control\" formControlName=\"name\" required> @if (name.invalid && (name.dirty || name.touched)) { <div class=\"alert alert-danger\"> @if (name.hasError('required')) { <div> Name is required. </div> } @if (name.hasError('minlength')) { <div> Name must be at least 4 characters long. </div> } @if (name.hasError('forbiddenName')) { <div> Name cannot be Bob. </div> } </div> } </div> <div class=\"form-group\"> <label for=\"role\">Role</label> <input type=\"text\" id=\"role\" class=\"form-control\" fo",
    "id": "validate-form-input-*-angular-47"
  },
  {
    "url": "https://angular.dev/guide/forms/form-validation",
    "title": "Validate form input • Angular",
    "chunk": "rmControlName=\"role\"> @if (role.pending) { <div>Validating...</div> } @if (role.invalid) { <div class=\"alert alert-danger role-errors\"> @if (role.hasError('uniqueRole')) { <div> Role is already taken. </div> } </div> } </div> @if (actorForm.hasError('unambiguousRole') && (actorForm.touched || actorForm.dirty)) { <div class=\"cross-validation-error-message alert alert-danger\"> Name cannot match role or audiences will be confused. </div> } </div> <div class=\"form-group\"> <label for=\"skill\">Skill</l",
    "id": "validate-form-input-*-angular-48"
  },
  {
    "url": "https://angular.dev/guide/forms/form-validation",
    "title": "Validate form input • Angular",
    "chunk": "abel> <select id=\"skill\" class=\"form-control\" formControlName=\"skill\" required> @for (skill of skills; track $index) { <option [value]=\"skill\">{{ skill }}</option> } </select> @if (skill.invalid && skill.touched) { <div class=\"alert alert-danger\"> @if (skill.hasError('required')) { <div>Skill is required.</div> } </div> } </div> <p>Complete the form to enable the Submit button.</p> <button type=\"submit\" class=\"btn btn-default\" [disabled]=\"actorForm.invalid\">Submit </button> <button type=\"button\"",
    "id": "validate-form-input-*-angular-49"
  },
  {
    "url": "https://angular.dev/guide/forms/form-validation",
    "title": "Validate form input • Angular",
    "chunk": " class=\"btn btn-default\" (click)=\"formDir.resetForm({})\">Reset </button> </div> </form> @if (formDir.submitted) { <div class=\"submitted-message\"> <p>You've submitted your actor, {{ actorForm.value.name }}!</p> <button type=\"button\" (click)=\"formDir.resetForm({})\">Add new actor</button> </div> }</div> This @if displays the error if the FormGroup has the cross validation error returned by the unambiguousRoleValidator validator, but only if the user finished interacting with the form. Adding cross-",
    "id": "validate-form-input-*-angular-50"
  },
  {
    "url": "https://angular.dev/guide/forms/form-validation",
    "title": "Validate form input • Angular",
    "chunk": "validation to template-driven forms For a template-driven form, you must create a directive to wrap the validator function. You provide that directive as the validator using the NG_VALIDATORS token, as shown in the following example. shared/unambiguous-role.directive.ts import {Directive} from '@angular/core';import { AbstractControl, NG_VALIDATORS, ValidationErrors, Validator, ValidatorFn,} from '@angular/forms';/** An actor's name can't match the actor's role */export const unambiguousRoleVali",
    "id": "validate-form-input-*-angular-51"
  },
  {
    "url": "https://angular.dev/guide/forms/form-validation",
    "title": "Validate form input • Angular",
    "chunk": "dator: ValidatorFn = ( control: AbstractControl,): ValidationErrors | null => { const name = control.get('name'); const role = control.get('role'); return name && role && name.value === role.value ? {unambiguousRole: true} : null;};@Directive({ selector: '[appUnambiguousRole]', providers: [ {provide: NG_VALIDATORS, useExisting: UnambiguousRoleValidatorDirective, multi: true}, ],})export class UnambiguousRoleValidatorDirective implements Validator { validate(control: AbstractControl): ValidationE",
    "id": "validate-form-input-*-angular-52"
  },
  {
    "url": "https://angular.dev/guide/forms/form-validation",
    "title": "Validate form input • Angular",
    "chunk": "rrors | null { return unambiguousRoleValidator(control); }} You must add the new directive to the HTML template. Because the validator must be registered at the highest level in the form, the following template puts the directive on the form tag. template/actor-form-template.component.html <div> <h2>Template-Driven Form</h2> <form #actorForm=\"ngForm\" appUnambiguousRole> <div [hidden]=\"actorForm.submitted\"> <div class=\"cross-validation\" [class.cross-validation-error]=\"actorForm.hasError('unambigu",
    "id": "validate-form-input-*-angular-53"
  },
  {
    "url": "https://angular.dev/guide/forms/form-validation",
    "title": "Validate form input • Angular",
    "chunk": "ousRole') && (actorForm.touched || actorForm.dirty)\"> <div class=\"form-group\"> <label for=\"name\">Name</label> <input type=\"text\" id=\"name\" name=\"name\" class=\"form-control\" required minlength=\"4\" appForbiddenName=\"bob\" [(ngModel)]=\"actor.name\" #name=\"ngModel\"> @if (name.invalid && (name.dirty || name.touched)) { <div class=\"alert\"> @if (name.hasError('required')) { <div> Name is required. </div> } @if (name.hasError('minlength')) { <div> Name must be at least 4 characters long. </div> } @if (name",
    "id": "validate-form-input-*-angular-54"
  },
  {
    "url": "https://angular.dev/guide/forms/form-validation",
    "title": "Validate form input • Angular",
    "chunk": ".hasError('forbiddenName')) { <div> Name cannot be Bob. </div> } </div> } </div> <div class=\"form-group\"> <label for=\"role\">Role</label> <input type=\"text\" id=\"role\" name=\"role\" #role=\"ngModel\" [(ngModel)]=\"actor.role\" [ngModelOptions]=\"{ updateOn: 'blur' }\" appUniqueRole> @if (role.pending) { <div>Validating...</div> } @if (role.invalid) { <div class=\"alert role-errors\"> @if (role.hasError('uniqueRole')) { <div> Role is already taken. </div> } </div> } </div> @if (actorForm.hasError('unambiguou",
    "id": "validate-form-input-*-angular-55"
  },
  {
    "url": "https://angular.dev/guide/forms/form-validation",
    "title": "Validate form input • Angular",
    "chunk": "sRole') && (actorForm.touched || actorForm.dirty)) { <div class=\"cross-validation-error-message alert\"> Name cannot match role. </div> } </div> <div class=\"form-group\"> <label for=\"skill\">Skill</label> <select id=\"skill\" name=\"skill\" required [(ngModel)]=\"actor.skill\" #skill=\"ngModel\"> @for (skill of skills; track $index) { <option [value]=\"skill\">{{ skill }}</option> } </select> @if (skill.errors && skill.touched) { <div class=\"alert\"> @if (skill.errors['required']) { <div>Skill is required.</d",
    "id": "validate-form-input-*-angular-56"
  },
  {
    "url": "https://angular.dev/guide/forms/form-validation",
    "title": "Validate form input • Angular",
    "chunk": "iv> } </div> } </div> <p>Complete the form to enable the Submit button.</p> <button type=\"submit\" [disabled]=\"actorForm.invalid\">Submit </button> <button type=\"button\" (click)=\"actorForm.resetForm({})\">Reset </button> </div> @if (actorForm.submitted) { <div class=\"submitted-message\"> <p>You've submitted your actor, {{ actorForm.value.name }}!</p> <button type=\"button\" (click)=\"actorForm.resetForm({})\">Add new actor</button> </div> } </form></div> To provide better user experience, an appropriate",
    "id": "validate-form-input-*-angular-57"
  },
  {
    "url": "https://angular.dev/guide/forms/form-validation",
    "title": "Validate form input • Angular",
    "chunk": " error message appears when the form is invalid. template/actor-form-template.component.html <div> <h2>Template-Driven Form</h2> <form #actorForm=\"ngForm\" appUnambiguousRole> <div [hidden]=\"actorForm.submitted\"> <div class=\"cross-validation\" [class.cross-validation-error]=\"actorForm.hasError('unambiguousRole') && (actorForm.touched || actorForm.dirty)\"> <div class=\"form-group\"> <label for=\"name\">Name</label> <input type=\"text\" id=\"name\" name=\"name\" class=\"form-control\" required minlength=\"4\" app",
    "id": "validate-form-input-*-angular-58"
  },
  {
    "url": "https://angular.dev/guide/forms/form-validation",
    "title": "Validate form input • Angular",
    "chunk": "ForbiddenName=\"bob\" [(ngModel)]=\"actor.name\" #name=\"ngModel\"> @if (name.invalid && (name.dirty || name.touched)) { <div class=\"alert\"> @if (name.hasError('required')) { <div> Name is required. </div> } @if (name.hasError('minlength')) { <div> Name must be at least 4 characters long. </div> } @if (name.hasError('forbiddenName')) { <div> Name cannot be Bob. </div> } </div> } </div> <div class=\"form-group\"> <label for=\"role\">Role</label> <input type=\"text\" id=\"role\" name=\"role\" #role=\"ngModel\" [(ng",
    "id": "validate-form-input-*-angular-59"
  },
  {
    "url": "https://angular.dev/guide/forms/form-validation",
    "title": "Validate form input • Angular",
    "chunk": "Model)]=\"actor.role\" [ngModelOptions]=\"{ updateOn: 'blur' }\" appUniqueRole> @if (role.pending) { <div>Validating...</div> } @if (role.invalid) { <div class=\"alert role-errors\"> @if (role.hasError('uniqueRole')) { <div> Role is already taken. </div> } </div> } </div> @if (actorForm.hasError('unambiguousRole') && (actorForm.touched || actorForm.dirty)) { <div class=\"cross-validation-error-message alert\"> Name cannot match role. </div> } </div> <div class=\"form-group\"> <label for=\"skill\">Skill</lab",
    "id": "validate-form-input-*-angular-60"
  },
  {
    "url": "https://angular.dev/guide/forms/form-validation",
    "title": "Validate form input • Angular",
    "chunk": "el> <select id=\"skill\" name=\"skill\" required [(ngModel)]=\"actor.skill\" #skill=\"ngModel\"> @for (skill of skills; track $index) { <option [value]=\"skill\">{{ skill }}</option> } </select> @if (skill.errors && skill.touched) { <div class=\"alert\"> @if (skill.errors['required']) { <div>Skill is required.</div> } </div> } </div> <p>Complete the form to enable the Submit button.</p> <button type=\"submit\" [disabled]=\"actorForm.invalid\">Submit </button> <button type=\"button\" (click)=\"actorForm.resetForm({",
    "id": "validate-form-input-*-angular-61"
  },
  {
    "url": "https://angular.dev/guide/forms/form-validation",
    "title": "Validate form input • Angular",
    "chunk": "})\">Reset </button> </div> @if (actorForm.submitted) { <div class=\"submitted-message\"> <p>You've submitted your actor, {{ actorForm.value.name }}!</p> <button type=\"button\" (click)=\"actorForm.resetForm({})\">Add new actor</button> </div> } </form></div> This is the same in both template-driven and reactive forms. Creating asynchronous validators Asynchronous validators implement the AsyncValidatorFn and AsyncValidator interfaces. These are very similar to their synchronous counterparts, with the ",
    "id": "validate-form-input-*-angular-62"
  },
  {
    "url": "https://angular.dev/guide/forms/form-validation",
    "title": "Validate form input • Angular",
    "chunk": "following differences. The validate() functions must return a Promise or an observable, The observable returned must be finite, meaning it must complete at some point. To convert an infinite observable into a finite one, pipe the observable through a filtering operator such as first, last, take, or takeUntil. Asynchronous validation happens after the synchronous validation, and is performed only if the synchronous validation is successful. This check lets forms avoid potentially expensive async ",
    "id": "validate-form-input-*-angular-63"
  },
  {
    "url": "https://angular.dev/guide/forms/form-validation",
    "title": "Validate form input • Angular",
    "chunk": "validation processes (such as an HTTP request) if the more basic validation methods have already found invalid input. After asynchronous validation begins, the form control enters a pending state. Inspect the control's pending property and use it to give visual feedback about the ongoing validation operation. A common UI pattern is to show a spinner while the async validation is being performed. The following example shows how to achieve this in a template-driven form. <input [(ngModel)]=\"name\" ",
    "id": "validate-form-input-*-angular-64"
  },
  {
    "url": "https://angular.dev/guide/forms/form-validation",
    "title": "Validate form input • Angular",
    "chunk": "#model=\"ngModel\" appSomeAsyncValidator>@if(model.pending) { <app-spinner />} Implementing a custom async validator In the following example, an async validator ensures that actors are cast for a role that is not already taken. New actors are constantly auditioning and old actors are retiring, so the list of available roles cannot be retrieved ahead of time. To validate the potential role entry, the validator must initiate an asynchronous operation to consult a central database of all currently c",
    "id": "validate-form-input-*-angular-65"
  },
  {
    "url": "https://angular.dev/guide/forms/form-validation",
    "title": "Validate form input • Angular",
    "chunk": "ast actors. The following code creates the validator class, UniqueRoleValidator, which implements the AsyncValidator interface. import {Directive, forwardRef, inject, Injectable} from '@angular/core';import { AsyncValidator, AbstractControl, NG_ASYNC_VALIDATORS, ValidationErrors,} from '@angular/forms';import {catchError, map} from 'rxjs/operators';import {ActorsService} from './actors.service';import {Observable, of} from 'rxjs';@Injectable({providedIn: 'root'})export class UniqueRoleValidator ",
    "id": "validate-form-input-*-angular-66"
  },
  {
    "url": "https://angular.dev/guide/forms/form-validation",
    "title": "Validate form input • Angular",
    "chunk": "implements AsyncValidator { private readonly actorsService = inject(ActorsService); validate(control: AbstractControl): Observable<ValidationErrors | null> { return this.actorsService.isRoleTaken(control.value).pipe( map((isTaken) => (isTaken ? {uniqueRole: true} : null)), catchError(() => of(null)), ); }}@Directive({ selector: '[appUniqueRole]', providers: [ { provide: NG_ASYNC_VALIDATORS, useExisting: forwardRef(() => UniqueRoleValidatorDirective), multi: true, }, ],})export class UniqueRoleVa",
    "id": "validate-form-input-*-angular-67"
  },
  {
    "url": "https://angular.dev/guide/forms/form-validation",
    "title": "Validate form input • Angular",
    "chunk": "lidatorDirective implements AsyncValidator { private readonly validator = inject(UniqueRoleValidator); validate(control: AbstractControl): Observable<ValidationErrors | null> { return this.validator.validate(control); }} The actorsService property is initialized with an instance of the ActorsService token, which defines the following interface. interface ActorsService { isRoleTaken: (role: string) => Observable<boolean>;} In a real world application, the ActorsService would be responsible for ma",
    "id": "validate-form-input-*-angular-68"
  },
  {
    "url": "https://angular.dev/guide/forms/form-validation",
    "title": "Validate form input • Angular",
    "chunk": "king an HTTP request to the actor database to check if the role is available. From the validator's point of view, the actual implementation of the service is not important, so the example can just code against the ActorsService interface. As the validation begins, the UnambiguousRoleValidator delegates to the ActorsService isRoleTaken() method with the current control value. At this point the control is marked as pending and remains in this state until the observable chain returned from the vali",
    "id": "validate-form-input-*-angular-69"
  },
  {
    "url": "https://angular.dev/guide/forms/form-validation",
    "title": "Validate form input • Angular",
    "chunk": "date() method completes. The isRoleTaken() method dispatches an HTTP request that checks if the role is available, and returns Observable<boolean> as the result. The validate() method pipes the response through the map operator and transforms it into a validation result. The method then, like any validator, returns null if the form is valid, and ValidationErrors if it is not. This validator handles any potential errors with the catchError operator. In this case, the validator treats the isRoleTa",
    "id": "validate-form-input-*-angular-70"
  },
  {
    "url": "https://angular.dev/guide/forms/form-validation",
    "title": "Validate form input • Angular",
    "chunk": "ken() error as a successful validation, because failure to make a validation request does not necessarily mean that the role is invalid. You could handle the error differently and return the ValidationError object instead. After some time passes, the observable chain completes and the asynchronous validation is done. The pending flag is set to false, and the form validity is updated. Adding async validators to reactive forms To use an async validator in reactive forms, begin by injecting the val",
    "id": "validate-form-input-*-angular-71"
  },
  {
    "url": "https://angular.dev/guide/forms/form-validation",
    "title": "Validate form input • Angular",
    "chunk": "idator into a property of the component class. import {Component, inject} from '@angular/core';import {FormControl, FormGroup, ReactiveFormsModule, Validators} from '@angular/forms';import {forbiddenNameValidator} from '../shared/forbidden-name.directive';import {UniqueRoleValidator} from '../shared/role.directive';@Component({ selector: 'app-actor-form-reactive', templateUrl: './actor-form-reactive.component.html', styleUrls: ['./actor-form-reactive.component.css'], imports: [ReactiveFormsModul",
    "id": "validate-form-input-*-angular-72"
  },
  {
    "url": "https://angular.dev/guide/forms/form-validation",
    "title": "Validate form input • Angular",
    "chunk": "e],})export class HeroFormReactiveComponent { roleValidator = inject(UniqueRoleValidator); skills = ['Method Acting', 'Singing', 'Dancing', 'Swordfighting']; actor = {name: 'Tom Cruise', role: 'Romeo', skill: this.skills[3]}; actorForm!: FormGroup; ngOnInit(): void { const roleControl = new FormControl('', { asyncValidators: [this.roleValidator.validate.bind(this.roleValidator)], updateOn: 'blur', }); roleControl.setValue(this.actor.role); this.actorForm = new FormGroup({ name: new FormControl(t",
    "id": "validate-form-input-*-angular-73"
  },
  {
    "url": "https://angular.dev/guide/forms/form-validation",
    "title": "Validate form input • Angular",
    "chunk": "his.actor.name, [ Validators.required, Validators.minLength(4), forbiddenNameValidator(/bob/i), ]), role: roleControl, skill: new FormControl(this.actor.skill, Validators.required), }); } get name() { return this.actorForm.get('name'); } get skill() { return this.actorForm.get('skill'); } get role() { return this.actorForm.get('role'); }} Then, pass the validator function directly to the FormControl to apply it. In the following example, the validate function of UnambiguousRoleValidator is appli",
    "id": "validate-form-input-*-angular-74"
  },
  {
    "url": "https://angular.dev/guide/forms/form-validation",
    "title": "Validate form input • Angular",
    "chunk": "ed to roleControl by passing it to the control's asyncValidators option and binding it to the instance of UnambiguousRoleValidator that was injected into ActorFormReactiveComponent. The value of asyncValidators can be either a single async validator function, or an array of functions. To learn more about FormControl options, see the AbstractControlOptions API reference. import {Component, inject} from '@angular/core';import {FormControl, FormGroup, ReactiveFormsModule, Validators} from '@angular",
    "id": "validate-form-input-*-angular-75"
  },
  {
    "url": "https://angular.dev/guide/forms/form-validation",
    "title": "Validate form input • Angular",
    "chunk": "/forms';import {forbiddenNameValidator} from '../shared/forbidden-name.directive';import {UniqueRoleValidator} from '../shared/role.directive';@Component({ selector: 'app-actor-form-reactive', templateUrl: './actor-form-reactive.component.html', styleUrls: ['./actor-form-reactive.component.css'], imports: [ReactiveFormsModule],})export class HeroFormReactiveComponent { roleValidator = inject(UniqueRoleValidator); skills = ['Method Acting', 'Singing', 'Dancing', 'Swordfighting']; actor = {name: '",
    "id": "validate-form-input-*-angular-76"
  },
  {
    "url": "https://angular.dev/guide/forms/form-validation",
    "title": "Validate form input • Angular",
    "chunk": "Tom Cruise', role: 'Romeo', skill: this.skills[3]}; actorForm!: FormGroup; ngOnInit(): void { const roleControl = new FormControl('', { asyncValidators: [this.roleValidator.validate.bind(this.roleValidator)], updateOn: 'blur', }); roleControl.setValue(this.actor.role); this.actorForm = new FormGroup({ name: new FormControl(this.actor.name, [ Validators.required, Validators.minLength(4), forbiddenNameValidator(/bob/i), ]), role: roleControl, skill: new FormControl(this.actor.skill, Validators.req",
    "id": "validate-form-input-*-angular-77"
  },
  {
    "url": "https://angular.dev/guide/forms/form-validation",
    "title": "Validate form input • Angular",
    "chunk": "uired), }); } get name() { return this.actorForm.get('name'); } get skill() { return this.actorForm.get('skill'); } get role() { return this.actorForm.get('role'); }} Adding async validators to template-driven forms To use an async validator in template-driven forms, create a new directive and register the NG_ASYNC_VALIDATORS provider on it. In the example below, the directive injects the UniqueRoleValidator class that contains the actual validation logic and invokes it in the validate function,",
    "id": "validate-form-input-*-angular-78"
  },
  {
    "url": "https://angular.dev/guide/forms/form-validation",
    "title": "Validate form input • Angular",
    "chunk": " triggered by Angular when validation should happen. import {Directive, forwardRef, inject, Injectable} from '@angular/core';import { AsyncValidator, AbstractControl, NG_ASYNC_VALIDATORS, ValidationErrors,} from '@angular/forms';import {catchError, map} from 'rxjs/operators';import {ActorsService} from './actors.service';import {Observable, of} from 'rxjs';@Injectable({providedIn: 'root'})export class UniqueRoleValidator implements AsyncValidator { private readonly actorsService = inject(ActorsS",
    "id": "validate-form-input-*-angular-79"
  },
  {
    "url": "https://angular.dev/guide/forms/form-validation",
    "title": "Validate form input • Angular",
    "chunk": "ervice); validate(control: AbstractControl): Observable<ValidationErrors | null> { return this.actorsService.isRoleTaken(control.value).pipe( map((isTaken) => (isTaken ? {uniqueRole: true} : null)), catchError(() => of(null)), ); }}@Directive({ selector: '[appUniqueRole]', providers: [ { provide: NG_ASYNC_VALIDATORS, useExisting: forwardRef(() => UniqueRoleValidatorDirective), multi: true, }, ],})export class UniqueRoleValidatorDirective implements AsyncValidator { private readonly validator = i",
    "id": "validate-form-input-*-angular-80"
  },
  {
    "url": "https://angular.dev/guide/forms/form-validation",
    "title": "Validate form input • Angular",
    "chunk": "nject(UniqueRoleValidator); validate(control: AbstractControl): Observable<ValidationErrors | null> { return this.validator.validate(control); }} Then, as with synchronous validators, add the directive's selector to an input to activate it. template/actor-form-template.component.html (unique-unambiguous-role-input) <div> <h2>Template-Driven Form</h2> <form #actorForm=\"ngForm\" appUnambiguousRole> <div [hidden]=\"actorForm.submitted\"> <div class=\"cross-validation\" [class.cross-validation-error]=\"ac",
    "id": "validate-form-input-*-angular-81"
  },
  {
    "url": "https://angular.dev/guide/forms/form-validation",
    "title": "Validate form input • Angular",
    "chunk": "torForm.hasError('unambiguousRole') && (actorForm.touched || actorForm.dirty)\"> <div class=\"form-group\"> <label for=\"name\">Name</label> <input type=\"text\" id=\"name\" name=\"name\" class=\"form-control\" required minlength=\"4\" appForbiddenName=\"bob\" [(ngModel)]=\"actor.name\" #name=\"ngModel\"> @if (name.invalid && (name.dirty || name.touched)) { <div class=\"alert\"> @if (name.hasError('required')) { <div> Name is required. </div> } @if (name.hasError('minlength')) { <div> Name must be at least 4 character",
    "id": "validate-form-input-*-angular-82"
  },
  {
    "url": "https://angular.dev/guide/forms/form-validation",
    "title": "Validate form input • Angular",
    "chunk": "s long. </div> } @if (name.hasError('forbiddenName')) { <div> Name cannot be Bob. </div> } </div> } </div> <div class=\"form-group\"> <label for=\"role\">Role</label> <input type=\"text\" id=\"role\" name=\"role\" #role=\"ngModel\" [(ngModel)]=\"actor.role\" [ngModelOptions]=\"{ updateOn: 'blur' }\" appUniqueRole> @if (role.pending) { <div>Validating...</div> } @if (role.invalid) { <div class=\"alert role-errors\"> @if (role.hasError('uniqueRole')) { <div> Role is already taken. </div> } </div> } </div> @if (acto",
    "id": "validate-form-input-*-angular-83"
  },
  {
    "url": "https://angular.dev/guide/forms/form-validation",
    "title": "Validate form input • Angular",
    "chunk": "rForm.hasError('unambiguousRole') && (actorForm.touched || actorForm.dirty)) { <div class=\"cross-validation-error-message alert\"> Name cannot match role. </div> } </div> <div class=\"form-group\"> <label for=\"skill\">Skill</label> <select id=\"skill\" name=\"skill\" required [(ngModel)]=\"actor.skill\" #skill=\"ngModel\"> @for (skill of skills; track $index) { <option [value]=\"skill\">{{ skill }}</option> } </select> @if (skill.errors && skill.touched) { <div class=\"alert\"> @if (skill.errors['required']) { ",
    "id": "validate-form-input-*-angular-84"
  },
  {
    "url": "https://angular.dev/guide/forms/form-validation",
    "title": "Validate form input • Angular",
    "chunk": "<div>Skill is required.</div> } </div> } </div> <p>Complete the form to enable the Submit button.</p> <button type=\"submit\" [disabled]=\"actorForm.invalid\">Submit </button> <button type=\"button\" (click)=\"actorForm.resetForm({})\">Reset </button> </div> @if (actorForm.submitted) { <div class=\"submitted-message\"> <p>You've submitted your actor, {{ actorForm.value.name }}!</p> <button type=\"button\" (click)=\"actorForm.resetForm({})\">Add new actor</button> </div> } </form></div> Optimizing performance ",
    "id": "validate-form-input-*-angular-85"
  },
  {
    "url": "https://angular.dev/guide/forms/form-validation",
    "title": "Validate form input • Angular",
    "chunk": "of async validators By default, all validators run after every form value change. With synchronous validators, this does not normally have a noticeable impact on application performance. Async validators, however, commonly perform some kind of HTTP request to validate the control. Dispatching an HTTP request after every keystroke could put a strain on the backend API, and should be avoided if possible. You can delay updating the form validity by changing the updateOn property from change (defaul",
    "id": "validate-form-input-*-angular-86"
  },
  {
    "url": "https://angular.dev/guide/forms/form-validation",
    "title": "Validate form input • Angular",
    "chunk": "t) to submit or blur. With template-driven forms, set the property in the template. <input [(ngModel)]=\"name\" [ngModelOptions]=\"{updateOn: 'blur'}\"> With reactive forms, set the property in the FormControl instance. new FormControl('', {updateOn: 'blur'}); Interaction with native HTML form validation By default, Angular disables native HTML form validation by adding the novalidate attribute on the enclosing <form> and uses directives to match these attributes with validator functions in the fram",
    "id": "validate-form-input-*-angular-87"
  },
  {
    "url": "https://angular.dev/guide/forms/form-validation",
    "title": "Validate form input • Angular",
    "chunk": "ework. If you want to use native validation in combination with Angular-based validation, you can re-enable it with the ngNativeValidate directive. See the API docs for details. Social MediaBlogX (formerly Twitter)BlueskyYouTube Discord GitHub Stack Overflow Community Contribute Code of Conduct Report Issues Google's DevLibrary Angular Google Developer Experts ResourcesPress KitRoadmapLanguages简体中文版正體中文版日本語版한국어 Ελληνικά Super-powered by Google ©2010-2025. Code licensed under an MIT-style License",
    "id": "validate-form-input-*-angular-88"
  },
  {
    "url": "https://angular.dev/guide/forms/form-validation",
    "title": "Validate form input • Angular",
    "chunk": " . Documentation licensed under CC BY 4.0 .",
    "id": "validate-form-input-*-angular-89"
  },
  {
    "url": "https://angular.dev/guide/forms/dynamic-forms",
    "title": "Building dynamic forms • Angular",
    "chunk": "In-depth GuidesForms Building dynamic forms Many forms, such as questionnaires, can be very similar to one another in format and intent. To make it faster and easier to generate different versions of such a form, you can create a dynamic form template based on metadata that describes the business object model. Then, use the template to generate new forms automatically, according to changes in the data model. The technique is particularly useful when you have a type of form whose content must cha",
    "id": "building-dynamic-forms-*-angular-0"
  },
  {
    "url": "https://angular.dev/guide/forms/dynamic-forms",
    "title": "Building dynamic forms • Angular",
    "chunk": "nge frequently to meet rapidly changing business and regulatory requirements. A typical use-case is a questionnaire. You might need to get input from users in different contexts. The format and style of the forms a user sees should remain constant, while the actual questions you need to ask vary with the context. In this tutorial you will build a dynamic form that presents a basic questionnaire. You build an online application for heroes seeking employment. The agency is constantly tinkering wit",
    "id": "building-dynamic-forms-*-angular-1"
  },
  {
    "url": "https://angular.dev/guide/forms/dynamic-forms",
    "title": "Building dynamic forms • Angular",
    "chunk": "h the application process, but by using the dynamic form you can create the new forms on the fly without changing the application code. The tutorial walks you through the following steps. Enable reactive forms for a project. Establish a data model to represent form controls. Populate the model with sample data. Develop a component to create form controls dynamically. The form you create uses input validation and styling to improve the user experience. It has a Submit button that is only enabled ",
    "id": "building-dynamic-forms-*-angular-2"
  },
  {
    "url": "https://angular.dev/guide/forms/dynamic-forms",
    "title": "Building dynamic forms • Angular",
    "chunk": "when all user input is valid, and flags invalid input with color coding and error messages. The basic version can evolve to support a richer variety of questions, more graceful rendering, and superior user experience. On this pagearrow_upward_alt Back to the top Enable reactive forms for your project Dynamic forms are based on reactive forms. To give the application access reactive forms directives, import ReactiveFormsModule from the @angular/forms library into the necessary components. dynamic",
    "id": "building-dynamic-forms-*-angular-3"
  },
  {
    "url": "https://angular.dev/guide/forms/dynamic-forms",
    "title": "Building dynamic forms • Angular",
    "chunk": "-form.component.ts import {Component, inject, input} from '@angular/core';import {FormGroup, ReactiveFormsModule} from '@angular/forms';import {DynamicFormQuestionComponent} from './dynamic-form-question.component';import {QuestionBase} from './question-base';import {QuestionControlService} from './question-control.service';@Component({ selector: 'app-dynamic-form', templateUrl: './dynamic-form.component.html', providers: [QuestionControlService], imports: [DynamicFormQuestionComponent, Reactive",
    "id": "building-dynamic-forms-*-angular-4"
  },
  {
    "url": "https://angular.dev/guide/forms/dynamic-forms",
    "title": "Building dynamic forms • Angular",
    "chunk": "FormsModule],})export class DynamicFormComponent { private readonly qcs = inject(QuestionControlService); questions = input<QuestionBase<string>[] | null>([]); form: FormGroup = this.qcs.toFormGroup(this.questions() as QuestionBase<string>[]); payLoad = ''; onSubmit() { this.payLoad = JSON.stringify(this.form.getRawValue()); }} dynamic-form-question.component.ts import {Component, input, Input} from '@angular/core';import {FormGroup, ReactiveFormsModule} from '@angular/forms';import {QuestionBas",
    "id": "building-dynamic-forms-*-angular-5"
  },
  {
    "url": "https://angular.dev/guide/forms/dynamic-forms",
    "title": "Building dynamic forms • Angular",
    "chunk": "e} from './question-base';@Component({ selector: 'app-question', templateUrl: './dynamic-form-question.component.html', imports: [ReactiveFormsModule],})export class DynamicFormQuestionComponent { question = input.required<QuestionBase<string>>(); form = input.required<FormGroup>(); get isValid() { return this.form().controls[this.question().key].valid; }} Create a form object model A dynamic form requires an object model that can describe all scenarios needed by the form functionality. The exam",
    "id": "building-dynamic-forms-*-angular-6"
  },
  {
    "url": "https://angular.dev/guide/forms/dynamic-forms",
    "title": "Building dynamic forms • Angular",
    "chunk": "ple hero-application form is a set of questions — that is, each control in the form must ask a question and accept an answer. The data model for this type of form must represent a question. The example includes the DynamicFormQuestionComponent, which defines a question as the fundamental object in the model. The following QuestionBase is a base class for a set of controls that can represent the question and its answer in the form. src/app/question-base.ts export class QuestionBase<T> { value: T ",
    "id": "building-dynamic-forms-*-angular-7"
  },
  {
    "url": "https://angular.dev/guide/forms/dynamic-forms",
    "title": "Building dynamic forms • Angular",
    "chunk": "| undefined; key: string; label: string; required: boolean; order: number; controlType: string; type: string; options: {key: string; value: string}[]; constructor( options: { value?: T; key?: string; label?: string; required?: boolean; order?: number; controlType?: string; type?: string; options?: {key: string; value: string}[]; } = {}, ) { this.value = options.value; this.key = options.key || ''; this.label = options.label || ''; this.required = !!options.required; this.order = options.order ==",
    "id": "building-dynamic-forms-*-angular-8"
  },
  {
    "url": "https://angular.dev/guide/forms/dynamic-forms",
    "title": "Building dynamic forms • Angular",
    "chunk": "= undefined ? 1 : options.order; this.controlType = options.controlType || ''; this.type = options.type || ''; this.options = options.options || []; }} Define control classes From this base, the example derives two new classes, TextboxQuestion and DropdownQuestion, that represent different control types. When you create the form template in the next step, you instantiate these specific question types in order to render the appropriate controls dynamically. The TextboxQuestion control type is rep",
    "id": "building-dynamic-forms-*-angular-9"
  },
  {
    "url": "https://angular.dev/guide/forms/dynamic-forms",
    "title": "Building dynamic forms • Angular",
    "chunk": "resented in a form template using an <input> element. It presents a question and lets users enter input. The type attribute of the element is defined based on the type field specified in the options argument (for example text, email, url). question-textbox.ts import {QuestionBase} from './question-base';export class TextboxQuestion extends QuestionBase<string> { override controlType = 'textbox';} The DropdownQuestion control type presents a list of choices in a select box. question-dropdown.ts i",
    "id": "building-dynamic-forms-*-angular-10"
  },
  {
    "url": "https://angular.dev/guide/forms/dynamic-forms",
    "title": "Building dynamic forms • Angular",
    "chunk": "mport {QuestionBase} from './question-base';export class DropdownQuestion extends QuestionBase<string> { override controlType = 'dropdown';} Compose form groups A dynamic form uses a service to create grouped sets of input controls, based on the form model. The following QuestionControlService collects a set of FormGroup instances that consume the metadata from the question model. You can specify default values and validation rules. src/app/question-control.service.ts import {Injectable} from '@",
    "id": "building-dynamic-forms-*-angular-11"
  },
  {
    "url": "https://angular.dev/guide/forms/dynamic-forms",
    "title": "Building dynamic forms • Angular",
    "chunk": "angular/core';import {FormControl, FormGroup, Validators} from '@angular/forms';import {QuestionBase} from './question-base';@Injectable()export class QuestionControlService { toFormGroup(questions: QuestionBase<string>[]) { const group: any = {}; questions.forEach((question) => { group[question.key] = question.required ? new FormControl(question.value || '', Validators.required) : new FormControl(question.value || ''); }); return new FormGroup(group); }} Compose dynamic form contents The dynami",
    "id": "building-dynamic-forms-*-angular-12"
  },
  {
    "url": "https://angular.dev/guide/forms/dynamic-forms",
    "title": "Building dynamic forms • Angular",
    "chunk": "c form itself is represented by a container component, which you add in a later step. Each question is represented in the form component's template by an <app-question> tag, which matches an instance of DynamicFormQuestionComponent. The DynamicFormQuestionComponent is responsible for rendering the details of an individual question based on values in the data-bound question object. The form relies on a [formGroup] directive to connect the template HTML to the underlying control objects. The Dynam",
    "id": "building-dynamic-forms-*-angular-13"
  },
  {
    "url": "https://angular.dev/guide/forms/dynamic-forms",
    "title": "Building dynamic forms • Angular",
    "chunk": "icFormQuestionComponent creates form groups and populates them with controls defined in the question model, specifying display and validation rules. dynamic-form-question.component.html <div [formGroup]=\"form()\"> <label [attr.for]=\"question().key\">{{ question().label }}</label> <div> @switch (question().controlType) { @case ('textbox') { <input [formControlName]=\"question().key\" [id]=\"question().key\" [type]=\"question().type\" /> } @case ('dropdown') { <select [id]=\"question().key\" [formControlNam",
    "id": "building-dynamic-forms-*-angular-14"
  },
  {
    "url": "https://angular.dev/guide/forms/dynamic-forms",
    "title": "Building dynamic forms • Angular",
    "chunk": "e]=\"question().key\"> @for (opt of question().options; track opt) { <option [value]=\"opt.key\">{{ opt.value }}</option> } </select> } } </div> @if (!isValid) { <div class=\"errorMessage\">{{ question().label }} is required</div> }</div> dynamic-form-question.component.ts import {Component, input, Input} from '@angular/core';import {FormGroup, ReactiveFormsModule} from '@angular/forms';import {QuestionBase} from './question-base';@Component({ selector: 'app-question', templateUrl: './dynamic-form-que",
    "id": "building-dynamic-forms-*-angular-15"
  },
  {
    "url": "https://angular.dev/guide/forms/dynamic-forms",
    "title": "Building dynamic forms • Angular",
    "chunk": "stion.component.html', imports: [ReactiveFormsModule],})export class DynamicFormQuestionComponent { question = input.required<QuestionBase<string>>(); form = input.required<FormGroup>(); get isValid() { return this.form().controls[this.question().key].valid; }} The goal of the DynamicFormQuestionComponent is to present question types defined in your model. You only have two types of questions at this point but you can imagine many more. The @switch block in the template determines which type of ",
    "id": "building-dynamic-forms-*-angular-16"
  },
  {
    "url": "https://angular.dev/guide/forms/dynamic-forms",
    "title": "Building dynamic forms • Angular",
    "chunk": "question to display. The switch uses directives with the formControlName and formGroup selectors. Both directives are defined in ReactiveFormsModule. Supply data Another service is needed to supply a specific set of questions from which to build an individual form. For this exercise you create the QuestionService to supply this array of questions from the hard-coded sample data. In a real-world app, the service might fetch data from a backend system. The key point, however, is that you control t",
    "id": "building-dynamic-forms-*-angular-17"
  },
  {
    "url": "https://angular.dev/guide/forms/dynamic-forms",
    "title": "Building dynamic forms • Angular",
    "chunk": "he hero job-application questions entirely through the objects returned from QuestionService. To maintain the questionnaire as requirements change, you only need to add, update, and remove objects from the questions array. The QuestionService supplies a set of questions in the form of an array bound to input() questions. src/app/question.service.ts import {Injectable} from '@angular/core';import {DropdownQuestion} from './question-dropdown';import {QuestionBase} from './question-base';import {Te",
    "id": "building-dynamic-forms-*-angular-18"
  },
  {
    "url": "https://angular.dev/guide/forms/dynamic-forms",
    "title": "Building dynamic forms • Angular",
    "chunk": "xtboxQuestion} from './question-textbox';import {of} from 'rxjs';@Injectable()export class QuestionService { // TODO: get from a remote source of question metadata getQuestions() { const questions: QuestionBase<string>[] = [ new DropdownQuestion({ key: 'favoriteAnimal', label: 'Favorite Animal', options: [ {key: 'cat', value: 'Cat'}, {key: 'dog', value: 'Dog'}, {key: 'horse', value: 'Horse'}, {key: 'capybara', value: 'Capybara'}, ], order: 3, }), new TextboxQuestion({ key: 'firstName', label: 'F",
    "id": "building-dynamic-forms-*-angular-19"
  },
  {
    "url": "https://angular.dev/guide/forms/dynamic-forms",
    "title": "Building dynamic forms • Angular",
    "chunk": "irst name', value: 'Alex', required: true, order: 1, }), new TextboxQuestion({ key: 'emailAddress', label: 'Email', type: 'email', order: 2, }), ]; return of(questions.sort((a, b) => a.order - b.order)); }} Create a dynamic form template The DynamicFormComponent component is the entry point and the main container for the form, which is represented using the <app-dynamic-form> in a template. The DynamicFormComponent component presents a list of questions by binding each one to an <app-question> e",
    "id": "building-dynamic-forms-*-angular-20"
  },
  {
    "url": "https://angular.dev/guide/forms/dynamic-forms",
    "title": "Building dynamic forms • Angular",
    "chunk": "lement that matches the DynamicFormQuestionComponent. dynamic-form.component.html <div> <form (ngSubmit)=\"onSubmit()\" [formGroup]=\"form\"> @for (question of questions(); track question) { <div class=\"form-row\"> <app-question [question]=\"question\" [form]=\"form\" /> </div> } <div class=\"form-row\"> <button type=\"submit\" [disabled]=\"!form.valid\">Save</button> </div> </form> @if (payLoad) { <div class=\"form-row\"><strong>Saved the following values</strong><br />{{ payLoad }}</div> }</div> dynamic-form.c",
    "id": "building-dynamic-forms-*-angular-21"
  },
  {
    "url": "https://angular.dev/guide/forms/dynamic-forms",
    "title": "Building dynamic forms • Angular",
    "chunk": "omponent.ts import {Component, inject, input} from '@angular/core';import {FormGroup, ReactiveFormsModule} from '@angular/forms';import {DynamicFormQuestionComponent} from './dynamic-form-question.component';import {QuestionBase} from './question-base';import {QuestionControlService} from './question-control.service';@Component({ selector: 'app-dynamic-form', templateUrl: './dynamic-form.component.html', providers: [QuestionControlService], imports: [DynamicFormQuestionComponent, ReactiveFormsMo",
    "id": "building-dynamic-forms-*-angular-22"
  },
  {
    "url": "https://angular.dev/guide/forms/dynamic-forms",
    "title": "Building dynamic forms • Angular",
    "chunk": "dule],})export class DynamicFormComponent { private readonly qcs = inject(QuestionControlService); questions = input<QuestionBase<string>[] | null>([]); form: FormGroup = this.qcs.toFormGroup(this.questions() as QuestionBase<string>[]); payLoad = ''; onSubmit() { this.payLoad = JSON.stringify(this.form.getRawValue()); }} Display the form To display an instance of the dynamic form, the AppComponent shell template passes the questions array returned by the QuestionService to the form container com",
    "id": "building-dynamic-forms-*-angular-23"
  },
  {
    "url": "https://angular.dev/guide/forms/dynamic-forms",
    "title": "Building dynamic forms • Angular",
    "chunk": "ponent, <app-dynamic-form>. app.component.ts import {Component, inject} from '@angular/core';import {AsyncPipe} from '@angular/common';import {DynamicFormComponent} from './dynamic-form.component';import {QuestionService} from './question.service';import {QuestionBase} from './question-base';import {Observable} from 'rxjs';@Component({ selector: 'app-root', template: ` <div> <h2>Job Application for Heroes</h2> <app-dynamic-form [questions]=\"questions$ | async\" /> </div> `, providers: [QuestionSe",
    "id": "building-dynamic-forms-*-angular-24"
  },
  {
    "url": "https://angular.dev/guide/forms/dynamic-forms",
    "title": "Building dynamic forms • Angular",
    "chunk": "rvice], imports: [AsyncPipe, DynamicFormComponent],})export class AppComponent { questions$: Observable<QuestionBase<string>[]> = inject(QuestionService).getQuestions();} This separation of model and data lets you repurpose the components for any type of survey, as long as it's compatible with the question object model. Ensuring valid data The form template uses dynamic data binding of metadata to render the form without making any hardcoded assumptions about specific questions. It adds both con",
    "id": "building-dynamic-forms-*-angular-25"
  },
  {
    "url": "https://angular.dev/guide/forms/dynamic-forms",
    "title": "Building dynamic forms • Angular",
    "chunk": "trol metadata and validation criteria dynamically. To ensure valid input, the Save button is disabled until the form is in a valid state. When the form is valid, click Save and the application renders the current form values as JSON. The following figure shows the final form. Next steps Validating form input Form validation guide Social MediaBlogX (formerly Twitter)BlueskyYouTube Discord GitHub Stack Overflow Community Contribute Code of Conduct Report Issues Google's DevLibrary Angular Google D",
    "id": "building-dynamic-forms-*-angular-26"
  },
  {
    "url": "https://angular.dev/guide/forms/dynamic-forms",
    "title": "Building dynamic forms • Angular",
    "chunk": "eveloper Experts ResourcesPress KitRoadmapLanguages简体中文版正體中文版日本語版한국어 Ελληνικά Super-powered by Google ©2010-2025. Code licensed under an MIT-style License . Documentation licensed under CC BY 4.0 .",
    "id": "building-dynamic-forms-*-angular-27"
  },
  {
    "url": "https://angular.dev/guide/routing",
    "title": "Routing • Overview • Angular",
    "chunk": "In-depth GuidesRouting Angular Routing Routing helps you change what the user sees in a single-page app. Angular Router (@angular/router) is the official library for managing navigation in Angular applications and a core part of the framework. It is included by default in all projects created by Angular CLI. On this pagearrow_upward_alt Back to the top Installation Angular Router is included by default in all Angular projects setup with the Angular CLI ng new command. Prerequisite Angular CLI Ad",
    "id": "routing-*-overview-*-angular-0"
  },
  {
    "url": "https://angular.dev/guide/routing",
    "title": "Routing • Overview • Angular",
    "chunk": "d to an existing project If your project does not have routing, you can install it manually with the following command: ng add @angular/router The Angular CLI will then install all the necessary dependencies. Why is routing necessary in a SPA? When you navigate to a URL in your web browser, the browser normally makes a network request to a web server and displays the returned HTML page. When you navigate to a different URL, such as clicking a link, the browser makes another network request and r",
    "id": "routing-*-overview-*-angular-1"
  },
  {
    "url": "https://angular.dev/guide/routing",
    "title": "Routing • Overview • Angular",
    "chunk": "eplaces the entire page with a new one. A single-page application (SPA) differs in that the browser only makes a request to a web server for the first page, the index.html. After that, a client-side router takes over, controlling which content displays based on the URL. When a user navigates to a different URL, the router updates the page's content in place without triggering a full-page reload. How Angular manages routing Routing in Angular is comprised of three primary parts: Routes define whi",
    "id": "routing-*-overview-*-angular-2"
  },
  {
    "url": "https://angular.dev/guide/routing",
    "title": "Routing • Overview • Angular",
    "chunk": "ch component displays when a user visits a specific URL. Outlets are placeholders in your templates that dynamically load and render components based on the active route. Links provide a way for users to navigate between different routes in your application without triggering a full page reload. In addition, the Angular Routing library offers additional functionality such as: Nested routes Programmatic navigation Route params, queries and wildcards Activated route information with ActivatedRoute",
    "id": "routing-*-overview-*-angular-3"
  },
  {
    "url": "https://angular.dev/guide/routing",
    "title": "Routing • Overview • Angular",
    "chunk": " View transition effects Navigation guards Next steps Learn about how you can define routes using Angular router. Social MediaBlogX (formerly Twitter)BlueskyYouTube Discord GitHub Stack Overflow Community Contribute Code of Conduct Report Issues Google's DevLibrary Angular Google Developer Experts ResourcesPress KitRoadmapLanguages简体中文版正體中文版日本語版한국어 Ελληνικά Super-powered by Google ©2010-2025. Code licensed under an MIT-style License . Documentation licensed under CC BY 4.0 . In-depth GuidesRouti",
    "id": "routing-*-overview-*-angular-4"
  },
  {
    "url": "https://angular.dev/guide/routing",
    "title": "Routing • Overview • Angular",
    "chunk": "ng Angular Routing Routing helps you change what the user sees in a single-page app.",
    "id": "routing-*-overview-*-angular-5"
  },
  {
    "url": "https://angular.dev/guide/routing/define-routes",
    "title": "Define routes • Angular",
    "chunk": "In-depth GuidesRouting Define routes Routes serve as the fundamental building blocks for navigation within an Angular app. On this pagearrow_upward_alt Back to the top What are routes? In Angular, a route is an object that defines which component should render for a specific URL path or pattern, as well as additional configuration options about what happens when a user navigates to that URL. Here is a basic example of a route: import { AdminPage } from './app-admin/app-admin.component';const adm",
    "id": "define-routes-*-angular-0"
  },
  {
    "url": "https://angular.dev/guide/routing/define-routes",
    "title": "Define routes • Angular",
    "chunk": "inPage = { path: 'admin', component: AdminPage} For this route, when a user visits the /admin path, the app will display the AdminPage component. Managing routes in your application Most projects define routes in a separate file that contains routes in the filename. A collection of routes looks like this: import { Routes } from '@angular/router';import { HomePage } from './home-page/home-page.component';import { AdminPage } from './about-page/admin-page.component';export const routes: Routes = [",
    "id": "define-routes-*-angular-1"
  },
  {
    "url": "https://angular.dev/guide/routing/define-routes",
    "title": "Define routes • Angular",
    "chunk": " { path: '', component: HomePage, }, { path: 'admin', component: AdminPage, },]; Tip: If you generated a project with Angular CLI, your routes are defined in src/app/app.routes.ts. Adding the router to your application When bootstrapping an Angular application without the Angular CLI, you can pass a configuration object that includes a providers array. Inside of the providers array, you can add the Angular router to your application by adding a provideRouter function call with your routes. impor",
    "id": "define-routes-*-angular-2"
  },
  {
    "url": "https://angular.dev/guide/routing/define-routes",
    "title": "Define routes • Angular",
    "chunk": "t { ApplicationConfig } from '@angular/core';import { provideRouter } from '@angular/router';import { routes } from './app.routes';export const appConfig: ApplicationConfig = { providers: [ provideRouter(routes), // ... ]}; Route URL Paths Static URL Paths Static URL Paths refer to routes with predefined paths that don't change based on dynamic parameters. These are routes that match a path string exactly and have a fixed outcome. Examples of this include: \"/admin\" \"/blog\" \"/settings/account\" De",
    "id": "define-routes-*-angular-3"
  },
  {
    "url": "https://angular.dev/guide/routing/define-routes",
    "title": "Define routes • Angular",
    "chunk": "fine URL Paths with Route Parameters Parameterized URLs allow you to define dynamic paths that allow multiple URLs to the same component while dynamically displaying data based on parameters in the URL. You can define this type of pattern by adding parameters to your route’s path string and prefixing each parameter with the colon (:) character. IMPORTANT: Parameters are distinct from information in the URL's query string. Learn more about query parameters in Angular in this guide. The following ",
    "id": "define-routes-*-angular-4"
  },
  {
    "url": "https://angular.dev/guide/routing/define-routes",
    "title": "Define routes • Angular",
    "chunk": "example displays a user profile component based on the user id passed in through the URL. import { Routes } from '@angular/router';import { UserProfile } from './user-profile/user-profile;const routes: Routes = [ { path: 'user/:id', component: UserProfile }]; In this example, URLs such as /user/leeroy and /user/jenkins render the UserProfile component. This component can then read the id parameter and use it to perform additional work, such as fetching data. See reading route state guide for det",
    "id": "define-routes-*-angular-5"
  },
  {
    "url": "https://angular.dev/guide/routing/define-routes",
    "title": "Define routes • Angular",
    "chunk": "ails on reading route parameters. Valid route parameter names must start with a letter (a-z, A-Z) and can only contain: Letters (a-z, A-Z) Numbers (0-9) Underscore (_) Hyphen (-) You can also define paths with multiple parameters: import { Routes } from '@angular/router';import { UserProfile } from './user-profile/user-profile.component';import { SocialMediaFeed } from './user-profile/social–media-feed.component';const routes: Routes = [ { path: 'user/:id/:social-media', component: SocialMediaFe",
    "id": "define-routes-*-angular-6"
  },
  {
    "url": "https://angular.dev/guide/routing/define-routes",
    "title": "Define routes • Angular",
    "chunk": "ed }, { path: 'user/:id/', component: UserProfile },]; With this new path, users can visit /user/leeroy/youtube and /user/leeroy/bluesky and see respective social media feeds based on the parameter for the user leeroy. See Reading route state for details on reading route parameters. Wildcards When you need to catch all routes for a specific path, the solution is a wildcard route which is defined with the double asterisk (**). A common example is defining a Page Not Found component. import { Home",
    "id": "define-routes-*-angular-7"
  },
  {
    "url": "https://angular.dev/guide/routing/define-routes",
    "title": "Define routes • Angular",
    "chunk": " } from './home/home.component';import { UserProfile } from './user-profile/user-profile.component';import { NotFound } from './not-found/not-found.component';const routes: Routes = [ { path: 'home', component: Home }, { path: 'user/:id', component: UserProfile }, { path: '**', component: NotFound }]; In this routes array, the app displays the NotFound component when the user visits any path outside of home and user/:id. Tip: Wildcard routes are typically placed at the end of a routes array. How",
    "id": "define-routes-*-angular-8"
  },
  {
    "url": "https://angular.dev/guide/routing/define-routes",
    "title": "Define routes • Angular",
    "chunk": " Angular matches URLs When you define routes, the order is important because Angular uses a first-match wins strategy. This means that once Angular matches a URL with a route path, it stops checking any further routes. As a result, always put more specific routes before less specific routes. The following example shows routes defined from most-specific to least specific: const routes: Routes = [ { path: '', component: HomeComponent }, // Empty path { path: 'users/new', component: NewUserComponen",
    "id": "define-routes-*-angular-9"
  },
  {
    "url": "https://angular.dev/guide/routing/define-routes",
    "title": "Define routes • Angular",
    "chunk": "t }, // Static, most specific { path: 'users/:id', component: UserDetailComponent }, // Dynamic { path: 'users', component: UsersComponent }, // Static, less specific { path: '**', component: NotFoundComponent } // Wildcard - always last]; If a user visits /users/new, Angular router would go through the following steps: Checks '' - doesn't match Checks users/new - matches! Stops here Never reaches users/:id even though it could match Never reaches users Never reaches ** Loading Route Component S",
    "id": "define-routes-*-angular-10"
  },
  {
    "url": "https://angular.dev/guide/routing/define-routes",
    "title": "Define routes • Angular",
    "chunk": "trategies Understanding how and when components load in Angular routing is crucial for building responsive web applications. Angular offers two primary strategies to control component loading behavior: Eagerly loaded: Components that are loaded immediately Lazily loaded: Components loaded only when needed Each approach offers distinct advantages for different scenarios. Eagerly loaded components When you define a route with the component property, the referenced component is eagerly loaded as pa",
    "id": "define-routes-*-angular-11"
  },
  {
    "url": "https://angular.dev/guide/routing/define-routes",
    "title": "Define routes • Angular",
    "chunk": "rt of the same JavaScript bundle as the route configuration. import { Routes } from \"@angular/router\";import { HomePage } from \"./components/home/home-page\"import { LoginPage } from \"./components/auth/login-page\"export const routes: Routes = [ // HomePage and LoginPage are both directly referenced in this config, // so their code is eagerly included in the same JavaScript bundle as this file. { path: \"\", component: HomePage }, { path: \"login\", component: LoginPage }] Eagerly loading route compon",
    "id": "define-routes-*-angular-12"
  },
  {
    "url": "https://angular.dev/guide/routing/define-routes",
    "title": "Define routes • Angular",
    "chunk": "ents like this means that the browser has to download and parse all of the JavaScript for these components as part of your initial page load, but the components are available to Angular immediately. While including more JavaScript in your initial page load leads to slower initial load times, this can lead to more seamless transitions as the user navigates through an application. Lazily loaded components You can use the loadComponent property to lazily load the JavaScript for a route only at the ",
    "id": "define-routes-*-angular-13"
  },
  {
    "url": "https://angular.dev/guide/routing/define-routes",
    "title": "Define routes • Angular",
    "chunk": "point at which that route would become active. import { Routes } from \"@angular/router\";export const routes: Routes = [ // The HomePage and LoginPage components are loaded lazily at the point at which // their corresponding routes become active. { path: 'login', loadComponent: () => import('./components/auth/login-page') }, { path: '', loadComponent: () => import('./components/home/home-page') }] The loadComponent property accepts a loader function that returns a Promise that resolves to an Angu",
    "id": "define-routes-*-angular-14"
  },
  {
    "url": "https://angular.dev/guide/routing/define-routes",
    "title": "Define routes • Angular",
    "chunk": "lar component. In most cases, this function uses the standard JavaScript dynamic import API. You can, however, use any arbitrary async loader function. Lazily loading routes can significantly improve the load speed of your Angular application by removing large portions of JavaScript from the initial bundle. These portions of your code compile into separate JavaScript \"chunks\" that the router requests only when the user visits the corresponding route. Should I use an eager or a lazy route? There ",
    "id": "define-routes-*-angular-15"
  },
  {
    "url": "https://angular.dev/guide/routing/define-routes",
    "title": "Define routes • Angular",
    "chunk": "are many factors to consider when deciding on whether a route should be eager or lazy. In general, eager loading is recommended for primary landing page(s) while other pages would be lazy-loaded. Note: While lazy routes have the upfront performance benefit of reducing the amount of initial data requested by the user, it adds future data requests that could be undesirable. This is particularly true when dealing with nested lazy loading at multiple levels, which can significantly impact performanc",
    "id": "define-routes-*-angular-16"
  },
  {
    "url": "https://angular.dev/guide/routing/define-routes",
    "title": "Define routes • Angular",
    "chunk": "e. Redirects You can define a route that redirects to another route instead of rendering a component: import { BlogComponent } from './home/blog.component';const routes: Routes = [ { path: 'articles', redirectTo: '/blog', }, { path: 'blog', component: BlogComponent },]; If you modify or remove a route, some users may still click on out-of-date links or bookmarks to that route. You can add a redirect to direct those users to an appropriate alternative route instead of a \"not found\" page. Page tit",
    "id": "define-routes-*-angular-17"
  },
  {
    "url": "https://angular.dev/guide/routing/define-routes",
    "title": "Define routes • Angular",
    "chunk": "les You can associate a title with each route. Angular automatically updates the page title when a route activates. Always define appropriate page titles for your application, as these titles are necessary to create an accessible experience. import { Routes } from '@angular/router';import { HomeComponent } from './home/home.component';import { AboutComponent } from './about/about.component';import { ProductsComponent } from './products/products.component';const routes: Routes = [ { path: '', com",
    "id": "define-routes-*-angular-18"
  },
  {
    "url": "https://angular.dev/guide/routing/define-routes",
    "title": "Define routes • Angular",
    "chunk": "ponent: HomeComponent, title: 'Home Page' }, { path: 'about', component: AboutComponent, title: 'About Us' }, { path: 'products', component: ProductsComponent, title: 'Our Products' }]; Route-level providers for dependency injection Each route has a providers property that lets you provide dependencies to that route's content via dependency injection. Common scenarios where this can be helpful include applications that have different services based on whether the user is an admin or not. export ",
    "id": "define-routes-*-angular-19"
  },
  {
    "url": "https://angular.dev/guide/routing/define-routes",
    "title": "Define routes • Angular",
    "chunk": "const ROUTES: Route[] = [ { path: 'admin', providers: [ AdminService, {provide: ADMIN_API_KEY, useValue: '12345'}, ], children: [ {path: 'users', component: AdminUsersComponent}, {path: 'teams', component: AdminTeamsComponent}, ], }, // ... other application routes that don't // have access to ADMIN_API_KEY or AdminService.]; In this code sample, the admin path contains a protected data property of ADMIN_API_KEY that is only available to children within its section. As a result, no other paths w",
    "id": "define-routes-*-angular-20"
  },
  {
    "url": "https://angular.dev/guide/routing/define-routes",
    "title": "Define routes • Angular",
    "chunk": "ill be able to access the data provided via ADMIN_API_KEY. See the Dependency injection guide for more information about providers and injection in Angular. Associating data with routes Route data enables you to attach additional information to routes. You are able to configure how components behave based on this data. There are two ways to work with route data: static data that remains constant, and dynamic data that can change based on runtime conditions. Static data You can associate arbitrar",
    "id": "define-routes-*-angular-21"
  },
  {
    "url": "https://angular.dev/guide/routing/define-routes",
    "title": "Define routes • Angular",
    "chunk": "y static data with a route via the data property in order to centralize things like route-specific metadata (e.g., analytics tracking, permissions, etc.): import { Routes } from '@angular/router';import { HomeComponent } from './home/home.component';import { AboutComponent } from './about/about.component';import { ProductsComponent } from './products/products.component';const routes: Routes = [ { path: 'about', component: AboutComponent, data: { analyticsId: '456' } }, { path: '', component: Hom",
    "id": "define-routes-*-angular-22"
  },
  {
    "url": "https://angular.dev/guide/routing/define-routes",
    "title": "Define routes • Angular",
    "chunk": "eComponent, data: { analyticsId: '123' } }]; In this code sample, the home and about page are configured with specific analyticsId which would then be used in their respective components for page tracking analytics. You can read this static data by injecting the ActivatedRoute. See Reading route state for details. Dynamic data with data resolvers When you need to provide dynamic data to a route, check out the guide on route data resolvers. Nested Routes Nested routes, also known as child routes,",
    "id": "define-routes-*-angular-23"
  },
  {
    "url": "https://angular.dev/guide/routing/define-routes",
    "title": "Define routes • Angular",
    "chunk": " are a common technique for managing more complex navigation routes where a component has a sub-view that changes based on the URL. You can add child routes to any route definition with the children property: const routes: Routes = [ path: 'product/:id', component: 'ProductComponent', children: [ { path: 'info', component: ProductInfoComponent }, { path: 'reviews', component: ProductReviewsComponent } ]] The above example defines a route for a product page that allows a user to change whether th",
    "id": "define-routes-*-angular-24"
  },
  {
    "url": "https://angular.dev/guide/routing/define-routes",
    "title": "Define routes • Angular",
    "chunk": "e product info or reviews are displayed based on the url. The children property accepts an array of Route objects. To display child routes, the parent component (ProductComponent in the example above) includes its own <router-outlet>. <!-- ProductComponent --><article> <h1>Product {{ id }}</h1> <router-outlet /></article> After adding child routes to the configuration and adding a <router-outlet> to the component, navigation between URLs that match the child routes updates only the nested outlet",
    "id": "define-routes-*-angular-25"
  },
  {
    "url": "https://angular.dev/guide/routing/define-routes",
    "title": "Define routes • Angular",
    "chunk": ". Next steps Learn how to display the contents of your routes with Outlets. Social MediaBlogX (formerly Twitter)BlueskyYouTube Discord GitHub Stack Overflow Community Contribute Code of Conduct Report Issues Google's DevLibrary Angular Google Developer Experts ResourcesPress KitRoadmapLanguages简体中文版正體中文版日本語版한국어 Ελληνικά Super-powered by Google ©2010-2025. Code licensed under an MIT-style License . Documentation licensed under CC BY 4.0 .",
    "id": "define-routes-*-angular-26"
  },
  {
    "url": "https://angular.dev/guide/routing/show-routes-with-outlets",
    "title": "Show routes with Outlets • Angular",
    "chunk": "In-depth GuidesRouting Show routes with outlets The RouterOutlet directive is a placeholder that marks the location where the router should render the component for the current URL. <app-header /><router-outlet /> <!-- Angular inserts your route content here --><app-footer /> import { Component } from '@angular/core';import { RouterOutlet } from '@angular/router';@Component({ selector: 'app-root', imports: [RouterOutlet], templateUrl: './app.component.html', styleUrl: './app.component.css'})expo",
    "id": "show-routes-with-outlets-*-angular-0"
  },
  {
    "url": "https://angular.dev/guide/routing/show-routes-with-outlets",
    "title": "Show routes with Outlets • Angular",
    "chunk": "rt class AppComponent {} In this example, if an application has the following routes defined: import { Routes } from '@angular/router';import { HomeComponent } from './home/home.component';import { ProductsComponent } from './products/products.component';const routes: Routes = [ { path: '', component: HomeComponent, title: 'Home Page' }, { path: 'products', component: ProductsComponent, title: 'Our Products' }]; When a user visits /products, Angular renders the following: <app-header></app-heade",
    "id": "show-routes-with-outlets-*-angular-1"
  },
  {
    "url": "https://angular.dev/guide/routing/show-routes-with-outlets",
    "title": "Show routes with Outlets • Angular",
    "chunk": "r><app-products></app-products><app-footer></app-footer> If the user goes back to the home page, then Angular renders: <app-header></app-header><app-home></app-home><app-footer></app-footer> When displaying a route, the <router-outlet> element remains present in the DOM as a reference point for future navigations. Angular inserts routed content just after the outlet element as a sibling. <!-- Contents of the component's template --><app-header /><router-outlet /><app-footer /> <!-- Content rende",
    "id": "show-routes-with-outlets-*-angular-2"
  },
  {
    "url": "https://angular.dev/guide/routing/show-routes-with-outlets",
    "title": "Show routes with Outlets • Angular",
    "chunk": "red on the page when the user visits /admin --><app-header>...</app-header><router-outlet></router-outlet><app-admin-page>...</app-admin-page><app-footer>...</app-footer> On this pagearrow_upward_alt Back to the top Nesting routes with child routes As your application grows more complex, you might want to create routes that are relative to a component other than your root component. This enables you to create experiences where only part of the application changes when the URL changes, as opposed",
    "id": "show-routes-with-outlets-*-angular-3"
  },
  {
    "url": "https://angular.dev/guide/routing/show-routes-with-outlets",
    "title": "Show routes with Outlets • Angular",
    "chunk": " to the users feeling like the entire page is refreshed. These types of nested routes are called child routes. This means you're adding a second <router-outlet> to your app, because it is in addition to the <router-outlet> in AppComponent. In this example, the Settings component will display the desired panel based on what the user selects. One of the unique things you’ll notice about child routes is that the component often has its own <nav> and <router-outlet>. <h1>Settings</h1><nav> <ul> <li>",
    "id": "show-routes-with-outlets-*-angular-4"
  },
  {
    "url": "https://angular.dev/guide/routing/show-routes-with-outlets",
    "title": "Show routes with Outlets • Angular",
    "chunk": "<a routerLink=\"profile\">Profile</a></li> <li><a routerLink=\"security\">Security</a></li> </ul></nav><router-outlet /> A child route is like any other route, in that it needs both a path and a component. The one difference is that you place child routes in a children array within the parent route. const routes: Routes = [ { path: 'settings-component', component: SettingsComponent, // this is the component with the <router-outlet> in the template children: [ { path: 'profile', // child route path c",
    "id": "show-routes-with-outlets-*-angular-5"
  },
  {
    "url": "https://angular.dev/guide/routing/show-routes-with-outlets",
    "title": "Show routes with Outlets • Angular",
    "chunk": "omponent: ProfileComponent, // child route component that the router renders }, { path: 'security', component: SecurityComponent, // another child route component that the router renders }, ], },]; Once both the routes and <router-outlet> are configured correctly, your application is now using nested routes! Secondary routes with named outlets Pages may have multiple outlets— you can assign a name to each outlet to specify which content belongs to which outlet. <app-header /><router-outlet /><ro",
    "id": "show-routes-with-outlets-*-angular-6"
  },
  {
    "url": "https://angular.dev/guide/routing/show-routes-with-outlets",
    "title": "Show routes with Outlets • Angular",
    "chunk": "uter-outlet name='read-more' /><router-outlet name='additional-actions' /><app-footer /> Each outlet must have a unique name. The name cannot be set or changed dynamically. By default, the name is 'primary'. Angular matches the outlet's name to the outlet property defined on each route: { path: 'user/:id', component: UserDetails, outlet: 'additional-actions'} Outlet lifecycle events There are four lifecycle events that a router outlet can emit: Event Description activate When a new component is ",
    "id": "show-routes-with-outlets-*-angular-7"
  },
  {
    "url": "https://angular.dev/guide/routing/show-routes-with-outlets",
    "title": "Show routes with Outlets • Angular",
    "chunk": "instantiated deactivate When a component is destroyed attach When the RouteReuseStrategy instructs the outlet to attach the subtree detach When the RouteReuseStrategy instructs the outlet to detach the subtree You can add event listeners with the standard event binding syntax: <router-outlet (activate)='onActivate($event)' (deactivate)='onDeactivate($event)' (attach)='onAttach($event)' (detach)='onDetach($event)'/> Check out the API docs for RouterOutlet if you’d like to learn more. Next steps L",
    "id": "show-routes-with-outlets-*-angular-8"
  },
  {
    "url": "https://angular.dev/guide/routing/show-routes-with-outlets",
    "title": "Show routes with Outlets • Angular",
    "chunk": "earn how to navigate to routes with Angular Router. Social MediaBlogX (formerly Twitter)BlueskyYouTube Discord GitHub Stack Overflow Community Contribute Code of Conduct Report Issues Google's DevLibrary Angular Google Developer Experts ResourcesPress KitRoadmapLanguages简体中文版正體中文版日本語版한국어 Ελληνικά Super-powered by Google ©2010-2025. Code licensed under an MIT-style License . Documentation licensed under CC BY 4.0 .",
    "id": "show-routes-with-outlets-*-angular-9"
  },
  {
    "url": "https://angular.dev/guide/routing/navigate-to-routes",
    "title": "Navigate to routes • Angular",
    "chunk": "In-depth GuidesRouting Navigate to routes The RouterLink directive is Angular's declarative approach to navigation. It allows you to use standard anchor elements (<a>) that seamlessly integrate with Angular's routing system. On this pagearrow_upward_alt Back to the top How to use RouterLink Instead of using regular anchor elements <a> with an href attribute, you add a RouterLink directive with the appropriate path in order to leverage Angular routing. import {RouterLink} from '@angular/router';@",
    "id": "navigate-to-routes-*-angular-0"
  },
  {
    "url": "https://angular.dev/guide/routing/navigate-to-routes",
    "title": "Navigate to routes • Angular",
    "chunk": "Component({ template: ` <nav> <a routerLink=\"/user-profile\">User profile</a> <a routerLink=\"/settings\">Settings</a> </nav> ` imports: [RouterLink], ...})export class App {} Using absolute or relative links Relative URLs in Angular routing allow you to define navigation paths relative to the current route's location. This is in contrast to absolute URLs which contain the full path with the protocol (e.g., http://) and the root domain (e.g., google.com). <!-- Absolute URL --><a href=\"https://www.a",
    "id": "navigate-to-routes-*-angular-1"
  },
  {
    "url": "https://angular.dev/guide/routing/navigate-to-routes",
    "title": "Navigate to routes • Angular",
    "chunk": "ngular.dev/essentials\">Angular Essentials Guide</a><!-- Relative URL --><a href=\"/essentials\">Angular Essentials Guide</a> In this example, the first example contains the full path with the protocol (i.e., https://) and the root domain (i.e., angular.dev) explicitly defined for the essentials page. In contrast, the second example assumes the user is already on the correct root domain for /essentials. Generally speaking, relative URLs are preferred because they are more maintainable across applic",
    "id": "navigate-to-routes-*-angular-2"
  },
  {
    "url": "https://angular.dev/guide/routing/navigate-to-routes",
    "title": "Navigate to routes • Angular",
    "chunk": "ations because they don’t need to know their absolute position within the routing hierarchy. How relative URLs work Angular routing has two syntaxes for defining relative URLs: strings and arrays. <!-- Navigates user to /dashboard --><a routerLink=\"dashboard\">Dashboard</a><a [routerLink]=\"['dashboard']\">Dashboard</a> HELPFUL: Passing a string is the most common way to define relative URLs. When you need to define dynamic parameters in a relative URL, use the array syntax: <a [routerLink]=\"['user",
    "id": "navigate-to-routes-*-angular-3"
  },
  {
    "url": "https://angular.dev/guide/routing/navigate-to-routes",
    "title": "Navigate to routes • Angular",
    "chunk": "', currentUserId]\">Current User</a> In addition, Angular routing allows you specify whether you want the path to be relative to the current URL or to the root domain based on whether the relative path is prefixed with a forward slash (/) or not. For example, if the user is on example.com/settings, here is how different relative paths can be defined for various scenarios: <!-- Navigates to /settings/notifications --><a routerLink=\"notifications\">Notifications</a><a routerLink=\"/settings/notificat",
    "id": "navigate-to-routes-*-angular-4"
  },
  {
    "url": "https://angular.dev/guide/routing/navigate-to-routes",
    "title": "Navigate to routes • Angular",
    "chunk": "ions\">Notifications</a><!-- Navigates to /team/:teamId/user/:userId --><a routerLink=\"/team/123/user/456\">User 456</a><a [routerLink]=\"['/team', teamId, 'user', userId]\">Current User</a>” Programmatic navigation to routes While RouterLink handles declarative navigation in templates, Angular provides programmatic navigation for scenarios where you need to navigate based on logic, user actions, or application state. By injecting Router, you can dynamically navigate to routes, pass parameters, and ",
    "id": "navigate-to-routes-*-angular-5"
  },
  {
    "url": "https://angular.dev/guide/routing/navigate-to-routes",
    "title": "Navigate to routes • Angular",
    "chunk": "control navigation behavior in your TypeScript code. router.navigate() You can use the router.navigate() method to programmatically navigate between routes by specifying a URL path array. import { Router } from '@angular/router';@Component({ selector: 'app-dashboard', template: ` <button (click)=\"navigateToProfile()\">View Profile</button> `})export class AppDashboard { private router = inject(Router); navigateToProfile() { // Standard navigation this.router.navigate(['/profile']); // With route ",
    "id": "navigate-to-routes-*-angular-6"
  },
  {
    "url": "https://angular.dev/guide/routing/navigate-to-routes",
    "title": "Navigate to routes • Angular",
    "chunk": "parameters this.router.navigate(['/users', userId]); // With query parameters this.router.navigate(['/search'], { queryParams: { category: 'books', sort: 'price' } }); }} router.navigate() supports both simple and complex routing scenarios, allowing you to pass route parameters, query parameters, and control navigation behavior. You can also build dynamic navigation paths relative to your component’s location in the routing tree using the relativeTo option. import { Router, ActivatedRoute } from",
    "id": "navigate-to-routes-*-angular-7"
  },
  {
    "url": "https://angular.dev/guide/routing/navigate-to-routes",
    "title": "Navigate to routes • Angular",
    "chunk": " '@angular/router';@Component({ selector: 'app-user-detail', template: ` <button (click)=\"navigateToEdit()\">Edit User</button> <button (click)=\"navigateToParent()\">Back to List</button> `})export class UserDetailComponent { private route = inject(ActivatedRoute); private router = inject(Router); constructor() {} // Navigate to a sibling route navigateToEdit() { // From: /users/123 // To: /users/123/edit this.router.navigate(['edit'], { relativeTo: this.route }); } // Navigate to parent navigateT",
    "id": "navigate-to-routes-*-angular-8"
  },
  {
    "url": "https://angular.dev/guide/routing/navigate-to-routes",
    "title": "Navigate to routes • Angular",
    "chunk": "oParent() { // From: /users/123 // To: /users this.router.navigate(['..'], { relativeTo: this.route }); }} router.navigateByUrl() The router.navigateByUrl() method provides a direct way to programmatically navigate using URL path strings rather than array segments. This method is ideal when you have a full URL path and need to perform absolute navigation, especially when working with externally provided URLs or deep linking scenarios. // Standard route navigationrouter.navigateByUrl('/products);",
    "id": "navigate-to-routes-*-angular-9"
  },
  {
    "url": "https://angular.dev/guide/routing/navigate-to-routes",
    "title": "Navigate to routes • Angular",
    "chunk": "// Navigate to nested routerouter.navigateByUrl('/products/featured');// Complete URL with parameters and fragmentrouter.navigateByUrl('/products/123?view=details#reviews');// Navigate with query parametersrouter.navigateByUrl('/search?category=books&sortBy=price'); In the event you need to replace the current URL in history, navigateByUrl also accepts a configuration object that has a replaceUrl option. // Replace current URL in historyrouter.navigateByUrl('/checkout', { replaceUrl: true}); Nex",
    "id": "navigate-to-routes-*-angular-10"
  },
  {
    "url": "https://angular.dev/guide/routing/navigate-to-routes",
    "title": "Navigate to routes • Angular",
    "chunk": "t steps Learn how to read route state to create responsive and context-aware components. Social MediaBlogX (formerly Twitter)BlueskyYouTube Discord GitHub Stack Overflow Community Contribute Code of Conduct Report Issues Google's DevLibrary Angular Google Developer Experts ResourcesPress KitRoadmapLanguages简体中文版正體中文版日本語版한국어 Ελληνικά Super-powered by Google ©2010-2025. Code licensed under an MIT-style License . Documentation licensed under CC BY 4.0 .",
    "id": "navigate-to-routes-*-angular-11"
  },
  {
    "url": "https://angular.dev/guide/routing/read-route-state",
    "title": "Read route state • Angular",
    "chunk": "In-depth GuidesRouting Read route state Angular Router allows you to read and use information associated with a route to create responsive and context-aware components. On this pagearrow_upward_alt Back to the top Get information about the current route with ActivatedRoute ActivatedRoute is a service from @angular/router that provides all the information associated with the current route. import { Component } from '@angular/core';import { ActivatedRoute } from '@angular/router';@Component({ sele",
    "id": "read-route-state-*-angular-0"
  },
  {
    "url": "https://angular.dev/guide/routing/read-route-state",
    "title": "Read route state • Angular",
    "chunk": "ctor: 'app-product',})export class ProductComponent { private activatedRoute = inject(ActivatedRoute); constructor() { console.log(this.activatedRoute); }} The ActivatedRoute can provide different information about the route. Some common properties include: Property Details url An Observable of the route paths, represented as an array of strings for each part of the route path. data An Observable that contains the data object provided for the route. Also contains any resolved values from the res",
    "id": "read-route-state-*-angular-1"
  },
  {
    "url": "https://angular.dev/guide/routing/read-route-state",
    "title": "Read route state • Angular",
    "chunk": "olve guard. params An Observable that contains the required and optional parameters specific to the route. queryParams An Observable that contains the query parameters available to all routes. Check out the ActivatedRoute API docs for a complete list of what you can access with in the route. Understanding route snapshots Page navigations are events over time, and you can access the router state at a given time by retrieving a route snapshot. Route snapshots contain essential information about th",
    "id": "read-route-state-*-angular-2"
  },
  {
    "url": "https://angular.dev/guide/routing/read-route-state",
    "title": "Read route state • Angular",
    "chunk": "e route, including its parameters, data, and child routes. In addition, snapshots are static and will not reflect future changes. Here’s an example of how you’d access a route snapshot: import { ActivatedRoute, ActivatedRouteSnapshot } from '@angular/router';@Component({ ... })export class UserProfileComponent { readonly userId: string; private activatedRoute = inject(ActivatedRoute); constructor() { // Example URL: https://www.angular.dev/users/123?role=admin&status=active#contact // Access rou",
    "id": "read-route-state-*-angular-3"
  },
  {
    "url": "https://angular.dev/guide/routing/read-route-state",
    "title": "Read route state • Angular",
    "chunk": "te parameters from snapshot this.userId = this.route.snapshot.paramMap.get('id'); // Access multiple route elements const snapshot = this.route.snapshot; console.log({ url: snapshot.url, // https://www.angular.dev // Route parameters object: {id: '123'} params: snapshot.params, // Query parameters object: {role: 'admin', status: 'active'} queryParams: snapshot.queryParams, // Query parameters }); }} Check out the ActivatedRoute API docs and ActivatedRouteSnapshot API docs for a complete list of ",
    "id": "read-route-state-*-angular-4"
  },
  {
    "url": "https://angular.dev/guide/routing/read-route-state",
    "title": "Read route state • Angular",
    "chunk": "all properties you can access. Reading parameters on a route There are two types of parameters that developers can utilize from a route: route and query parameters. Route Parameters Route parameters allow you to pass data to a component through the URL. This is useful when you want to display specific content based on an identifier in the URL, like a user ID or a product ID. You can define route parameters by prefixing the parameter name with a colon (:). import { Routes } from '@angular/router'",
    "id": "read-route-state-*-angular-5"
  },
  {
    "url": "https://angular.dev/guide/routing/read-route-state",
    "title": "Read route state • Angular",
    "chunk": ";import { ProductComponent } from './product/product.component';const routes: Routes = [ { path: 'product/:id', component: ProductComponent }]; You can access parameters by subscribing to route.params. import { Component, inject, signal } from '@angular/core';import { ActivatedRoute } from '@angular/router';@Component({ selector: 'app-product-detail', template: `<h1>Product Details: {{ productId() }}</h1>`,})export class ProductDetailComponent { productId = signal(''); private activatedRoute = i",
    "id": "read-route-state-*-angular-6"
  },
  {
    "url": "https://angular.dev/guide/routing/read-route-state",
    "title": "Read route state • Angular",
    "chunk": "nject(ActivatedRoute); constructor() { // Access route parameters this.activatedRoute.params.subscribe((params) => { this.productId.set(params['id']); }); }} Query Parameters Query parameters provide a flexible way to pass optional data through URLs without affecting the route structure. Unlike route parameters, query parameters can persist across navigation events and are perfect for handling filtering, sorting, pagination, and other stateful UI elements. // Single parameter structure// /produc",
    "id": "read-route-state-*-angular-7"
  },
  {
    "url": "https://angular.dev/guide/routing/read-route-state",
    "title": "Read route state • Angular",
    "chunk": "ts?category=electronicsrouter.navigate(['/products'], { queryParams: { category: 'electronics' }});// Multiple parameters// /products?category=electronics&sort=price&page=1router.navigate(['/products'], { queryParams: { category: 'electronics', sort: 'price', page: 1 }}); You can access query parameters with route.queryParams. Here is an example of a ProductListComponent that updates the query parameters that affect how it displays a list of products: import { ActivatedRoute, Router } from '@ang",
    "id": "read-route-state-*-angular-8"
  },
  {
    "url": "https://angular.dev/guide/routing/read-route-state",
    "title": "Read route state • Angular",
    "chunk": "ular/router';@Component({ selector: 'app-product-list', template: ` <div> <select (change)=\"updateSort($event)\"> <option value=\"price\">Price</option> <option value=\"name\">Name</option> </select> <!-- Products list --> </div> `})export class ProductListComponent implements OnInit { private route = inject(ActivatedRoute); private router = inject(Router); constructor() { // Access query parameters reactively this.route.queryParams.subscribe(params => { const sort = params['sort'] || 'price'; const ",
    "id": "read-route-state-*-angular-9"
  },
  {
    "url": "https://angular.dev/guide/routing/read-route-state",
    "title": "Read route state • Angular",
    "chunk": "page = Number(params['page']) || 1; this.loadProducts(sort, page); }); } updateSort(event: Event) { const sort = (event.target as HTMLSelectElement).value; // Update URL with new query parameter this.router.navigate([], { queryParams: { sort }, queryParamsHandling: 'merge' // Preserve other query parameters }); }} In this example, users can use a select element to sort the product list by name or price. The associated change handler updates the URL’s query parameters, which in turn triggers a ch",
    "id": "read-route-state-*-angular-10"
  },
  {
    "url": "https://angular.dev/guide/routing/read-route-state",
    "title": "Read route state • Angular",
    "chunk": "ange event that can read the updated query parameters and update the product list. For more information, check out the official docs on QueryParamsHandling. Detect active current route with RouterLinkActive You can use the RouterLinkActive directive to dynamically style navigation elements based on the current active route. This is common in navigation elements to inform users what the active route is. <nav> <a class=\"button\" routerLink=\"/about\" routerLinkActive=\"active-button\" ariaCurrentWhenAc",
    "id": "read-route-state-*-angular-11"
  },
  {
    "url": "https://angular.dev/guide/routing/read-route-state",
    "title": "Read route state • Angular",
    "chunk": "tive=\"page\"> About </a> | <a class=\"button\" routerLink=\"/settings\" routerLinkActive=\"active-button\" ariaCurrentWhenActive=\"page\"> Settings </a></nav> In this example, Angular Router will apply the active-button class to the correct anchor link and ariaCurrentWhenActive to page when the URL matches the corresponding routerLink. If you need to add multiple classes onto the element, you can use either a space-separated string or an array: <!-- Space-separated string syntax --><a routerLink=\"/user/b",
    "id": "read-route-state-*-angular-12"
  },
  {
    "url": "https://angular.dev/guide/routing/read-route-state",
    "title": "Read route state • Angular",
    "chunk": "ob\" routerLinkActive=\"class1 class2\">Bob</a><!-- Array syntax --><a routerLink=\"/user/bob\" [routerLinkActive]=\"['class1', 'class2']\">Bob</a> When you specify a value for routerLinkActive, you are also defining the same value for ariaCurrentWhenActive. This makes sure that visually impaired users (which may not perceive the different styling being applied) can also identify the active button. If you want to define a different value for aria, you’ll need to explicitly set the value using the ariaC",
    "id": "read-route-state-*-angular-13"
  },
  {
    "url": "https://angular.dev/guide/routing/read-route-state",
    "title": "Read route state • Angular",
    "chunk": "urrentWhenActive directive. Route matching strategy By default, RouterLinkActive considers any ancestors in the route a match. <a [routerLink]=\"['/user/jane']\" routerLinkActive=\"active-link\"> User</a><a [routerLink]=\"['/user/jane/role/admin']\" routerLinkActive=\"active-link\"> Role</a> When the user visits /user/jane/role/admin, both links would have the active-link class. Only apply RouterLinkActive on exact route matches If you only want to apply the class on an exact match, you need to provide ",
    "id": "read-route-state-*-angular-14"
  },
  {
    "url": "https://angular.dev/guide/routing/read-route-state",
    "title": "Read route state • Angular",
    "chunk": "the routerLinkActiveOptions directive with a configuration object that contains the value exact: true. <a [routerLink]=\"['/user/jane']\" routerLinkActive=\"active-link\" [routerLinkActiveOptions]=\"{exact: true}\"> User</a><a [routerLink]=\"['/user/jane/role/admin']\" routerLinkActive=\"active-link\" [routerLinkActiveOptions]=\"{exact: true}\"> Role</a> If you want to be more precise in how a route is matched, it’s worth noting that exact: true is actually syntactic sugar for the full set of matching optio",
    "id": "read-route-state-*-angular-15"
  },
  {
    "url": "https://angular.dev/guide/routing/read-route-state",
    "title": "Read route state • Angular",
    "chunk": "ns: // `exact: true` is equivalent to{ paths: 'exact', fragment: 'ignored', matrixParams: 'ignored', queryParams: 'exact',}// `exact: false` is equivalent{ paths: 'subset', fragment: 'ignored', matrixParams: 'ignored', queryParams: 'subset',} For more information, check out the official docs for isActiveMatchOptions. Apply RouterLinkActive to an ancestor The RouterLinkActive directive can also be applied to an ancestor element in order to allow developers to style the elements as desired. <div r",
    "id": "read-route-state-*-angular-16"
  },
  {
    "url": "https://angular.dev/guide/routing/read-route-state",
    "title": "Read route state • Angular",
    "chunk": "outerLinkActive=\"active-link\" [routerLinkActiveOptions]=\"{exact: true}\"> <a routerLink=\"/user/jim\">Jim</a> <a routerLink=\"/user/bob\">Bob</a></div> For more information, check out the API docs for RouterLinkActive. Social MediaBlogX (formerly Twitter)BlueskyYouTube Discord GitHub Stack Overflow Community Contribute Code of Conduct Report Issues Google's DevLibrary Angular Google Developer Experts ResourcesPress KitRoadmapLanguages简体中文版正體中文版日本語版한국어 Ελληνικά Super-powered by Google ©2010-2025. Code",
    "id": "read-route-state-*-angular-17"
  },
  {
    "url": "https://angular.dev/guide/routing/read-route-state",
    "title": "Read route state • Angular",
    "chunk": " licensed under an MIT-style License . Documentation licensed under CC BY 4.0 .",
    "id": "read-route-state-*-angular-18"
  },
  {
    "url": "https://angular.dev/guide/routing/common-router-tasks",
    "title": "Other routing tasks • Angular",
    "chunk": "In-depth GuidesRouting Other common Routing Tasks This guide covers some other common tasks associated with using Angular router in your application. On this pagearrow_upward_alt Back to the top Getting route information Often, as a user navigates your application, you want to pass information from one component to another. For example, consider an application that displays a shopping list of grocery items. Each item in the list has a unique id. To edit an item, users click an Edit button, which",
    "id": "other-routing-tasks-*-angular-0"
  },
  {
    "url": "https://angular.dev/guide/routing/common-router-tasks",
    "title": "Other routing tasks • Angular",
    "chunk": " opens an EditGroceryItem component. You want that component to retrieve the id for the grocery item so it can display the right information to the user. Use a route to pass this type of information to your application components. To do so, you use the withComponentInputBinding feature with provideRouter or the bindToComponentInputs option of RouterModule.forRoot. To get information from a route: Add withComponentInputBinding Add the withComponentInputBinding feature to the provideRouter method.",
    "id": "other-routing-tasks-*-angular-1"
  },
  {
    "url": "https://angular.dev/guide/routing/common-router-tasks",
    "title": "Other routing tasks • Angular",
    "chunk": " providers: [ provideRouter(appRoutes, withComponentInputBinding()),] Add an Input to the component Update the component to have an input() property matching the name of the parameter. id = input.required<string>()hero = computed(() => this.service.getHero(id)); NOTE: You can bind all route data with key, value pairs to component inputs: static or resolved route data, path parameters, matrix parameters, and query parameters. If you want to use the parent components route info you will need to se",
    "id": "other-routing-tasks-*-angular-2"
  },
  {
    "url": "https://angular.dev/guide/routing/common-router-tasks",
    "title": "Other routing tasks • Angular",
    "chunk": "t the router paramsInheritanceStrategy option: withRouterConfig({paramsInheritanceStrategy: 'always'}) Displaying a 404 page To display a 404 page, set up a wildcard route with the component property set to the component you'd like to use for your 404 page as follows: const routes: Routes = [ { path: 'first-component', component: FirstComponent }, { path: 'second-component', component: SecondComponent }, { path: '**', component: PageNotFoundComponent }, // Wildcard route for a 404 page]; The las",
    "id": "other-routing-tasks-*-angular-3"
  },
  {
    "url": "https://angular.dev/guide/routing/common-router-tasks",
    "title": "Other routing tasks • Angular",
    "chunk": "t route with the path of ** is a wildcard route. The router selects this route if the requested URL doesn't match any of the paths earlier in the list and sends the user to the PageNotFoundComponent. Preventing unauthorized access Use route guards to prevent users from navigating to parts of an application without authorization. The following route guards are available in Angular: canActivate canActivateChild canDeactivate canMatch resolve canLoad To use route guards, consider using component-le",
    "id": "other-routing-tasks-*-angular-4"
  },
  {
    "url": "https://angular.dev/guide/routing/common-router-tasks",
    "title": "Other routing tasks • Angular",
    "chunk": "ss routes as this facilitates guarding child routes. Create a file for your guard: ng generate guard your-guard In your guard file, add the guard functions you want to use. The following example uses canActivateFn to guard the route. export const yourGuardFunction: CanActivateFn = ( next: ActivatedRouteSnapshot, state: RouterStateSnapshot) => { // your logic goes here} In your routing module, use the appropriate property in your routes configuration. Here, canActivate tells the router to mediate",
    "id": "other-routing-tasks-*-angular-5"
  },
  {
    "url": "https://angular.dev/guide/routing/common-router-tasks",
    "title": "Other routing tasks • Angular",
    "chunk": " navigation to this particular route. { path: '/your-path', component: YourComponent, canActivate: [yourGuardFunction],} Link parameters array A link parameters array holds the following ingredients for router navigation: The path of the route to the destination component Required and optional route parameters that go into the route URL Bind the RouterLink directive to such an array like this: <a [routerLink]=\"['/heroes']\">Heroes</a> The following is a two-element array when specifying a route p",
    "id": "other-routing-tasks-*-angular-6"
  },
  {
    "url": "https://angular.dev/guide/routing/common-router-tasks",
    "title": "Other routing tasks • Angular",
    "chunk": "arameter: <a [routerLink]=\"['/hero', hero.id]\"> <span class=\"badge\">{{ hero.id }}</span>{{ hero.name }}</a> Provide optional route parameters in an object, as in { foo: 'foo' }: <a [routerLink]=\"['/crisis-center', { foo: 'foo' }]\">Crisis Center</a> These three examples cover the needs of an application with one level of routing. However, with a child router, such as in the crisis center, you create new link array possibilities. The following minimal RouterLink example builds upon a specified def",
    "id": "other-routing-tasks-*-angular-7"
  },
  {
    "url": "https://angular.dev/guide/routing/common-router-tasks",
    "title": "Other routing tasks • Angular",
    "chunk": "ault child route for the crisis center. <a [routerLink]=\"['/crisis-center']\">Crisis Center</a> Review the following: The first item in the array identifies the parent route (/crisis-center) There are no parameters for this parent route There is no default for the child route so you need to pick one You're navigating to the CrisisListComponent, whose route path is /, but you don't need to explicitly add the slash Consider the following router link that navigates from the root of the application d",
    "id": "other-routing-tasks-*-angular-8"
  },
  {
    "url": "https://angular.dev/guide/routing/common-router-tasks",
    "title": "Other routing tasks • Angular",
    "chunk": "own to the Dragon Crisis: <a [routerLink]=\"['/crisis-center', 1]\">Dragon Crisis</a> The first item in the array identifies the parent route (/crisis-center) There are no parameters for this parent route The second item identifies the child route details about a particular crisis (/:id) The details child route requires an id route parameter You added the id of the Dragon Crisis as the second item in the array (1) The resulting path is /crisis-center/1 You could also redefine the AppComponent temp",
    "id": "other-routing-tasks-*-angular-9"
  },
  {
    "url": "https://angular.dev/guide/routing/common-router-tasks",
    "title": "Other routing tasks • Angular",
    "chunk": "late with Crisis Center routes exclusively: @Component({ template: ` <h1 class=\"title\">Angular Router</h1> <nav> <a [routerLink]=\"['/crisis-center']\">Crisis Center</a> <a [routerLink]=\"['/crisis-center/1', { foo: 'foo' }]\">Dragon Crisis</a> <a [routerLink]=\"['/crisis-center/2']\">Shark Crisis</a> </nav> <router-outlet /> `})export class AppComponent {} In summary, you can write applications with one, two or more levels of routing. The link parameters array affords the flexibility to represent any",
    "id": "other-routing-tasks-*-angular-10"
  },
  {
    "url": "https://angular.dev/guide/routing/common-router-tasks",
    "title": "Other routing tasks • Angular",
    "chunk": " routing depth and any legal sequence of route paths, (required) router parameters, and (optional) route parameter objects. LocationStrategy and browser URL styles When the router navigates to a new component view, it updates the browser's location and history with a URL for that view. Modern HTML5 browsers support history.pushState, a technique that changes a browser's location and history without triggering a server page request. The router can compose a \"natural\" URL that is indistinguishable",
    "id": "other-routing-tasks-*-angular-11"
  },
  {
    "url": "https://angular.dev/guide/routing/common-router-tasks",
    "title": "Other routing tasks • Angular",
    "chunk": " from one that would otherwise require a page load. Here's the Crisis Center URL in this \"HTML5 pushState\" style: localhost:3002/crisis-center Older browsers send page requests to the server when the location URL changes unless the change occurs after a \"#\" (called the \"hash\"). Routers can take advantage of this exception by composing in-application route URLs with hashes. Here's a \"hash URL\" that routes to the Crisis Center. localhost:3002/src/#/crisis-center The router supports both styles wit",
    "id": "other-routing-tasks-*-angular-12"
  },
  {
    "url": "https://angular.dev/guide/routing/common-router-tasks",
    "title": "Other routing tasks • Angular",
    "chunk": "h two LocationStrategy providers: Providers Details PathLocationStrategy The default \"HTML5 pushState\" style. HashLocationStrategy The \"hash URL\" style. The RouterModule.forRoot() function sets the LocationStrategy to the PathLocationStrategy, which makes it the default strategy. You also have the option of switching to the HashLocationStrategy with an override during the bootstrapping process. HELPFUL: For more information on providers and the bootstrap process, see Dependency Injection. Social",
    "id": "other-routing-tasks-*-angular-13"
  },
  {
    "url": "https://angular.dev/guide/routing/common-router-tasks",
    "title": "Other routing tasks • Angular",
    "chunk": " MediaBlogX (formerly Twitter)BlueskyYouTube Discord GitHub Stack Overflow Community Contribute Code of Conduct Report Issues Google's DevLibrary Angular Google Developer Experts ResourcesPress KitRoadmapLanguages简体中文版正體中文版日本語版한국어 Ελληνικά Super-powered by Google ©2010-2025. Code licensed under an MIT-style License . Documentation licensed under CC BY 4.0 .",
    "id": "other-routing-tasks-*-angular-14"
  },
  {
    "url": "https://angular.dev/guide/routing/routing-with-urlmatcher",
    "title": "Creating custom route matches • Angular",
    "chunk": "In-depth GuidesRouting Creating custom route matches The Angular Router supports a powerful matching strategy that you can use to help users navigate your application. This matching strategy supports static routes, variable routes with parameters, wildcard routes, and so on. Also, build your own custom pattern matching for situations in which the URLs are more complicated. In this tutorial, you'll build a custom route matcher using Angular's UrlMatcher. This matcher looks for a Twitter handle in",
    "id": "creating-custom-route-matches-*-angular-0"
  },
  {
    "url": "https://angular.dev/guide/routing/routing-with-urlmatcher",
    "title": "Creating custom route matches • Angular",
    "chunk": " the URL. On this pagearrow_upward_alt Back to the top Objectives Implement Angular's UrlMatcher to create a custom route matcher. Create a sample application Using the Angular CLI, create a new application, angular-custom-route-match. In addition to the default Angular application framework, you will also create a profile component. Create a new Angular project, angular-custom-route-match. ng new angular-custom-route-match When prompted with Would you like to add Angular routing?, select Y. Whe",
    "id": "creating-custom-route-matches-*-angular-1"
  },
  {
    "url": "https://angular.dev/guide/routing/routing-with-urlmatcher",
    "title": "Creating custom route matches • Angular",
    "chunk": "n prompted with Which stylesheet format would you like to use?, select CSS. After a few moments, a new project, angular-custom-route-match, is ready. From your terminal, navigate to the angular-custom-route-match directory. Create a component, profile. ng generate component profile In your code editor, locate the file, profile.component.html and replace the placeholder content with the following HTML. src/app/profile/profile.component.html <p> Hello {{ username() }}!</p> In your code editor, loc",
    "id": "creating-custom-route-matches-*-angular-2"
  },
  {
    "url": "https://angular.dev/guide/routing/routing-with-urlmatcher",
    "title": "Creating custom route matches • Angular",
    "chunk": "ate the file, app.component.html and replace the placeholder content with the following HTML. src/app/app.component.html <h2>Routing with Custom Matching</h2>Navigate to <a routerLink=\"/@Angular\">my profile</a><router-outlet></router-outlet> Configure your routes for your application With your application framework in place, you next need to add routing capabilities to the app.config.ts file. As a part of this process, you will create a custom URL matcher that looks for a Twitter handle in the U",
    "id": "creating-custom-route-matches-*-angular-3"
  },
  {
    "url": "https://angular.dev/guide/routing/routing-with-urlmatcher",
    "title": "Creating custom route matches • Angular",
    "chunk": "RL. This handle is identified by a preceding @ symbol. In your code editor, open your app.config.ts file. Add an import statement for Angular's provideRouter and withComponentInputBinding as well as the application routes. import {provideRouter, withComponentInputBinding} from '@angular/router'; import {routes} from './app.routes'; In the providers array, add a provideRouter(routes, withComponentInputBinding()) statement. Define the custom route matcher by adding the following code to the applic",
    "id": "creating-custom-route-matches-*-angular-4"
  },
  {
    "url": "https://angular.dev/guide/routing/routing-with-urlmatcher",
    "title": "Creating custom route matches • Angular",
    "chunk": "ation routes. src/app/app.routes.ts import {Routes, UrlSegment} from '@angular/router';import {ProfileComponent} from './profile/profile.component';export const routes: Routes = [ { matcher: (url) => { if (url.length === 1 && url[0].path.match(/^@[\\w]+$/gm)) { return {consumed: url, posParams: {username: new UrlSegment(url[0].path.slice(1), {})}}; } return null; }, component: ProfileComponent, },]; This custom matcher is a function that performs the following tasks: The matcher verifies that the",
    "id": "creating-custom-route-matches-*-angular-5"
  },
  {
    "url": "https://angular.dev/guide/routing/routing-with-urlmatcher",
    "title": "Creating custom route matches • Angular",
    "chunk": " array contains only one segment The matcher employs a regular expression to ensure that the format of the username is a match If there is a match, the function returns the entire URL, defining a username route parameter as a substring of the path If there isn't a match, the function returns null and the router continues to look for other routes that match the URL HELPFUL: A custom URL matcher behaves like any other route definition. Define child routes or lazy loaded routes as you would with an",
    "id": "creating-custom-route-matches-*-angular-6"
  },
  {
    "url": "https://angular.dev/guide/routing/routing-with-urlmatcher",
    "title": "Creating custom route matches • Angular",
    "chunk": "y other route. Reading the route parameters With the custom matcher in place, you can now bind the route parameter in the profile component. In your code editor, open your profile.component.ts file and create an Input matching the username parameter. We added the withComponentInputBinding feature earlier in provideRouter. This allows the Router to bind information directly to the route components. @Input() username!: string; Test your custom URL matcher With your code in place, you can now test ",
    "id": "creating-custom-route-matches-*-angular-7"
  },
  {
    "url": "https://angular.dev/guide/routing/routing-with-urlmatcher",
    "title": "Creating custom route matches • Angular",
    "chunk": "your custom URL matcher. From a terminal window, run the ng serve command. ng serve Open a browser to http://localhost:4200. You should see a single web page, consisting of a sentence that reads Navigate to my profile. Click the my profile hyperlink. A new sentence, reading Hello, Angular! appears on the page. Next steps Pattern matching with the Angular Router provides you with a lot of flexibility when you have dynamic URLs in your application. To learn more about the Angular Router, see the f",
    "id": "creating-custom-route-matches-*-angular-8"
  },
  {
    "url": "https://angular.dev/guide/routing/routing-with-urlmatcher",
    "title": "Creating custom route matches • Angular",
    "chunk": "ollowing topics: In-app Routing and Navigation Router API HELPFUL: This content is based on Custom Route Matching with the Angular Router, by Brandon Roberts. Social MediaBlogX (formerly Twitter)BlueskyYouTube Discord GitHub Stack Overflow Community Contribute Code of Conduct Report Issues Google's DevLibrary Angular Google Developer Experts ResourcesPress KitRoadmapLanguages简体中文版正體中文版日本語版한국어 Ελληνικά Super-powered by Google ©2010-2025. Code licensed under an MIT-style License . Documentation li",
    "id": "creating-custom-route-matches-*-angular-9"
  },
  {
    "url": "https://angular.dev/guide/routing/routing-with-urlmatcher",
    "title": "Creating custom route matches • Angular",
    "chunk": "censed under CC BY 4.0 .",
    "id": "creating-custom-route-matches-*-angular-10"
  },
  {
    "url": "https://angular.dev/guide/performance",
    "title": "Server-side & hybrid-rendering • Overview • Angular",
    "chunk": "In-depth GuidesServer-side & hybrid-rendering Server-side & hybrid rendering Learn about different ways you can optimize the performance of your application with different rendering strategies. One of the top priorities of any developer is ensuring that their application is as performant as possible. These guides are here to help you follow best practices for building performant applications by taking advantage of different rendering strategies. Guides Types Description Server and hybrid renderi",
    "id": "server-side-and-hybrid-rendering-*-overview-*-angular-0"
  },
  {
    "url": "https://angular.dev/guide/performance",
    "title": "Server-side & hybrid-rendering • Overview • Angular",
    "chunk": "ng Learn how to leverage rendering pages on the server to improve load times. Hydration A process to improve application performance by restoring its state after server-side rendering and reusing existing DOM structure as much as possible. Incremental Hydration Incremental hydration is an advanced type of hydration that can leave sections of your application dehydrated and incrementally trigger hydration of those sections as they are needed. Social MediaBlogX (formerly Twitter)BlueskyYouTube Dis",
    "id": "server-side-and-hybrid-rendering-*-overview-*-angular-1"
  },
  {
    "url": "https://angular.dev/guide/performance",
    "title": "Server-side & hybrid-rendering • Overview • Angular",
    "chunk": "cord GitHub Stack Overflow Community Contribute Code of Conduct Report Issues Google's DevLibrary Angular Google Developer Experts ResourcesPress KitRoadmapLanguages简体中文版正體中文版日本語版한국어 Ελληνικά Super-powered by Google ©2010-2025. Code licensed under an MIT-style License . Documentation licensed under CC BY 4.0 . In-depth GuidesServer-side & hybrid-rendering Server-side & hybrid rendering Learn about different ways you can optimize the performance of your application with different rendering strate",
    "id": "server-side-and-hybrid-rendering-*-overview-*-angular-2"
  },
  {
    "url": "https://angular.dev/guide/performance",
    "title": "Server-side & hybrid-rendering • Overview • Angular",
    "chunk": "gies.",
    "id": "server-side-and-hybrid-rendering-*-overview-*-angular-3"
  },
  {
    "url": "https://angular.dev/guide/ssr",
    "title": "Server-side and hybrid-rendering • Angular",
    "chunk": "In-depth GuidesServer-side & hybrid-rendering Server and hybrid rendering Angular ships all applications as client-side rendered (CSR) by default. While this approach delivers a initial payload that's lightweight, it introduces trade-offs including slower load times, degraded performance metrics, and higher resource demands since the user's device performs most of the computations. As a result, many applications achieve significant performance improvements by integrating server-side rendering (S",
    "id": "server-side-and-hybrid-rendering-*-angular-0"
  },
  {
    "url": "https://angular.dev/guide/ssr",
    "title": "Server-side and hybrid-rendering • Angular",
    "chunk": "SR) into a hybrid rendering strategy. On this pagearrow_upward_alt Back to the top What is hybrid rendering? Hybrid rendering allows developers to leverage the benefits of server-side rendering (SSR), pre-rendering (also known as \"static site generation\" or SSG) and client-side rendering (CSR) to optimize your Angular application. It gives you fine-grained control over how your different parts of your app is rendered to give your users the best experience possible. Setting up hybrid rendering Yo",
    "id": "server-side-and-hybrid-rendering-*-angular-1"
  },
  {
    "url": "https://angular.dev/guide/ssr",
    "title": "Server-side and hybrid-rendering • Angular",
    "chunk": "u can create a new project with hybrid rendering by using the server-side rendering flag (i.e., --ssr) with the Angular CLI ng new command: ng new --ssr You can also enable hybrid rendering by adding server-side rendering to an existing project with the ng add command: ng add @angular/ssr NOTE: By default, Angular prerenders your entire application and generates a server file. To disable this and create a fully static app, set outputMode to static. To enable SSR, update the server routes to use ",
    "id": "server-side-and-hybrid-rendering-*-angular-2"
  },
  {
    "url": "https://angular.dev/guide/ssr",
    "title": "Server-side and hybrid-rendering • Angular",
    "chunk": "RenderMode.Server. For more details, see Server routing and Generate a fully static application. Server routing Configuring server routes You can create a server route config by declaring an array of ServerRoute objects. This configuration typically lives in a file named app.routes.server.ts. // app.routes.server.tsimport { RenderMode, ServerRoute } from '@angular/ssr';export const serverRoutes: ServerRoute[] = [ { path: '', // This renders the \"/\" route on the client (CSR) renderMode: RenderMod",
    "id": "server-side-and-hybrid-rendering-*-angular-3"
  },
  {
    "url": "https://angular.dev/guide/ssr",
    "title": "Server-side and hybrid-rendering • Angular",
    "chunk": "e.Client, }, { path: 'about', // This page is static, so we prerender it (SSG) renderMode: RenderMode.Prerender, }, { path: 'profile', // This page requires user-specific data, so we use SSR renderMode: RenderMode.Server, }, { path: '**', // All other routes will be rendered on the server (SSR) renderMode: RenderMode.Server, },]; You can add this config to your application with provideServerRendering using the withRoutes function: import { provideServerRendering, withRoutes } from '@angular/ssr'",
    "id": "server-side-and-hybrid-rendering-*-angular-4"
  },
  {
    "url": "https://angular.dev/guide/ssr",
    "title": "Server-side and hybrid-rendering • Angular",
    "chunk": ";import { serverRoutes } from './app.routes.server';// app.config.server.tsconst serverConfig: ApplicationConfig = { providers: [ provideServerRendering(withRoutes(serverRoutes)), // ... other providers ... ]}; When using the App shell pattern, you must specify the component to be used as the app shell for client-side rendered routes. To do this, use the withAppShell fetaure: import { provideServerRendering, withRoutes, withAppShell } from '@angular/ssr';import { AppShellComponent } from './app-",
    "id": "server-side-and-hybrid-rendering-*-angular-5"
  },
  {
    "url": "https://angular.dev/guide/ssr",
    "title": "Server-side and hybrid-rendering • Angular",
    "chunk": "shell/app-shell.component';const serverConfig: ApplicationConfig = { providers: [ provideServerRendering( withRoutes(serverRoutes), withAppShell(AppShellComponent), ), // ... other providers ... ]}; Rendering modes The server routing configuration lets you specify how each route in your application should render by setting a RenderMode: Rendering mode Description Server (SSR) Renders the application on the server for each request, sending a fully populated HTML page to the browser. Client (CSR) ",
    "id": "server-side-and-hybrid-rendering-*-angular-6"
  },
  {
    "url": "https://angular.dev/guide/ssr",
    "title": "Server-side and hybrid-rendering • Angular",
    "chunk": "Renders the application in the browser. This is the default Angular behavior. Prerender (SSG) Prerenders the application at build time, generating static HTML files for each route. Choosing a rendering mode Each rendering mode has different benefits and drawbacks. You can choose rendering modes based on the specific needs of your application. Client-side rendering Client-side rendering has the simplest development model, as you can write code that assumes it always runs in a web browser. This le",
    "id": "server-side-and-hybrid-rendering-*-angular-7"
  },
  {
    "url": "https://angular.dev/guide/ssr",
    "title": "Server-side and hybrid-rendering • Angular",
    "chunk": "ts you use a wide range of client-side libraries that also assume they run in a browser. Client-side rendering generally has worse performance than other rendering modes, as it must download, parse, and execute your page's JavaScript before the user can see any rendered content. If your page fetches more data from the server as it renders, users also have to wait for those additional requests before they can view the complete content. If your page is indexed by search crawlers, client-side rende",
    "id": "server-side-and-hybrid-rendering-*-angular-8"
  },
  {
    "url": "https://angular.dev/guide/ssr",
    "title": "Server-side and hybrid-rendering • Angular",
    "chunk": "ring may negatively affect search engine optimization (SEO), as search crawlers have limits to how much JavaScript they execute when indexing a page. When client-side rendering, the server does not need to do any work to render a page beyond serving static JavaScript assets. You may consider this factor if server cost is a concern. Applications that support installable, offline experiences with service workers can rely on client-side rendering without needing to communicate with a server. Server",
    "id": "server-side-and-hybrid-rendering-*-angular-9"
  },
  {
    "url": "https://angular.dev/guide/ssr",
    "title": "Server-side and hybrid-rendering • Angular",
    "chunk": "-side rendering Server-side rendering offers faster page loads than client-side rendering. Instead of waiting for JavaScript to download and run, the server directly renders an HTML document upon receiving a request from the browser. The user experiences only the latency necessary for the server to fetch data and render the requested page. This mode also eliminates the need for additional network requests from the browser, as your code can fetch data during rendering on the server. Server-side r",
    "id": "server-side-and-hybrid-rendering-*-angular-10"
  },
  {
    "url": "https://angular.dev/guide/ssr",
    "title": "Server-side and hybrid-rendering • Angular",
    "chunk": "endering generally has excellent search engine optimization (SEO), as search crawlers receive a fully rendered HTML document. Server-side rendering requires you to author code that does not strictly depend on browser APIs and limits your selection of JavaScript libraries that assume they run in a browser. When server-side rendering, your server runs Angular to produce an HTML response for every request which may increase server hosting costs. Build-time prerendering Prerendering offers faster pa",
    "id": "server-side-and-hybrid-rendering-*-angular-11"
  },
  {
    "url": "https://angular.dev/guide/ssr",
    "title": "Server-side and hybrid-rendering • Angular",
    "chunk": "ge loads than both client-side rendering and server-side rendering. Because prerendering creates HTML documents at build-time, the server can directly respond to requests with the static HTML document without any additional work. Prerendering requires that all information necessary to render a page is available at build-time. This means that prerendered pages cannot include any data to the specific user loading the page. Prerendering is primarily useful for pages that are the same for all users ",
    "id": "server-side-and-hybrid-rendering-*-angular-12"
  },
  {
    "url": "https://angular.dev/guide/ssr",
    "title": "Server-side and hybrid-rendering • Angular",
    "chunk": "of your application. Because prerendering occurs at build-time, it may add significant time to your production builds. Using getPrerenderParams to produce a large number of HTML documents may affect the total file size of your deployments, and thus lead to slower deployments. Prerendering generally has excellent search engine optimization (SEO), as search crawlers receive a fully rendered HTML document. Prerendering requires you to author code that does not strictly depend on browser APIs and li",
    "id": "server-side-and-hybrid-rendering-*-angular-13"
  },
  {
    "url": "https://angular.dev/guide/ssr",
    "title": "Server-side and hybrid-rendering • Angular",
    "chunk": "mits your selection of JavaScript libraries that assume they run in a browser. Prerendering incurs extremely little overhead per server request, as your server responds with static HTML documents. Static files are also easily cached by Content Delivery Networks (CDNs), browsers, and intermediate caching layers for even faster subsequent page loads. Fully static sites can also be deployed solely through a CDN or static file server, eliminating the need to maintain a custom server runtime for your",
    "id": "server-side-and-hybrid-rendering-*-angular-14"
  },
  {
    "url": "https://angular.dev/guide/ssr",
    "title": "Server-side and hybrid-rendering • Angular",
    "chunk": " application. This enhances scalability by offloading work from an application web server, making it particularly beneficial for high-traffic applications. NOTE: When using Angular service worker, the first request is server-rendered, but all subsequent requests are handled by the service worker and rendered client-side. Setting headers and status codes You can set custom headers and status codes for individual server routes using the headers and status properties in the ServerRoute configuratio",
    "id": "server-side-and-hybrid-rendering-*-angular-15"
  },
  {
    "url": "https://angular.dev/guide/ssr",
    "title": "Server-side and hybrid-rendering • Angular",
    "chunk": "n. // app.routes.server.tsimport { RenderMode, ServerRoute } from '@angular/ssr';export const serverRoutes: ServerRoute[] = [ { path: 'profile', renderMode: RenderMode.Server, headers: { 'X-My-Custom-Header': 'some-value', }, status: 201, }, // ... other routes]; Redirects Angular handles redirects specified by the redirectTo property in route configurations, differently on the server-side. Server-Side Rendering (SSR) Redirects are performed using standard HTTP redirects (e.g., 301, 302) within ",
    "id": "server-side-and-hybrid-rendering-*-angular-16"
  },
  {
    "url": "https://angular.dev/guide/ssr",
    "title": "Server-side and hybrid-rendering • Angular",
    "chunk": "the server-side rendering process. Prerendering (SSG) Redirects are implemented as \"soft redirects\" using <meta http-equiv=\"refresh\"> tags in the prerendered HTML. Customizing build-time prerendering (SSG) When using RenderMode.Prerender, you can specify several configuration options to customize the prerendering and serving process. Parameterized routes For each route with RenderMode.Prerender, you can specify a getPrerenderParams function. This function lets you control which specific paramete",
    "id": "server-side-and-hybrid-rendering-*-angular-17"
  },
  {
    "url": "https://angular.dev/guide/ssr",
    "title": "Server-side and hybrid-rendering • Angular",
    "chunk": "rs produce separate prerendered documents. The getPrerenderParams function returns a Promise that resolves to an array of objects. Each object is a key-value map of route parameter name to value. For example, if you define a route like post/:id, getPrerenderParams could return the array [{id: 123}, {id: 456}], and thus render separate documents for post/123 and post/456. The body of getPrerenderParams can use Angular's inject function to inject dependencies and perform any work to determine whic",
    "id": "server-side-and-hybrid-rendering-*-angular-18"
  },
  {
    "url": "https://angular.dev/guide/ssr",
    "title": "Server-side and hybrid-rendering • Angular",
    "chunk": "h routes to prerender. This typically includes making requests to fetch data to construct the array of parameter values. You can also use this function with catch-all routes (e.g., /**), where the parameter name will be \"**\" and the return value will be the segments of the path, such as foo/bar. These can be combined with other parameters (e.g., /post/:id/**) to handle more complex route configuration. // app.routes.server.tsimport { RenderMode, ServerRoute } from '@angular/ssr';export const ser",
    "id": "server-side-and-hybrid-rendering-*-angular-19"
  },
  {
    "url": "https://angular.dev/guide/ssr",
    "title": "Server-side and hybrid-rendering • Angular",
    "chunk": "verRoutes: ServerRoute[] = [ { path: 'post/:id', renderMode: RenderMode.Prerender, async getPrerenderParams() { const dataService = inject(PostService); const ids = await dataService.getIds(); // Assuming this returns ['1', '2', '3'] return ids.map(id => ({ id })); // Generates paths like: /post/1, /post/2, /post/3 }, }, { path: 'post/:id/**', renderMode: RenderMode.Prerender, async getPrerenderParams() { return [ { id: '1', '**': 'foo/3' }, { id: '2', '**': 'bar/4' }, ]; // Generates paths like",
    "id": "server-side-and-hybrid-rendering-*-angular-20"
  },
  {
    "url": "https://angular.dev/guide/ssr",
    "title": "Server-side and hybrid-rendering • Angular",
    "chunk": ": /post/1/foo/3, /post/2/bar/4 }, },]; Because getPrerenderParams exclusively applies to RenderMode.Prerender, this function always runs at build-time. getPrerenderParams must not rely on any browser-specific or server-specific APIs for data. IMPORTANT: When using inject inside getPrerenderParams, please remember that inject must be used synchronously. It cannot be invoked within asynchronous callbacks or following any await statements. For more information, refer to runInInjectionContext. Fallb",
    "id": "server-side-and-hybrid-rendering-*-angular-21"
  },
  {
    "url": "https://angular.dev/guide/ssr",
    "title": "Server-side and hybrid-rendering • Angular",
    "chunk": "ack strategies When using RenderMode.Prerender mode, you can specify a fallback strategy to handle requests for paths that haven't been prerendered. The available fallback strategies are: Server: Falls back to server-side rendering. This is the default behavior if no fallback property is specified. Client: Falls back to client-side rendering. None: No fallback. Angular will not handle requests for paths that are not prerendered. // app.routes.server.tsimport { RenderMode, PrerenderFallback, Serv",
    "id": "server-side-and-hybrid-rendering-*-angular-22"
  },
  {
    "url": "https://angular.dev/guide/ssr",
    "title": "Server-side and hybrid-rendering • Angular",
    "chunk": "erRoute } from '@angular/ssr';export const serverRoutes: ServerRoute[] = [ { path: 'post/:id', renderMode: RenderMode.Prerender, fallback: PrerenderFallback.Client, // Fallback to CSR if not prerendered async getPrerenderParams() { // This function returns an array of objects representing prerendered posts at the paths: // `/post/1`, `/post/2`, and `/post/3`. // The path `/post/4` will utilize the fallback behavior if it's requested. return [{ id: 1 }, { id: 2 }, { id: 3 }]; }, },]; Authoring se",
    "id": "server-side-and-hybrid-rendering-*-angular-23"
  },
  {
    "url": "https://angular.dev/guide/ssr",
    "title": "Server-side and hybrid-rendering • Angular",
    "chunk": "rver-compatible components Some common browser APIs and capabilities might not be available on the server. Applications cannot make use of browser-specific global objects like window, document, navigator, or location as well as certain properties of HTMLElement. In general, code which relies on browser-specific symbols should only be executed in the browser, not on the server. This can be enforced through the afterEveryRender and afterNextRender lifecycle hooks. These are only executed on the br",
    "id": "server-side-and-hybrid-rendering-*-angular-24"
  },
  {
    "url": "https://angular.dev/guide/ssr",
    "title": "Server-side and hybrid-rendering • Angular",
    "chunk": "owser and skipped on the server. import { Component, ViewChild, afterNextRender } from '@angular/core';@Component({ selector: 'my-cmp', template: `<span #content>{{ ... }}</span>`,})export class MyComponent { @ViewChild('content') contentRef: ElementRef; constructor() { afterNextRender(() => { // Safe to check `scrollHeight` because this will only run in the browser, not the server. console.log('content height: ' + this.contentRef.nativeElement.scrollHeight); }); }} Accessing Request and Respons",
    "id": "server-side-and-hybrid-rendering-*-angular-25"
  },
  {
    "url": "https://angular.dev/guide/ssr",
    "title": "Server-side and hybrid-rendering • Angular",
    "chunk": "e via DI The @angular/core package provides several tokens for interacting with the server-side rendering environment. These tokens give you access to crucial information and objects within your Angular application during SSR. REQUEST: Provides access to the current request object, which is of type Request from the Web API. This allows you to access headers, cookies, and other request information. RESPONSE_INIT: Provides access to the response initialization options, which is of type ResponseIni",
    "id": "server-side-and-hybrid-rendering-*-angular-26"
  },
  {
    "url": "https://angular.dev/guide/ssr",
    "title": "Server-side and hybrid-rendering • Angular",
    "chunk": "t from the Web API. This allows you to set headers and the status code for the response dynamically. Use this token to set headers or status codes that need to be determined at runtime. REQUEST_CONTEXT: Provides access to additional context related to the current request. This context can be passed as the second parameter of the handle function. Typically, this is used to provide additional request-related information that is not part of the standard Web API. import { inject, REQUEST } from '@an",
    "id": "server-side-and-hybrid-rendering-*-angular-27"
  },
  {
    "url": "https://angular.dev/guide/ssr",
    "title": "Server-side and hybrid-rendering • Angular",
    "chunk": "gular/core';@Component({ selector: 'app-my-component', template: `<h1>My Component</h1>`,})export class MyComponent { constructor() { const request = inject(REQUEST); console.log(request?.url); }} IMPORTANT: The above tokens will be null in the following scenarios: During the build processes. When the application is rendered in the browser (CSR). When performing static site generation (SSG). During route extraction in development (at the time of the request). Generate a fully static application ",
    "id": "server-side-and-hybrid-rendering-*-angular-28"
  },
  {
    "url": "https://angular.dev/guide/ssr",
    "title": "Server-side and hybrid-rendering • Angular",
    "chunk": "By default, Angular prerenders your entire application and generates a server file for handling requests. This allows your app to serve pre-rendered content to users. However, if you prefer a fully static site without a server, you can opt out of this behavior by setting the outputMode to static in your angular.json configuration file. When outputMode is set to static, Angular generates pre-rendered HTML files for each route at build time, but it does not generate a server file or require a Node",
    "id": "server-side-and-hybrid-rendering-*-angular-29"
  },
  {
    "url": "https://angular.dev/guide/ssr",
    "title": "Server-side and hybrid-rendering • Angular",
    "chunk": ".js server to serve the app. This is useful for deploying to static hosting providers where a backend server is not needed. To configure this, update your angular.json file as follows: { \"projects\": { \"your-app\": { \"architect\": { \"build\": { \"options\": { \"outputMode\": \"static\" } } } } }} Caching data when using HttpClient HttpClient cached outgoing network requests when running on the server. This information is serialized and transferred to the browser as part of the initial HTML sent from the s",
    "id": "server-side-and-hybrid-rendering-*-angular-30"
  },
  {
    "url": "https://angular.dev/guide/ssr",
    "title": "Server-side and hybrid-rendering • Angular",
    "chunk": "erver. In the browser, HttpClient checks whether it has data in the cache and if so, reuses it instead of making a new HTTP request during initial application rendering. HttpClient stops using the cache once an application becomes stable while running in a browser. By default, HttpClient caches all HEAD and GET requests which don't contain Authorization or Proxy-Authorization headers. You can override those settings by using withHttpTransferCacheOptions when providing hydration. bootstrapApplica",
    "id": "server-side-and-hybrid-rendering-*-angular-31"
  },
  {
    "url": "https://angular.dev/guide/ssr",
    "title": "Server-side and hybrid-rendering • Angular",
    "chunk": "tion(AppComponent, { providers: [ provideClientHydration(withHttpTransferCacheOptions({ includePostRequests: true })) ]}); Configuring a server Node.js The @angular/ssr/node extends @angular/ssr specifically for Node.js environments. It provides APIs that make it easier to implement server-side rendering within your Node.js application. For a complete list of functions and usage examples, refer to the @angular/ssr/node API reference API reference. // server.tsimport { AngularNodeAppEngine, creat",
    "id": "server-side-and-hybrid-rendering-*-angular-32"
  },
  {
    "url": "https://angular.dev/guide/ssr",
    "title": "Server-side and hybrid-rendering • Angular",
    "chunk": "eNodeRequestHandler, writeResponseToNodeResponse } from '@angular/ssr/node';import express from 'express';const app = express();const angularApp = new AngularNodeAppEngine();app.use('*', (req, res, next) => { angularApp .handle(req) .then(response => { if (response) { writeResponseToNodeResponse(response, res); } else { next(); // Pass control to the next middleware } }) .catch(next);});/** * The request handler used by the Angular CLI (dev-server and during build). */export const reqHandler = c",
    "id": "server-side-and-hybrid-rendering-*-angular-33"
  },
  {
    "url": "https://angular.dev/guide/ssr",
    "title": "Server-side and hybrid-rendering • Angular",
    "chunk": "reateNodeRequestHandler(app); Non-Node.js The @angular/ssr provides essential APIs for server-side rendering your Angular application on platforms other than Node.js. It leverages the standard Request and Response objects from the Web API, enabling you to integrate Angular SSR into various server environments. For detailed information and examples, refer to the @angular/ssr API reference. // server.tsimport { AngularAppEngine, createRequestHandler } from '@angular/ssr';const angularApp = new Ang",
    "id": "server-side-and-hybrid-rendering-*-angular-34"
  },
  {
    "url": "https://angular.dev/guide/ssr",
    "title": "Server-side and hybrid-rendering • Angular",
    "chunk": "ularAppEngine();/** * This is a request handler used by the Angular CLI (dev-server and during build). */export const reqHandler = createRequestHandler(async (req: Request) => { const res: Response|null = await angularApp.render(req); // ...}); Social MediaBlogX (formerly Twitter)BlueskyYouTube Discord GitHub Stack Overflow Community Contribute Code of Conduct Report Issues Google's DevLibrary Angular Google Developer Experts ResourcesPress KitRoadmapLanguages简体中文版正體中文版日本語版한국어 Ελληνικά Super-pow",
    "id": "server-side-and-hybrid-rendering-*-angular-35"
  },
  {
    "url": "https://angular.dev/guide/ssr",
    "title": "Server-side and hybrid-rendering • Angular",
    "chunk": "ered by Google ©2010-2025. Code licensed under an MIT-style License . Documentation licensed under CC BY 4.0 .",
    "id": "server-side-and-hybrid-rendering-*-angular-36"
  },
  {
    "url": "https://angular.dev/guide/hydration",
    "title": "Hydration • Angular",
    "chunk": "In-depth GuidesServer-side & hybrid-rendering Hydration On this pagearrow_upward_alt Back to the top What is hydration Hydration is the process that restores the server-side rendered application on the client. This includes things like reusing the server rendered DOM structures, persisting the application state, transferring application data that was retrieved already by the server, and other processes. Why is hydration important? Hydration improves application performance by avoiding extra work",
    "id": "hydration-*-angular-0"
  },
  {
    "url": "https://angular.dev/guide/hydration",
    "title": "Hydration • Angular",
    "chunk": " to re-create DOM nodes. Instead, Angular tries to match existing DOM elements to the applications structure at runtime and reuses DOM nodes when possible. This results in a performance improvement that can be measured using Core Web Vitals (CWV) statistics, such as reducing the First Input Delay (FID) and Largest Contentful Paint (LCP), as well as Cumulative Layout Shift (CLS). Improving these numbers also affects things like SEO performance. Without hydration enabled, server-side rendered Angu",
    "id": "hydration-*-angular-1"
  },
  {
    "url": "https://angular.dev/guide/hydration",
    "title": "Hydration • Angular",
    "chunk": "lar applications will destroy and re-render the application's DOM, which may result in a visible UI flicker. This re-rendering can negatively impact Core Web Vitals like LCP and cause a layout shift. Enabling hydration allows the existing DOM to be re-used and prevents a flicker. How do you enable hydration in Angular Hydration can be enabled for server-side rendered (SSR) applications only. Follow the Angular SSR Guide to enable server-side rendering first. Using Angular CLI If you've used Angu",
    "id": "hydration-*-angular-2"
  },
  {
    "url": "https://angular.dev/guide/hydration",
    "title": "Hydration • Angular",
    "chunk": "lar CLI to enable SSR (either by enabling it during application creation or later via ng add @angular/ssr), the code that enables hydration should already be included into your application. Manual setup If you have a custom setup and didn't use Angular CLI to enable SSR, you can enable hydration manually by visiting your main application component or module and importing provideClientHydration from @angular/platform-browser. You'll then add that provider to your app's bootstrapping providers lis",
    "id": "hydration-*-angular-3"
  },
  {
    "url": "https://angular.dev/guide/hydration",
    "title": "Hydration • Angular",
    "chunk": "t. import { bootstrapApplication, provideClientHydration,} from '@angular/platform-browser';...bootstrapApplication(AppComponent, { providers: [provideClientHydration()]}); Alternatively if you are using NgModules, you would add provideClientHydration to your root app module's provider list. import {provideClientHydration} from '@angular/platform-browser';import {NgModule} from '@angular/core';@NgModule({ declarations: [AppComponent], exports: [AppComponent], bootstrap: [AppComponent], providers",
    "id": "hydration-*-angular-4"
  },
  {
    "url": "https://angular.dev/guide/hydration",
    "title": "Hydration • Angular",
    "chunk": ": [provideClientHydration()],})export class AppModule {} IMPORTANT: Make sure that the provideClientHydration() call is also included into a set of providers that is used to bootstrap an application on the server. In applications with the default project structure (generated by the ng new command), adding a call to the root AppModule should be sufficient, since this module is imported by the server module. If you use a custom setup, add the provideClientHydration() call to the providers list in ",
    "id": "hydration-*-angular-5"
  },
  {
    "url": "https://angular.dev/guide/hydration",
    "title": "Hydration • Angular",
    "chunk": "the server bootstrap configuration. Verify that hydration is enabled After you've configured hydration and have started up your server, load your application in the browser. HELPFUL: You will likely need to fix instances of Direct DOM Manipulation before hydration will fully work either by switching to Angular constructs or by using ngSkipHydration. See Constraints, Direct DOM Manipulation, and How to skip hydration for particular components for more details. While running an application in dev ",
    "id": "hydration-*-angular-6"
  },
  {
    "url": "https://angular.dev/guide/hydration",
    "title": "Hydration • Angular",
    "chunk": "mode, you can confirm hydration is enabled by opening the Developer Tools in your browser and viewing the console. You should see a message that includes hydration-related stats, such as the number of components and nodes hydrated. Angular calculates the stats based on all components rendered on a page, including those that come from third-party libraries. You can also use Angular DevTools browser extension to see hydration status of components on a page. Angular DevTools also allows to enable a",
    "id": "hydration-*-angular-7"
  },
  {
    "url": "https://angular.dev/guide/hydration",
    "title": "Hydration • Angular",
    "chunk": "n overlay to indicate which parts of the page were hydrated. If there is a hydration mismatch error - DevTools would also highlight a component that caused the error. Capturing and replaying events When an application is rendered on the server, it is visible in a browser as soon as produced HTML loads. Users may assume that they can interact with the page, but event listeners are not attached until hydration completes. Starting from v18, you can enable the Event Replay feature that allows to cap",
    "id": "hydration-*-angular-8"
  },
  {
    "url": "https://angular.dev/guide/hydration",
    "title": "Hydration • Angular",
    "chunk": "ture all events that happen before hydration and replay those events once hydration has completed. You can enable it using the withEventReplay() function, for example: import {provideClientHydration, withEventReplay} from '@angular/platform-browser';bootstrapApplication(App, { providers: [ provideClientHydration(withEventReplay()) ]}); How event replay works Event Replay is a feature that improves user experience by capturing user events that were triggered before the hydration process is comple",
    "id": "hydration-*-angular-9"
  },
  {
    "url": "https://angular.dev/guide/hydration",
    "title": "Hydration • Angular",
    "chunk": "te. Then those events are replayed, ensuring none of that interaction was lost. The Event Replay is divided into three main phases: Capturing user interactions Prior to Hydration, Event Replay captures and stores all interactions that the user may perform, such as clicks and other browser native events. Storing events The Event Contract keeps in memory all the interactions recorded in the previous step, ensuring that they are not lost for later replay. Relaunch of events Once Hydration is comple",
    "id": "hydration-*-angular-10"
  },
  {
    "url": "https://angular.dev/guide/hydration",
    "title": "Hydration • Angular",
    "chunk": "te, Angular re-invokes the captured events. Event replay supports native browser events, for example click, mouseover, and focusin. If you'd like to learn more about JSAction, the library that powers event replay, you can read more on the readme. This feature ensures a consistent user experience, preventing user actions performed before Hydration from being ignored. NOTE: if you have incremental hydration enabled, event replay is automatically enabled under the hood. Constraints Hydration impose",
    "id": "hydration-*-angular-11"
  },
  {
    "url": "https://angular.dev/guide/hydration",
    "title": "Hydration • Angular",
    "chunk": "s a few constraints on your application that are not present without hydration enabled. Your application must have the same generated DOM structure on both the server and the client. The process of hydration expects the DOM tree to have the same structure in both places. This also includes whitespaces and comment nodes that Angular produces during the rendering on the server. Those whitespaces and nodes must be present in the HTML generated by the server-side rendering process. IMPORTANT: The HT",
    "id": "hydration-*-angular-12"
  },
  {
    "url": "https://angular.dev/guide/hydration",
    "title": "Hydration • Angular",
    "chunk": "ML produced by the server side rendering operation must not be altered between the server and the client. If there is a mismatch between server and client DOM tree structures, the hydration process will encounter problems attempting to match up what was expected to what is actually present in the DOM. Components that do direct DOM manipulation using native DOM APIs are the most common culprit. Direct DOM Manipulation If you have components that manipulate the DOM using native DOM APIs or use inn",
    "id": "hydration-*-angular-13"
  },
  {
    "url": "https://angular.dev/guide/hydration",
    "title": "Hydration • Angular",
    "chunk": "erHTML or outerHTML, the hydration process will encounter errors. Specific cases where DOM manipulation is a problem are situations like accessing the document, querying for specific elements, and injecting additional nodes using appendChild. Detaching DOM nodes and moving them to other locations will also result in errors. This is because Angular is unaware of these DOM changes and cannot resolve them during the hydration process. Angular will expect a certain structure, but it will encounter a",
    "id": "hydration-*-angular-14"
  },
  {
    "url": "https://angular.dev/guide/hydration",
    "title": "Hydration • Angular",
    "chunk": " different structure when attempting to hydrate. This mismatch will result in hydration failure and throw a DOM mismatch error (see below). It is best to refactor your component to avoid this sort of DOM manipulation. Try to use Angular APIs to do this work, if you can. If you cannot refactor this behavior, use the ngSkipHydration attribute (described below) until you can refactor into a hydration friendly solution. Valid HTML structure There are a few cases where if you have a component templat",
    "id": "hydration-*-angular-15"
  },
  {
    "url": "https://angular.dev/guide/hydration",
    "title": "Hydration • Angular",
    "chunk": "e that does not have valid HTML structure, this could result in a DOM mismatch error during hydration. As an example, here are some of the most common cases of this issue. <table> without a <tbody> <div> inside a <p> <a> inside another <a> If you are uncertain about whether your HTML is valid, you can use a syntax validator to check it. NOTE: While the HTML standard does not require the <tbody> element inside tables, modern browsers automatically create a <tbody> element in tables that do not de",
    "id": "hydration-*-angular-16"
  },
  {
    "url": "https://angular.dev/guide/hydration",
    "title": "Hydration • Angular",
    "chunk": "clare one. Because of this inconsistency, always explicitly declare a <tbody> element in tables to avoid hydration errors. Preserve Whitespaces Configuration When using the hydration feature, we recommend using the default setting of false for preserveWhitespaces. If this setting is not in your tsconfig, the value will be false and no changes are required. If you choose to enable preserving whitespaces by adding preserveWhitespaces: true to your tsconfig, it is possible you may encounter issues ",
    "id": "hydration-*-angular-17"
  },
  {
    "url": "https://angular.dev/guide/hydration",
    "title": "Hydration • Angular",
    "chunk": "with hydration. This is not yet a fully supported configuration. HELPFUL: Make sure that this setting is set consistently in tsconfig.server.json for your server and tsconfig.app.json for your browser builds. A mismatched value will cause hydration to break. If you choose to set this setting in your tsconfig, we recommend to set it only in tsconfig.app.json which by default the tsconfig.server.json will inherit it from. Custom or Noop Zone.js are not yet supported Hydration relies on a signal fr",
    "id": "hydration-*-angular-18"
  },
  {
    "url": "https://angular.dev/guide/hydration",
    "title": "Hydration • Angular",
    "chunk": "om Zone.js when it becomes stable inside an application, so that Angular can start the serialization process on the server or post-hydration cleanup on the client to remove DOM nodes that remained unclaimed. Providing a custom or a \"noop\" Zone.js implementation may lead to a different timing of the \"stable\" event, thus triggering the serialization or the cleanup too early or too late. This is not yet a fully supported configuration and you may need to adjust the timing of the onStable event in t",
    "id": "hydration-*-angular-19"
  },
  {
    "url": "https://angular.dev/guide/hydration",
    "title": "Hydration • Angular",
    "chunk": "he custom Zone.js implementation. Errors There are several hydration related errors you may encounter ranging from node mismatches to cases when the ngSkipHydration was used on an invalid host node. The most common error case that may occur is due to direct DOM manipulation using native APIs that results in hydration being unable to find or match the expected DOM tree structure on the client that was rendered by the server. The other case you may encounter this type of error was mentioned in the",
    "id": "hydration-*-angular-20"
  },
  {
    "url": "https://angular.dev/guide/hydration",
    "title": "Hydration • Angular",
    "chunk": " Valid HTML structure section earlier. So, make sure the HTML in your templates are using valid structure, and you'll avoid that error case. For a full reference on hydration related errors, visit the Errors Reference Guide. How to skip hydration for particular components Some components may not work properly with hydration enabled due to some of the aforementioned issues, like Direct DOM Manipulation. As a workaround, you can add the ngSkipHydration attribute to a component's tag in order to sk",
    "id": "hydration-*-angular-21"
  },
  {
    "url": "https://angular.dev/guide/hydration",
    "title": "Hydration • Angular",
    "chunk": "ip hydrating the entire component. <app-example ngSkipHydration /> Alternatively you can set ngSkipHydration as a host binding. @Component({ ... host: {ngSkipHydration: 'true'},})class ExampleComponent {} The ngSkipHydration attribute will force Angular to skip hydrating the entire component and its children. Using this attribute means that the component will behave as if hydration is not enabled, meaning it will destroy and re-render itself. HELPFUL: This will fix rendering issues, but it means",
    "id": "hydration-*-angular-22"
  },
  {
    "url": "https://angular.dev/guide/hydration",
    "title": "Hydration • Angular",
    "chunk": " that for this component (and its children), you don't get the benefits of hydration. You will need to adjust your component's implementation to avoid hydration-breaking patterns (i.e. Direct DOM Manipulation) to be able to remove the skip hydration annotation. The ngSkipHydration attribute can only be used on component host nodes. Angular throws an error if this attribute is added to other nodes. Keep in mind that adding the ngSkipHydration attribute to your root application component would eff",
    "id": "hydration-*-angular-23"
  },
  {
    "url": "https://angular.dev/guide/hydration",
    "title": "Hydration • Angular",
    "chunk": "ectively disable hydration for your entire application. Be careful and thoughtful about using this attribute. It is intended as a last resort workaround. Components that break hydration should be considered bugs that need to be fixed. Hydration Timing and Application Stability Application stability is an important part of the hydration process. Hydration and any post-hydration processes only occur once the application has reported stability. There are a number of ways that stability can be delay",
    "id": "hydration-*-angular-24"
  },
  {
    "url": "https://angular.dev/guide/hydration",
    "title": "Hydration • Angular",
    "chunk": "ed. Examples include setting timeouts and intervals, unresolved promises, and pending microtasks. In those cases, you may encounter the Application remains unstable error, which indicates that your app has not yet reached the stable state after 10 seconds. If you're finding that your application is not hydrating right away, take a look at what is impacting application stability and refactor to avoid causing these delays. I18N HELPFUL: Support for internationalization with hydration is currently ",
    "id": "hydration-*-angular-25"
  },
  {
    "url": "https://angular.dev/guide/hydration",
    "title": "Hydration • Angular",
    "chunk": "in developer preview. By default, Angular will skip hydration for components that use i18n blocks, effectively re-rendering those components from scratch. To enable hydration for i18n blocks, you can add withI18nSupport to your provideClientHydration call. import { bootstrapApplication, provideClientHydration, withI18nSupport,} from '@angular/platform-browser';...bootstrapApplication(AppComponent, { providers: [provideClientHydration(withI18nSupport())]}); Consistent rendering across server-side",
    "id": "hydration-*-angular-26"
  },
  {
    "url": "https://angular.dev/guide/hydration",
    "title": "Hydration • Angular",
    "chunk": " and client-side Avoid introducing @if blocks and other conditionals that display different content when server-side rendering than client-side rendering, such as using an @if block with Angular's isPlatformBrowser function. These rendering differences cause layout shifts, negatively impacting end-user experience and core web vitals. Third Party Libraries with DOM Manipulation There are a number of third party libraries that depend on DOM manipulation to be able to render. D3 charts is a prime e",
    "id": "hydration-*-angular-27"
  },
  {
    "url": "https://angular.dev/guide/hydration",
    "title": "Hydration • Angular",
    "chunk": "xample. These libraries worked without hydration, but they may cause DOM mismatch errors when hydration is enabled. For now, if you encounter DOM mismatch errors using one of these libraries, you can add the ngSkipHydration attribute to the component that renders using that library. Third Party Scripts with DOM Manipulation Many third party scripts, such as ad trackers and analytics, modify the DOM before hydration can occur. These scripts may cause hydration errors because the page no longer ma",
    "id": "hydration-*-angular-28"
  },
  {
    "url": "https://angular.dev/guide/hydration",
    "title": "Hydration • Angular",
    "chunk": "tches the structure expected by Angular. Prefer deferring this type of script until after hydration whenever possible. Consider using AfterNextRender to delay the script until post-hydration processes have occured. Incremental Hydration Incremental hydration is an advanced form of hydration that allows for more granular control over when hydration happens. See the incremental hydration guide for more information. Social MediaBlogX (formerly Twitter)BlueskyYouTube Discord GitHub Stack Overflow Co",
    "id": "hydration-*-angular-29"
  },
  {
    "url": "https://angular.dev/guide/hydration",
    "title": "Hydration • Angular",
    "chunk": "mmunity Contribute Code of Conduct Report Issues Google's DevLibrary Angular Google Developer Experts ResourcesPress KitRoadmapLanguages简体中文版正體中文版日本語版한국어 Ελληνικά Super-powered by Google ©2010-2025. Code licensed under an MIT-style License . Documentation licensed under CC BY 4.0 .",
    "id": "hydration-*-angular-30"
  },
  {
    "url": "https://angular.dev/guide/incremental-hydration",
    "title": "Incremental Hydration • Angular",
    "chunk": "In-depth GuidesServer-side & hybrid-rendering Incremental Hydration Incremental hydration is an advanced type of hydration that can leave sections of your application dehydrated and incrementally trigger hydration of those sections as they are needed. On this pagearrow_upward_alt Back to the top Why use incremental hydration? Incremental hydration is a performance improvement that builds on top of full application hydration. It can produce smaller initial bundles while still providing an end-use",
    "id": "incremental-hydration-*-angular-0"
  },
  {
    "url": "https://angular.dev/guide/incremental-hydration",
    "title": "Incremental Hydration • Angular",
    "chunk": "r experience that is comparable to a full application hydration experience. Smaller bundles improve initial load times, reducing First Input Delay (FID) and Cumulative Layout Shift (CLS). Incremental hydration also lets you use deferrable views (@defer) for content that may not have been deferrable before. Specifically, you can now use deferrable views for content that is above the fold. Prior to incremental hydration, putting a @defer block above the fold would result in placeholder content ren",
    "id": "incremental-hydration-*-angular-1"
  },
  {
    "url": "https://angular.dev/guide/incremental-hydration",
    "title": "Incremental Hydration • Angular",
    "chunk": "dering and then being replaced by the @defer block's main template content. This would result in a layout shift. Incremental hydration means the main template of the @defer block will render with no layout shift on hydration. How do you enable incremental hydration in Angular? You can enable incremental hydration for applications that already use server-side rendering (SSR) with hydration. Follow the Angular SSR Guide to enable server-side rendering and the Angular Hydration Guide to enable hydr",
    "id": "incremental-hydration-*-angular-2"
  },
  {
    "url": "https://angular.dev/guide/incremental-hydration",
    "title": "Incremental Hydration • Angular",
    "chunk": "ation first. Enable incremental hydration by adding the withIncrementalHydration() function to the provideClientHydration provider. import { bootstrapApplication, provideClientHydration, withIncrementalHydration,} from '@angular/platform-browser';...bootstrapApplication(AppComponent, { providers: [provideClientHydration(withIncrementalHydration())]}); Incremental Hydration depends on and enables event replay automatically. If you already have withEventReplay() in your list, you can safely remove",
    "id": "incremental-hydration-*-angular-3"
  },
  {
    "url": "https://angular.dev/guide/incremental-hydration",
    "title": "Incremental Hydration • Angular",
    "chunk": " it after enabling incremental hydration. How does incremental hydration work? Incremental hydration builds on top of full-application hydration, deferrable views, and event replay. With incremental hydration, you can add additional triggers to @defer blocks that define incremental hydration boundaries. Adding a hydrate trigger to a defer block tells Angular that it should load that defer block's dependencies during server-side rendering and render the main template rather than the @placeholder.",
    "id": "incremental-hydration-*-angular-4"
  },
  {
    "url": "https://angular.dev/guide/incremental-hydration",
    "title": "Incremental Hydration • Angular",
    "chunk": " When client-side rendering, the dependencies are still deferred, and the defer block content stays dehydrated until its hydrate trigger fires. That trigger tells the defer block to fetch its dependencies and hydrate the content. Any browser events, specifically those that match listeners registered in your component, that are triggered by the user prior to hydration are queued up and replayed once the hydration process is complete. Controlling hydration of content with triggers You can specify ",
    "id": "incremental-hydration-*-angular-5"
  },
  {
    "url": "https://angular.dev/guide/incremental-hydration",
    "title": "Incremental Hydration • Angular",
    "chunk": "hydrate triggers that control when Angular loads and hydrates deferred content. These are additional triggers that can be used alongside regular @defer triggers. Each @defer block may have multiple hydrate event triggers, separated with a semicolon (;). Angular triggers hydration when any of the triggers fire. There are three types of hydrate triggers: hydrate on, hydrate when, and hydrate never. hydrate on hydrate on specifies a condition for when hydration is triggered for the @defer block. Th",
    "id": "incremental-hydration-*-angular-6"
  },
  {
    "url": "https://angular.dev/guide/incremental-hydration",
    "title": "Incremental Hydration • Angular",
    "chunk": "e available triggers are as follows: Trigger Description hydrate on idle Triggers when the browser is idle. hydrate on viewport Triggers when specified content enters the viewport hydrate on interaction Triggers when the user interacts with specified element hydrate on hover Triggers when the mouse hovers over specified area hydrate on immediate Triggers immediately after non-deferred content has finished rendering hydrate on timer Triggers after a specific duration hydrate on idle The hydrate o",
    "id": "incremental-hydration-*-angular-7"
  },
  {
    "url": "https://angular.dev/guide/incremental-hydration",
    "title": "Incremental Hydration • Angular",
    "chunk": "n idle trigger loads the deferrable view's dependencies and hydrates the content once the browser has reached an idle state, based on requestIdleCallback. @defer (hydrate on idle) { <large-cmp />} @placeholder { <div>Large component placeholder</div>} hydrate on viewport The hydrate on viewport trigger loads the deferrable view's dependencies and hydrates the corresponding page of the app when the specified content enters the viewport using the Intersection Observer API. @defer (hydrate on viewp",
    "id": "incremental-hydration-*-angular-8"
  },
  {
    "url": "https://angular.dev/guide/incremental-hydration",
    "title": "Incremental Hydration • Angular",
    "chunk": "ort) { <large-cmp />} @placeholder { <div>Large component placeholder</div>} hydrate on interaction The hydrate on interaction trigger loads the deferrable view's dependencies and hydrates the content when the user interacts with the specified element through click or keydown events. @defer (hydrate on interaction) { <large-cmp />} @placeholder { <div>Large component placeholder</div>} hydrate on hover The hydrate on hover trigger loads the deferrable view's dependencies and hydrates the content",
    "id": "incremental-hydration-*-angular-9"
  },
  {
    "url": "https://angular.dev/guide/incremental-hydration",
    "title": "Incremental Hydration • Angular",
    "chunk": " when the mouse has hovered over the triggered area through the mouseover and focusin events. @defer (hydrate on hover) { <large-cmp />} @placeholder { <div>Large component placeholder</div>} hydrate on immediate The hydrate on immediate trigger loads the deferrable view's dependencies and hydrates the content immediately. This means that the deferred block loads as soon as all other non-deferred content has finished rendering. @defer (hydrate on immediate) { <large-cmp />} @placeholder { <div>L",
    "id": "incremental-hydration-*-angular-10"
  },
  {
    "url": "https://angular.dev/guide/incremental-hydration",
    "title": "Incremental Hydration • Angular",
    "chunk": "arge component placeholder</div>} hydrate on timer The hydrate on timer trigger loads the deferrable view's dependencies and hydrates the content after a specified duration. @defer (hydrate on timer(500ms)) { <large-cmp />} @placeholder { <div>Large component placeholder</div>} The duration parameter must be specified in milliseconds (ms) or seconds (s). hydrate when The hydrate when trigger accepts a custom conditional expression and loads the deferrable view's dependencies and hydrates the con",
    "id": "incremental-hydration-*-angular-11"
  },
  {
    "url": "https://angular.dev/guide/incremental-hydration",
    "title": "Incremental Hydration • Angular",
    "chunk": "tent when the condition becomes truthy. @defer (hydrate when condition) { <large-cmp />} @placeholder { <div>Large component placeholder</div>} NOTE: hydrate when conditions only trigger when they are the top-most dehydrated @defer block. The condition provided for the trigger is specified in the parent component, which needs to exist before it can be triggered. If the parent block is dehydrated, that expression will not yet be resolvable by Angular. hydrate never The hydrate never allows users ",
    "id": "incremental-hydration-*-angular-12"
  },
  {
    "url": "https://angular.dev/guide/incremental-hydration",
    "title": "Incremental Hydration • Angular",
    "chunk": "to specify that the content in the defer block should remain dehydrated indefinitely, effectively becoming static content. Note that this applies to the initial render only. During a subsequent client-side render, a @defer block with hydrate never would still fetch dependencies, as hydration only applies to initial load of server-side rendered content. In the example below, subsequent client-side renders would load the @defer block dependencies on viewport. @defer (on viewport; hydrate never) { ",
    "id": "incremental-hydration-*-angular-13"
  },
  {
    "url": "https://angular.dev/guide/incremental-hydration",
    "title": "Incremental Hydration • Angular",
    "chunk": "<large-cmp />} @placeholder { <div>Large component placeholder</div>} NOTE: Using hydrate never prevents hydration of the entire nested subtree of a given @defer block. No other hydrate triggers fire for content nested underneath that block. Hydrate triggers alongside regular triggers Hydrate triggers are additional triggers that are used alongside regular triggers on a @defer block. Hydration is an initial load optimization, and that means hydrate triggers only apply to that initial load. Any s",
    "id": "incremental-hydration-*-angular-14"
  },
  {
    "url": "https://angular.dev/guide/incremental-hydration",
    "title": "Incremental Hydration • Angular",
    "chunk": "ubsequent client side render will still use the regular trigger. @defer (on idle; hydrate on interaction) { <example-cmp />} @placeholder{ <div>Example Placeholder</div>} In this example, on the initial load, the hydrate on interaction applies. Hydration will be triggered on interaction with the <example-cmp /> component. On any subsequent page load that is client-side rendered, for example when a user clicks a routerLink that loads a page with this component, the on idle will apply. How does in",
    "id": "incremental-hydration-*-angular-15"
  },
  {
    "url": "https://angular.dev/guide/incremental-hydration",
    "title": "Incremental Hydration • Angular",
    "chunk": "cremental hydration work with nested @defer blocks? Angular's component and dependency system is hierarchical, which means hydrating any component requires all of its parents also be hydrated. So if hydration is triggered for a child @defer block of a nested set of dehydrated @defer blocks, hydration is triggered from the top-most dehydrated @defer block down to the triggered child and fire in that order. @defer (hydrate on interaction) { <parent-block-cmp /> @defer (hydrate on hover) { <child-b",
    "id": "incremental-hydration-*-angular-16"
  },
  {
    "url": "https://angular.dev/guide/incremental-hydration",
    "title": "Incremental Hydration • Angular",
    "chunk": "lock-cmp /> } @placeholder { <div>Child placeholder</div> }} @placeholder{ <div>Parent Placeholder</div>} In the above example, hovering over the nested @defer block triggers hydration. The parent @defer block with the <parent-block-cmp /> hydrates first, then the child @defer block with <child-block-cmp /> hydrates after. Constraints Incremental hydration has the same constraints as full-application hydration, including limits on direct DOM manipulation and requiring valid HTML structure. Visit",
    "id": "incremental-hydration-*-angular-17"
  },
  {
    "url": "https://angular.dev/guide/incremental-hydration",
    "title": "Incremental Hydration • Angular",
    "chunk": " the Hydration guide constraints section for more details. Do I still need to specify @placeholder blocks? Yes. @placeholder block content is not used for incremental hydration, but a @placeholder is still necessary for subsequent client-side rendering cases. If your content was not on the route that was part of the initial load, then any navigation to the route that has your @defer block content renders like a regular @defer block. So the @placeholder is rendered in those client-side rendering ",
    "id": "incremental-hydration-*-angular-18"
  },
  {
    "url": "https://angular.dev/guide/incremental-hydration",
    "title": "Incremental Hydration • Angular",
    "chunk": "cases. Social MediaBlogX (formerly Twitter)BlueskyYouTube Discord GitHub Stack Overflow Community Contribute Code of Conduct Report Issues Google's DevLibrary Angular Google Developer Experts ResourcesPress KitRoadmapLanguages简体中文版正體中文版日本語版한국어 Ελληνικά Super-powered by Google ©2010-2025. Code licensed under an MIT-style License . Documentation licensed under CC BY 4.0 .",
    "id": "incremental-hydration-*-angular-19"
  },
  {
    "url": "https://angular.dev/tools/cli",
    "title": "Angular CLI • Overview • Angular",
    "chunk": "Developer ToolsAngular CLI The Angular CLI The Angular CLI is a command-line interface tool which allows you to scaffold, develop, test, deploy, and maintain Angular applications directly from a command shell. Angular CLI is published on npm as the @angular/cli package and includes a binary named ng. Commands invoking ng are using the Angular CLI. Try Angular without local setup If you are new to Angular, you might want to start with Try it now!, which introduces the essentials of Angular in the",
    "id": "angular-cli-*-overview-*-angular-0"
  },
  {
    "url": "https://angular.dev/tools/cli",
    "title": "Angular CLI • Overview • Angular",
    "chunk": " context of a ready-made basic online store app for you to examine and modify. This standalone tutorial takes advantage of the interactive StackBlitz environment for online development. You don't need to set up your local environment until you're ready. Getting Started Install Angular CLI to create and build your first app. Get Started Command Reference Discover CLI commands to make you more productive with Angular. Learn More Schematics Create and run schematics to generate and modify source fi",
    "id": "angular-cli-*-overview-*-angular-1"
  },
  {
    "url": "https://angular.dev/tools/cli",
    "title": "Angular CLI • Overview • Angular",
    "chunk": "les in your application automatically. Learn More Builders Create and run builders to perform complex transformations from your source code to generated build outputs. Learn More On this pagearrow_upward_alt Back to the top CLI command-language syntax Angular CLI roughly follows Unix/POSIX conventions for option syntax. Boolean options Boolean options have two forms: --this-option sets the flag to true, --no-this-option sets it to false. You can also use --this-option=false or --this-option=true",
    "id": "angular-cli-*-overview-*-angular-2"
  },
  {
    "url": "https://angular.dev/tools/cli",
    "title": "Angular CLI • Overview • Angular",
    "chunk": ". If neither option is supplied, the flag remains in its default state, as listed in the reference documentation. Array options Array options can be provided in two forms: --option value1 value2 or --option value1 --option value2. Key/value options Some options like --define expect an array of key=value pairs as their values. Just like array options, key/value options can be provided in two forms: --define 'KEY_1=\"value1\"' KEY_2=true or --define 'KEY_1=\"value1\"' --define KEY_2=true. Relative pat",
    "id": "angular-cli-*-overview-*-angular-3"
  },
  {
    "url": "https://angular.dev/tools/cli",
    "title": "Angular CLI • Overview • Angular",
    "chunk": "hs Options that specify files can be given as absolute paths, or as paths relative to the current working directory, which is generally either the workspace or project root. Social MediaBlogX (formerly Twitter)BlueskyYouTube Discord GitHub Stack Overflow Community Contribute Code of Conduct Report Issues Google's DevLibrary Angular Google Developer Experts ResourcesPress KitRoadmapLanguages简体中文版正體中文版日本語版한국어 Ελληνικά Super-powered by Google ©2010-2025. Code licensed under an MIT-style License . D",
    "id": "angular-cli-*-overview-*-angular-4"
  },
  {
    "url": "https://angular.dev/tools/cli",
    "title": "Angular CLI • Overview • Angular",
    "chunk": "ocumentation licensed under CC BY 4.0 .",
    "id": "angular-cli-*-overview-*-angular-5"
  },
  {
    "url": "https://angular.dev/guide/testing",
    "title": "Testing • Overview • Angular",
    "chunk": "In-depth GuidesTesting Testing Testing your Angular application helps you check that your application is working as you expect. On this pagearrow_upward_alt Back to the top Set up testing The Angular CLI downloads and installs everything you need to test an Angular application with Jasmine testing framework. The project you create with the CLI is immediately ready to test. Just run the ng test CLI command: ng test The ng test command builds the application in watch mode, and launches the Karma t",
    "id": "testing-*-overview-*-angular-0"
  },
  {
    "url": "https://angular.dev/guide/testing",
    "title": "Testing • Overview • Angular",
    "chunk": "est runner. The console output looks like below: 02 11 2022 09:08:28.605:INFO [karma-server]: Karma v6.4.1 server started at http://localhost:9876/02 11 2022 09:08:28.607:INFO [launcher]: Launching browsers Chrome with concurrency unlimited02 11 2022 09:08:28.620:INFO [launcher]: Starting browser Chrome02 11 2022 09:08:31.312:INFO [Chrome]: Connected on socket -LaEYvD2R7MdcS0-AAAB with id 31534482Chrome: Executed 3 of 3 SUCCESS (0.193 secs / 0.172 secs)TOTAL: 3 SUCCESS The last line of the log s",
    "id": "testing-*-overview-*-angular-1"
  },
  {
    "url": "https://angular.dev/guide/testing",
    "title": "Testing • Overview • Angular",
    "chunk": "hows that Karma ran three tests that all passed. The test output is displayed in the browser using Karma Jasmine HTML Reporter. Click on a test row to re-run just that test or click on a description to re-run the tests in the selected test group (\"test suite\"). Meanwhile, the ng test command is watching for changes. To see this in action, make a small change to app.component.ts and save. The tests run again, the browser refreshes, and the new test results appear. Configuration The Angular CLI ta",
    "id": "testing-*-overview-*-angular-2"
  },
  {
    "url": "https://angular.dev/guide/testing",
    "title": "Testing • Overview • Angular",
    "chunk": "kes care of Jasmine and Karma configuration for you. It constructs the full configuration in memory, based on options specified in the angular.json file. If you want to customize Karma, you can create a karma.conf.js by running the following command: ng generate config karma HELPFUL: Read more about Karma configuration in the Karma configuration guide. Other test frameworks You can also unit test an Angular application with other testing libraries and test runners. Each library and runner has it",
    "id": "testing-*-overview-*-angular-3"
  },
  {
    "url": "https://angular.dev/guide/testing",
    "title": "Testing • Overview • Angular",
    "chunk": "s own distinctive installation procedures, configuration, and syntax. Test file name and location Inside the src/app folder the Angular CLI generated a test file for the AppComponent named app.component.spec.ts. IMPORTANT: The test file extension must be .spec.ts so that tooling can identify it as a file with tests (also known as a spec file). The app.component.ts and app.component.spec.ts files are siblings in the same folder. The root file names (app.component) are the same for both files. Ado",
    "id": "testing-*-overview-*-angular-4"
  },
  {
    "url": "https://angular.dev/guide/testing",
    "title": "Testing • Overview • Angular",
    "chunk": "pt these two conventions in your own projects for every kind of test file. Place your spec file next to the file it tests It's a good idea to put unit test spec files in the same folder as the application source code files that they test: Such tests are painless to find You see at a glance if a part of your application lacks tests Nearby tests can reveal how a part works in context When you move the source (inevitable), you remember to move the test When you rename the source file (inevitable), ",
    "id": "testing-*-overview-*-angular-5"
  },
  {
    "url": "https://angular.dev/guide/testing",
    "title": "Testing • Overview • Angular",
    "chunk": "you remember to rename the test file Place your spec files in a test folder Application integration specs can test the interactions of multiple parts spread across folders and modules. They don't really belong to any part in particular, so they don't have a natural home next to any one file. It's often better to create an appropriate folder for them in the tests directory. Of course specs that test the test helpers belong in the test folder, next to their corresponding helper files. Testing in c",
    "id": "testing-*-overview-*-angular-6"
  },
  {
    "url": "https://angular.dev/guide/testing",
    "title": "Testing • Overview • Angular",
    "chunk": "ontinuous integration One of the best ways to keep your project bug-free is through a test suite, but you might forget to run tests all the time. Continuous integration (CI) servers let you set up your project repository so that your tests run on every commit and pull request. To test your Angular CLI application in Continuous integration (CI) run the following command: ng test --no-watch --no-progress --browsers=ChromeHeadless More information on testing After you've set up your application for",
    "id": "testing-*-overview-*-angular-7"
  },
  {
    "url": "https://angular.dev/guide/testing",
    "title": "Testing • Overview • Angular",
    "chunk": " testing, you might find the following testing guides useful. Details Code coverage How much of your app your tests are covering and how to specify required amounts. Testing services How to test the services your application uses. Basics of testing components Basics of testing Angular components. Component testing scenarios Various kinds of component testing scenarios and use cases. Testing attribute directives How to test your attribute directives. Testing pipes How to test pipes. Debugging tes",
    "id": "testing-*-overview-*-angular-8"
  },
  {
    "url": "https://angular.dev/guide/testing",
    "title": "Testing • Overview • Angular",
    "chunk": "ts Common testing bugs. Testing utility APIs Angular testing features. Social MediaBlogX (formerly Twitter)BlueskyYouTube Discord GitHub Stack Overflow Community Contribute Code of Conduct Report Issues Google's DevLibrary Angular Google Developer Experts ResourcesPress KitRoadmapLanguages简体中文版正體中文版日本語版한국어 Ελληνικά Super-powered by Google ©2010-2025. Code licensed under an MIT-style License . Documentation licensed under CC BY 4.0 .",
    "id": "testing-*-overview-*-angular-9"
  },
  {
    "url": "https://angular.dev/guide/testing/code-coverage",
    "title": "Code coverage • Angular",
    "chunk": "In-depth GuidesTesting Find out how much code you're testing The Angular CLI can run unit tests and create code coverage reports. Code coverage reports show you any parts of your code base that might not be properly tested by your unit tests. To generate a coverage report run the following command in the root of your project. ng test --no-watch --code-coverage When the tests are complete, the command creates a new /coverage directory in the project. Open the index.html file to see a report with ",
    "id": "code-coverage-*-angular-0"
  },
  {
    "url": "https://angular.dev/guide/testing/code-coverage",
    "title": "Code coverage • Angular",
    "chunk": "your source code and code coverage values. If you want to create code-coverage reports every time you test, set the following option in the Angular CLI configuration file, angular.json: \"test\": { \"options\": { \"codeCoverage\": true }} On this pagearrow_upward_alt Back to the top Code coverage enforcement The code coverage percentages let you estimate how much of your code is tested. If your team decides on a set minimum amount to be unit tested, enforce this minimum with the Angular CLI. For examp",
    "id": "code-coverage-*-angular-1"
  },
  {
    "url": "https://angular.dev/guide/testing/code-coverage",
    "title": "Code coverage • Angular",
    "chunk": "le, suppose you want the code base to have a minimum of 80% code coverage. To enable this, open the Karma test platform configuration file, karma.conf.js, and add the check property in the coverageReporter: key. coverageReporter: { dir: require('path').join(__dirname, './coverage/<project-name>'), subdir: '.', reporters: [ { type: 'html' }, { type: 'text-summary' } ], check: { global: { statements: 80, branches: 80, functions: 80, lines: 80 } }} HELPFUL: Read more about creating and fine tuning ",
    "id": "code-coverage-*-angular-2"
  },
  {
    "url": "https://angular.dev/guide/testing/code-coverage",
    "title": "Code coverage • Angular",
    "chunk": "Karma configuration in the testing guide. The check property causes the tool to enforce a minimum of 80% code coverage when the unit tests are run in the project. Read more on coverage configuration options in the karma coverage documentation. Social MediaBlogX (formerly Twitter)BlueskyYouTube Discord GitHub Stack Overflow Community Contribute Code of Conduct Report Issues Google's DevLibrary Angular Google Developer Experts ResourcesPress KitRoadmapLanguages简体中文版正體中文版日本語版한국어 Ελληνικά Super-powe",
    "id": "code-coverage-*-angular-3"
  },
  {
    "url": "https://angular.dev/guide/testing/code-coverage",
    "title": "Code coverage • Angular",
    "chunk": "red by Google ©2010-2025. Code licensed under an MIT-style License . Documentation licensed under CC BY 4.0 .",
    "id": "code-coverage-*-angular-4"
  },
  {
    "url": "https://angular.dev/guide/testing/services",
    "title": "Testing services • Angular",
    "chunk": "In-depth GuidesTesting Testing services To check that your services are working as you intend, you can write tests specifically for them. Services are often the smoothest files to unit test. Here are some synchronous and asynchronous unit tests of the ValueService written without assistance from Angular testing utilities. app/demo/demo.spec.ts import {LightswitchComponent, MasterService, ValueService, ReversePipe} from './demo';///////// Fakes /////////export class FakeValueService extends Value",
    "id": "testing-services-*-angular-0"
  },
  {
    "url": "https://angular.dev/guide/testing/services",
    "title": "Testing services • Angular",
    "chunk": "Service { override value = 'faked service value';}////////////////////////describe('demo (no TestBed):', () => { // Straight Jasmine testing without Angular's testing support describe('ValueService', () => { let service: ValueService; beforeEach(() => { service = new ValueService(); }); it('#getValue should return real value', () => { expect(service.getValue()).toBe('real value'); }); it('#getObservableValue should return value from observable', (done: DoneFn) => { service.getObservableValue().s",
    "id": "testing-services-*-angular-1"
  },
  {
    "url": "https://angular.dev/guide/testing/services",
    "title": "Testing services • Angular",
    "chunk": "ubscribe((value) => { expect(value).toBe('observable value'); done(); }); }); it('#getPromiseValue should return value from a promise', (done: DoneFn) => { service.getPromiseValue().then((value) => { expect(value).toBe('promise value'); done(); }); }); }); // MasterService requires injection of a ValueService describe('MasterService without Angular testing support', () => { let masterService: MasterService; it('#getValue should return real value from the real service', () => { masterService = ne",
    "id": "testing-services-*-angular-2"
  },
  {
    "url": "https://angular.dev/guide/testing/services",
    "title": "Testing services • Angular",
    "chunk": "w MasterService(new ValueService()); expect(masterService.getValue()).toBe('real value'); }); it('#getValue should return faked value from a fakeService', () => { masterService = new MasterService(new FakeValueService()); expect(masterService.getValue()).toBe('faked service value'); }); it('#getValue should return faked value from a fake object', () => { const fake = {getValue: () => 'fake value'}; masterService = new MasterService(fake as ValueService); expect(masterService.getValue()).toBe('fa",
    "id": "testing-services-*-angular-3"
  },
  {
    "url": "https://angular.dev/guide/testing/services",
    "title": "Testing services • Angular",
    "chunk": "ke value'); }); it('#getValue should return stubbed value from a spy', () => { // create `getValue` spy on an object representing the ValueService const valueServiceSpy = jasmine.createSpyObj('ValueService', ['getValue']); // set the value to return when the `getValue` spy is called. const stubValue = 'stub value'; valueServiceSpy.getValue.and.returnValue(stubValue); masterService = new MasterService(valueServiceSpy); expect(masterService.getValue()).withContext('service returned stub value').to",
    "id": "testing-services-*-angular-4"
  },
  {
    "url": "https://angular.dev/guide/testing/services",
    "title": "Testing services • Angular",
    "chunk": "Be(stubValue); expect(valueServiceSpy.getValue.calls.count()) .withContext('spy method was called once') .toBe(1); expect(valueServiceSpy.getValue.calls.mostRecent().returnValue).toBe(stubValue); }); }); describe('MasterService (no beforeEach)', () => { it('#getValue should return stubbed value from a spy', () => { const {masterService, stubValue, valueServiceSpy} = setup(); expect(masterService.getValue()).withContext('service returned stub value').toBe(stubValue); expect(valueServiceSpy.getVal",
    "id": "testing-services-*-angular-5"
  },
  {
    "url": "https://angular.dev/guide/testing/services",
    "title": "Testing services • Angular",
    "chunk": "ue.calls.count()) .withContext('spy method was called once') .toBe(1); expect(valueServiceSpy.getValue.calls.mostRecent().returnValue).toBe(stubValue); }); function setup() { const valueServiceSpy = jasmine.createSpyObj('ValueService', ['getValue']); const stubValue = 'stub value'; const masterService = new MasterService(valueServiceSpy); valueServiceSpy.getValue.and.returnValue(stubValue); return {masterService, stubValue, valueServiceSpy}; } }); describe('ReversePipe', () => { let pipe: Revers",
    "id": "testing-services-*-angular-6"
  },
  {
    "url": "https://angular.dev/guide/testing/services",
    "title": "Testing services • Angular",
    "chunk": "ePipe; beforeEach(() => { pipe = new ReversePipe(); }); it('transforms \"abc\" to \"cba\"', () => { expect(pipe.transform('abc')).toBe('cba'); }); it('no change to palindrome: \"able was I ere I saw elba\"', () => { const palindrome = 'able was I ere I saw elba'; expect(pipe.transform(palindrome)).toBe(palindrome); }); }); describe('LightswitchComp', () => { it('#clicked() should toggle #isOn', () => { const comp = new LightswitchComponent(); expect(comp.isOn).withContext('off at first').toBe(false); ",
    "id": "testing-services-*-angular-7"
  },
  {
    "url": "https://angular.dev/guide/testing/services",
    "title": "Testing services • Angular",
    "chunk": "comp.clicked(); expect(comp.isOn).withContext('on after click').toBe(true); comp.clicked(); expect(comp.isOn).withContext('off after second click').toBe(false); }); it('#clicked() should set #message to \"is on\"', () => { const comp = new LightswitchComponent(); expect(comp.message) .withContext('off at first') .toMatch(/is off/i); comp.clicked(); expect(comp.message).withContext('on after clicked').toMatch(/is on/i); }); });}); On this pagearrow_upward_alt Back to the top Services with dependenc",
    "id": "testing-services-*-angular-8"
  },
  {
    "url": "https://angular.dev/guide/testing/services",
    "title": "Testing services • Angular",
    "chunk": "ies Services often depend on other services that Angular injects into the constructor. In many cases, you can create and inject these dependencies by hand while calling the service's constructor. The MasterService is a simple example: app/demo/demo.ts import { Component, ContentChildren, Directive, EventEmitter, HostBinding, HostListener, inject, Injectable, input, output, OnChanges, OnDestroy, OnInit, Pipe, PipeTransform, SimpleChanges, signal,} from '@angular/core';import {FormsModule} from '@",
    "id": "testing-services-*-angular-9"
  },
  {
    "url": "https://angular.dev/guide/testing/services",
    "title": "Testing services • Angular",
    "chunk": "angular/forms';import {of} from 'rxjs';import {delay} from 'rxjs/operators';import {sharedImports} from '../shared/shared';////////// The App: Services and Components for the tests. //////////////export interface Hero { name: string;}////////// Services ///////////////@Injectable()export class ValueService { value = 'real value'; getValue() { return this.value; } setValue(value: string) { this.value = value; } getObservableValue() { return of('observable value'); } getPromiseValue() { return Pro",
    "id": "testing-services-*-angular-10"
  },
  {
    "url": "https://angular.dev/guide/testing/services",
    "title": "Testing services • Angular",
    "chunk": "mise.resolve('promise value'); } getObservableDelayValue() { return of('observable delay value').pipe(delay(10)); }}@Injectable()export class MasterService { public valueService = inject(ValueService); getValue() { return this.valueService.getValue(); }}/////////// Pipe /////////////////* * Reverse the input string. */@Pipe({name: 'reverse'})export class ReversePipe implements PipeTransform { transform(s: string) { let r = ''; for (let i = s.length; i; ) { r += s[--i]; } return r; }}////////////",
    "id": "testing-services-*-angular-11"
  },
  {
    "url": "https://angular.dev/guide/testing/services",
    "title": "Testing services • Angular",
    "chunk": " Components /////////////@Component({ selector: 'bank-account', template: ` Bank Name: {{ bank() }} Account Id: {{ id() }} `,})export class BankAccountComponent { bank = input(''); id = input('', {alias: 'account'});}/** A component with attributes, styles, classes, and property setting */@Component({ selector: 'bank-account-parent', template: ` <bank-account bank=\"RBC\" account=\"4747\" [style.width.px]=\"width\" [style.color]=\"color\" [class.closed]=\"isClosed\" [class.open]=\"!isClosed\" /> `, imports:",
    "id": "testing-services-*-angular-12"
  },
  {
    "url": "https://angular.dev/guide/testing/services",
    "title": "Testing services • Angular",
    "chunk": " [BankAccountComponent],})export class BankAccountParentComponent { width = 200; color = 'red'; isClosed = true;}@Component({ selector: 'lightswitch-comp', template: ` <button type=\"button\" (click)=\"clicked()\">Click me!</button> <span>{{ message }}</span>`,})export class LightswitchComponent { isOn = false; clicked() { this.isOn = !this.isOn; } get message() { return `The light is ${this.isOn ? 'On' : 'Off'}`; }}@Component({ selector: 'child-1', template: '<span>Child-1({{text()}})</span>',})exp",
    "id": "testing-services-*-angular-13"
  },
  {
    "url": "https://angular.dev/guide/testing/services",
    "title": "Testing services • Angular",
    "chunk": "ort class Child1Component { text = input('Original');}@Component({ selector: 'child-2', template: '<div>Child-2({{text()}})</div>',})export class Child2Component { text = input('');}@Component({ selector: 'child-3', template: '<div>Child-3({{text}})</div>',})export class Child3Component { text = input('');}@Component({ selector: 'input-comp', template: '<input [(ngModel)]=\"name\">', imports: [FormsModule],})export class InputComponent { name = signal('John');}@Component({ selector: 'input-value-c",
    "id": "testing-services-*-angular-14"
  },
  {
    "url": "https://angular.dev/guide/testing/services",
    "title": "Testing services • Angular",
    "chunk": "omp', template: ` Name: <input [value]=\"name\" /> {{ name }} `,})export class InputValueBinderComponent { name = 'Sally'; // initial value}@Component({ selector: 'parent-comp', imports: [Child1Component], template: 'Parent(<child-1></child-1>)',})export class ParentComponent {}@Component({ selector: 'io-comp', template: '<button type=\"button\" class=\"hero\" (click)=\"click()\">Original {{hero().name}}</button>',})export class IoComponent { hero = input.required<Hero>(); selected = output<Hero>(); cli",
    "id": "testing-services-*-angular-15"
  },
  {
    "url": "https://angular.dev/guide/testing/services",
    "title": "Testing services • Angular",
    "chunk": "ck() { this.selected.emit(this.hero); }}@Component({ selector: 'io-parent-comp', template: ` @if (!selectedHero) { <p><i>Click to select a hero</i></p> } @if (selectedHero) { <p>The selected hero is {{ selectedHero.name }}</p> } @for (hero of heroes; track hero) { <io-comp [hero]=\"hero\" (selected)=\"onSelect($event)\"> </io-comp> } `, imports: [IoComponent, sharedImports],})export class IoParentComponent { heroes: Hero[] = [{name: 'Bob'}, {name: 'Carol'}, {name: 'Ted'}, {name: 'Alice'}]; selectedH",
    "id": "testing-services-*-angular-16"
  },
  {
    "url": "https://angular.dev/guide/testing/services",
    "title": "Testing services • Angular",
    "chunk": "ero!: Hero; onSelect(hero: Hero) { this.selectedHero = hero; }}@Component({ selector: 'my-if-comp', template: 'MyIf(@if (showMore) {<span>More</span>})', imports: [sharedImports],})export class MyIfComponent { showMore = false;}@Component({ selector: 'my-service-comp', template: 'injected value: {{valueService.value}}', providers: [ValueService],})export class TestProvidersComponent { public valueService = inject(ValueService);}@Component({ selector: 'my-service-comp', template: 'injected value:",
    "id": "testing-services-*-angular-17"
  },
  {
    "url": "https://angular.dev/guide/testing/services",
    "title": "Testing services • Angular",
    "chunk": " {{valueService.value}}', viewProviders: [ValueService],})export class TestViewProvidersComponent { public valueService = inject(ValueService);}@Component({ selector: 'external-template-comp', templateUrl: './demo-external-template.html',})export class ExternalTemplateComponent { private service = inject(ValueService, {optional: true}); serviceValue = this.service?.getValue() ?? '';}@Component({ selector: 'comp-w-ext-comp', imports: [ExternalTemplateComponent], template: ` <h3>comp-w-ext-comp</h",
    "id": "testing-services-*-angular-18"
  },
  {
    "url": "https://angular.dev/guide/testing/services",
    "title": "Testing services • Angular",
    "chunk": "3> <external-template-comp></external-template-comp> `,})export class InnerCompWithExternalTemplateComponent {}@Component({selector: 'needs-content', template: '<ng-content></ng-content>'})export class NeedsContentComponent { // children with #content local variable @ContentChildren('content') children: any;}@Component({ selector: 'reverse-pipe-comp', template: ` <input [(ngModel)]=\"text\" /> <span>{{ text | reverse }}</span> `, imports: [ReversePipe, FormsModule],})export class ReversePipeCompon",
    "id": "testing-services-*-angular-19"
  },
  {
    "url": "https://angular.dev/guide/testing/services",
    "title": "Testing services • Angular",
    "chunk": "ent { text = 'my dog has fleas.';}@Component({ imports: [NeedsContentComponent], template: '<div>Replace Me</div>',})export class ShellComponent {}@Component({ selector: 'demo-comp', template: ` <h1>Specs Demo</h1> <my-if-parent-comp></my-if-parent-comp> <hr> <h3>Input/Output Component</h3> <io-parent-comp></io-parent-comp> <hr> <h3>External Template Component</h3> <external-template-comp></external-template-comp> <hr> <h3>Component With External Template Component</h3> <comp-w-ext-comp></comp-w",
    "id": "testing-services-*-angular-20"
  },
  {
    "url": "https://angular.dev/guide/testing/services",
    "title": "Testing services • Angular",
    "chunk": "-ext-comp> <hr> <h3>Reverse Pipe</h3> <reverse-pipe-comp></reverse-pipe-comp> <hr> <h3>InputValueBinder Directive</h3> <input-value-comp></input-value-comp> <hr> <h3>Button Component</h3> <lightswitch-comp></lightswitch-comp> <hr> <h3>Needs Content</h3> <needs-content #nc> <child-1 #content text=\"My\"></child-1> <child-2 #content text=\"dog\"></child-2> <child-2 text=\"has\"></child-2> <child-3 #content text=\"fleas\"></child-3> <div #content>!</div> </needs-content> `, imports: [ Child1Component, Chil",
    "id": "testing-services-*-angular-21"
  },
  {
    "url": "https://angular.dev/guide/testing/services",
    "title": "Testing services • Angular",
    "chunk": "d2Component, Child3Component, ExternalTemplateComponent, InnerCompWithExternalTemplateComponent, InputValueBinderComponent, IoParentComponent, LightswitchComponent, NeedsContentComponent, ReversePipeComponent, ],})export class DemoComponent {}//////// Aggregations ////////////export const demoProviders = [MasterService, ValueService]; MasterService delegates its only method, getValue, to the injected ValueService. Here are several ways to test it. app/demo/demo.spec.ts import {LightswitchCompone",
    "id": "testing-services-*-angular-22"
  },
  {
    "url": "https://angular.dev/guide/testing/services",
    "title": "Testing services • Angular",
    "chunk": "nt, MasterService, ValueService, ReversePipe} from './demo';///////// Fakes /////////export class FakeValueService extends ValueService { override value = 'faked service value';}////////////////////////describe('demo (no TestBed):', () => { // Straight Jasmine testing without Angular's testing support describe('ValueService', () => { let service: ValueService; beforeEach(() => { service = new ValueService(); }); it('#getValue should return real value', () => { expect(service.getValue()).toBe('re",
    "id": "testing-services-*-angular-23"
  },
  {
    "url": "https://angular.dev/guide/testing/services",
    "title": "Testing services • Angular",
    "chunk": "al value'); }); it('#getObservableValue should return value from observable', (done: DoneFn) => { service.getObservableValue().subscribe((value) => { expect(value).toBe('observable value'); done(); }); }); it('#getPromiseValue should return value from a promise', (done: DoneFn) => { service.getPromiseValue().then((value) => { expect(value).toBe('promise value'); done(); }); }); }); // MasterService requires injection of a ValueService describe('MasterService without Angular testing support', () ",
    "id": "testing-services-*-angular-24"
  },
  {
    "url": "https://angular.dev/guide/testing/services",
    "title": "Testing services • Angular",
    "chunk": "=> { let masterService: MasterService; it('#getValue should return real value from the real service', () => { masterService = new MasterService(new ValueService()); expect(masterService.getValue()).toBe('real value'); }); it('#getValue should return faked value from a fakeService', () => { masterService = new MasterService(new FakeValueService()); expect(masterService.getValue()).toBe('faked service value'); }); it('#getValue should return faked value from a fake object', () => { const fake = {g",
    "id": "testing-services-*-angular-25"
  },
  {
    "url": "https://angular.dev/guide/testing/services",
    "title": "Testing services • Angular",
    "chunk": "etValue: () => 'fake value'}; masterService = new MasterService(fake as ValueService); expect(masterService.getValue()).toBe('fake value'); }); it('#getValue should return stubbed value from a spy', () => { // create `getValue` spy on an object representing the ValueService const valueServiceSpy = jasmine.createSpyObj('ValueService', ['getValue']); // set the value to return when the `getValue` spy is called. const stubValue = 'stub value'; valueServiceSpy.getValue.and.returnValue(stubValue); ma",
    "id": "testing-services-*-angular-26"
  },
  {
    "url": "https://angular.dev/guide/testing/services",
    "title": "Testing services • Angular",
    "chunk": "sterService = new MasterService(valueServiceSpy); expect(masterService.getValue()).withContext('service returned stub value').toBe(stubValue); expect(valueServiceSpy.getValue.calls.count()) .withContext('spy method was called once') .toBe(1); expect(valueServiceSpy.getValue.calls.mostRecent().returnValue).toBe(stubValue); }); }); describe('MasterService (no beforeEach)', () => { it('#getValue should return stubbed value from a spy', () => { const {masterService, stubValue, valueServiceSpy} = set",
    "id": "testing-services-*-angular-27"
  },
  {
    "url": "https://angular.dev/guide/testing/services",
    "title": "Testing services • Angular",
    "chunk": "up(); expect(masterService.getValue()).withContext('service returned stub value').toBe(stubValue); expect(valueServiceSpy.getValue.calls.count()) .withContext('spy method was called once') .toBe(1); expect(valueServiceSpy.getValue.calls.mostRecent().returnValue).toBe(stubValue); }); function setup() { const valueServiceSpy = jasmine.createSpyObj('ValueService', ['getValue']); const stubValue = 'stub value'; const masterService = new MasterService(valueServiceSpy); valueServiceSpy.getValue.and.re",
    "id": "testing-services-*-angular-28"
  },
  {
    "url": "https://angular.dev/guide/testing/services",
    "title": "Testing services • Angular",
    "chunk": "turnValue(stubValue); return {masterService, stubValue, valueServiceSpy}; } }); describe('ReversePipe', () => { let pipe: ReversePipe; beforeEach(() => { pipe = new ReversePipe(); }); it('transforms \"abc\" to \"cba\"', () => { expect(pipe.transform('abc')).toBe('cba'); }); it('no change to palindrome: \"able was I ere I saw elba\"', () => { const palindrome = 'able was I ere I saw elba'; expect(pipe.transform(palindrome)).toBe(palindrome); }); }); describe('LightswitchComp', () => { it('#clicked() sh",
    "id": "testing-services-*-angular-29"
  },
  {
    "url": "https://angular.dev/guide/testing/services",
    "title": "Testing services • Angular",
    "chunk": "ould toggle #isOn', () => { const comp = new LightswitchComponent(); expect(comp.isOn).withContext('off at first').toBe(false); comp.clicked(); expect(comp.isOn).withContext('on after click').toBe(true); comp.clicked(); expect(comp.isOn).withContext('off after second click').toBe(false); }); it('#clicked() should set #message to \"is on\"', () => { const comp = new LightswitchComponent(); expect(comp.message) .withContext('off at first') .toMatch(/is off/i); comp.clicked(); expect(comp.message).wi",
    "id": "testing-services-*-angular-30"
  },
  {
    "url": "https://angular.dev/guide/testing/services",
    "title": "Testing services • Angular",
    "chunk": "thContext('on after clicked').toMatch(/is on/i); }); });}); The first test creates a ValueService with new and passes it to the MasterService constructor. However, injecting the real service rarely works well as most dependent services are difficult to create and control. Instead, mock the dependency, use a dummy value, or create a spy on the pertinent service method. HELPFUL: Prefer spies as they are usually the best way to mock services. These standard testing techniques are great for unit tes",
    "id": "testing-services-*-angular-31"
  },
  {
    "url": "https://angular.dev/guide/testing/services",
    "title": "Testing services • Angular",
    "chunk": "ting services in isolation. However, you almost always inject services into application classes using Angular dependency injection and you should have tests that reflect that usage pattern. Angular testing utilities make it straightforward to investigate how injected services behave. Testing services with the TestBed Your application relies on Angular dependency injection (DI) to create services. When a service has a dependent service, DI finds or creates that dependent service. And if that depe",
    "id": "testing-services-*-angular-32"
  },
  {
    "url": "https://angular.dev/guide/testing/services",
    "title": "Testing services • Angular",
    "chunk": "ndent service has its own dependencies, DI finds-or-creates them as well. As a service consumer, you don't worry about any of this. You don't worry about the order of constructor arguments or how they're created. As a service tester, you must at least think about the first level of service dependencies but you can let Angular DI do the service creation and deal with constructor argument order when you use the TestBed testing utility to provide and create services. Angular TestBed The TestBed is ",
    "id": "testing-services-*-angular-33"
  },
  {
    "url": "https://angular.dev/guide/testing/services",
    "title": "Testing services • Angular",
    "chunk": "the most important of the Angular testing utilities. The TestBed creates a dynamically-constructed Angular test module that emulates an Angular @NgModule. The TestBed.configureTestingModule() method takes a metadata object that can have most of the properties of an @NgModule. To test a service, you set the providers metadata property with an array of the services that you'll test or mock. app/demo/demo.testbed.spec.ts (provide ValueService in beforeEach) import {Component, DebugElement, Injectab",
    "id": "testing-services-*-angular-34"
  },
  {
    "url": "https://angular.dev/guide/testing/services",
    "title": "Testing services • Angular",
    "chunk": "le} from '@angular/core';import { ComponentFixture, fakeAsync, inject, TestBed, tick, waitForAsync,} from '@angular/core/testing';import {FormsModule, NgControl, NgModel} from '@angular/forms';import {By} from '@angular/platform-browser';import {addMatchers, click} from '../../testing';import { BankAccountComponent, BankAccountParentComponent, Child1Component, Child2Component, Child3Component, ExternalTemplateComponent, InputComponent, IoComponent, IoParentComponent, LightswitchComponent, Master",
    "id": "testing-services-*-angular-35"
  },
  {
    "url": "https://angular.dev/guide/testing/services",
    "title": "Testing services • Angular",
    "chunk": "Service, MyIfChildComponent, MyIfComponent, MyIfParentComponent, NeedsContentComponent, ParentComponent, ReversePipeComponent, ShellComponent, TestProvidersComponent, TestViewProvidersComponent, ValueService,} from './demo';export class NotProvided extends ValueService { /* example below */}beforeEach(addMatchers);describe('demo (with TestBed):', () => { //////// Service Tests ///////////// describe('ValueService', () => { let service: ValueService; beforeEach(() => { TestBed.configureTestingMod",
    "id": "testing-services-*-angular-36"
  },
  {
    "url": "https://angular.dev/guide/testing/services",
    "title": "Testing services • Angular",
    "chunk": "ule({providers: [ValueService]}); service = TestBed.inject(ValueService); }); it('should use ValueService', () => { service = TestBed.inject(ValueService); expect(service.getValue()).toBe('real value'); }); it('can inject a default value when service is not provided', () => { expect(TestBed.inject(NotProvided, null)).toBeNull(); }); it('test should wait for ValueService.getPromiseValue', waitForAsync(() => { service.getPromiseValue().then((value) => expect(value).toBe('promise value')); })); it(",
    "id": "testing-services-*-angular-37"
  },
  {
    "url": "https://angular.dev/guide/testing/services",
    "title": "Testing services • Angular",
    "chunk": "'test should wait for ValueService.getObservableValue', waitForAsync(() => { service.getObservableValue().subscribe((value) => expect(value).toBe('observable value')); })); // Must use done. See https://github.com/angular/angular/issues/10127 it('test should wait for ValueService.getObservableDelayValue', (done: DoneFn) => { service.getObservableDelayValue().subscribe((value) => { expect(value).toBe('observable delay value'); done(); }); }); it('should allow the use of fakeAsync', fakeAsync(() =",
    "id": "testing-services-*-angular-38"
  },
  {
    "url": "https://angular.dev/guide/testing/services",
    "title": "Testing services • Angular",
    "chunk": "> { let value: any; service.getPromiseValue().then((val: any) => (value = val)); tick(); // Trigger JS engine cycle until all promises resolve. expect(value).toBe('promise value'); })); }); describe('MasterService', () => { let masterService: MasterService; let valueServiceSpy: jasmine.SpyObj<ValueService>; beforeEach(() => { const spy = jasmine.createSpyObj('ValueService', ['getValue']); TestBed.configureTestingModule({ // Provide both the service-to-test and its (spy) dependency providers: [Ma",
    "id": "testing-services-*-angular-39"
  },
  {
    "url": "https://angular.dev/guide/testing/services",
    "title": "Testing services • Angular",
    "chunk": "sterService, {provide: ValueService, useValue: spy}], }); // Inject both the service-to-test and its (spy) dependency masterService = TestBed.inject(MasterService); valueServiceSpy = TestBed.inject(ValueService) as jasmine.SpyObj<ValueService>; }); it('#getValue should return stubbed value from a spy', () => { const stubValue = 'stub value'; valueServiceSpy.getValue.and.returnValue(stubValue); expect(masterService.getValue()).withContext('service returned stub value').toBe(stubValue); expect(val",
    "id": "testing-services-*-angular-40"
  },
  {
    "url": "https://angular.dev/guide/testing/services",
    "title": "Testing services • Angular",
    "chunk": "ueServiceSpy.getValue.calls.count()) .withContext('spy method was called once') .toBe(1); expect(valueServiceSpy.getValue.calls.mostRecent().returnValue).toBe(stubValue); }); }); describe('use inject within `it`', () => { beforeEach(() => { TestBed.configureTestingModule({providers: [ValueService]}); }); it('should use modified providers', inject([ValueService], (service: ValueService) => { service.setValue('value modified in beforeEach'); expect(service.getValue()).toBe('value modified in befor",
    "id": "testing-services-*-angular-41"
  },
  {
    "url": "https://angular.dev/guide/testing/services",
    "title": "Testing services • Angular",
    "chunk": "eEach'); })); }); describe('using waitForAsync(inject) within beforeEach', () => { let serviceValue: string; beforeEach(() => { TestBed.configureTestingModule({providers: [ValueService]}); }); beforeEach(waitForAsync( inject([ValueService], (service: ValueService) => { service.getPromiseValue().then((value) => (serviceValue = value)); }), )); it('should use asynchronously modified value ... in synchronous test', () => { expect(serviceValue).toBe('promise value'); }); }); /////////// Component Te",
    "id": "testing-services-*-angular-42"
  },
  {
    "url": "https://angular.dev/guide/testing/services",
    "title": "Testing services • Angular",
    "chunk": "sts ////////////////// describe('TestBed component tests', () => { // beforeEach(waitForAsync(() => { // TestBed.configureTestingModule() // // Compile everything in DemoModule // ; // })); it('should create a component with inline template', () => { const fixture = TestBed.createComponent(Child1Component); fixture.detectChanges(); expect(fixture).toHaveText('Child'); }); it('should create a component with external template', () => { const fixture = TestBed.createComponent(ExternalTemplateCompon",
    "id": "testing-services-*-angular-43"
  },
  {
    "url": "https://angular.dev/guide/testing/services",
    "title": "Testing services • Angular",
    "chunk": "ent); fixture.detectChanges(); expect(fixture).toHaveText('from external template'); }); it('should allow changing members of the component', () => { const fixture = TestBed.createComponent(MyIfComponent); fixture.detectChanges(); expect(fixture).toHaveText('MyIf()'); fixture.componentInstance.showMore = true; fixture.detectChanges(); expect(fixture).toHaveText('MyIf(More)'); }); it('should create a nested component bound to inputs/outputs', () => { const fixture = TestBed.createComponent(IoPare",
    "id": "testing-services-*-angular-44"
  },
  {
    "url": "https://angular.dev/guide/testing/services",
    "title": "Testing services • Angular",
    "chunk": "ntComponent); fixture.detectChanges(); const heroes = fixture.debugElement.queryAll(By.css('.hero')); expect(heroes.length).withContext('has heroes').toBeGreaterThan(0); const comp = fixture.componentInstance; const hero = comp.heroes[0]; click(heroes[0]); fixture.detectChanges(); const selected = fixture.debugElement.query(By.css('p')); expect(selected).toHaveText(hero.name); }); it('can access the instance variable of an `*ngFor` row component', () => { const fixture = TestBed.createComponent(",
    "id": "testing-services-*-angular-45"
  },
  {
    "url": "https://angular.dev/guide/testing/services",
    "title": "Testing services • Angular",
    "chunk": "IoParentComponent); const comp = fixture.componentInstance; const heroName = comp.heroes[0].name; // first hero's name fixture.detectChanges(); const ngForRow = fixture.debugElement.query(By.directive(IoComponent)); // first hero ngForRow const hero = ngForRow.context.hero; // the hero object passed into the row expect(hero.name).withContext('ngRow.context.hero').toBe(heroName); const rowComp = ngForRow.componentInstance; // jasmine.any is an \"instance-of-type\" test. expect(rowComp).withContext(",
    "id": "testing-services-*-angular-46"
  },
  {
    "url": "https://angular.dev/guide/testing/services",
    "title": "Testing services • Angular",
    "chunk": "'component is IoComp').toEqual(jasmine.any(IoComponent)); expect(rowComp.hero.name).withContext('component.hero').toBe(heroName); }); it('should support clicking a button', () => { const fixture = TestBed.createComponent(LightswitchComponent); const btn = fixture.debugElement.query(By.css('button')); const span = fixture.debugElement.query(By.css('span')).nativeElement; fixture.detectChanges(); expect(span.textContent) .withContext('before click') .toMatch(/is off/i); click(btn); fixture.detectC",
    "id": "testing-services-*-angular-47"
  },
  {
    "url": "https://angular.dev/guide/testing/services",
    "title": "Testing services • Angular",
    "chunk": "hanges(); expect(span.textContent).withContext('after click').toMatch(/is on/i); }); // ngModel is async so we must wait for it with promise-based `whenStable` it('should support entering text in input box (ngModel)', waitForAsync(() => { const expectedOrigName = 'John'; const expectedNewName = 'Sally'; const fixture = TestBed.createComponent(InputComponent); fixture.detectChanges(); const comp = fixture.componentInstance; const input = fixture.debugElement.query(By.css('input')).nativeElement a",
    "id": "testing-services-*-angular-48"
  },
  {
    "url": "https://angular.dev/guide/testing/services",
    "title": "Testing services • Angular",
    "chunk": "s HTMLInputElement; expect(comp.name) .withContext(`At start name should be ${expectedOrigName} `) .toBe(expectedOrigName); // wait until ngModel binds comp.name to input box fixture .whenStable() .then(() => { expect(input.value) .withContext( `After ngModel updates input box, input.value should be ${expectedOrigName} `, ) .toBe(expectedOrigName); // simulate user entering new name in input input.value = expectedNewName; // that change doesn't flow to the component immediately expect(comp.name(",
    "id": "testing-services-*-angular-49"
  },
  {
    "url": "https://angular.dev/guide/testing/services",
    "title": "Testing services • Angular",
    "chunk": ")) .withContext( `comp.name should still be ${expectedOrigName} after value change, before binding happens`, ) .toBe(expectedOrigName); // Dispatch a DOM event so that Angular learns of input value change. // then wait while ngModel pushes input.box value to comp.name input.dispatchEvent(new Event('input')); return fixture.whenStable(); }) .then(() => { expect(comp.name()) .withContext(`After ngModel updates the model, comp.name should be ${expectedNewName} `) .toBe(expectedNewName); }); })); //",
    "id": "testing-services-*-angular-50"
  },
  {
    "url": "https://angular.dev/guide/testing/services",
    "title": "Testing services • Angular",
    "chunk": " fakeAsync version of ngModel input test enables sync test style // synchronous `tick` replaces asynchronous promise-base `whenStable` it('should support entering text in input box (ngModel) - fakeAsync', fakeAsync(() => { const expectedOrigName = 'John'; const expectedNewName = 'Sally'; const fixture = TestBed.createComponent(InputComponent); fixture.detectChanges(); const comp = fixture.componentInstance; const input = fixture.debugElement.query(By.css('input')).nativeElement as HTMLInputEleme",
    "id": "testing-services-*-angular-51"
  },
  {
    "url": "https://angular.dev/guide/testing/services",
    "title": "Testing services • Angular",
    "chunk": "nt; expect(comp.name) .withContext(`At start name should be ${expectedOrigName} `) .toBe(expectedOrigName); // wait until ngModel binds comp.name to input box tick(); expect(input.value) .withContext(`After ngModel updates input box, input.value should be ${expectedOrigName} `) .toBe(expectedOrigName); // simulate user entering new name in input input.value = expectedNewName; // that change doesn't flow to the component immediately expect(comp.name) .withContext( `comp.name should still be ${exp",
    "id": "testing-services-*-angular-52"
  },
  {
    "url": "https://angular.dev/guide/testing/services",
    "title": "Testing services • Angular",
    "chunk": "ectedOrigName} after value change, before binding happens`, ) .toBe(expectedOrigName); // Dispatch a DOM event so that Angular learns of input value change. // then wait a tick while ngModel pushes input.box value to comp.name input.dispatchEvent(new Event('input')); tick(); expect(comp.name) .withContext(`After ngModel updates the model, comp.name should be ${expectedNewName} `) .toBe(expectedNewName); })); it('ReversePipeComp should reverse the input text', fakeAsync(() => { const inputText = ",
    "id": "testing-services-*-angular-53"
  },
  {
    "url": "https://angular.dev/guide/testing/services",
    "title": "Testing services • Angular",
    "chunk": "'the quick brown fox.'; const expectedText = '.xof nworb kciuq eht'; const fixture = TestBed.createComponent(ReversePipeComponent); fixture.detectChanges(); const comp = fixture.componentInstance; const input = fixture.debugElement.query(By.css('input')).nativeElement as HTMLInputElement; const span = fixture.debugElement.query(By.css('span')).nativeElement as HTMLElement; // simulate user entering new name in input input.value = inputText; // Dispatch a DOM event so that Angular learns of input",
    "id": "testing-services-*-angular-54"
  },
  {
    "url": "https://angular.dev/guide/testing/services",
    "title": "Testing services • Angular",
    "chunk": " value change. // then wait a tick while ngModel pushes input.box value to comp.text // and Angular updates the output span input.dispatchEvent(new Event('input')); tick(); fixture.detectChanges(); expect(span.textContent).withContext('output span').toBe(expectedText); expect(comp.text).withContext('component.text').toBe(inputText); })); // Use this technique to find attached directives of any kind it('can examine attached directives and listeners', () => { const fixture = TestBed.createComponen",
    "id": "testing-services-*-angular-55"
  },
  {
    "url": "https://angular.dev/guide/testing/services",
    "title": "Testing services • Angular",
    "chunk": "t(InputComponent); fixture.detectChanges(); const inputEl = fixture.debugElement.query(By.css('input')); expect(inputEl.providerTokens).withContext('NgModel directive').toContain(NgModel); const ngControl = inputEl.injector.get(NgControl); expect(ngControl).withContext('NgControl directive').toEqual(jasmine.any(NgControl)); expect(inputEl.listeners.length).withContext('several listeners attached').toBeGreaterThan(2); }); it('BankAccountComponent should set attributes, styles, classes, and proper",
    "id": "testing-services-*-angular-56"
  },
  {
    "url": "https://angular.dev/guide/testing/services",
    "title": "Testing services • Angular",
    "chunk": "ties', () => { const fixture = TestBed.createComponent(BankAccountParentComponent); fixture.detectChanges(); const comp = fixture.componentInstance; // the only child is debugElement of the BankAccount component const el = fixture.debugElement.children[0]; const childComp = el.componentInstance as BankAccountComponent; expect(childComp).toEqual(jasmine.any(BankAccountComponent)); expect(el.context).withContext('context is the child component').toBe(childComp); expect(el.attributes['account']).wi",
    "id": "testing-services-*-angular-57"
  },
  {
    "url": "https://angular.dev/guide/testing/services",
    "title": "Testing services • Angular",
    "chunk": "thContext('account attribute').toBe(childComp.id); expect(el.attributes['bank']).withContext('bank attribute').toBe(childComp.bank); expect(el.classes['closed']).withContext('closed class').toBe(true); expect(el.classes['open']).withContext('open class').toBeFalsy(); expect(el.styles['color']).withContext('color style').toBe(comp.color); expect(el.styles['width']) .withContext('width style') .toBe(comp.width + 'px'); // Removed on 12/02/2016 when ceased public discussion of the `Renderer`. Reviv",
    "id": "testing-services-*-angular-58"
  },
  {
    "url": "https://angular.dev/guide/testing/services",
    "title": "Testing services • Angular",
    "chunk": "e in future? // expect(el.properties['customProperty']).toBe(true, 'customProperty'); }); }); describe('TestBed component overrides:', () => { it(\"should override ChildComp's template\", () => { const fixture = TestBed.configureTestingModule({ imports: [Child1Component], }) .overrideComponent(Child1Component, { set: {template: '<span>Fake</span>'}, }) .createComponent(Child1Component); fixture.detectChanges(); expect(fixture).toHaveText('Fake'); }); it(\"should override TestProvidersComp's ValueSe",
    "id": "testing-services-*-angular-59"
  },
  {
    "url": "https://angular.dev/guide/testing/services",
    "title": "Testing services • Angular",
    "chunk": "rvice provider\", () => { const fixture = TestBed.configureTestingModule({ imports: [TestProvidersComponent], }) .overrideComponent(TestProvidersComponent, { remove: {providers: [ValueService]}, add: {providers: [{provide: ValueService, useClass: FakeValueService}]}, // Or replace them all (this component has only one provider) // set: { providers: [{ provide: ValueService, useClass: FakeValueService }] }, }) .createComponent(TestProvidersComponent); fixture.detectChanges(); expect(fixture).toHav",
    "id": "testing-services-*-angular-60"
  },
  {
    "url": "https://angular.dev/guide/testing/services",
    "title": "Testing services • Angular",
    "chunk": "eText('injected value: faked value', 'text'); // Explore the providerTokens const tokens = fixture.debugElement.providerTokens; expect(tokens).withContext('component ctor').toContain(fixture.componentInstance.constructor); expect(tokens).withContext('TestProvidersComp').toContain(TestProvidersComponent); expect(tokens).withContext('ValueService').toContain(ValueService); }); it(\"should override TestViewProvidersComp's ValueService viewProvider\", () => { const fixture = TestBed.configureTestingMo",
    "id": "testing-services-*-angular-61"
  },
  {
    "url": "https://angular.dev/guide/testing/services",
    "title": "Testing services • Angular",
    "chunk": "dule({ imports: [TestViewProvidersComponent], }) .overrideComponent(TestViewProvidersComponent, { // remove: { viewProviders: [ValueService]}, // add: { viewProviders: [{ provide: ValueService, useClass: FakeValueService }] // }, // Or replace them all (this component has only one viewProvider) set: {viewProviders: [{provide: ValueService, useClass: FakeValueService}]}, }) .createComponent(TestViewProvidersComponent); fixture.detectChanges(); expect(fixture).toHaveText('injected value: faked val",
    "id": "testing-services-*-angular-62"
  },
  {
    "url": "https://angular.dev/guide/testing/services",
    "title": "Testing services • Angular",
    "chunk": "ue'); }); it(\"injected provider should not be same as component's provider\", () => { // TestComponent is parent of TestProvidersComponent @Component({ template: '<my-service-comp></my-service-comp>', imports: [TestProvidersComponent], }) class TestComponent {} // 3 levels of ValueService provider: module, TestComponent, TestProvidersComponent const fixture = TestBed.configureTestingModule({ imports: [TestComponent, TestProvidersComponent], providers: [ValueService], }) .overrideComponent(TestCom",
    "id": "testing-services-*-angular-63"
  },
  {
    "url": "https://angular.dev/guide/testing/services",
    "title": "Testing services • Angular",
    "chunk": "ponent, { set: {providers: [{provide: ValueService, useValue: {}}]}, }) .overrideComponent(TestProvidersComponent, { set: {providers: [{provide: ValueService, useClass: FakeValueService}]}, }) .createComponent(TestComponent); let testBedProvider!: ValueService; // `inject` uses TestBed's injector inject([ValueService], (s: ValueService) => (testBedProvider = s))(); const tcProvider = fixture.debugElement.injector.get(ValueService) as ValueService; const tpcProvider = fixture.debugElement.childre",
    "id": "testing-services-*-angular-64"
  },
  {
    "url": "https://angular.dev/guide/testing/services",
    "title": "Testing services • Angular",
    "chunk": "n[0].injector.get( ValueService, ) as FakeValueService; expect(testBedProvider).withContext('testBed/tc not same providers').not.toBe(tcProvider); expect(testBedProvider).withContext('testBed/tpc not same providers').not.toBe(tpcProvider); expect(testBedProvider instanceof ValueService) .withContext('testBedProvider is ValueService') .toBe(true); expect(tcProvider) .withContext('tcProvider is {}') .toEqual({} as ValueService); expect(tpcProvider instanceof FakeValueService) .withContext('tpcProv",
    "id": "testing-services-*-angular-65"
  },
  {
    "url": "https://angular.dev/guide/testing/services",
    "title": "Testing services • Angular",
    "chunk": "ider is FakeValueService') .toBe(true); }); it('can access template local variables as references', () => { const fixture = TestBed.configureTestingModule({ imports: [ ShellComponent, NeedsContentComponent, Child1Component, Child2Component, Child3Component, ], }) .overrideComponent(ShellComponent, { set: { selector: 'test-shell', imports: [NeedsContentComponent, Child1Component, Child2Component, Child3Component], template: ` <needs-content #nc> <child-1 #content text=\"My\"></child-1> <child-2 #co",
    "id": "testing-services-*-angular-66"
  },
  {
    "url": "https://angular.dev/guide/testing/services",
    "title": "Testing services • Angular",
    "chunk": "ntent text=\"dog\"></child-2> <child-2 text=\"has\"></child-2> <child-3 #content text=\"fleas\"></child-3> <div #content>!</div> </needs-content> `, }, }) .createComponent(ShellComponent); fixture.detectChanges(); // NeedsContentComp is the child of ShellComp const el = fixture.debugElement.children[0]; const comp = el.componentInstance; expect(comp.children.toArray().length) .withContext('three different child components and an ElementRef with #content') .toBe(4); expect(el.references['nc']).withCont",
    "id": "testing-services-*-angular-67"
  },
  {
    "url": "https://angular.dev/guide/testing/services",
    "title": "Testing services • Angular",
    "chunk": "ext('#nc reference to component').toBe(comp); // Filter for DebugElements with a #content reference const contentRefs = el.queryAll((de) => de.references['content']); expect(contentRefs.length).withContext('elements w/ a #content reference').toBe(4); }); }); describe('nested (one-deep) component override', () => { beforeEach(() => { TestBed.configureTestingModule({ imports: [ParentComponent, FakeChildComponent], }).overrideComponent(ParentComponent, { set: {imports: [FakeChildComponent]}, }); })",
    "id": "testing-services-*-angular-68"
  },
  {
    "url": "https://angular.dev/guide/testing/services",
    "title": "Testing services • Angular",
    "chunk": "; it('ParentComp should use Fake Child component', () => { const fixture = TestBed.createComponent(ParentComponent); fixture.detectChanges(); expect(fixture).toHaveText('Parent(Fake Child)'); }); }); describe('nested (two-deep) component override', () => { beforeEach(() => { TestBed.configureTestingModule({ imports: [ParentComponent, FakeChildWithGrandchildComponent, FakeGrandchildComponent], }).overrideComponent(ParentComponent, { set: {imports: [FakeChildWithGrandchildComponent, FakeGrandchild",
    "id": "testing-services-*-angular-69"
  },
  {
    "url": "https://angular.dev/guide/testing/services",
    "title": "Testing services • Angular",
    "chunk": "Component]}, }); }); it('should use Fake Grandchild component', () => { const fixture = TestBed.createComponent(ParentComponent); fixture.detectChanges(); expect(fixture).toHaveText('Parent(Fake Child(Fake Grandchild))'); }); });});////////// Fakes ///////////@Component({ selector: 'child-1', template: 'Fake Child',})class FakeChildComponent {}@Component({ selector: 'grandchild-1', template: 'Fake Grandchild',})class FakeGrandchildComponent {}@Component({ selector: 'child-1', imports: [FakeGrand",
    "id": "testing-services-*-angular-70"
  },
  {
    "url": "https://angular.dev/guide/testing/services",
    "title": "Testing services • Angular",
    "chunk": "childComponent], template: 'Fake Child(<grandchild-1></grandchild-1>)',})class FakeChildWithGrandchildComponent {}@Injectable()class FakeValueService extends ValueService { override value = 'faked value';} Then inject it inside a test by calling TestBed.inject() with the service class as the argument. HELPFUL: TestBed.get() was deprecated as of Angular version 9. To help minimize breaking changes, Angular introduces a new function called TestBed.inject(), which you should use instead. import {Co",
    "id": "testing-services-*-angular-71"
  },
  {
    "url": "https://angular.dev/guide/testing/services",
    "title": "Testing services • Angular",
    "chunk": "mponent, DebugElement, Injectable} from '@angular/core';import { ComponentFixture, fakeAsync, inject, TestBed, tick, waitForAsync,} from '@angular/core/testing';import {FormsModule, NgControl, NgModel} from '@angular/forms';import {By} from '@angular/platform-browser';import {addMatchers, click} from '../../testing';import { BankAccountComponent, BankAccountParentComponent, Child1Component, Child2Component, Child3Component, ExternalTemplateComponent, InputComponent, IoComponent, IoParentComponen",
    "id": "testing-services-*-angular-72"
  },
  {
    "url": "https://angular.dev/guide/testing/services",
    "title": "Testing services • Angular",
    "chunk": "t, LightswitchComponent, MasterService, MyIfChildComponent, MyIfComponent, MyIfParentComponent, NeedsContentComponent, ParentComponent, ReversePipeComponent, ShellComponent, TestProvidersComponent, TestViewProvidersComponent, ValueService,} from './demo';export class NotProvided extends ValueService { /* example below */}beforeEach(addMatchers);describe('demo (with TestBed):', () => { //////// Service Tests ///////////// describe('ValueService', () => { let service: ValueService; beforeEach(() =",
    "id": "testing-services-*-angular-73"
  },
  {
    "url": "https://angular.dev/guide/testing/services",
    "title": "Testing services • Angular",
    "chunk": "> { TestBed.configureTestingModule({providers: [ValueService]}); service = TestBed.inject(ValueService); }); it('should use ValueService', () => { service = TestBed.inject(ValueService); expect(service.getValue()).toBe('real value'); }); it('can inject a default value when service is not provided', () => { expect(TestBed.inject(NotProvided, null)).toBeNull(); }); it('test should wait for ValueService.getPromiseValue', waitForAsync(() => { service.getPromiseValue().then((value) => expect(value).t",
    "id": "testing-services-*-angular-74"
  },
  {
    "url": "https://angular.dev/guide/testing/services",
    "title": "Testing services • Angular",
    "chunk": "oBe('promise value')); })); it('test should wait for ValueService.getObservableValue', waitForAsync(() => { service.getObservableValue().subscribe((value) => expect(value).toBe('observable value')); })); // Must use done. See https://github.com/angular/angular/issues/10127 it('test should wait for ValueService.getObservableDelayValue', (done: DoneFn) => { service.getObservableDelayValue().subscribe((value) => { expect(value).toBe('observable delay value'); done(); }); }); it('should allow the us",
    "id": "testing-services-*-angular-75"
  },
  {
    "url": "https://angular.dev/guide/testing/services",
    "title": "Testing services • Angular",
    "chunk": "e of fakeAsync', fakeAsync(() => { let value: any; service.getPromiseValue().then((val: any) => (value = val)); tick(); // Trigger JS engine cycle until all promises resolve. expect(value).toBe('promise value'); })); }); describe('MasterService', () => { let masterService: MasterService; let valueServiceSpy: jasmine.SpyObj<ValueService>; beforeEach(() => { const spy = jasmine.createSpyObj('ValueService', ['getValue']); TestBed.configureTestingModule({ // Provide both the service-to-test and its ",
    "id": "testing-services-*-angular-76"
  },
  {
    "url": "https://angular.dev/guide/testing/services",
    "title": "Testing services • Angular",
    "chunk": "(spy) dependency providers: [MasterService, {provide: ValueService, useValue: spy}], }); // Inject both the service-to-test and its (spy) dependency masterService = TestBed.inject(MasterService); valueServiceSpy = TestBed.inject(ValueService) as jasmine.SpyObj<ValueService>; }); it('#getValue should return stubbed value from a spy', () => { const stubValue = 'stub value'; valueServiceSpy.getValue.and.returnValue(stubValue); expect(masterService.getValue()).withContext('service returned stub valu",
    "id": "testing-services-*-angular-77"
  },
  {
    "url": "https://angular.dev/guide/testing/services",
    "title": "Testing services • Angular",
    "chunk": "e').toBe(stubValue); expect(valueServiceSpy.getValue.calls.count()) .withContext('spy method was called once') .toBe(1); expect(valueServiceSpy.getValue.calls.mostRecent().returnValue).toBe(stubValue); }); }); describe('use inject within `it`', () => { beforeEach(() => { TestBed.configureTestingModule({providers: [ValueService]}); }); it('should use modified providers', inject([ValueService], (service: ValueService) => { service.setValue('value modified in beforeEach'); expect(service.getValue()",
    "id": "testing-services-*-angular-78"
  },
  {
    "url": "https://angular.dev/guide/testing/services",
    "title": "Testing services • Angular",
    "chunk": ").toBe('value modified in beforeEach'); })); }); describe('using waitForAsync(inject) within beforeEach', () => { let serviceValue: string; beforeEach(() => { TestBed.configureTestingModule({providers: [ValueService]}); }); beforeEach(waitForAsync( inject([ValueService], (service: ValueService) => { service.getPromiseValue().then((value) => (serviceValue = value)); }), )); it('should use asynchronously modified value ... in synchronous test', () => { expect(serviceValue).toBe('promise value'); }",
    "id": "testing-services-*-angular-79"
  },
  {
    "url": "https://angular.dev/guide/testing/services",
    "title": "Testing services • Angular",
    "chunk": "); }); /////////// Component Tests ////////////////// describe('TestBed component tests', () => { // beforeEach(waitForAsync(() => { // TestBed.configureTestingModule() // // Compile everything in DemoModule // ; // })); it('should create a component with inline template', () => { const fixture = TestBed.createComponent(Child1Component); fixture.detectChanges(); expect(fixture).toHaveText('Child'); }); it('should create a component with external template', () => { const fixture = TestBed.createC",
    "id": "testing-services-*-angular-80"
  },
  {
    "url": "https://angular.dev/guide/testing/services",
    "title": "Testing services • Angular",
    "chunk": "omponent(ExternalTemplateComponent); fixture.detectChanges(); expect(fixture).toHaveText('from external template'); }); it('should allow changing members of the component', () => { const fixture = TestBed.createComponent(MyIfComponent); fixture.detectChanges(); expect(fixture).toHaveText('MyIf()'); fixture.componentInstance.showMore = true; fixture.detectChanges(); expect(fixture).toHaveText('MyIf(More)'); }); it('should create a nested component bound to inputs/outputs', () => { const fixture =",
    "id": "testing-services-*-angular-81"
  },
  {
    "url": "https://angular.dev/guide/testing/services",
    "title": "Testing services • Angular",
    "chunk": " TestBed.createComponent(IoParentComponent); fixture.detectChanges(); const heroes = fixture.debugElement.queryAll(By.css('.hero')); expect(heroes.length).withContext('has heroes').toBeGreaterThan(0); const comp = fixture.componentInstance; const hero = comp.heroes[0]; click(heroes[0]); fixture.detectChanges(); const selected = fixture.debugElement.query(By.css('p')); expect(selected).toHaveText(hero.name); }); it('can access the instance variable of an `*ngFor` row component', () => { const fix",
    "id": "testing-services-*-angular-82"
  },
  {
    "url": "https://angular.dev/guide/testing/services",
    "title": "Testing services • Angular",
    "chunk": "ture = TestBed.createComponent(IoParentComponent); const comp = fixture.componentInstance; const heroName = comp.heroes[0].name; // first hero's name fixture.detectChanges(); const ngForRow = fixture.debugElement.query(By.directive(IoComponent)); // first hero ngForRow const hero = ngForRow.context.hero; // the hero object passed into the row expect(hero.name).withContext('ngRow.context.hero').toBe(heroName); const rowComp = ngForRow.componentInstance; // jasmine.any is an \"instance-of-type\" tes",
    "id": "testing-services-*-angular-83"
  },
  {
    "url": "https://angular.dev/guide/testing/services",
    "title": "Testing services • Angular",
    "chunk": "t. expect(rowComp).withContext('component is IoComp').toEqual(jasmine.any(IoComponent)); expect(rowComp.hero.name).withContext('component.hero').toBe(heroName); }); it('should support clicking a button', () => { const fixture = TestBed.createComponent(LightswitchComponent); const btn = fixture.debugElement.query(By.css('button')); const span = fixture.debugElement.query(By.css('span')).nativeElement; fixture.detectChanges(); expect(span.textContent) .withContext('before click') .toMatch(/is off/",
    "id": "testing-services-*-angular-84"
  },
  {
    "url": "https://angular.dev/guide/testing/services",
    "title": "Testing services • Angular",
    "chunk": "i); click(btn); fixture.detectChanges(); expect(span.textContent).withContext('after click').toMatch(/is on/i); }); // ngModel is async so we must wait for it with promise-based `whenStable` it('should support entering text in input box (ngModel)', waitForAsync(() => { const expectedOrigName = 'John'; const expectedNewName = 'Sally'; const fixture = TestBed.createComponent(InputComponent); fixture.detectChanges(); const comp = fixture.componentInstance; const input = fixture.debugElement.query(B",
    "id": "testing-services-*-angular-85"
  },
  {
    "url": "https://angular.dev/guide/testing/services",
    "title": "Testing services • Angular",
    "chunk": "y.css('input')).nativeElement as HTMLInputElement; expect(comp.name) .withContext(`At start name should be ${expectedOrigName} `) .toBe(expectedOrigName); // wait until ngModel binds comp.name to input box fixture .whenStable() .then(() => { expect(input.value) .withContext( `After ngModel updates input box, input.value should be ${expectedOrigName} `, ) .toBe(expectedOrigName); // simulate user entering new name in input input.value = expectedNewName; // that change doesn't flow to the componen",
    "id": "testing-services-*-angular-86"
  },
  {
    "url": "https://angular.dev/guide/testing/services",
    "title": "Testing services • Angular",
    "chunk": "t immediately expect(comp.name()) .withContext( `comp.name should still be ${expectedOrigName} after value change, before binding happens`, ) .toBe(expectedOrigName); // Dispatch a DOM event so that Angular learns of input value change. // then wait while ngModel pushes input.box value to comp.name input.dispatchEvent(new Event('input')); return fixture.whenStable(); }) .then(() => { expect(comp.name()) .withContext(`After ngModel updates the model, comp.name should be ${expectedNewName} `) .toB",
    "id": "testing-services-*-angular-87"
  },
  {
    "url": "https://angular.dev/guide/testing/services",
    "title": "Testing services • Angular",
    "chunk": "e(expectedNewName); }); })); // fakeAsync version of ngModel input test enables sync test style // synchronous `tick` replaces asynchronous promise-base `whenStable` it('should support entering text in input box (ngModel) - fakeAsync', fakeAsync(() => { const expectedOrigName = 'John'; const expectedNewName = 'Sally'; const fixture = TestBed.createComponent(InputComponent); fixture.detectChanges(); const comp = fixture.componentInstance; const input = fixture.debugElement.query(By.css('input')).",
    "id": "testing-services-*-angular-88"
  },
  {
    "url": "https://angular.dev/guide/testing/services",
    "title": "Testing services • Angular",
    "chunk": "nativeElement as HTMLInputElement; expect(comp.name) .withContext(`At start name should be ${expectedOrigName} `) .toBe(expectedOrigName); // wait until ngModel binds comp.name to input box tick(); expect(input.value) .withContext(`After ngModel updates input box, input.value should be ${expectedOrigName} `) .toBe(expectedOrigName); // simulate user entering new name in input input.value = expectedNewName; // that change doesn't flow to the component immediately expect(comp.name) .withContext( `",
    "id": "testing-services-*-angular-89"
  },
  {
    "url": "https://angular.dev/guide/testing/services",
    "title": "Testing services • Angular",
    "chunk": "comp.name should still be ${expectedOrigName} after value change, before binding happens`, ) .toBe(expectedOrigName); // Dispatch a DOM event so that Angular learns of input value change. // then wait a tick while ngModel pushes input.box value to comp.name input.dispatchEvent(new Event('input')); tick(); expect(comp.name) .withContext(`After ngModel updates the model, comp.name should be ${expectedNewName} `) .toBe(expectedNewName); })); it('ReversePipeComp should reverse the input text', fakeA",
    "id": "testing-services-*-angular-90"
  },
  {
    "url": "https://angular.dev/guide/testing/services",
    "title": "Testing services • Angular",
    "chunk": "sync(() => { const inputText = 'the quick brown fox.'; const expectedText = '.xof nworb kciuq eht'; const fixture = TestBed.createComponent(ReversePipeComponent); fixture.detectChanges(); const comp = fixture.componentInstance; const input = fixture.debugElement.query(By.css('input')).nativeElement as HTMLInputElement; const span = fixture.debugElement.query(By.css('span')).nativeElement as HTMLElement; // simulate user entering new name in input input.value = inputText; // Dispatch a DOM event ",
    "id": "testing-services-*-angular-91"
  },
  {
    "url": "https://angular.dev/guide/testing/services",
    "title": "Testing services • Angular",
    "chunk": "so that Angular learns of input value change. // then wait a tick while ngModel pushes input.box value to comp.text // and Angular updates the output span input.dispatchEvent(new Event('input')); tick(); fixture.detectChanges(); expect(span.textContent).withContext('output span').toBe(expectedText); expect(comp.text).withContext('component.text').toBe(inputText); })); // Use this technique to find attached directives of any kind it('can examine attached directives and listeners', () => { const f",
    "id": "testing-services-*-angular-92"
  },
  {
    "url": "https://angular.dev/guide/testing/services",
    "title": "Testing services • Angular",
    "chunk": "ixture = TestBed.createComponent(InputComponent); fixture.detectChanges(); const inputEl = fixture.debugElement.query(By.css('input')); expect(inputEl.providerTokens).withContext('NgModel directive').toContain(NgModel); const ngControl = inputEl.injector.get(NgControl); expect(ngControl).withContext('NgControl directive').toEqual(jasmine.any(NgControl)); expect(inputEl.listeners.length).withContext('several listeners attached').toBeGreaterThan(2); }); it('BankAccountComponent should set attribut",
    "id": "testing-services-*-angular-93"
  },
  {
    "url": "https://angular.dev/guide/testing/services",
    "title": "Testing services • Angular",
    "chunk": "es, styles, classes, and properties', () => { const fixture = TestBed.createComponent(BankAccountParentComponent); fixture.detectChanges(); const comp = fixture.componentInstance; // the only child is debugElement of the BankAccount component const el = fixture.debugElement.children[0]; const childComp = el.componentInstance as BankAccountComponent; expect(childComp).toEqual(jasmine.any(BankAccountComponent)); expect(el.context).withContext('context is the child component').toBe(childComp); expe",
    "id": "testing-services-*-angular-94"
  },
  {
    "url": "https://angular.dev/guide/testing/services",
    "title": "Testing services • Angular",
    "chunk": "ct(el.attributes['account']).withContext('account attribute').toBe(childComp.id); expect(el.attributes['bank']).withContext('bank attribute').toBe(childComp.bank); expect(el.classes['closed']).withContext('closed class').toBe(true); expect(el.classes['open']).withContext('open class').toBeFalsy(); expect(el.styles['color']).withContext('color style').toBe(comp.color); expect(el.styles['width']) .withContext('width style') .toBe(comp.width + 'px'); // Removed on 12/02/2016 when ceased public disc",
    "id": "testing-services-*-angular-95"
  },
  {
    "url": "https://angular.dev/guide/testing/services",
    "title": "Testing services • Angular",
    "chunk": "ussion of the `Renderer`. Revive in future? // expect(el.properties['customProperty']).toBe(true, 'customProperty'); }); }); describe('TestBed component overrides:', () => { it(\"should override ChildComp's template\", () => { const fixture = TestBed.configureTestingModule({ imports: [Child1Component], }) .overrideComponent(Child1Component, { set: {template: '<span>Fake</span>'}, }) .createComponent(Child1Component); fixture.detectChanges(); expect(fixture).toHaveText('Fake'); }); it(\"should overr",
    "id": "testing-services-*-angular-96"
  },
  {
    "url": "https://angular.dev/guide/testing/services",
    "title": "Testing services • Angular",
    "chunk": "ide TestProvidersComp's ValueService provider\", () => { const fixture = TestBed.configureTestingModule({ imports: [TestProvidersComponent], }) .overrideComponent(TestProvidersComponent, { remove: {providers: [ValueService]}, add: {providers: [{provide: ValueService, useClass: FakeValueService}]}, // Or replace them all (this component has only one provider) // set: { providers: [{ provide: ValueService, useClass: FakeValueService }] }, }) .createComponent(TestProvidersComponent); fixture.detectC",
    "id": "testing-services-*-angular-97"
  },
  {
    "url": "https://angular.dev/guide/testing/services",
    "title": "Testing services • Angular",
    "chunk": "hanges(); expect(fixture).toHaveText('injected value: faked value', 'text'); // Explore the providerTokens const tokens = fixture.debugElement.providerTokens; expect(tokens).withContext('component ctor').toContain(fixture.componentInstance.constructor); expect(tokens).withContext('TestProvidersComp').toContain(TestProvidersComponent); expect(tokens).withContext('ValueService').toContain(ValueService); }); it(\"should override TestViewProvidersComp's ValueService viewProvider\", () => { const fixtu",
    "id": "testing-services-*-angular-98"
  },
  {
    "url": "https://angular.dev/guide/testing/services",
    "title": "Testing services • Angular",
    "chunk": "re = TestBed.configureTestingModule({ imports: [TestViewProvidersComponent], }) .overrideComponent(TestViewProvidersComponent, { // remove: { viewProviders: [ValueService]}, // add: { viewProviders: [{ provide: ValueService, useClass: FakeValueService }] // }, // Or replace them all (this component has only one viewProvider) set: {viewProviders: [{provide: ValueService, useClass: FakeValueService}]}, }) .createComponent(TestViewProvidersComponent); fixture.detectChanges(); expect(fixture).toHave",
    "id": "testing-services-*-angular-99"
  },
  {
    "url": "https://angular.dev/guide/testing/services",
    "title": "Testing services • Angular",
    "chunk": "Text('injected value: faked value'); }); it(\"injected provider should not be same as component's provider\", () => { // TestComponent is parent of TestProvidersComponent @Component({ template: '<my-service-comp></my-service-comp>', imports: [TestProvidersComponent], }) class TestComponent {} // 3 levels of ValueService provider: module, TestComponent, TestProvidersComponent const fixture = TestBed.configureTestingModule({ imports: [TestComponent, TestProvidersComponent], providers: [ValueService]",
    "id": "testing-services-*-angular-100"
  },
  {
    "url": "https://angular.dev/guide/testing/services",
    "title": "Testing services • Angular",
    "chunk": ", }) .overrideComponent(TestComponent, { set: {providers: [{provide: ValueService, useValue: {}}]}, }) .overrideComponent(TestProvidersComponent, { set: {providers: [{provide: ValueService, useClass: FakeValueService}]}, }) .createComponent(TestComponent); let testBedProvider!: ValueService; // `inject` uses TestBed's injector inject([ValueService], (s: ValueService) => (testBedProvider = s))(); const tcProvider = fixture.debugElement.injector.get(ValueService) as ValueService; const tpcProvider",
    "id": "testing-services-*-angular-101"
  },
  {
    "url": "https://angular.dev/guide/testing/services",
    "title": "Testing services • Angular",
    "chunk": " = fixture.debugElement.children[0].injector.get( ValueService, ) as FakeValueService; expect(testBedProvider).withContext('testBed/tc not same providers').not.toBe(tcProvider); expect(testBedProvider).withContext('testBed/tpc not same providers').not.toBe(tpcProvider); expect(testBedProvider instanceof ValueService) .withContext('testBedProvider is ValueService') .toBe(true); expect(tcProvider) .withContext('tcProvider is {}') .toEqual({} as ValueService); expect(tpcProvider instanceof FakeValu",
    "id": "testing-services-*-angular-102"
  },
  {
    "url": "https://angular.dev/guide/testing/services",
    "title": "Testing services • Angular",
    "chunk": "eService) .withContext('tpcProvider is FakeValueService') .toBe(true); }); it('can access template local variables as references', () => { const fixture = TestBed.configureTestingModule({ imports: [ ShellComponent, NeedsContentComponent, Child1Component, Child2Component, Child3Component, ], }) .overrideComponent(ShellComponent, { set: { selector: 'test-shell', imports: [NeedsContentComponent, Child1Component, Child2Component, Child3Component], template: ` <needs-content #nc> <child-1 #content te",
    "id": "testing-services-*-angular-103"
  },
  {
    "url": "https://angular.dev/guide/testing/services",
    "title": "Testing services • Angular",
    "chunk": "xt=\"My\"></child-1> <child-2 #content text=\"dog\"></child-2> <child-2 text=\"has\"></child-2> <child-3 #content text=\"fleas\"></child-3> <div #content>!</div> </needs-content> `, }, }) .createComponent(ShellComponent); fixture.detectChanges(); // NeedsContentComp is the child of ShellComp const el = fixture.debugElement.children[0]; const comp = el.componentInstance; expect(comp.children.toArray().length) .withContext('three different child components and an ElementRef with #content') .toBe(4); expec",
    "id": "testing-services-*-angular-104"
  },
  {
    "url": "https://angular.dev/guide/testing/services",
    "title": "Testing services • Angular",
    "chunk": "t(el.references['nc']).withContext('#nc reference to component').toBe(comp); // Filter for DebugElements with a #content reference const contentRefs = el.queryAll((de) => de.references['content']); expect(contentRefs.length).withContext('elements w/ a #content reference').toBe(4); }); }); describe('nested (one-deep) component override', () => { beforeEach(() => { TestBed.configureTestingModule({ imports: [ParentComponent, FakeChildComponent], }).overrideComponent(ParentComponent, { set: {imports",
    "id": "testing-services-*-angular-105"
  },
  {
    "url": "https://angular.dev/guide/testing/services",
    "title": "Testing services • Angular",
    "chunk": ": [FakeChildComponent]}, }); }); it('ParentComp should use Fake Child component', () => { const fixture = TestBed.createComponent(ParentComponent); fixture.detectChanges(); expect(fixture).toHaveText('Parent(Fake Child)'); }); }); describe('nested (two-deep) component override', () => { beforeEach(() => { TestBed.configureTestingModule({ imports: [ParentComponent, FakeChildWithGrandchildComponent, FakeGrandchildComponent], }).overrideComponent(ParentComponent, { set: {imports: [FakeChildWithGran",
    "id": "testing-services-*-angular-106"
  },
  {
    "url": "https://angular.dev/guide/testing/services",
    "title": "Testing services • Angular",
    "chunk": "dchildComponent, FakeGrandchildComponent]}, }); }); it('should use Fake Grandchild component', () => { const fixture = TestBed.createComponent(ParentComponent); fixture.detectChanges(); expect(fixture).toHaveText('Parent(Fake Child(Fake Grandchild))'); }); });});////////// Fakes ///////////@Component({ selector: 'child-1', template: 'Fake Child',})class FakeChildComponent {}@Component({ selector: 'grandchild-1', template: 'Fake Grandchild',})class FakeGrandchildComponent {}@Component({ selector:",
    "id": "testing-services-*-angular-107"
  },
  {
    "url": "https://angular.dev/guide/testing/services",
    "title": "Testing services • Angular",
    "chunk": " 'child-1', imports: [FakeGrandchildComponent], template: 'Fake Child(<grandchild-1></grandchild-1>)',})class FakeChildWithGrandchildComponent {}@Injectable()class FakeValueService extends ValueService { override value = 'faked value';} Or inside the beforeEach() if you prefer to inject the service as part of your setup. import {Component, DebugElement, Injectable} from '@angular/core';import { ComponentFixture, fakeAsync, inject, TestBed, tick, waitForAsync,} from '@angular/core/testing';import",
    "id": "testing-services-*-angular-108"
  },
  {
    "url": "https://angular.dev/guide/testing/services",
    "title": "Testing services • Angular",
    "chunk": " {FormsModule, NgControl, NgModel} from '@angular/forms';import {By} from '@angular/platform-browser';import {addMatchers, click} from '../../testing';import { BankAccountComponent, BankAccountParentComponent, Child1Component, Child2Component, Child3Component, ExternalTemplateComponent, InputComponent, IoComponent, IoParentComponent, LightswitchComponent, MasterService, MyIfChildComponent, MyIfComponent, MyIfParentComponent, NeedsContentComponent, ParentComponent, ReversePipeComponent, ShellComp",
    "id": "testing-services-*-angular-109"
  },
  {
    "url": "https://angular.dev/guide/testing/services",
    "title": "Testing services • Angular",
    "chunk": "onent, TestProvidersComponent, TestViewProvidersComponent, ValueService,} from './demo';export class NotProvided extends ValueService { /* example below */}beforeEach(addMatchers);describe('demo (with TestBed):', () => { //////// Service Tests ///////////// describe('ValueService', () => { let service: ValueService; beforeEach(() => { TestBed.configureTestingModule({providers: [ValueService]}); service = TestBed.inject(ValueService); }); it('should use ValueService', () => { service = TestBed.in",
    "id": "testing-services-*-angular-110"
  },
  {
    "url": "https://angular.dev/guide/testing/services",
    "title": "Testing services • Angular",
    "chunk": "ject(ValueService); expect(service.getValue()).toBe('real value'); }); it('can inject a default value when service is not provided', () => { expect(TestBed.inject(NotProvided, null)).toBeNull(); }); it('test should wait for ValueService.getPromiseValue', waitForAsync(() => { service.getPromiseValue().then((value) => expect(value).toBe('promise value')); })); it('test should wait for ValueService.getObservableValue', waitForAsync(() => { service.getObservableValue().subscribe((value) => expect(va",
    "id": "testing-services-*-angular-111"
  },
  {
    "url": "https://angular.dev/guide/testing/services",
    "title": "Testing services • Angular",
    "chunk": "lue).toBe('observable value')); })); // Must use done. See https://github.com/angular/angular/issues/10127 it('test should wait for ValueService.getObservableDelayValue', (done: DoneFn) => { service.getObservableDelayValue().subscribe((value) => { expect(value).toBe('observable delay value'); done(); }); }); it('should allow the use of fakeAsync', fakeAsync(() => { let value: any; service.getPromiseValue().then((val: any) => (value = val)); tick(); // Trigger JS engine cycle until all promises r",
    "id": "testing-services-*-angular-112"
  },
  {
    "url": "https://angular.dev/guide/testing/services",
    "title": "Testing services • Angular",
    "chunk": "esolve. expect(value).toBe('promise value'); })); }); describe('MasterService', () => { let masterService: MasterService; let valueServiceSpy: jasmine.SpyObj<ValueService>; beforeEach(() => { const spy = jasmine.createSpyObj('ValueService', ['getValue']); TestBed.configureTestingModule({ // Provide both the service-to-test and its (spy) dependency providers: [MasterService, {provide: ValueService, useValue: spy}], }); // Inject both the service-to-test and its (spy) dependency masterService = Te",
    "id": "testing-services-*-angular-113"
  },
  {
    "url": "https://angular.dev/guide/testing/services",
    "title": "Testing services • Angular",
    "chunk": "stBed.inject(MasterService); valueServiceSpy = TestBed.inject(ValueService) as jasmine.SpyObj<ValueService>; }); it('#getValue should return stubbed value from a spy', () => { const stubValue = 'stub value'; valueServiceSpy.getValue.and.returnValue(stubValue); expect(masterService.getValue()).withContext('service returned stub value').toBe(stubValue); expect(valueServiceSpy.getValue.calls.count()) .withContext('spy method was called once') .toBe(1); expect(valueServiceSpy.getValue.calls.mostRece",
    "id": "testing-services-*-angular-114"
  },
  {
    "url": "https://angular.dev/guide/testing/services",
    "title": "Testing services • Angular",
    "chunk": "nt().returnValue).toBe(stubValue); }); }); describe('use inject within `it`', () => { beforeEach(() => { TestBed.configureTestingModule({providers: [ValueService]}); }); it('should use modified providers', inject([ValueService], (service: ValueService) => { service.setValue('value modified in beforeEach'); expect(service.getValue()).toBe('value modified in beforeEach'); })); }); describe('using waitForAsync(inject) within beforeEach', () => { let serviceValue: string; beforeEach(() => { TestBed.",
    "id": "testing-services-*-angular-115"
  },
  {
    "url": "https://angular.dev/guide/testing/services",
    "title": "Testing services • Angular",
    "chunk": "configureTestingModule({providers: [ValueService]}); }); beforeEach(waitForAsync( inject([ValueService], (service: ValueService) => { service.getPromiseValue().then((value) => (serviceValue = value)); }), )); it('should use asynchronously modified value ... in synchronous test', () => { expect(serviceValue).toBe('promise value'); }); }); /////////// Component Tests ////////////////// describe('TestBed component tests', () => { // beforeEach(waitForAsync(() => { // TestBed.configureTestingModule(",
    "id": "testing-services-*-angular-116"
  },
  {
    "url": "https://angular.dev/guide/testing/services",
    "title": "Testing services • Angular",
    "chunk": ") // // Compile everything in DemoModule // ; // })); it('should create a component with inline template', () => { const fixture = TestBed.createComponent(Child1Component); fixture.detectChanges(); expect(fixture).toHaveText('Child'); }); it('should create a component with external template', () => { const fixture = TestBed.createComponent(ExternalTemplateComponent); fixture.detectChanges(); expect(fixture).toHaveText('from external template'); }); it('should allow changing members of the compon",
    "id": "testing-services-*-angular-117"
  },
  {
    "url": "https://angular.dev/guide/testing/services",
    "title": "Testing services • Angular",
    "chunk": "ent', () => { const fixture = TestBed.createComponent(MyIfComponent); fixture.detectChanges(); expect(fixture).toHaveText('MyIf()'); fixture.componentInstance.showMore = true; fixture.detectChanges(); expect(fixture).toHaveText('MyIf(More)'); }); it('should create a nested component bound to inputs/outputs', () => { const fixture = TestBed.createComponent(IoParentComponent); fixture.detectChanges(); const heroes = fixture.debugElement.queryAll(By.css('.hero')); expect(heroes.length).withContext(",
    "id": "testing-services-*-angular-118"
  },
  {
    "url": "https://angular.dev/guide/testing/services",
    "title": "Testing services • Angular",
    "chunk": "'has heroes').toBeGreaterThan(0); const comp = fixture.componentInstance; const hero = comp.heroes[0]; click(heroes[0]); fixture.detectChanges(); const selected = fixture.debugElement.query(By.css('p')); expect(selected).toHaveText(hero.name); }); it('can access the instance variable of an `*ngFor` row component', () => { const fixture = TestBed.createComponent(IoParentComponent); const comp = fixture.componentInstance; const heroName = comp.heroes[0].name; // first hero's name fixture.detectCha",
    "id": "testing-services-*-angular-119"
  },
  {
    "url": "https://angular.dev/guide/testing/services",
    "title": "Testing services • Angular",
    "chunk": "nges(); const ngForRow = fixture.debugElement.query(By.directive(IoComponent)); // first hero ngForRow const hero = ngForRow.context.hero; // the hero object passed into the row expect(hero.name).withContext('ngRow.context.hero').toBe(heroName); const rowComp = ngForRow.componentInstance; // jasmine.any is an \"instance-of-type\" test. expect(rowComp).withContext('component is IoComp').toEqual(jasmine.any(IoComponent)); expect(rowComp.hero.name).withContext('component.hero').toBe(heroName); }); it",
    "id": "testing-services-*-angular-120"
  },
  {
    "url": "https://angular.dev/guide/testing/services",
    "title": "Testing services • Angular",
    "chunk": "('should support clicking a button', () => { const fixture = TestBed.createComponent(LightswitchComponent); const btn = fixture.debugElement.query(By.css('button')); const span = fixture.debugElement.query(By.css('span')).nativeElement; fixture.detectChanges(); expect(span.textContent) .withContext('before click') .toMatch(/is off/i); click(btn); fixture.detectChanges(); expect(span.textContent).withContext('after click').toMatch(/is on/i); }); // ngModel is async so we must wait for it with pro",
    "id": "testing-services-*-angular-121"
  },
  {
    "url": "https://angular.dev/guide/testing/services",
    "title": "Testing services • Angular",
    "chunk": "mise-based `whenStable` it('should support entering text in input box (ngModel)', waitForAsync(() => { const expectedOrigName = 'John'; const expectedNewName = 'Sally'; const fixture = TestBed.createComponent(InputComponent); fixture.detectChanges(); const comp = fixture.componentInstance; const input = fixture.debugElement.query(By.css('input')).nativeElement as HTMLInputElement; expect(comp.name) .withContext(`At start name should be ${expectedOrigName} `) .toBe(expectedOrigName); // wait unti",
    "id": "testing-services-*-angular-122"
  },
  {
    "url": "https://angular.dev/guide/testing/services",
    "title": "Testing services • Angular",
    "chunk": "l ngModel binds comp.name to input box fixture .whenStable() .then(() => { expect(input.value) .withContext( `After ngModel updates input box, input.value should be ${expectedOrigName} `, ) .toBe(expectedOrigName); // simulate user entering new name in input input.value = expectedNewName; // that change doesn't flow to the component immediately expect(comp.name()) .withContext( `comp.name should still be ${expectedOrigName} after value change, before binding happens`, ) .toBe(expectedOrigName); ",
    "id": "testing-services-*-angular-123"
  },
  {
    "url": "https://angular.dev/guide/testing/services",
    "title": "Testing services • Angular",
    "chunk": "// Dispatch a DOM event so that Angular learns of input value change. // then wait while ngModel pushes input.box value to comp.name input.dispatchEvent(new Event('input')); return fixture.whenStable(); }) .then(() => { expect(comp.name()) .withContext(`After ngModel updates the model, comp.name should be ${expectedNewName} `) .toBe(expectedNewName); }); })); // fakeAsync version of ngModel input test enables sync test style // synchronous `tick` replaces asynchronous promise-base `whenStable` i",
    "id": "testing-services-*-angular-124"
  },
  {
    "url": "https://angular.dev/guide/testing/services",
    "title": "Testing services • Angular",
    "chunk": "t('should support entering text in input box (ngModel) - fakeAsync', fakeAsync(() => { const expectedOrigName = 'John'; const expectedNewName = 'Sally'; const fixture = TestBed.createComponent(InputComponent); fixture.detectChanges(); const comp = fixture.componentInstance; const input = fixture.debugElement.query(By.css('input')).nativeElement as HTMLInputElement; expect(comp.name) .withContext(`At start name should be ${expectedOrigName} `) .toBe(expectedOrigName); // wait until ngModel binds ",
    "id": "testing-services-*-angular-125"
  },
  {
    "url": "https://angular.dev/guide/testing/services",
    "title": "Testing services • Angular",
    "chunk": "comp.name to input box tick(); expect(input.value) .withContext(`After ngModel updates input box, input.value should be ${expectedOrigName} `) .toBe(expectedOrigName); // simulate user entering new name in input input.value = expectedNewName; // that change doesn't flow to the component immediately expect(comp.name) .withContext( `comp.name should still be ${expectedOrigName} after value change, before binding happens`, ) .toBe(expectedOrigName); // Dispatch a DOM event so that Angular learns of",
    "id": "testing-services-*-angular-126"
  },
  {
    "url": "https://angular.dev/guide/testing/services",
    "title": "Testing services • Angular",
    "chunk": " input value change. // then wait a tick while ngModel pushes input.box value to comp.name input.dispatchEvent(new Event('input')); tick(); expect(comp.name) .withContext(`After ngModel updates the model, comp.name should be ${expectedNewName} `) .toBe(expectedNewName); })); it('ReversePipeComp should reverse the input text', fakeAsync(() => { const inputText = 'the quick brown fox.'; const expectedText = '.xof nworb kciuq eht'; const fixture = TestBed.createComponent(ReversePipeComponent); fixt",
    "id": "testing-services-*-angular-127"
  },
  {
    "url": "https://angular.dev/guide/testing/services",
    "title": "Testing services • Angular",
    "chunk": "ure.detectChanges(); const comp = fixture.componentInstance; const input = fixture.debugElement.query(By.css('input')).nativeElement as HTMLInputElement; const span = fixture.debugElement.query(By.css('span')).nativeElement as HTMLElement; // simulate user entering new name in input input.value = inputText; // Dispatch a DOM event so that Angular learns of input value change. // then wait a tick while ngModel pushes input.box value to comp.text // and Angular updates the output span input.dispat",
    "id": "testing-services-*-angular-128"
  },
  {
    "url": "https://angular.dev/guide/testing/services",
    "title": "Testing services • Angular",
    "chunk": "chEvent(new Event('input')); tick(); fixture.detectChanges(); expect(span.textContent).withContext('output span').toBe(expectedText); expect(comp.text).withContext('component.text').toBe(inputText); })); // Use this technique to find attached directives of any kind it('can examine attached directives and listeners', () => { const fixture = TestBed.createComponent(InputComponent); fixture.detectChanges(); const inputEl = fixture.debugElement.query(By.css('input')); expect(inputEl.providerTokens).",
    "id": "testing-services-*-angular-129"
  },
  {
    "url": "https://angular.dev/guide/testing/services",
    "title": "Testing services • Angular",
    "chunk": "withContext('NgModel directive').toContain(NgModel); const ngControl = inputEl.injector.get(NgControl); expect(ngControl).withContext('NgControl directive').toEqual(jasmine.any(NgControl)); expect(inputEl.listeners.length).withContext('several listeners attached').toBeGreaterThan(2); }); it('BankAccountComponent should set attributes, styles, classes, and properties', () => { const fixture = TestBed.createComponent(BankAccountParentComponent); fixture.detectChanges(); const comp = fixture.compon",
    "id": "testing-services-*-angular-130"
  },
  {
    "url": "https://angular.dev/guide/testing/services",
    "title": "Testing services • Angular",
    "chunk": "entInstance; // the only child is debugElement of the BankAccount component const el = fixture.debugElement.children[0]; const childComp = el.componentInstance as BankAccountComponent; expect(childComp).toEqual(jasmine.any(BankAccountComponent)); expect(el.context).withContext('context is the child component').toBe(childComp); expect(el.attributes['account']).withContext('account attribute').toBe(childComp.id); expect(el.attributes['bank']).withContext('bank attribute').toBe(childComp.bank); exp",
    "id": "testing-services-*-angular-131"
  },
  {
    "url": "https://angular.dev/guide/testing/services",
    "title": "Testing services • Angular",
    "chunk": "ect(el.classes['closed']).withContext('closed class').toBe(true); expect(el.classes['open']).withContext('open class').toBeFalsy(); expect(el.styles['color']).withContext('color style').toBe(comp.color); expect(el.styles['width']) .withContext('width style') .toBe(comp.width + 'px'); // Removed on 12/02/2016 when ceased public discussion of the `Renderer`. Revive in future? // expect(el.properties['customProperty']).toBe(true, 'customProperty'); }); }); describe('TestBed component overrides:', (",
    "id": "testing-services-*-angular-132"
  },
  {
    "url": "https://angular.dev/guide/testing/services",
    "title": "Testing services • Angular",
    "chunk": ") => { it(\"should override ChildComp's template\", () => { const fixture = TestBed.configureTestingModule({ imports: [Child1Component], }) .overrideComponent(Child1Component, { set: {template: '<span>Fake</span>'}, }) .createComponent(Child1Component); fixture.detectChanges(); expect(fixture).toHaveText('Fake'); }); it(\"should override TestProvidersComp's ValueService provider\", () => { const fixture = TestBed.configureTestingModule({ imports: [TestProvidersComponent], }) .overrideComponent(TestP",
    "id": "testing-services-*-angular-133"
  },
  {
    "url": "https://angular.dev/guide/testing/services",
    "title": "Testing services • Angular",
    "chunk": "rovidersComponent, { remove: {providers: [ValueService]}, add: {providers: [{provide: ValueService, useClass: FakeValueService}]}, // Or replace them all (this component has only one provider) // set: { providers: [{ provide: ValueService, useClass: FakeValueService }] }, }) .createComponent(TestProvidersComponent); fixture.detectChanges(); expect(fixture).toHaveText('injected value: faked value', 'text'); // Explore the providerTokens const tokens = fixture.debugElement.providerTokens; expect(t",
    "id": "testing-services-*-angular-134"
  },
  {
    "url": "https://angular.dev/guide/testing/services",
    "title": "Testing services • Angular",
    "chunk": "okens).withContext('component ctor').toContain(fixture.componentInstance.constructor); expect(tokens).withContext('TestProvidersComp').toContain(TestProvidersComponent); expect(tokens).withContext('ValueService').toContain(ValueService); }); it(\"should override TestViewProvidersComp's ValueService viewProvider\", () => { const fixture = TestBed.configureTestingModule({ imports: [TestViewProvidersComponent], }) .overrideComponent(TestViewProvidersComponent, { // remove: { viewProviders: [ValueServ",
    "id": "testing-services-*-angular-135"
  },
  {
    "url": "https://angular.dev/guide/testing/services",
    "title": "Testing services • Angular",
    "chunk": "ice]}, // add: { viewProviders: [{ provide: ValueService, useClass: FakeValueService }] // }, // Or replace them all (this component has only one viewProvider) set: {viewProviders: [{provide: ValueService, useClass: FakeValueService}]}, }) .createComponent(TestViewProvidersComponent); fixture.detectChanges(); expect(fixture).toHaveText('injected value: faked value'); }); it(\"injected provider should not be same as component's provider\", () => { // TestComponent is parent of TestProvidersComponen",
    "id": "testing-services-*-angular-136"
  },
  {
    "url": "https://angular.dev/guide/testing/services",
    "title": "Testing services • Angular",
    "chunk": "t @Component({ template: '<my-service-comp></my-service-comp>', imports: [TestProvidersComponent], }) class TestComponent {} // 3 levels of ValueService provider: module, TestComponent, TestProvidersComponent const fixture = TestBed.configureTestingModule({ imports: [TestComponent, TestProvidersComponent], providers: [ValueService], }) .overrideComponent(TestComponent, { set: {providers: [{provide: ValueService, useValue: {}}]}, }) .overrideComponent(TestProvidersComponent, { set: {providers: [{",
    "id": "testing-services-*-angular-137"
  },
  {
    "url": "https://angular.dev/guide/testing/services",
    "title": "Testing services • Angular",
    "chunk": "provide: ValueService, useClass: FakeValueService}]}, }) .createComponent(TestComponent); let testBedProvider!: ValueService; // `inject` uses TestBed's injector inject([ValueService], (s: ValueService) => (testBedProvider = s))(); const tcProvider = fixture.debugElement.injector.get(ValueService) as ValueService; const tpcProvider = fixture.debugElement.children[0].injector.get( ValueService, ) as FakeValueService; expect(testBedProvider).withContext('testBed/tc not same providers').not.toBe(tc",
    "id": "testing-services-*-angular-138"
  },
  {
    "url": "https://angular.dev/guide/testing/services",
    "title": "Testing services • Angular",
    "chunk": "Provider); expect(testBedProvider).withContext('testBed/tpc not same providers').not.toBe(tpcProvider); expect(testBedProvider instanceof ValueService) .withContext('testBedProvider is ValueService') .toBe(true); expect(tcProvider) .withContext('tcProvider is {}') .toEqual({} as ValueService); expect(tpcProvider instanceof FakeValueService) .withContext('tpcProvider is FakeValueService') .toBe(true); }); it('can access template local variables as references', () => { const fixture = TestBed.conf",
    "id": "testing-services-*-angular-139"
  },
  {
    "url": "https://angular.dev/guide/testing/services",
    "title": "Testing services • Angular",
    "chunk": "igureTestingModule({ imports: [ ShellComponent, NeedsContentComponent, Child1Component, Child2Component, Child3Component, ], }) .overrideComponent(ShellComponent, { set: { selector: 'test-shell', imports: [NeedsContentComponent, Child1Component, Child2Component, Child3Component], template: ` <needs-content #nc> <child-1 #content text=\"My\"></child-1> <child-2 #content text=\"dog\"></child-2> <child-2 text=\"has\"></child-2> <child-3 #content text=\"fleas\"></child-3> <div #content>!</div> </needs-conte",
    "id": "testing-services-*-angular-140"
  },
  {
    "url": "https://angular.dev/guide/testing/services",
    "title": "Testing services • Angular",
    "chunk": "nt> `, }, }) .createComponent(ShellComponent); fixture.detectChanges(); // NeedsContentComp is the child of ShellComp const el = fixture.debugElement.children[0]; const comp = el.componentInstance; expect(comp.children.toArray().length) .withContext('three different child components and an ElementRef with #content') .toBe(4); expect(el.references['nc']).withContext('#nc reference to component').toBe(comp); // Filter for DebugElements with a #content reference const contentRefs = el.queryAll((de)",
    "id": "testing-services-*-angular-141"
  },
  {
    "url": "https://angular.dev/guide/testing/services",
    "title": "Testing services • Angular",
    "chunk": " => de.references['content']); expect(contentRefs.length).withContext('elements w/ a #content reference').toBe(4); }); }); describe('nested (one-deep) component override', () => { beforeEach(() => { TestBed.configureTestingModule({ imports: [ParentComponent, FakeChildComponent], }).overrideComponent(ParentComponent, { set: {imports: [FakeChildComponent]}, }); }); it('ParentComp should use Fake Child component', () => { const fixture = TestBed.createComponent(ParentComponent); fixture.detectChang",
    "id": "testing-services-*-angular-142"
  },
  {
    "url": "https://angular.dev/guide/testing/services",
    "title": "Testing services • Angular",
    "chunk": "es(); expect(fixture).toHaveText('Parent(Fake Child)'); }); }); describe('nested (two-deep) component override', () => { beforeEach(() => { TestBed.configureTestingModule({ imports: [ParentComponent, FakeChildWithGrandchildComponent, FakeGrandchildComponent], }).overrideComponent(ParentComponent, { set: {imports: [FakeChildWithGrandchildComponent, FakeGrandchildComponent]}, }); }); it('should use Fake Grandchild component', () => { const fixture = TestBed.createComponent(ParentComponent); fixtur",
    "id": "testing-services-*-angular-143"
  },
  {
    "url": "https://angular.dev/guide/testing/services",
    "title": "Testing services • Angular",
    "chunk": "e.detectChanges(); expect(fixture).toHaveText('Parent(Fake Child(Fake Grandchild))'); }); });});////////// Fakes ///////////@Component({ selector: 'child-1', template: 'Fake Child',})class FakeChildComponent {}@Component({ selector: 'grandchild-1', template: 'Fake Grandchild',})class FakeGrandchildComponent {}@Component({ selector: 'child-1', imports: [FakeGrandchildComponent], template: 'Fake Child(<grandchild-1></grandchild-1>)',})class FakeChildWithGrandchildComponent {}@Injectable()class Fak",
    "id": "testing-services-*-angular-144"
  },
  {
    "url": "https://angular.dev/guide/testing/services",
    "title": "Testing services • Angular",
    "chunk": "eValueService extends ValueService { override value = 'faked value';} When testing a service with a dependency, provide the mock in the providers array. In the following example, the mock is a spy object. import {Component, DebugElement, Injectable} from '@angular/core';import { ComponentFixture, fakeAsync, inject, TestBed, tick, waitForAsync,} from '@angular/core/testing';import {FormsModule, NgControl, NgModel} from '@angular/forms';import {By} from '@angular/platform-browser';import {addMatch",
    "id": "testing-services-*-angular-145"
  },
  {
    "url": "https://angular.dev/guide/testing/services",
    "title": "Testing services • Angular",
    "chunk": "ers, click} from '../../testing';import { BankAccountComponent, BankAccountParentComponent, Child1Component, Child2Component, Child3Component, ExternalTemplateComponent, InputComponent, IoComponent, IoParentComponent, LightswitchComponent, MasterService, MyIfChildComponent, MyIfComponent, MyIfParentComponent, NeedsContentComponent, ParentComponent, ReversePipeComponent, ShellComponent, TestProvidersComponent, TestViewProvidersComponent, ValueService,} from './demo';export class NotProvided exten",
    "id": "testing-services-*-angular-146"
  },
  {
    "url": "https://angular.dev/guide/testing/services",
    "title": "Testing services • Angular",
    "chunk": "ds ValueService { /* example below */}beforeEach(addMatchers);describe('demo (with TestBed):', () => { //////// Service Tests ///////////// describe('ValueService', () => { let service: ValueService; beforeEach(() => { TestBed.configureTestingModule({providers: [ValueService]}); service = TestBed.inject(ValueService); }); it('should use ValueService', () => { service = TestBed.inject(ValueService); expect(service.getValue()).toBe('real value'); }); it('can inject a default value when service is ",
    "id": "testing-services-*-angular-147"
  },
  {
    "url": "https://angular.dev/guide/testing/services",
    "title": "Testing services • Angular",
    "chunk": "not provided', () => { expect(TestBed.inject(NotProvided, null)).toBeNull(); }); it('test should wait for ValueService.getPromiseValue', waitForAsync(() => { service.getPromiseValue().then((value) => expect(value).toBe('promise value')); })); it('test should wait for ValueService.getObservableValue', waitForAsync(() => { service.getObservableValue().subscribe((value) => expect(value).toBe('observable value')); })); // Must use done. See https://github.com/angular/angular/issues/10127 it('test sh",
    "id": "testing-services-*-angular-148"
  },
  {
    "url": "https://angular.dev/guide/testing/services",
    "title": "Testing services • Angular",
    "chunk": "ould wait for ValueService.getObservableDelayValue', (done: DoneFn) => { service.getObservableDelayValue().subscribe((value) => { expect(value).toBe('observable delay value'); done(); }); }); it('should allow the use of fakeAsync', fakeAsync(() => { let value: any; service.getPromiseValue().then((val: any) => (value = val)); tick(); // Trigger JS engine cycle until all promises resolve. expect(value).toBe('promise value'); })); }); describe('MasterService', () => { let masterService: MasterServi",
    "id": "testing-services-*-angular-149"
  },
  {
    "url": "https://angular.dev/guide/testing/services",
    "title": "Testing services • Angular",
    "chunk": "ce; let valueServiceSpy: jasmine.SpyObj<ValueService>; beforeEach(() => { const spy = jasmine.createSpyObj('ValueService', ['getValue']); TestBed.configureTestingModule({ // Provide both the service-to-test and its (spy) dependency providers: [MasterService, {provide: ValueService, useValue: spy}], }); // Inject both the service-to-test and its (spy) dependency masterService = TestBed.inject(MasterService); valueServiceSpy = TestBed.inject(ValueService) as jasmine.SpyObj<ValueService>; }); it('#",
    "id": "testing-services-*-angular-150"
  },
  {
    "url": "https://angular.dev/guide/testing/services",
    "title": "Testing services • Angular",
    "chunk": "getValue should return stubbed value from a spy', () => { const stubValue = 'stub value'; valueServiceSpy.getValue.and.returnValue(stubValue); expect(masterService.getValue()).withContext('service returned stub value').toBe(stubValue); expect(valueServiceSpy.getValue.calls.count()) .withContext('spy method was called once') .toBe(1); expect(valueServiceSpy.getValue.calls.mostRecent().returnValue).toBe(stubValue); }); }); describe('use inject within `it`', () => { beforeEach(() => { TestBed.confi",
    "id": "testing-services-*-angular-151"
  },
  {
    "url": "https://angular.dev/guide/testing/services",
    "title": "Testing services • Angular",
    "chunk": "gureTestingModule({providers: [ValueService]}); }); it('should use modified providers', inject([ValueService], (service: ValueService) => { service.setValue('value modified in beforeEach'); expect(service.getValue()).toBe('value modified in beforeEach'); })); }); describe('using waitForAsync(inject) within beforeEach', () => { let serviceValue: string; beforeEach(() => { TestBed.configureTestingModule({providers: [ValueService]}); }); beforeEach(waitForAsync( inject([ValueService], (service: Val",
    "id": "testing-services-*-angular-152"
  },
  {
    "url": "https://angular.dev/guide/testing/services",
    "title": "Testing services • Angular",
    "chunk": "ueService) => { service.getPromiseValue().then((value) => (serviceValue = value)); }), )); it('should use asynchronously modified value ... in synchronous test', () => { expect(serviceValue).toBe('promise value'); }); }); /////////// Component Tests ////////////////// describe('TestBed component tests', () => { // beforeEach(waitForAsync(() => { // TestBed.configureTestingModule() // // Compile everything in DemoModule // ; // })); it('should create a component with inline template', () => { con",
    "id": "testing-services-*-angular-153"
  },
  {
    "url": "https://angular.dev/guide/testing/services",
    "title": "Testing services • Angular",
    "chunk": "st fixture = TestBed.createComponent(Child1Component); fixture.detectChanges(); expect(fixture).toHaveText('Child'); }); it('should create a component with external template', () => { const fixture = TestBed.createComponent(ExternalTemplateComponent); fixture.detectChanges(); expect(fixture).toHaveText('from external template'); }); it('should allow changing members of the component', () => { const fixture = TestBed.createComponent(MyIfComponent); fixture.detectChanges(); expect(fixture).toHaveT",
    "id": "testing-services-*-angular-154"
  },
  {
    "url": "https://angular.dev/guide/testing/services",
    "title": "Testing services • Angular",
    "chunk": "ext('MyIf()'); fixture.componentInstance.showMore = true; fixture.detectChanges(); expect(fixture).toHaveText('MyIf(More)'); }); it('should create a nested component bound to inputs/outputs', () => { const fixture = TestBed.createComponent(IoParentComponent); fixture.detectChanges(); const heroes = fixture.debugElement.queryAll(By.css('.hero')); expect(heroes.length).withContext('has heroes').toBeGreaterThan(0); const comp = fixture.componentInstance; const hero = comp.heroes[0]; click(heroes[0]",
    "id": "testing-services-*-angular-155"
  },
  {
    "url": "https://angular.dev/guide/testing/services",
    "title": "Testing services • Angular",
    "chunk": "); fixture.detectChanges(); const selected = fixture.debugElement.query(By.css('p')); expect(selected).toHaveText(hero.name); }); it('can access the instance variable of an `*ngFor` row component', () => { const fixture = TestBed.createComponent(IoParentComponent); const comp = fixture.componentInstance; const heroName = comp.heroes[0].name; // first hero's name fixture.detectChanges(); const ngForRow = fixture.debugElement.query(By.directive(IoComponent)); // first hero ngForRow const hero = ng",
    "id": "testing-services-*-angular-156"
  },
  {
    "url": "https://angular.dev/guide/testing/services",
    "title": "Testing services • Angular",
    "chunk": "ForRow.context.hero; // the hero object passed into the row expect(hero.name).withContext('ngRow.context.hero').toBe(heroName); const rowComp = ngForRow.componentInstance; // jasmine.any is an \"instance-of-type\" test. expect(rowComp).withContext('component is IoComp').toEqual(jasmine.any(IoComponent)); expect(rowComp.hero.name).withContext('component.hero').toBe(heroName); }); it('should support clicking a button', () => { const fixture = TestBed.createComponent(LightswitchComponent); const btn ",
    "id": "testing-services-*-angular-157"
  },
  {
    "url": "https://angular.dev/guide/testing/services",
    "title": "Testing services • Angular",
    "chunk": "= fixture.debugElement.query(By.css('button')); const span = fixture.debugElement.query(By.css('span')).nativeElement; fixture.detectChanges(); expect(span.textContent) .withContext('before click') .toMatch(/is off/i); click(btn); fixture.detectChanges(); expect(span.textContent).withContext('after click').toMatch(/is on/i); }); // ngModel is async so we must wait for it with promise-based `whenStable` it('should support entering text in input box (ngModel)', waitForAsync(() => { const expectedO",
    "id": "testing-services-*-angular-158"
  },
  {
    "url": "https://angular.dev/guide/testing/services",
    "title": "Testing services • Angular",
    "chunk": "rigName = 'John'; const expectedNewName = 'Sally'; const fixture = TestBed.createComponent(InputComponent); fixture.detectChanges(); const comp = fixture.componentInstance; const input = fixture.debugElement.query(By.css('input')).nativeElement as HTMLInputElement; expect(comp.name) .withContext(`At start name should be ${expectedOrigName} `) .toBe(expectedOrigName); // wait until ngModel binds comp.name to input box fixture .whenStable() .then(() => { expect(input.value) .withContext( `After ng",
    "id": "testing-services-*-angular-159"
  },
  {
    "url": "https://angular.dev/guide/testing/services",
    "title": "Testing services • Angular",
    "chunk": "Model updates input box, input.value should be ${expectedOrigName} `, ) .toBe(expectedOrigName); // simulate user entering new name in input input.value = expectedNewName; // that change doesn't flow to the component immediately expect(comp.name()) .withContext( `comp.name should still be ${expectedOrigName} after value change, before binding happens`, ) .toBe(expectedOrigName); // Dispatch a DOM event so that Angular learns of input value change. // then wait while ngModel pushes input.box valu",
    "id": "testing-services-*-angular-160"
  },
  {
    "url": "https://angular.dev/guide/testing/services",
    "title": "Testing services • Angular",
    "chunk": "e to comp.name input.dispatchEvent(new Event('input')); return fixture.whenStable(); }) .then(() => { expect(comp.name()) .withContext(`After ngModel updates the model, comp.name should be ${expectedNewName} `) .toBe(expectedNewName); }); })); // fakeAsync version of ngModel input test enables sync test style // synchronous `tick` replaces asynchronous promise-base `whenStable` it('should support entering text in input box (ngModel) - fakeAsync', fakeAsync(() => { const expectedOrigName = 'John'",
    "id": "testing-services-*-angular-161"
  },
  {
    "url": "https://angular.dev/guide/testing/services",
    "title": "Testing services • Angular",
    "chunk": "; const expectedNewName = 'Sally'; const fixture = TestBed.createComponent(InputComponent); fixture.detectChanges(); const comp = fixture.componentInstance; const input = fixture.debugElement.query(By.css('input')).nativeElement as HTMLInputElement; expect(comp.name) .withContext(`At start name should be ${expectedOrigName} `) .toBe(expectedOrigName); // wait until ngModel binds comp.name to input box tick(); expect(input.value) .withContext(`After ngModel updates input box, input.value should b",
    "id": "testing-services-*-angular-162"
  },
  {
    "url": "https://angular.dev/guide/testing/services",
    "title": "Testing services • Angular",
    "chunk": "e ${expectedOrigName} `) .toBe(expectedOrigName); // simulate user entering new name in input input.value = expectedNewName; // that change doesn't flow to the component immediately expect(comp.name) .withContext( `comp.name should still be ${expectedOrigName} after value change, before binding happens`, ) .toBe(expectedOrigName); // Dispatch a DOM event so that Angular learns of input value change. // then wait a tick while ngModel pushes input.box value to comp.name input.dispatchEvent(new Eve",
    "id": "testing-services-*-angular-163"
  },
  {
    "url": "https://angular.dev/guide/testing/services",
    "title": "Testing services • Angular",
    "chunk": "nt('input')); tick(); expect(comp.name) .withContext(`After ngModel updates the model, comp.name should be ${expectedNewName} `) .toBe(expectedNewName); })); it('ReversePipeComp should reverse the input text', fakeAsync(() => { const inputText = 'the quick brown fox.'; const expectedText = '.xof nworb kciuq eht'; const fixture = TestBed.createComponent(ReversePipeComponent); fixture.detectChanges(); const comp = fixture.componentInstance; const input = fixture.debugElement.query(By.css('input'))",
    "id": "testing-services-*-angular-164"
  },
  {
    "url": "https://angular.dev/guide/testing/services",
    "title": "Testing services • Angular",
    "chunk": ".nativeElement as HTMLInputElement; const span = fixture.debugElement.query(By.css('span')).nativeElement as HTMLElement; // simulate user entering new name in input input.value = inputText; // Dispatch a DOM event so that Angular learns of input value change. // then wait a tick while ngModel pushes input.box value to comp.text // and Angular updates the output span input.dispatchEvent(new Event('input')); tick(); fixture.detectChanges(); expect(span.textContent).withContext('output span').toBe",
    "id": "testing-services-*-angular-165"
  },
  {
    "url": "https://angular.dev/guide/testing/services",
    "title": "Testing services • Angular",
    "chunk": "(expectedText); expect(comp.text).withContext('component.text').toBe(inputText); })); // Use this technique to find attached directives of any kind it('can examine attached directives and listeners', () => { const fixture = TestBed.createComponent(InputComponent); fixture.detectChanges(); const inputEl = fixture.debugElement.query(By.css('input')); expect(inputEl.providerTokens).withContext('NgModel directive').toContain(NgModel); const ngControl = inputEl.injector.get(NgControl); expect(ngContr",
    "id": "testing-services-*-angular-166"
  },
  {
    "url": "https://angular.dev/guide/testing/services",
    "title": "Testing services • Angular",
    "chunk": "ol).withContext('NgControl directive').toEqual(jasmine.any(NgControl)); expect(inputEl.listeners.length).withContext('several listeners attached').toBeGreaterThan(2); }); it('BankAccountComponent should set attributes, styles, classes, and properties', () => { const fixture = TestBed.createComponent(BankAccountParentComponent); fixture.detectChanges(); const comp = fixture.componentInstance; // the only child is debugElement of the BankAccount component const el = fixture.debugElement.children[0",
    "id": "testing-services-*-angular-167"
  },
  {
    "url": "https://angular.dev/guide/testing/services",
    "title": "Testing services • Angular",
    "chunk": "]; const childComp = el.componentInstance as BankAccountComponent; expect(childComp).toEqual(jasmine.any(BankAccountComponent)); expect(el.context).withContext('context is the child component').toBe(childComp); expect(el.attributes['account']).withContext('account attribute').toBe(childComp.id); expect(el.attributes['bank']).withContext('bank attribute').toBe(childComp.bank); expect(el.classes['closed']).withContext('closed class').toBe(true); expect(el.classes['open']).withContext('open class')",
    "id": "testing-services-*-angular-168"
  },
  {
    "url": "https://angular.dev/guide/testing/services",
    "title": "Testing services • Angular",
    "chunk": ".toBeFalsy(); expect(el.styles['color']).withContext('color style').toBe(comp.color); expect(el.styles['width']) .withContext('width style') .toBe(comp.width + 'px'); // Removed on 12/02/2016 when ceased public discussion of the `Renderer`. Revive in future? // expect(el.properties['customProperty']).toBe(true, 'customProperty'); }); }); describe('TestBed component overrides:', () => { it(\"should override ChildComp's template\", () => { const fixture = TestBed.configureTestingModule({ imports: [C",
    "id": "testing-services-*-angular-169"
  },
  {
    "url": "https://angular.dev/guide/testing/services",
    "title": "Testing services • Angular",
    "chunk": "hild1Component], }) .overrideComponent(Child1Component, { set: {template: '<span>Fake</span>'}, }) .createComponent(Child1Component); fixture.detectChanges(); expect(fixture).toHaveText('Fake'); }); it(\"should override TestProvidersComp's ValueService provider\", () => { const fixture = TestBed.configureTestingModule({ imports: [TestProvidersComponent], }) .overrideComponent(TestProvidersComponent, { remove: {providers: [ValueService]}, add: {providers: [{provide: ValueService, useClass: FakeValu",
    "id": "testing-services-*-angular-170"
  },
  {
    "url": "https://angular.dev/guide/testing/services",
    "title": "Testing services • Angular",
    "chunk": "eService}]}, // Or replace them all (this component has only one provider) // set: { providers: [{ provide: ValueService, useClass: FakeValueService }] }, }) .createComponent(TestProvidersComponent); fixture.detectChanges(); expect(fixture).toHaveText('injected value: faked value', 'text'); // Explore the providerTokens const tokens = fixture.debugElement.providerTokens; expect(tokens).withContext('component ctor').toContain(fixture.componentInstance.constructor); expect(tokens).withContext('Tes",
    "id": "testing-services-*-angular-171"
  },
  {
    "url": "https://angular.dev/guide/testing/services",
    "title": "Testing services • Angular",
    "chunk": "tProvidersComp').toContain(TestProvidersComponent); expect(tokens).withContext('ValueService').toContain(ValueService); }); it(\"should override TestViewProvidersComp's ValueService viewProvider\", () => { const fixture = TestBed.configureTestingModule({ imports: [TestViewProvidersComponent], }) .overrideComponent(TestViewProvidersComponent, { // remove: { viewProviders: [ValueService]}, // add: { viewProviders: [{ provide: ValueService, useClass: FakeValueService }] // }, // Or replace them all (",
    "id": "testing-services-*-angular-172"
  },
  {
    "url": "https://angular.dev/guide/testing/services",
    "title": "Testing services • Angular",
    "chunk": "this component has only one viewProvider) set: {viewProviders: [{provide: ValueService, useClass: FakeValueService}]}, }) .createComponent(TestViewProvidersComponent); fixture.detectChanges(); expect(fixture).toHaveText('injected value: faked value'); }); it(\"injected provider should not be same as component's provider\", () => { // TestComponent is parent of TestProvidersComponent @Component({ template: '<my-service-comp></my-service-comp>', imports: [TestProvidersComponent], }) class TestCompon",
    "id": "testing-services-*-angular-173"
  },
  {
    "url": "https://angular.dev/guide/testing/services",
    "title": "Testing services • Angular",
    "chunk": "ent {} // 3 levels of ValueService provider: module, TestComponent, TestProvidersComponent const fixture = TestBed.configureTestingModule({ imports: [TestComponent, TestProvidersComponent], providers: [ValueService], }) .overrideComponent(TestComponent, { set: {providers: [{provide: ValueService, useValue: {}}]}, }) .overrideComponent(TestProvidersComponent, { set: {providers: [{provide: ValueService, useClass: FakeValueService}]}, }) .createComponent(TestComponent); let testBedProvider!: ValueS",
    "id": "testing-services-*-angular-174"
  },
  {
    "url": "https://angular.dev/guide/testing/services",
    "title": "Testing services • Angular",
    "chunk": "ervice; // `inject` uses TestBed's injector inject([ValueService], (s: ValueService) => (testBedProvider = s))(); const tcProvider = fixture.debugElement.injector.get(ValueService) as ValueService; const tpcProvider = fixture.debugElement.children[0].injector.get( ValueService, ) as FakeValueService; expect(testBedProvider).withContext('testBed/tc not same providers').not.toBe(tcProvider); expect(testBedProvider).withContext('testBed/tpc not same providers').not.toBe(tpcProvider); expect(testBed",
    "id": "testing-services-*-angular-175"
  },
  {
    "url": "https://angular.dev/guide/testing/services",
    "title": "Testing services • Angular",
    "chunk": "Provider instanceof ValueService) .withContext('testBedProvider is ValueService') .toBe(true); expect(tcProvider) .withContext('tcProvider is {}') .toEqual({} as ValueService); expect(tpcProvider instanceof FakeValueService) .withContext('tpcProvider is FakeValueService') .toBe(true); }); it('can access template local variables as references', () => { const fixture = TestBed.configureTestingModule({ imports: [ ShellComponent, NeedsContentComponent, Child1Component, Child2Component, Child3Compone",
    "id": "testing-services-*-angular-176"
  },
  {
    "url": "https://angular.dev/guide/testing/services",
    "title": "Testing services • Angular",
    "chunk": "nt, ], }) .overrideComponent(ShellComponent, { set: { selector: 'test-shell', imports: [NeedsContentComponent, Child1Component, Child2Component, Child3Component], template: ` <needs-content #nc> <child-1 #content text=\"My\"></child-1> <child-2 #content text=\"dog\"></child-2> <child-2 text=\"has\"></child-2> <child-3 #content text=\"fleas\"></child-3> <div #content>!</div> </needs-content> `, }, }) .createComponent(ShellComponent); fixture.detectChanges(); // NeedsContentComp is the child of ShellComp ",
    "id": "testing-services-*-angular-177"
  },
  {
    "url": "https://angular.dev/guide/testing/services",
    "title": "Testing services • Angular",
    "chunk": "const el = fixture.debugElement.children[0]; const comp = el.componentInstance; expect(comp.children.toArray().length) .withContext('three different child components and an ElementRef with #content') .toBe(4); expect(el.references['nc']).withContext('#nc reference to component').toBe(comp); // Filter for DebugElements with a #content reference const contentRefs = el.queryAll((de) => de.references['content']); expect(contentRefs.length).withContext('elements w/ a #content reference').toBe(4); });",
    "id": "testing-services-*-angular-178"
  },
  {
    "url": "https://angular.dev/guide/testing/services",
    "title": "Testing services • Angular",
    "chunk": " }); describe('nested (one-deep) component override', () => { beforeEach(() => { TestBed.configureTestingModule({ imports: [ParentComponent, FakeChildComponent], }).overrideComponent(ParentComponent, { set: {imports: [FakeChildComponent]}, }); }); it('ParentComp should use Fake Child component', () => { const fixture = TestBed.createComponent(ParentComponent); fixture.detectChanges(); expect(fixture).toHaveText('Parent(Fake Child)'); }); }); describe('nested (two-deep) component override', () =>",
    "id": "testing-services-*-angular-179"
  },
  {
    "url": "https://angular.dev/guide/testing/services",
    "title": "Testing services • Angular",
    "chunk": " { beforeEach(() => { TestBed.configureTestingModule({ imports: [ParentComponent, FakeChildWithGrandchildComponent, FakeGrandchildComponent], }).overrideComponent(ParentComponent, { set: {imports: [FakeChildWithGrandchildComponent, FakeGrandchildComponent]}, }); }); it('should use Fake Grandchild component', () => { const fixture = TestBed.createComponent(ParentComponent); fixture.detectChanges(); expect(fixture).toHaveText('Parent(Fake Child(Fake Grandchild))'); }); });});////////// Fakes /////",
    "id": "testing-services-*-angular-180"
  },
  {
    "url": "https://angular.dev/guide/testing/services",
    "title": "Testing services • Angular",
    "chunk": "//////@Component({ selector: 'child-1', template: 'Fake Child',})class FakeChildComponent {}@Component({ selector: 'grandchild-1', template: 'Fake Grandchild',})class FakeGrandchildComponent {}@Component({ selector: 'child-1', imports: [FakeGrandchildComponent], template: 'Fake Child(<grandchild-1></grandchild-1>)',})class FakeChildWithGrandchildComponent {}@Injectable()class FakeValueService extends ValueService { override value = 'faked value';} The test consumes that spy in the same way it di",
    "id": "testing-services-*-angular-181"
  },
  {
    "url": "https://angular.dev/guide/testing/services",
    "title": "Testing services • Angular",
    "chunk": "d earlier. import {Component, DebugElement, Injectable} from '@angular/core';import { ComponentFixture, fakeAsync, inject, TestBed, tick, waitForAsync,} from '@angular/core/testing';import {FormsModule, NgControl, NgModel} from '@angular/forms';import {By} from '@angular/platform-browser';import {addMatchers, click} from '../../testing';import { BankAccountComponent, BankAccountParentComponent, Child1Component, Child2Component, Child3Component, ExternalTemplateComponent, InputComponent, IoCompon",
    "id": "testing-services-*-angular-182"
  },
  {
    "url": "https://angular.dev/guide/testing/services",
    "title": "Testing services • Angular",
    "chunk": "ent, IoParentComponent, LightswitchComponent, MasterService, MyIfChildComponent, MyIfComponent, MyIfParentComponent, NeedsContentComponent, ParentComponent, ReversePipeComponent, ShellComponent, TestProvidersComponent, TestViewProvidersComponent, ValueService,} from './demo';export class NotProvided extends ValueService { /* example below */}beforeEach(addMatchers);describe('demo (with TestBed):', () => { //////// Service Tests ///////////// describe('ValueService', () => { let service: ValueSer",
    "id": "testing-services-*-angular-183"
  },
  {
    "url": "https://angular.dev/guide/testing/services",
    "title": "Testing services • Angular",
    "chunk": "vice; beforeEach(() => { TestBed.configureTestingModule({providers: [ValueService]}); service = TestBed.inject(ValueService); }); it('should use ValueService', () => { service = TestBed.inject(ValueService); expect(service.getValue()).toBe('real value'); }); it('can inject a default value when service is not provided', () => { expect(TestBed.inject(NotProvided, null)).toBeNull(); }); it('test should wait for ValueService.getPromiseValue', waitForAsync(() => { service.getPromiseValue().then((valu",
    "id": "testing-services-*-angular-184"
  },
  {
    "url": "https://angular.dev/guide/testing/services",
    "title": "Testing services • Angular",
    "chunk": "e) => expect(value).toBe('promise value')); })); it('test should wait for ValueService.getObservableValue', waitForAsync(() => { service.getObservableValue().subscribe((value) => expect(value).toBe('observable value')); })); // Must use done. See https://github.com/angular/angular/issues/10127 it('test should wait for ValueService.getObservableDelayValue', (done: DoneFn) => { service.getObservableDelayValue().subscribe((value) => { expect(value).toBe('observable delay value'); done(); }); }); it",
    "id": "testing-services-*-angular-185"
  },
  {
    "url": "https://angular.dev/guide/testing/services",
    "title": "Testing services • Angular",
    "chunk": "('should allow the use of fakeAsync', fakeAsync(() => { let value: any; service.getPromiseValue().then((val: any) => (value = val)); tick(); // Trigger JS engine cycle until all promises resolve. expect(value).toBe('promise value'); })); }); describe('MasterService', () => { let masterService: MasterService; let valueServiceSpy: jasmine.SpyObj<ValueService>; beforeEach(() => { const spy = jasmine.createSpyObj('ValueService', ['getValue']); TestBed.configureTestingModule({ // Provide both the ser",
    "id": "testing-services-*-angular-186"
  },
  {
    "url": "https://angular.dev/guide/testing/services",
    "title": "Testing services • Angular",
    "chunk": "vice-to-test and its (spy) dependency providers: [MasterService, {provide: ValueService, useValue: spy}], }); // Inject both the service-to-test and its (spy) dependency masterService = TestBed.inject(MasterService); valueServiceSpy = TestBed.inject(ValueService) as jasmine.SpyObj<ValueService>; }); it('#getValue should return stubbed value from a spy', () => { const stubValue = 'stub value'; valueServiceSpy.getValue.and.returnValue(stubValue); expect(masterService.getValue()).withContext('servi",
    "id": "testing-services-*-angular-187"
  },
  {
    "url": "https://angular.dev/guide/testing/services",
    "title": "Testing services • Angular",
    "chunk": "ce returned stub value').toBe(stubValue); expect(valueServiceSpy.getValue.calls.count()) .withContext('spy method was called once') .toBe(1); expect(valueServiceSpy.getValue.calls.mostRecent().returnValue).toBe(stubValue); }); }); describe('use inject within `it`', () => { beforeEach(() => { TestBed.configureTestingModule({providers: [ValueService]}); }); it('should use modified providers', inject([ValueService], (service: ValueService) => { service.setValue('value modified in beforeEach'); expe",
    "id": "testing-services-*-angular-188"
  },
  {
    "url": "https://angular.dev/guide/testing/services",
    "title": "Testing services • Angular",
    "chunk": "ct(service.getValue()).toBe('value modified in beforeEach'); })); }); describe('using waitForAsync(inject) within beforeEach', () => { let serviceValue: string; beforeEach(() => { TestBed.configureTestingModule({providers: [ValueService]}); }); beforeEach(waitForAsync( inject([ValueService], (service: ValueService) => { service.getPromiseValue().then((value) => (serviceValue = value)); }), )); it('should use asynchronously modified value ... in synchronous test', () => { expect(serviceValue).toB",
    "id": "testing-services-*-angular-189"
  },
  {
    "url": "https://angular.dev/guide/testing/services",
    "title": "Testing services • Angular",
    "chunk": "e('promise value'); }); }); /////////// Component Tests ////////////////// describe('TestBed component tests', () => { // beforeEach(waitForAsync(() => { // TestBed.configureTestingModule() // // Compile everything in DemoModule // ; // })); it('should create a component with inline template', () => { const fixture = TestBed.createComponent(Child1Component); fixture.detectChanges(); expect(fixture).toHaveText('Child'); }); it('should create a component with external template', () => { const fixt",
    "id": "testing-services-*-angular-190"
  },
  {
    "url": "https://angular.dev/guide/testing/services",
    "title": "Testing services • Angular",
    "chunk": "ure = TestBed.createComponent(ExternalTemplateComponent); fixture.detectChanges(); expect(fixture).toHaveText('from external template'); }); it('should allow changing members of the component', () => { const fixture = TestBed.createComponent(MyIfComponent); fixture.detectChanges(); expect(fixture).toHaveText('MyIf()'); fixture.componentInstance.showMore = true; fixture.detectChanges(); expect(fixture).toHaveText('MyIf(More)'); }); it('should create a nested component bound to inputs/outputs', ()",
    "id": "testing-services-*-angular-191"
  },
  {
    "url": "https://angular.dev/guide/testing/services",
    "title": "Testing services • Angular",
    "chunk": " => { const fixture = TestBed.createComponent(IoParentComponent); fixture.detectChanges(); const heroes = fixture.debugElement.queryAll(By.css('.hero')); expect(heroes.length).withContext('has heroes').toBeGreaterThan(0); const comp = fixture.componentInstance; const hero = comp.heroes[0]; click(heroes[0]); fixture.detectChanges(); const selected = fixture.debugElement.query(By.css('p')); expect(selected).toHaveText(hero.name); }); it('can access the instance variable of an `*ngFor` row componen",
    "id": "testing-services-*-angular-192"
  },
  {
    "url": "https://angular.dev/guide/testing/services",
    "title": "Testing services • Angular",
    "chunk": "t', () => { const fixture = TestBed.createComponent(IoParentComponent); const comp = fixture.componentInstance; const heroName = comp.heroes[0].name; // first hero's name fixture.detectChanges(); const ngForRow = fixture.debugElement.query(By.directive(IoComponent)); // first hero ngForRow const hero = ngForRow.context.hero; // the hero object passed into the row expect(hero.name).withContext('ngRow.context.hero').toBe(heroName); const rowComp = ngForRow.componentInstance; // jasmine.any is an \"",
    "id": "testing-services-*-angular-193"
  },
  {
    "url": "https://angular.dev/guide/testing/services",
    "title": "Testing services • Angular",
    "chunk": "instance-of-type\" test. expect(rowComp).withContext('component is IoComp').toEqual(jasmine.any(IoComponent)); expect(rowComp.hero.name).withContext('component.hero').toBe(heroName); }); it('should support clicking a button', () => { const fixture = TestBed.createComponent(LightswitchComponent); const btn = fixture.debugElement.query(By.css('button')); const span = fixture.debugElement.query(By.css('span')).nativeElement; fixture.detectChanges(); expect(span.textContent) .withContext('before clic",
    "id": "testing-services-*-angular-194"
  },
  {
    "url": "https://angular.dev/guide/testing/services",
    "title": "Testing services • Angular",
    "chunk": "k') .toMatch(/is off/i); click(btn); fixture.detectChanges(); expect(span.textContent).withContext('after click').toMatch(/is on/i); }); // ngModel is async so we must wait for it with promise-based `whenStable` it('should support entering text in input box (ngModel)', waitForAsync(() => { const expectedOrigName = 'John'; const expectedNewName = 'Sally'; const fixture = TestBed.createComponent(InputComponent); fixture.detectChanges(); const comp = fixture.componentInstance; const input = fixture",
    "id": "testing-services-*-angular-195"
  },
  {
    "url": "https://angular.dev/guide/testing/services",
    "title": "Testing services • Angular",
    "chunk": ".debugElement.query(By.css('input')).nativeElement as HTMLInputElement; expect(comp.name) .withContext(`At start name should be ${expectedOrigName} `) .toBe(expectedOrigName); // wait until ngModel binds comp.name to input box fixture .whenStable() .then(() => { expect(input.value) .withContext( `After ngModel updates input box, input.value should be ${expectedOrigName} `, ) .toBe(expectedOrigName); // simulate user entering new name in input input.value = expectedNewName; // that change doesn't",
    "id": "testing-services-*-angular-196"
  },
  {
    "url": "https://angular.dev/guide/testing/services",
    "title": "Testing services • Angular",
    "chunk": " flow to the component immediately expect(comp.name()) .withContext( `comp.name should still be ${expectedOrigName} after value change, before binding happens`, ) .toBe(expectedOrigName); // Dispatch a DOM event so that Angular learns of input value change. // then wait while ngModel pushes input.box value to comp.name input.dispatchEvent(new Event('input')); return fixture.whenStable(); }) .then(() => { expect(comp.name()) .withContext(`After ngModel updates the model, comp.name should be ${exp",
    "id": "testing-services-*-angular-197"
  },
  {
    "url": "https://angular.dev/guide/testing/services",
    "title": "Testing services • Angular",
    "chunk": "ectedNewName} `) .toBe(expectedNewName); }); })); // fakeAsync version of ngModel input test enables sync test style // synchronous `tick` replaces asynchronous promise-base `whenStable` it('should support entering text in input box (ngModel) - fakeAsync', fakeAsync(() => { const expectedOrigName = 'John'; const expectedNewName = 'Sally'; const fixture = TestBed.createComponent(InputComponent); fixture.detectChanges(); const comp = fixture.componentInstance; const input = fixture.debugElement.qu",
    "id": "testing-services-*-angular-198"
  },
  {
    "url": "https://angular.dev/guide/testing/services",
    "title": "Testing services • Angular",
    "chunk": "ery(By.css('input')).nativeElement as HTMLInputElement; expect(comp.name) .withContext(`At start name should be ${expectedOrigName} `) .toBe(expectedOrigName); // wait until ngModel binds comp.name to input box tick(); expect(input.value) .withContext(`After ngModel updates input box, input.value should be ${expectedOrigName} `) .toBe(expectedOrigName); // simulate user entering new name in input input.value = expectedNewName; // that change doesn't flow to the component immediately expect(comp.",
    "id": "testing-services-*-angular-199"
  },
  {
    "url": "https://angular.dev/guide/testing/services",
    "title": "Testing services • Angular",
    "chunk": "name) .withContext( `comp.name should still be ${expectedOrigName} after value change, before binding happens`, ) .toBe(expectedOrigName); // Dispatch a DOM event so that Angular learns of input value change. // then wait a tick while ngModel pushes input.box value to comp.name input.dispatchEvent(new Event('input')); tick(); expect(comp.name) .withContext(`After ngModel updates the model, comp.name should be ${expectedNewName} `) .toBe(expectedNewName); })); it('ReversePipeComp should reverse t",
    "id": "testing-services-*-angular-200"
  },
  {
    "url": "https://angular.dev/guide/testing/services",
    "title": "Testing services • Angular",
    "chunk": "he input text', fakeAsync(() => { const inputText = 'the quick brown fox.'; const expectedText = '.xof nworb kciuq eht'; const fixture = TestBed.createComponent(ReversePipeComponent); fixture.detectChanges(); const comp = fixture.componentInstance; const input = fixture.debugElement.query(By.css('input')).nativeElement as HTMLInputElement; const span = fixture.debugElement.query(By.css('span')).nativeElement as HTMLElement; // simulate user entering new name in input input.value = inputText; // ",
    "id": "testing-services-*-angular-201"
  },
  {
    "url": "https://angular.dev/guide/testing/services",
    "title": "Testing services • Angular",
    "chunk": "Dispatch a DOM event so that Angular learns of input value change. // then wait a tick while ngModel pushes input.box value to comp.text // and Angular updates the output span input.dispatchEvent(new Event('input')); tick(); fixture.detectChanges(); expect(span.textContent).withContext('output span').toBe(expectedText); expect(comp.text).withContext('component.text').toBe(inputText); })); // Use this technique to find attached directives of any kind it('can examine attached directives and listen",
    "id": "testing-services-*-angular-202"
  },
  {
    "url": "https://angular.dev/guide/testing/services",
    "title": "Testing services • Angular",
    "chunk": "ers', () => { const fixture = TestBed.createComponent(InputComponent); fixture.detectChanges(); const inputEl = fixture.debugElement.query(By.css('input')); expect(inputEl.providerTokens).withContext('NgModel directive').toContain(NgModel); const ngControl = inputEl.injector.get(NgControl); expect(ngControl).withContext('NgControl directive').toEqual(jasmine.any(NgControl)); expect(inputEl.listeners.length).withContext('several listeners attached').toBeGreaterThan(2); }); it('BankAccountComponen",
    "id": "testing-services-*-angular-203"
  },
  {
    "url": "https://angular.dev/guide/testing/services",
    "title": "Testing services • Angular",
    "chunk": "t should set attributes, styles, classes, and properties', () => { const fixture = TestBed.createComponent(BankAccountParentComponent); fixture.detectChanges(); const comp = fixture.componentInstance; // the only child is debugElement of the BankAccount component const el = fixture.debugElement.children[0]; const childComp = el.componentInstance as BankAccountComponent; expect(childComp).toEqual(jasmine.any(BankAccountComponent)); expect(el.context).withContext('context is the child component').",
    "id": "testing-services-*-angular-204"
  },
  {
    "url": "https://angular.dev/guide/testing/services",
    "title": "Testing services • Angular",
    "chunk": "toBe(childComp); expect(el.attributes['account']).withContext('account attribute').toBe(childComp.id); expect(el.attributes['bank']).withContext('bank attribute').toBe(childComp.bank); expect(el.classes['closed']).withContext('closed class').toBe(true); expect(el.classes['open']).withContext('open class').toBeFalsy(); expect(el.styles['color']).withContext('color style').toBe(comp.color); expect(el.styles['width']) .withContext('width style') .toBe(comp.width + 'px'); // Removed on 12/02/2016 wh",
    "id": "testing-services-*-angular-205"
  },
  {
    "url": "https://angular.dev/guide/testing/services",
    "title": "Testing services • Angular",
    "chunk": "en ceased public discussion of the `Renderer`. Revive in future? // expect(el.properties['customProperty']).toBe(true, 'customProperty'); }); }); describe('TestBed component overrides:', () => { it(\"should override ChildComp's template\", () => { const fixture = TestBed.configureTestingModule({ imports: [Child1Component], }) .overrideComponent(Child1Component, { set: {template: '<span>Fake</span>'}, }) .createComponent(Child1Component); fixture.detectChanges(); expect(fixture).toHaveText('Fake');",
    "id": "testing-services-*-angular-206"
  },
  {
    "url": "https://angular.dev/guide/testing/services",
    "title": "Testing services • Angular",
    "chunk": " }); it(\"should override TestProvidersComp's ValueService provider\", () => { const fixture = TestBed.configureTestingModule({ imports: [TestProvidersComponent], }) .overrideComponent(TestProvidersComponent, { remove: {providers: [ValueService]}, add: {providers: [{provide: ValueService, useClass: FakeValueService}]}, // Or replace them all (this component has only one provider) // set: { providers: [{ provide: ValueService, useClass: FakeValueService }] }, }) .createComponent(TestProvidersCompon",
    "id": "testing-services-*-angular-207"
  },
  {
    "url": "https://angular.dev/guide/testing/services",
    "title": "Testing services • Angular",
    "chunk": "ent); fixture.detectChanges(); expect(fixture).toHaveText('injected value: faked value', 'text'); // Explore the providerTokens const tokens = fixture.debugElement.providerTokens; expect(tokens).withContext('component ctor').toContain(fixture.componentInstance.constructor); expect(tokens).withContext('TestProvidersComp').toContain(TestProvidersComponent); expect(tokens).withContext('ValueService').toContain(ValueService); }); it(\"should override TestViewProvidersComp's ValueService viewProvider\"",
    "id": "testing-services-*-angular-208"
  },
  {
    "url": "https://angular.dev/guide/testing/services",
    "title": "Testing services • Angular",
    "chunk": ", () => { const fixture = TestBed.configureTestingModule({ imports: [TestViewProvidersComponent], }) .overrideComponent(TestViewProvidersComponent, { // remove: { viewProviders: [ValueService]}, // add: { viewProviders: [{ provide: ValueService, useClass: FakeValueService }] // }, // Or replace them all (this component has only one viewProvider) set: {viewProviders: [{provide: ValueService, useClass: FakeValueService}]}, }) .createComponent(TestViewProvidersComponent); fixture.detectChanges(); e",
    "id": "testing-services-*-angular-209"
  },
  {
    "url": "https://angular.dev/guide/testing/services",
    "title": "Testing services • Angular",
    "chunk": "xpect(fixture).toHaveText('injected value: faked value'); }); it(\"injected provider should not be same as component's provider\", () => { // TestComponent is parent of TestProvidersComponent @Component({ template: '<my-service-comp></my-service-comp>', imports: [TestProvidersComponent], }) class TestComponent {} // 3 levels of ValueService provider: module, TestComponent, TestProvidersComponent const fixture = TestBed.configureTestingModule({ imports: [TestComponent, TestProvidersComponent], prov",
    "id": "testing-services-*-angular-210"
  },
  {
    "url": "https://angular.dev/guide/testing/services",
    "title": "Testing services • Angular",
    "chunk": "iders: [ValueService], }) .overrideComponent(TestComponent, { set: {providers: [{provide: ValueService, useValue: {}}]}, }) .overrideComponent(TestProvidersComponent, { set: {providers: [{provide: ValueService, useClass: FakeValueService}]}, }) .createComponent(TestComponent); let testBedProvider!: ValueService; // `inject` uses TestBed's injector inject([ValueService], (s: ValueService) => (testBedProvider = s))(); const tcProvider = fixture.debugElement.injector.get(ValueService) as ValueServi",
    "id": "testing-services-*-angular-211"
  },
  {
    "url": "https://angular.dev/guide/testing/services",
    "title": "Testing services • Angular",
    "chunk": "ce; const tpcProvider = fixture.debugElement.children[0].injector.get( ValueService, ) as FakeValueService; expect(testBedProvider).withContext('testBed/tc not same providers').not.toBe(tcProvider); expect(testBedProvider).withContext('testBed/tpc not same providers').not.toBe(tpcProvider); expect(testBedProvider instanceof ValueService) .withContext('testBedProvider is ValueService') .toBe(true); expect(tcProvider) .withContext('tcProvider is {}') .toEqual({} as ValueService); expect(tpcProvide",
    "id": "testing-services-*-angular-212"
  },
  {
    "url": "https://angular.dev/guide/testing/services",
    "title": "Testing services • Angular",
    "chunk": "r instanceof FakeValueService) .withContext('tpcProvider is FakeValueService') .toBe(true); }); it('can access template local variables as references', () => { const fixture = TestBed.configureTestingModule({ imports: [ ShellComponent, NeedsContentComponent, Child1Component, Child2Component, Child3Component, ], }) .overrideComponent(ShellComponent, { set: { selector: 'test-shell', imports: [NeedsContentComponent, Child1Component, Child2Component, Child3Component], template: ` <needs-content #nc>",
    "id": "testing-services-*-angular-213"
  },
  {
    "url": "https://angular.dev/guide/testing/services",
    "title": "Testing services • Angular",
    "chunk": " <child-1 #content text=\"My\"></child-1> <child-2 #content text=\"dog\"></child-2> <child-2 text=\"has\"></child-2> <child-3 #content text=\"fleas\"></child-3> <div #content>!</div> </needs-content> `, }, }) .createComponent(ShellComponent); fixture.detectChanges(); // NeedsContentComp is the child of ShellComp const el = fixture.debugElement.children[0]; const comp = el.componentInstance; expect(comp.children.toArray().length) .withContext('three different child components and an ElementRef with #cont",
    "id": "testing-services-*-angular-214"
  },
  {
    "url": "https://angular.dev/guide/testing/services",
    "title": "Testing services • Angular",
    "chunk": "ent') .toBe(4); expect(el.references['nc']).withContext('#nc reference to component').toBe(comp); // Filter for DebugElements with a #content reference const contentRefs = el.queryAll((de) => de.references['content']); expect(contentRefs.length).withContext('elements w/ a #content reference').toBe(4); }); }); describe('nested (one-deep) component override', () => { beforeEach(() => { TestBed.configureTestingModule({ imports: [ParentComponent, FakeChildComponent], }).overrideComponent(ParentCompo",
    "id": "testing-services-*-angular-215"
  },
  {
    "url": "https://angular.dev/guide/testing/services",
    "title": "Testing services • Angular",
    "chunk": "nent, { set: {imports: [FakeChildComponent]}, }); }); it('ParentComp should use Fake Child component', () => { const fixture = TestBed.createComponent(ParentComponent); fixture.detectChanges(); expect(fixture).toHaveText('Parent(Fake Child)'); }); }); describe('nested (two-deep) component override', () => { beforeEach(() => { TestBed.configureTestingModule({ imports: [ParentComponent, FakeChildWithGrandchildComponent, FakeGrandchildComponent], }).overrideComponent(ParentComponent, { set: {import",
    "id": "testing-services-*-angular-216"
  },
  {
    "url": "https://angular.dev/guide/testing/services",
    "title": "Testing services • Angular",
    "chunk": "s: [FakeChildWithGrandchildComponent, FakeGrandchildComponent]}, }); }); it('should use Fake Grandchild component', () => { const fixture = TestBed.createComponent(ParentComponent); fixture.detectChanges(); expect(fixture).toHaveText('Parent(Fake Child(Fake Grandchild))'); }); });});////////// Fakes ///////////@Component({ selector: 'child-1', template: 'Fake Child',})class FakeChildComponent {}@Component({ selector: 'grandchild-1', template: 'Fake Grandchild',})class FakeGrandchildComponent {}@",
    "id": "testing-services-*-angular-217"
  },
  {
    "url": "https://angular.dev/guide/testing/services",
    "title": "Testing services • Angular",
    "chunk": "Component({ selector: 'child-1', imports: [FakeGrandchildComponent], template: 'Fake Child(<grandchild-1></grandchild-1>)',})class FakeChildWithGrandchildComponent {}@Injectable()class FakeValueService extends ValueService { override value = 'faked value';} Testing without beforeEach() Most test suites in this guide call beforeEach() to set the preconditions for each it() test and rely on the TestBed to create classes and inject services. There's another school of testing that never calls before",
    "id": "testing-services-*-angular-218"
  },
  {
    "url": "https://angular.dev/guide/testing/services",
    "title": "Testing services • Angular",
    "chunk": "Each() and prefers to create classes explicitly rather than use the TestBed. Here's how you might rewrite one of the MasterService tests in that style. Begin by putting re-usable, preparatory code in a setup function instead of beforeEach(). app/demo/demo.spec.ts (setup) import {LightswitchComponent, MasterService, ValueService, ReversePipe} from './demo';///////// Fakes /////////export class FakeValueService extends ValueService { override value = 'faked service value';}////////////////////////",
    "id": "testing-services-*-angular-219"
  },
  {
    "url": "https://angular.dev/guide/testing/services",
    "title": "Testing services • Angular",
    "chunk": "describe('demo (no TestBed):', () => { // Straight Jasmine testing without Angular's testing support describe('ValueService', () => { let service: ValueService; beforeEach(() => { service = new ValueService(); }); it('#getValue should return real value', () => { expect(service.getValue()).toBe('real value'); }); it('#getObservableValue should return value from observable', (done: DoneFn) => { service.getObservableValue().subscribe((value) => { expect(value).toBe('observable value'); done(); }); ",
    "id": "testing-services-*-angular-220"
  },
  {
    "url": "https://angular.dev/guide/testing/services",
    "title": "Testing services • Angular",
    "chunk": "}); it('#getPromiseValue should return value from a promise', (done: DoneFn) => { service.getPromiseValue().then((value) => { expect(value).toBe('promise value'); done(); }); }); }); // MasterService requires injection of a ValueService describe('MasterService without Angular testing support', () => { let masterService: MasterService; it('#getValue should return real value from the real service', () => { masterService = new MasterService(new ValueService()); expect(masterService.getValue()).toBe",
    "id": "testing-services-*-angular-221"
  },
  {
    "url": "https://angular.dev/guide/testing/services",
    "title": "Testing services • Angular",
    "chunk": "('real value'); }); it('#getValue should return faked value from a fakeService', () => { masterService = new MasterService(new FakeValueService()); expect(masterService.getValue()).toBe('faked service value'); }); it('#getValue should return faked value from a fake object', () => { const fake = {getValue: () => 'fake value'}; masterService = new MasterService(fake as ValueService); expect(masterService.getValue()).toBe('fake value'); }); it('#getValue should return stubbed value from a spy', () ",
    "id": "testing-services-*-angular-222"
  },
  {
    "url": "https://angular.dev/guide/testing/services",
    "title": "Testing services • Angular",
    "chunk": "=> { // create `getValue` spy on an object representing the ValueService const valueServiceSpy = jasmine.createSpyObj('ValueService', ['getValue']); // set the value to return when the `getValue` spy is called. const stubValue = 'stub value'; valueServiceSpy.getValue.and.returnValue(stubValue); masterService = new MasterService(valueServiceSpy); expect(masterService.getValue()).withContext('service returned stub value').toBe(stubValue); expect(valueServiceSpy.getValue.calls.count()) .withContext",
    "id": "testing-services-*-angular-223"
  },
  {
    "url": "https://angular.dev/guide/testing/services",
    "title": "Testing services • Angular",
    "chunk": "('spy method was called once') .toBe(1); expect(valueServiceSpy.getValue.calls.mostRecent().returnValue).toBe(stubValue); }); }); describe('MasterService (no beforeEach)', () => { it('#getValue should return stubbed value from a spy', () => { const {masterService, stubValue, valueServiceSpy} = setup(); expect(masterService.getValue()).withContext('service returned stub value').toBe(stubValue); expect(valueServiceSpy.getValue.calls.count()) .withContext('spy method was called once') .toBe(1); exp",
    "id": "testing-services-*-angular-224"
  },
  {
    "url": "https://angular.dev/guide/testing/services",
    "title": "Testing services • Angular",
    "chunk": "ect(valueServiceSpy.getValue.calls.mostRecent().returnValue).toBe(stubValue); }); function setup() { const valueServiceSpy = jasmine.createSpyObj('ValueService', ['getValue']); const stubValue = 'stub value'; const masterService = new MasterService(valueServiceSpy); valueServiceSpy.getValue.and.returnValue(stubValue); return {masterService, stubValue, valueServiceSpy}; } }); describe('ReversePipe', () => { let pipe: ReversePipe; beforeEach(() => { pipe = new ReversePipe(); }); it('transforms \"ab",
    "id": "testing-services-*-angular-225"
  },
  {
    "url": "https://angular.dev/guide/testing/services",
    "title": "Testing services • Angular",
    "chunk": "c\" to \"cba\"', () => { expect(pipe.transform('abc')).toBe('cba'); }); it('no change to palindrome: \"able was I ere I saw elba\"', () => { const palindrome = 'able was I ere I saw elba'; expect(pipe.transform(palindrome)).toBe(palindrome); }); }); describe('LightswitchComp', () => { it('#clicked() should toggle #isOn', () => { const comp = new LightswitchComponent(); expect(comp.isOn).withContext('off at first').toBe(false); comp.clicked(); expect(comp.isOn).withContext('on after click').toBe(true)",
    "id": "testing-services-*-angular-226"
  },
  {
    "url": "https://angular.dev/guide/testing/services",
    "title": "Testing services • Angular",
    "chunk": "; comp.clicked(); expect(comp.isOn).withContext('off after second click').toBe(false); }); it('#clicked() should set #message to \"is on\"', () => { const comp = new LightswitchComponent(); expect(comp.message) .withContext('off at first') .toMatch(/is off/i); comp.clicked(); expect(comp.message).withContext('on after clicked').toMatch(/is on/i); }); });}); The setup() function returns an object literal with the variables, such as masterService, that a test might reference. You don't define semi-g",
    "id": "testing-services-*-angular-227"
  },
  {
    "url": "https://angular.dev/guide/testing/services",
    "title": "Testing services • Angular",
    "chunk": "lobal variables (for example, let masterService: MasterService) in the body of the describe(). Then each test invokes setup() in its first line, before continuing with steps that manipulate the test subject and assert expectations. import {LightswitchComponent, MasterService, ValueService, ReversePipe} from './demo';///////// Fakes /////////export class FakeValueService extends ValueService { override value = 'faked service value';}////////////////////////describe('demo (no TestBed):', () => { /",
    "id": "testing-services-*-angular-228"
  },
  {
    "url": "https://angular.dev/guide/testing/services",
    "title": "Testing services • Angular",
    "chunk": "/ Straight Jasmine testing without Angular's testing support describe('ValueService', () => { let service: ValueService; beforeEach(() => { service = new ValueService(); }); it('#getValue should return real value', () => { expect(service.getValue()).toBe('real value'); }); it('#getObservableValue should return value from observable', (done: DoneFn) => { service.getObservableValue().subscribe((value) => { expect(value).toBe('observable value'); done(); }); }); it('#getPromiseValue should return v",
    "id": "testing-services-*-angular-229"
  },
  {
    "url": "https://angular.dev/guide/testing/services",
    "title": "Testing services • Angular",
    "chunk": "alue from a promise', (done: DoneFn) => { service.getPromiseValue().then((value) => { expect(value).toBe('promise value'); done(); }); }); }); // MasterService requires injection of a ValueService describe('MasterService without Angular testing support', () => { let masterService: MasterService; it('#getValue should return real value from the real service', () => { masterService = new MasterService(new ValueService()); expect(masterService.getValue()).toBe('real value'); }); it('#getValue should",
    "id": "testing-services-*-angular-230"
  },
  {
    "url": "https://angular.dev/guide/testing/services",
    "title": "Testing services • Angular",
    "chunk": " return faked value from a fakeService', () => { masterService = new MasterService(new FakeValueService()); expect(masterService.getValue()).toBe('faked service value'); }); it('#getValue should return faked value from a fake object', () => { const fake = {getValue: () => 'fake value'}; masterService = new MasterService(fake as ValueService); expect(masterService.getValue()).toBe('fake value'); }); it('#getValue should return stubbed value from a spy', () => { // create `getValue` spy on an obje",
    "id": "testing-services-*-angular-231"
  },
  {
    "url": "https://angular.dev/guide/testing/services",
    "title": "Testing services • Angular",
    "chunk": "ct representing the ValueService const valueServiceSpy = jasmine.createSpyObj('ValueService', ['getValue']); // set the value to return when the `getValue` spy is called. const stubValue = 'stub value'; valueServiceSpy.getValue.and.returnValue(stubValue); masterService = new MasterService(valueServiceSpy); expect(masterService.getValue()).withContext('service returned stub value').toBe(stubValue); expect(valueServiceSpy.getValue.calls.count()) .withContext('spy method was called once') .toBe(1);",
    "id": "testing-services-*-angular-232"
  },
  {
    "url": "https://angular.dev/guide/testing/services",
    "title": "Testing services • Angular",
    "chunk": " expect(valueServiceSpy.getValue.calls.mostRecent().returnValue).toBe(stubValue); }); }); describe('MasterService (no beforeEach)', () => { it('#getValue should return stubbed value from a spy', () => { const {masterService, stubValue, valueServiceSpy} = setup(); expect(masterService.getValue()).withContext('service returned stub value').toBe(stubValue); expect(valueServiceSpy.getValue.calls.count()) .withContext('spy method was called once') .toBe(1); expect(valueServiceSpy.getValue.calls.mostR",
    "id": "testing-services-*-angular-233"
  },
  {
    "url": "https://angular.dev/guide/testing/services",
    "title": "Testing services • Angular",
    "chunk": "ecent().returnValue).toBe(stubValue); }); function setup() { const valueServiceSpy = jasmine.createSpyObj('ValueService', ['getValue']); const stubValue = 'stub value'; const masterService = new MasterService(valueServiceSpy); valueServiceSpy.getValue.and.returnValue(stubValue); return {masterService, stubValue, valueServiceSpy}; } }); describe('ReversePipe', () => { let pipe: ReversePipe; beforeEach(() => { pipe = new ReversePipe(); }); it('transforms \"abc\" to \"cba\"', () => { expect(pipe.transf",
    "id": "testing-services-*-angular-234"
  },
  {
    "url": "https://angular.dev/guide/testing/services",
    "title": "Testing services • Angular",
    "chunk": "orm('abc')).toBe('cba'); }); it('no change to palindrome: \"able was I ere I saw elba\"', () => { const palindrome = 'able was I ere I saw elba'; expect(pipe.transform(palindrome)).toBe(palindrome); }); }); describe('LightswitchComp', () => { it('#clicked() should toggle #isOn', () => { const comp = new LightswitchComponent(); expect(comp.isOn).withContext('off at first').toBe(false); comp.clicked(); expect(comp.isOn).withContext('on after click').toBe(true); comp.clicked(); expect(comp.isOn).with",
    "id": "testing-services-*-angular-235"
  },
  {
    "url": "https://angular.dev/guide/testing/services",
    "title": "Testing services • Angular",
    "chunk": "Context('off after second click').toBe(false); }); it('#clicked() should set #message to \"is on\"', () => { const comp = new LightswitchComponent(); expect(comp.message) .withContext('off at first') .toMatch(/is off/i); comp.clicked(); expect(comp.message).withContext('on after clicked').toMatch(/is on/i); }); });}); Notice how the test uses destructuring assignment to extract the setup variables that it needs. import {LightswitchComponent, MasterService, ValueService, ReversePipe} from './demo';",
    "id": "testing-services-*-angular-236"
  },
  {
    "url": "https://angular.dev/guide/testing/services",
    "title": "Testing services • Angular",
    "chunk": "///////// Fakes /////////export class FakeValueService extends ValueService { override value = 'faked service value';}////////////////////////describe('demo (no TestBed):', () => { // Straight Jasmine testing without Angular's testing support describe('ValueService', () => { let service: ValueService; beforeEach(() => { service = new ValueService(); }); it('#getValue should return real value', () => { expect(service.getValue()).toBe('real value'); }); it('#getObservableValue should return value ",
    "id": "testing-services-*-angular-237"
  },
  {
    "url": "https://angular.dev/guide/testing/services",
    "title": "Testing services • Angular",
    "chunk": "from observable', (done: DoneFn) => { service.getObservableValue().subscribe((value) => { expect(value).toBe('observable value'); done(); }); }); it('#getPromiseValue should return value from a promise', (done: DoneFn) => { service.getPromiseValue().then((value) => { expect(value).toBe('promise value'); done(); }); }); }); // MasterService requires injection of a ValueService describe('MasterService without Angular testing support', () => { let masterService: MasterService; it('#getValue should ",
    "id": "testing-services-*-angular-238"
  },
  {
    "url": "https://angular.dev/guide/testing/services",
    "title": "Testing services • Angular",
    "chunk": "return real value from the real service', () => { masterService = new MasterService(new ValueService()); expect(masterService.getValue()).toBe('real value'); }); it('#getValue should return faked value from a fakeService', () => { masterService = new MasterService(new FakeValueService()); expect(masterService.getValue()).toBe('faked service value'); }); it('#getValue should return faked value from a fake object', () => { const fake = {getValue: () => 'fake value'}; masterService = new MasterServ",
    "id": "testing-services-*-angular-239"
  },
  {
    "url": "https://angular.dev/guide/testing/services",
    "title": "Testing services • Angular",
    "chunk": "ice(fake as ValueService); expect(masterService.getValue()).toBe('fake value'); }); it('#getValue should return stubbed value from a spy', () => { // create `getValue` spy on an object representing the ValueService const valueServiceSpy = jasmine.createSpyObj('ValueService', ['getValue']); // set the value to return when the `getValue` spy is called. const stubValue = 'stub value'; valueServiceSpy.getValue.and.returnValue(stubValue); masterService = new MasterService(valueServiceSpy); expect(mas",
    "id": "testing-services-*-angular-240"
  },
  {
    "url": "https://angular.dev/guide/testing/services",
    "title": "Testing services • Angular",
    "chunk": "terService.getValue()).withContext('service returned stub value').toBe(stubValue); expect(valueServiceSpy.getValue.calls.count()) .withContext('spy method was called once') .toBe(1); expect(valueServiceSpy.getValue.calls.mostRecent().returnValue).toBe(stubValue); }); }); describe('MasterService (no beforeEach)', () => { it('#getValue should return stubbed value from a spy', () => { const {masterService, stubValue, valueServiceSpy} = setup(); expect(masterService.getValue()).withContext('service ",
    "id": "testing-services-*-angular-241"
  },
  {
    "url": "https://angular.dev/guide/testing/services",
    "title": "Testing services • Angular",
    "chunk": "returned stub value').toBe(stubValue); expect(valueServiceSpy.getValue.calls.count()) .withContext('spy method was called once') .toBe(1); expect(valueServiceSpy.getValue.calls.mostRecent().returnValue).toBe(stubValue); }); function setup() { const valueServiceSpy = jasmine.createSpyObj('ValueService', ['getValue']); const stubValue = 'stub value'; const masterService = new MasterService(valueServiceSpy); valueServiceSpy.getValue.and.returnValue(stubValue); return {masterService, stubValue, valu",
    "id": "testing-services-*-angular-242"
  },
  {
    "url": "https://angular.dev/guide/testing/services",
    "title": "Testing services • Angular",
    "chunk": "eServiceSpy}; } }); describe('ReversePipe', () => { let pipe: ReversePipe; beforeEach(() => { pipe = new ReversePipe(); }); it('transforms \"abc\" to \"cba\"', () => { expect(pipe.transform('abc')).toBe('cba'); }); it('no change to palindrome: \"able was I ere I saw elba\"', () => { const palindrome = 'able was I ere I saw elba'; expect(pipe.transform(palindrome)).toBe(palindrome); }); }); describe('LightswitchComp', () => { it('#clicked() should toggle #isOn', () => { const comp = new LightswitchComp",
    "id": "testing-services-*-angular-243"
  },
  {
    "url": "https://angular.dev/guide/testing/services",
    "title": "Testing services • Angular",
    "chunk": "onent(); expect(comp.isOn).withContext('off at first').toBe(false); comp.clicked(); expect(comp.isOn).withContext('on after click').toBe(true); comp.clicked(); expect(comp.isOn).withContext('off after second click').toBe(false); }); it('#clicked() should set #message to \"is on\"', () => { const comp = new LightswitchComponent(); expect(comp.message) .withContext('off at first') .toMatch(/is off/i); comp.clicked(); expect(comp.message).withContext('on after clicked').toMatch(/is on/i); }); });}); ",
    "id": "testing-services-*-angular-244"
  },
  {
    "url": "https://angular.dev/guide/testing/services",
    "title": "Testing services • Angular",
    "chunk": "Many developers feel this approach is cleaner and more explicit than the traditional beforeEach() style. Although this testing guide follows the traditional style and the default CLI schematics generate test files with beforeEach() and TestBed, feel free to adopt this alternative approach in your own projects. Testing HTTP services Data services that make HTTP calls to remote servers typically inject and delegate to the Angular HttpClient service for XHR calls. You can test a data service with a",
    "id": "testing-services-*-angular-245"
  },
  {
    "url": "https://angular.dev/guide/testing/services",
    "title": "Testing services • Angular",
    "chunk": "n injected HttpClient spy as you would test any service with a dependency. app/model/hero.service.spec.ts (tests with spies) import {HttpClientTestingModule, HttpTestingController} from '@angular/common/http/testing';// Other importsimport {TestBed} from '@angular/core/testing';import {HttpClient, HttpResponse, HttpErrorResponse} from '@angular/common/http';import {asyncData, asyncError} from '../../testing/async-observable-helpers';import {Hero} from './hero';import {HeroService} from './hero.s",
    "id": "testing-services-*-angular-246"
  },
  {
    "url": "https://angular.dev/guide/testing/services",
    "title": "Testing services • Angular",
    "chunk": "ervice';describe('HeroesService (with spies)', () => { let httpClientSpy: jasmine.SpyObj<HttpClient>; let heroService: HeroService; beforeEach(() => { // TODO: spy on other methods too httpClientSpy = jasmine.createSpyObj('HttpClient', ['get']); heroService = new HeroService(httpClientSpy); }); it('should return expected heroes (HttpClient called once)', (done: DoneFn) => { const expectedHeroes: Hero[] = [ {id: 1, name: 'A'}, {id: 2, name: 'B'}, ]; httpClientSpy.get.and.returnValue(asyncData(exp",
    "id": "testing-services-*-angular-247"
  },
  {
    "url": "https://angular.dev/guide/testing/services",
    "title": "Testing services • Angular",
    "chunk": "ectedHeroes)); heroService.getHeroes().subscribe({ next: (heroes) => { expect(heroes).withContext('expected heroes').toEqual(expectedHeroes); done(); }, error: done.fail, }); expect(httpClientSpy.get.calls.count()).withContext('one call').toBe(1); }); it('should return an error when the server returns a 404', (done: DoneFn) => { const errorResponse = new HttpErrorResponse({ error: 'test 404 error', status: 404, statusText: 'Not Found', }); httpClientSpy.get.and.returnValue(asyncError(errorRespon",
    "id": "testing-services-*-angular-248"
  },
  {
    "url": "https://angular.dev/guide/testing/services",
    "title": "Testing services • Angular",
    "chunk": "se)); heroService.getHeroes().subscribe({ next: (heroes) => done.fail('expected an error, not heroes'), error: (error) => { expect(error.message).toContain('test 404 error'); done(); }, }); });});describe('HeroesService (with mocks)', () => { let httpClient: HttpClient; let httpTestingController: HttpTestingController; let heroService: HeroService; beforeEach(() => { TestBed.configureTestingModule({ // Import the HttpClient mocking services imports: [HttpClientTestingModule], // Provide the serv",
    "id": "testing-services-*-angular-249"
  },
  {
    "url": "https://angular.dev/guide/testing/services",
    "title": "Testing services • Angular",
    "chunk": "ice-under-test providers: [HeroService], }); // Inject the http, test controller, and service-under-test // as they will be referenced by each test. httpClient = TestBed.inject(HttpClient); httpTestingController = TestBed.inject(HttpTestingController); heroService = TestBed.inject(HeroService); }); afterEach(() => { // After every test, assert that there are no more pending requests. httpTestingController.verify(); }); /// HeroService method tests begin /// describe('#getHeroes', () => { let exp",
    "id": "testing-services-*-angular-250"
  },
  {
    "url": "https://angular.dev/guide/testing/services",
    "title": "Testing services • Angular",
    "chunk": "ectedHeroes: Hero[]; beforeEach(() => { heroService = TestBed.inject(HeroService); expectedHeroes = [ {id: 1, name: 'A'}, {id: 2, name: 'B'}, ] as Hero[]; }); it('should return expected heroes (called once)', () => { heroService.getHeroes().subscribe({ next: (heroes) => expect(heroes).withContext('should return expected heroes').toEqual(expectedHeroes), error: fail, }); // HeroService should have made one request to GET heroes from expected URL const req = httpTestingController.expectOne(heroSer",
    "id": "testing-services-*-angular-251"
  },
  {
    "url": "https://angular.dev/guide/testing/services",
    "title": "Testing services • Angular",
    "chunk": "vice.heroesUrl); expect(req.request.method).toEqual('GET'); // Respond with the mock heroes req.flush(expectedHeroes); }); it('should be OK returning no heroes', () => { heroService.getHeroes().subscribe({ next: (heroes) => expect(heroes.length).withContext('should have empty heroes array').toEqual(0), error: fail, }); const req = httpTestingController.expectOne(heroService.heroesUrl); req.flush([]); // Respond with no heroes }); it('should turn 404 into a user-friendly error', () => { const msg",
    "id": "testing-services-*-angular-252"
  },
  {
    "url": "https://angular.dev/guide/testing/services",
    "title": "Testing services • Angular",
    "chunk": " = 'Deliberate 404'; heroService.getHeroes().subscribe({ next: (heroes) => fail('expected to fail'), error: (error) => expect(error.message).toContain(msg), }); const req = httpTestingController.expectOne(heroService.heroesUrl); // respond with a 404 and the error message in the body req.flush(msg, {status: 404, statusText: 'Not Found'}); }); it('should return expected heroes (called multiple times)', () => { heroService.getHeroes().subscribe(); heroService.getHeroes().subscribe(); heroService.g",
    "id": "testing-services-*-angular-253"
  },
  {
    "url": "https://angular.dev/guide/testing/services",
    "title": "Testing services • Angular",
    "chunk": "etHeroes().subscribe({ next: (heroes) => expect(heroes).withContext('should return expected heroes').toEqual(expectedHeroes), error: fail, }); const requests = httpTestingController.match(heroService.heroesUrl); expect(requests.length).withContext('calls to getHeroes()').toEqual(3); // Respond to each request with different mock hero results requests[0].flush([]); requests[1].flush([{id: 1, name: 'bob'}]); requests[2].flush(expectedHeroes); }); }); describe('#updateHero', () => { // Expecting th",
    "id": "testing-services-*-angular-254"
  },
  {
    "url": "https://angular.dev/guide/testing/services",
    "title": "Testing services • Angular",
    "chunk": "e query form of URL so should not 404 when id not found const makeUrl = (id: number) => `${heroService.heroesUrl}/?id=${id}`; it('should update a hero and return it', () => { const updateHero: Hero = {id: 1, name: 'A'}; heroService.updateHero(updateHero).subscribe({ next: (data) => expect(data).withContext('should return the hero').toEqual(updateHero), error: fail, }); // HeroService should have made one request to PUT hero const req = httpTestingController.expectOne(heroService.heroesUrl); expe",
    "id": "testing-services-*-angular-255"
  },
  {
    "url": "https://angular.dev/guide/testing/services",
    "title": "Testing services • Angular",
    "chunk": "ct(req.request.method).toEqual('PUT'); expect(req.request.body).toEqual(updateHero); // Expect server to return the hero after PUT const expectedResponse = new HttpResponse({ status: 200, statusText: 'OK', body: updateHero, }); req.event(expectedResponse); }); it('should turn 404 error into user-facing error', () => { const msg = 'Deliberate 404'; const updateHero: Hero = {id: 1, name: 'A'}; heroService.updateHero(updateHero).subscribe({ next: (heroes) => fail('expected to fail'), error: (error)",
    "id": "testing-services-*-angular-256"
  },
  {
    "url": "https://angular.dev/guide/testing/services",
    "title": "Testing services • Angular",
    "chunk": " => expect(error.message).toContain(msg), }); const req = httpTestingController.expectOne(heroService.heroesUrl); // respond with a 404 and the error message in the body req.flush(msg, {status: 404, statusText: 'Not Found'}); }); it('should turn network error into user-facing error', (done) => { // Create mock ProgressEvent with type `error`, raised when something goes wrong at // the network level. Connection timeout, DNS error, offline, etc. const errorEvent = new ProgressEvent('error'); const",
    "id": "testing-services-*-angular-257"
  },
  {
    "url": "https://angular.dev/guide/testing/services",
    "title": "Testing services • Angular",
    "chunk": " updateHero: Hero = {id: 1, name: 'A'}; heroService.updateHero(updateHero).subscribe({ next: (heroes) => fail('expected to fail'), error: (error) => { expect(error).toBe(errorEvent); done(); }, }); const req = httpTestingController.expectOne(heroService.heroesUrl); // Respond with mock error req.error(errorEvent); }); }); // TODO: test other HeroService methods}); IMPORTANT: The HeroService methods return Observables. You must subscribe to an observable to (a) cause it to execute and (b) assert ",
    "id": "testing-services-*-angular-258"
  },
  {
    "url": "https://angular.dev/guide/testing/services",
    "title": "Testing services • Angular",
    "chunk": "that the method succeeds or fails. The subscribe() method takes a success (next) and fail (error) callback. Make sure you provide both callbacks so that you capture errors. Neglecting to do so produces an asynchronous uncaught observable error that the test runner will likely attribute to a completely different test. HttpClientTestingModule Extended interactions between a data service and the HttpClient can be complex and difficult to mock with spies. The HttpClientTestingModule can make these t",
    "id": "testing-services-*-angular-259"
  },
  {
    "url": "https://angular.dev/guide/testing/services",
    "title": "Testing services • Angular",
    "chunk": "esting scenarios more manageable. While the code sample accompanying this guide demonstrates HttpClientTestingModule, this page defers to the Http guide, which covers testing with the HttpClientTestingModule in detail. Social MediaBlogX (formerly Twitter)BlueskyYouTube Discord GitHub Stack Overflow Community Contribute Code of Conduct Report Issues Google's DevLibrary Angular Google Developer Experts ResourcesPress KitRoadmapLanguages简体中文版正體中文版日本語版한국어 Ελληνικά Super-powered by Google ©2010-2025.",
    "id": "testing-services-*-angular-260"
  },
  {
    "url": "https://angular.dev/guide/testing/services",
    "title": "Testing services • Angular",
    "chunk": " Code licensed under an MIT-style License . Documentation licensed under CC BY 4.0 .",
    "id": "testing-services-*-angular-261"
  },
  {
    "url": "https://angular.dev/guide/testing/components-basics",
    "title": "Basics of testing components • Angular",
    "chunk": "In-depth GuidesTesting Basics of testing components A component, unlike all other parts of an Angular application, combines an HTML template and a TypeScript class. The component truly is the template and the class working together. To adequately test a component, you should test that they work together as intended. Such tests require creating the component's host element in the browser DOM, as Angular does, and investigating the component class's interaction with the DOM as described by its tem",
    "id": "basics-of-testing-components-*-angular-0"
  },
  {
    "url": "https://angular.dev/guide/testing/components-basics",
    "title": "Basics of testing components • Angular",
    "chunk": "plate. The Angular TestBed facilitates this kind of testing as you'll see in the following sections. But in many cases, testing the component class alone, without DOM involvement, can validate much of the component's behavior in a straightforward, more obvious way. On this pagearrow_upward_alt Back to the top Component DOM testing A component is more than just its class. A component interacts with the DOM and with other components. Classes alone cannot tell you if the component is going to rende",
    "id": "basics-of-testing-components-*-angular-1"
  },
  {
    "url": "https://angular.dev/guide/testing/components-basics",
    "title": "Basics of testing components • Angular",
    "chunk": "r properly, respond to user input and gestures, or integrate with its parent and child components. Is Lightswitch.clicked() bound to anything such that the user can invoke it? Is the Lightswitch.message displayed? Can the user actually select the hero displayed by DashboardHeroComponent? Is the hero name displayed as expected (such as uppercase)? Is the welcome message displayed by the template of WelcomeComponent? These might not be troubling questions for the preceding simple components illust",
    "id": "basics-of-testing-components-*-angular-2"
  },
  {
    "url": "https://angular.dev/guide/testing/components-basics",
    "title": "Basics of testing components • Angular",
    "chunk": "rated. But many components have complex interactions with the DOM elements described in their templates, causing HTML to appear and disappear as the component state changes. To answer these kinds of questions, you have to create the DOM elements associated with the components, you must examine the DOM to confirm that component state displays properly at the appropriate times, and you must simulate user interaction with the screen to determine whether those interactions cause the component to beh",
    "id": "basics-of-testing-components-*-angular-3"
  },
  {
    "url": "https://angular.dev/guide/testing/components-basics",
    "title": "Basics of testing components • Angular",
    "chunk": "ave as expected. To write these kinds of test, you'll use additional features of the TestBed as well as other testing helpers. CLI-generated tests The CLI creates an initial test file for you by default when you ask it to generate a new component. For example, the following CLI command generates a BannerComponent in the app/banner folder (with inline template and styles): ng generate component banner --inline-template --inline-style --module app It also generates an initial test file for the com",
    "id": "basics-of-testing-components-*-angular-4"
  },
  {
    "url": "https://angular.dev/guide/testing/components-basics",
    "title": "Basics of testing components • Angular",
    "chunk": "ponent, banner-external.component.spec.ts, that looks like this: app/banner/banner-external.component.spec.ts (initial) import {DebugElement} from '@angular/core';import {ComponentFixture, TestBed, waitForAsync} from '@angular/core/testing';import {By} from '@angular/platform-browser';import {BannerComponent} from './banner-initial.component';/*import { BannerComponent } from './banner.component';describe('BannerComponent', () => {*/describe('BannerComponent (initial CLI generated)', () => { let",
    "id": "basics-of-testing-components-*-angular-5"
  },
  {
    "url": "https://angular.dev/guide/testing/components-basics",
    "title": "Basics of testing components • Angular",
    "chunk": " component: BannerComponent; let fixture: ComponentFixture<BannerComponent>; beforeEach(waitForAsync(() => { TestBed.configureTestingModule({imports: [BannerComponent]}); })); beforeEach(() => { fixture = TestBed.createComponent(BannerComponent); component = fixture.componentInstance; fixture.detectChanges(); }); it('should create', () => { expect(component).toBeDefined(); });});describe('BannerComponent (minimal)', () => { it('should create', () => { TestBed.configureTestingModule({imports: [Ba",
    "id": "basics-of-testing-components-*-angular-6"
  },
  {
    "url": "https://angular.dev/guide/testing/components-basics",
    "title": "Basics of testing components • Angular",
    "chunk": "nnerComponent]}); const fixture = TestBed.createComponent(BannerComponent); const component = fixture.componentInstance; expect(component).toBeDefined(); });});describe('BannerComponent (with beforeEach)', () => { let component: BannerComponent; let fixture: ComponentFixture<BannerComponent>; beforeEach(() => { TestBed.configureTestingModule({imports: [BannerComponent]}); fixture = TestBed.createComponent(BannerComponent); component = fixture.componentInstance; }); it('should create', () => { ex",
    "id": "basics-of-testing-components-*-angular-7"
  },
  {
    "url": "https://angular.dev/guide/testing/components-basics",
    "title": "Basics of testing components • Angular",
    "chunk": "pect(component).toBeDefined(); }); it('should contain \"banner works!\"', () => { const bannerElement: HTMLElement = fixture.nativeElement; expect(bannerElement.textContent).toContain('banner works!'); }); it('should have <p> with \"banner works!\"', () => { const bannerElement: HTMLElement = fixture.nativeElement; const p = bannerElement.querySelector('p')!; expect(p.textContent).toEqual('banner works!'); }); it('should find the <p> with fixture.debugElement.nativeElement', () => { const bannerDe: ",
    "id": "basics-of-testing-components-*-angular-8"
  },
  {
    "url": "https://angular.dev/guide/testing/components-basics",
    "title": "Basics of testing components • Angular",
    "chunk": "DebugElement = fixture.debugElement; const bannerEl: HTMLElement = bannerDe.nativeElement; const p = bannerEl.querySelector('p')!; expect(p.textContent).toEqual('banner works!'); }); it('should find the <p> with fixture.debugElement.query(By.css)', () => { const bannerDe: DebugElement = fixture.debugElement; const paragraphDe = bannerDe.query(By.css('p')); const p: HTMLElement = paragraphDe.nativeElement; expect(p.textContent).toEqual('banner works!'); });}); HELPFUL: Because compileComponents i",
    "id": "basics-of-testing-components-*-angular-9"
  },
  {
    "url": "https://angular.dev/guide/testing/components-basics",
    "title": "Basics of testing components • Angular",
    "chunk": "s asynchronous, it uses the waitForAsync utility function imported from @angular/core/testing. Refer to the waitForAsync section for more details. Reduce the setup Only the last three lines of this file actually test the component and all they do is assert that Angular can create the component. The rest of the file is boilerplate setup code anticipating more advanced tests that might become necessary if the component evolves into something substantial. You'll learn about these advanced test feat",
    "id": "basics-of-testing-components-*-angular-10"
  },
  {
    "url": "https://angular.dev/guide/testing/components-basics",
    "title": "Basics of testing components • Angular",
    "chunk": "ures in the following sections. For now, you can radically reduce this test file to a more manageable size: app/banner/banner-initial.component.spec.ts (minimal) import {DebugElement} from '@angular/core';import {ComponentFixture, TestBed, waitForAsync} from '@angular/core/testing';import {By} from '@angular/platform-browser';import {BannerComponent} from './banner-initial.component';/*import { BannerComponent } from './banner.component';describe('BannerComponent', () => {*/describe('BannerCompo",
    "id": "basics-of-testing-components-*-angular-11"
  },
  {
    "url": "https://angular.dev/guide/testing/components-basics",
    "title": "Basics of testing components • Angular",
    "chunk": "nent (initial CLI generated)', () => { let component: BannerComponent; let fixture: ComponentFixture<BannerComponent>; beforeEach(waitForAsync(() => { TestBed.configureTestingModule({imports: [BannerComponent]}); })); beforeEach(() => { fixture = TestBed.createComponent(BannerComponent); component = fixture.componentInstance; fixture.detectChanges(); }); it('should create', () => { expect(component).toBeDefined(); });});describe('BannerComponent (minimal)', () => { it('should create', () => { Te",
    "id": "basics-of-testing-components-*-angular-12"
  },
  {
    "url": "https://angular.dev/guide/testing/components-basics",
    "title": "Basics of testing components • Angular",
    "chunk": "stBed.configureTestingModule({imports: [BannerComponent]}); const fixture = TestBed.createComponent(BannerComponent); const component = fixture.componentInstance; expect(component).toBeDefined(); });});describe('BannerComponent (with beforeEach)', () => { let component: BannerComponent; let fixture: ComponentFixture<BannerComponent>; beforeEach(() => { TestBed.configureTestingModule({imports: [BannerComponent]}); fixture = TestBed.createComponent(BannerComponent); component = fixture.componentIn",
    "id": "basics-of-testing-components-*-angular-13"
  },
  {
    "url": "https://angular.dev/guide/testing/components-basics",
    "title": "Basics of testing components • Angular",
    "chunk": "stance; }); it('should create', () => { expect(component).toBeDefined(); }); it('should contain \"banner works!\"', () => { const bannerElement: HTMLElement = fixture.nativeElement; expect(bannerElement.textContent).toContain('banner works!'); }); it('should have <p> with \"banner works!\"', () => { const bannerElement: HTMLElement = fixture.nativeElement; const p = bannerElement.querySelector('p')!; expect(p.textContent).toEqual('banner works!'); }); it('should find the <p> with fixture.debugElemen",
    "id": "basics-of-testing-components-*-angular-14"
  },
  {
    "url": "https://angular.dev/guide/testing/components-basics",
    "title": "Basics of testing components • Angular",
    "chunk": "t.nativeElement', () => { const bannerDe: DebugElement = fixture.debugElement; const bannerEl: HTMLElement = bannerDe.nativeElement; const p = bannerEl.querySelector('p')!; expect(p.textContent).toEqual('banner works!'); }); it('should find the <p> with fixture.debugElement.query(By.css)', () => { const bannerDe: DebugElement = fixture.debugElement; const paragraphDe = bannerDe.query(By.css('p')); const p: HTMLElement = paragraphDe.nativeElement; expect(p.textContent).toEqual('banner works!'); }",
    "id": "basics-of-testing-components-*-angular-15"
  },
  {
    "url": "https://angular.dev/guide/testing/components-basics",
    "title": "Basics of testing components • Angular",
    "chunk": ");}); In this example, the metadata object passed to TestBed.configureTestingModule simply declares BannerComponent, the component to test. import {DebugElement} from '@angular/core';import {ComponentFixture, TestBed, waitForAsync} from '@angular/core/testing';import {By} from '@angular/platform-browser';import {BannerComponent} from './banner-initial.component';/*import { BannerComponent } from './banner.component';describe('BannerComponent', () => {*/describe('BannerComponent (initial CLI gene",
    "id": "basics-of-testing-components-*-angular-16"
  },
  {
    "url": "https://angular.dev/guide/testing/components-basics",
    "title": "Basics of testing components • Angular",
    "chunk": "rated)', () => { let component: BannerComponent; let fixture: ComponentFixture<BannerComponent>; beforeEach(waitForAsync(() => { TestBed.configureTestingModule({imports: [BannerComponent]}); })); beforeEach(() => { fixture = TestBed.createComponent(BannerComponent); component = fixture.componentInstance; fixture.detectChanges(); }); it('should create', () => { expect(component).toBeDefined(); });});describe('BannerComponent (minimal)', () => { it('should create', () => { TestBed.configureTesting",
    "id": "basics-of-testing-components-*-angular-17"
  },
  {
    "url": "https://angular.dev/guide/testing/components-basics",
    "title": "Basics of testing components • Angular",
    "chunk": "Module({imports: [BannerComponent]}); const fixture = TestBed.createComponent(BannerComponent); const component = fixture.componentInstance; expect(component).toBeDefined(); });});describe('BannerComponent (with beforeEach)', () => { let component: BannerComponent; let fixture: ComponentFixture<BannerComponent>; beforeEach(() => { TestBed.configureTestingModule({imports: [BannerComponent]}); fixture = TestBed.createComponent(BannerComponent); component = fixture.componentInstance; }); it('should",
    "id": "basics-of-testing-components-*-angular-18"
  },
  {
    "url": "https://angular.dev/guide/testing/components-basics",
    "title": "Basics of testing components • Angular",
    "chunk": " create', () => { expect(component).toBeDefined(); }); it('should contain \"banner works!\"', () => { const bannerElement: HTMLElement = fixture.nativeElement; expect(bannerElement.textContent).toContain('banner works!'); }); it('should have <p> with \"banner works!\"', () => { const bannerElement: HTMLElement = fixture.nativeElement; const p = bannerElement.querySelector('p')!; expect(p.textContent).toEqual('banner works!'); }); it('should find the <p> with fixture.debugElement.nativeElement', () =",
    "id": "basics-of-testing-components-*-angular-19"
  },
  {
    "url": "https://angular.dev/guide/testing/components-basics",
    "title": "Basics of testing components • Angular",
    "chunk": "> { const bannerDe: DebugElement = fixture.debugElement; const bannerEl: HTMLElement = bannerDe.nativeElement; const p = bannerEl.querySelector('p')!; expect(p.textContent).toEqual('banner works!'); }); it('should find the <p> with fixture.debugElement.query(By.css)', () => { const bannerDe: DebugElement = fixture.debugElement; const paragraphDe = bannerDe.query(By.css('p')); const p: HTMLElement = paragraphDe.nativeElement; expect(p.textContent).toEqual('banner works!'); });}); HELPFUL: There's",
    "id": "basics-of-testing-components-*-angular-20"
  },
  {
    "url": "https://angular.dev/guide/testing/components-basics",
    "title": "Basics of testing components • Angular",
    "chunk": " no need to declare or import anything else. The default test module is pre-configured with something like the BrowserModule from @angular/platform-browser. Later you'll call TestBed.configureTestingModule() with imports, providers, and more declarations to suit your testing needs. Optional override methods can further fine-tune aspects of the configuration. createComponent() After configuring TestBed, you call its createComponent() method. import {DebugElement} from '@angular/core';import {Comp",
    "id": "basics-of-testing-components-*-angular-21"
  },
  {
    "url": "https://angular.dev/guide/testing/components-basics",
    "title": "Basics of testing components • Angular",
    "chunk": "onentFixture, TestBed, waitForAsync} from '@angular/core/testing';import {By} from '@angular/platform-browser';import {BannerComponent} from './banner-initial.component';/*import { BannerComponent } from './banner.component';describe('BannerComponent', () => {*/describe('BannerComponent (initial CLI generated)', () => { let component: BannerComponent; let fixture: ComponentFixture<BannerComponent>; beforeEach(waitForAsync(() => { TestBed.configureTestingModule({imports: [BannerComponent]}); }));",
    "id": "basics-of-testing-components-*-angular-22"
  },
  {
    "url": "https://angular.dev/guide/testing/components-basics",
    "title": "Basics of testing components • Angular",
    "chunk": " beforeEach(() => { fixture = TestBed.createComponent(BannerComponent); component = fixture.componentInstance; fixture.detectChanges(); }); it('should create', () => { expect(component).toBeDefined(); });});describe('BannerComponent (minimal)', () => { it('should create', () => { TestBed.configureTestingModule({imports: [BannerComponent]}); const fixture = TestBed.createComponent(BannerComponent); const component = fixture.componentInstance; expect(component).toBeDefined(); });});describe('Banne",
    "id": "basics-of-testing-components-*-angular-23"
  },
  {
    "url": "https://angular.dev/guide/testing/components-basics",
    "title": "Basics of testing components • Angular",
    "chunk": "rComponent (with beforeEach)', () => { let component: BannerComponent; let fixture: ComponentFixture<BannerComponent>; beforeEach(() => { TestBed.configureTestingModule({imports: [BannerComponent]}); fixture = TestBed.createComponent(BannerComponent); component = fixture.componentInstance; }); it('should create', () => { expect(component).toBeDefined(); }); it('should contain \"banner works!\"', () => { const bannerElement: HTMLElement = fixture.nativeElement; expect(bannerElement.textContent).toC",
    "id": "basics-of-testing-components-*-angular-24"
  },
  {
    "url": "https://angular.dev/guide/testing/components-basics",
    "title": "Basics of testing components • Angular",
    "chunk": "ontain('banner works!'); }); it('should have <p> with \"banner works!\"', () => { const bannerElement: HTMLElement = fixture.nativeElement; const p = bannerElement.querySelector('p')!; expect(p.textContent).toEqual('banner works!'); }); it('should find the <p> with fixture.debugElement.nativeElement', () => { const bannerDe: DebugElement = fixture.debugElement; const bannerEl: HTMLElement = bannerDe.nativeElement; const p = bannerEl.querySelector('p')!; expect(p.textContent).toEqual('banner works!",
    "id": "basics-of-testing-components-*-angular-25"
  },
  {
    "url": "https://angular.dev/guide/testing/components-basics",
    "title": "Basics of testing components • Angular",
    "chunk": "'); }); it('should find the <p> with fixture.debugElement.query(By.css)', () => { const bannerDe: DebugElement = fixture.debugElement; const paragraphDe = bannerDe.query(By.css('p')); const p: HTMLElement = paragraphDe.nativeElement; expect(p.textContent).toEqual('banner works!'); });}); TestBed.createComponent() creates an instance of the BannerComponent, adds a corresponding element to the test-runner DOM, and returns a ComponentFixture. IMPORTANT: Do not re-configure TestBed after calling cre",
    "id": "basics-of-testing-components-*-angular-26"
  },
  {
    "url": "https://angular.dev/guide/testing/components-basics",
    "title": "Basics of testing components • Angular",
    "chunk": "ateComponent. The createComponent method freezes the current TestBed definition, closing it to further configuration. You cannot call any more TestBed configuration methods, not configureTestingModule(), nor get(), nor any of the override... methods. If you try, TestBed throws an error. ComponentFixture The ComponentFixture is a test harness for interacting with the created component and its corresponding element. Access the component instance through the fixture and confirm it exists with a Jas",
    "id": "basics-of-testing-components-*-angular-27"
  },
  {
    "url": "https://angular.dev/guide/testing/components-basics",
    "title": "Basics of testing components • Angular",
    "chunk": "mine expectation: import {DebugElement} from '@angular/core';import {ComponentFixture, TestBed, waitForAsync} from '@angular/core/testing';import {By} from '@angular/platform-browser';import {BannerComponent} from './banner-initial.component';/*import { BannerComponent } from './banner.component';describe('BannerComponent', () => {*/describe('BannerComponent (initial CLI generated)', () => { let component: BannerComponent; let fixture: ComponentFixture<BannerComponent>; beforeEach(waitForAsync((",
    "id": "basics-of-testing-components-*-angular-28"
  },
  {
    "url": "https://angular.dev/guide/testing/components-basics",
    "title": "Basics of testing components • Angular",
    "chunk": ") => { TestBed.configureTestingModule({imports: [BannerComponent]}); })); beforeEach(() => { fixture = TestBed.createComponent(BannerComponent); component = fixture.componentInstance; fixture.detectChanges(); }); it('should create', () => { expect(component).toBeDefined(); });});describe('BannerComponent (minimal)', () => { it('should create', () => { TestBed.configureTestingModule({imports: [BannerComponent]}); const fixture = TestBed.createComponent(BannerComponent); const component = fixture.",
    "id": "basics-of-testing-components-*-angular-29"
  },
  {
    "url": "https://angular.dev/guide/testing/components-basics",
    "title": "Basics of testing components • Angular",
    "chunk": "componentInstance; expect(component).toBeDefined(); });});describe('BannerComponent (with beforeEach)', () => { let component: BannerComponent; let fixture: ComponentFixture<BannerComponent>; beforeEach(() => { TestBed.configureTestingModule({imports: [BannerComponent]}); fixture = TestBed.createComponent(BannerComponent); component = fixture.componentInstance; }); it('should create', () => { expect(component).toBeDefined(); }); it('should contain \"banner works!\"', () => { const bannerElement: H",
    "id": "basics-of-testing-components-*-angular-30"
  },
  {
    "url": "https://angular.dev/guide/testing/components-basics",
    "title": "Basics of testing components • Angular",
    "chunk": "TMLElement = fixture.nativeElement; expect(bannerElement.textContent).toContain('banner works!'); }); it('should have <p> with \"banner works!\"', () => { const bannerElement: HTMLElement = fixture.nativeElement; const p = bannerElement.querySelector('p')!; expect(p.textContent).toEqual('banner works!'); }); it('should find the <p> with fixture.debugElement.nativeElement', () => { const bannerDe: DebugElement = fixture.debugElement; const bannerEl: HTMLElement = bannerDe.nativeElement; const p = b",
    "id": "basics-of-testing-components-*-angular-31"
  },
  {
    "url": "https://angular.dev/guide/testing/components-basics",
    "title": "Basics of testing components • Angular",
    "chunk": "annerEl.querySelector('p')!; expect(p.textContent).toEqual('banner works!'); }); it('should find the <p> with fixture.debugElement.query(By.css)', () => { const bannerDe: DebugElement = fixture.debugElement; const paragraphDe = bannerDe.query(By.css('p')); const p: HTMLElement = paragraphDe.nativeElement; expect(p.textContent).toEqual('banner works!'); });}); beforeEach() You will add more tests as this component evolves. Rather than duplicate the TestBed configuration for each test, you refacto",
    "id": "basics-of-testing-components-*-angular-32"
  },
  {
    "url": "https://angular.dev/guide/testing/components-basics",
    "title": "Basics of testing components • Angular",
    "chunk": "r to pull the setup into a Jasmine beforeEach() and some supporting variables: import {DebugElement} from '@angular/core';import {ComponentFixture, TestBed, waitForAsync} from '@angular/core/testing';import {By} from '@angular/platform-browser';import {BannerComponent} from './banner-initial.component';/*import { BannerComponent } from './banner.component';describe('BannerComponent', () => {*/describe('BannerComponent (initial CLI generated)', () => { let component: BannerComponent; let fixture:",
    "id": "basics-of-testing-components-*-angular-33"
  },
  {
    "url": "https://angular.dev/guide/testing/components-basics",
    "title": "Basics of testing components • Angular",
    "chunk": " ComponentFixture<BannerComponent>; beforeEach(waitForAsync(() => { TestBed.configureTestingModule({imports: [BannerComponent]}); })); beforeEach(() => { fixture = TestBed.createComponent(BannerComponent); component = fixture.componentInstance; fixture.detectChanges(); }); it('should create', () => { expect(component).toBeDefined(); });});describe('BannerComponent (minimal)', () => { it('should create', () => { TestBed.configureTestingModule({imports: [BannerComponent]}); const fixture = TestBed",
    "id": "basics-of-testing-components-*-angular-34"
  },
  {
    "url": "https://angular.dev/guide/testing/components-basics",
    "title": "Basics of testing components • Angular",
    "chunk": ".createComponent(BannerComponent); const component = fixture.componentInstance; expect(component).toBeDefined(); });});describe('BannerComponent (with beforeEach)', () => { let component: BannerComponent; let fixture: ComponentFixture<BannerComponent>; beforeEach(() => { TestBed.configureTestingModule({imports: [BannerComponent]}); fixture = TestBed.createComponent(BannerComponent); component = fixture.componentInstance; }); it('should create', () => { expect(component).toBeDefined(); }); it('sh",
    "id": "basics-of-testing-components-*-angular-35"
  },
  {
    "url": "https://angular.dev/guide/testing/components-basics",
    "title": "Basics of testing components • Angular",
    "chunk": "ould contain \"banner works!\"', () => { const bannerElement: HTMLElement = fixture.nativeElement; expect(bannerElement.textContent).toContain('banner works!'); }); it('should have <p> with \"banner works!\"', () => { const bannerElement: HTMLElement = fixture.nativeElement; const p = bannerElement.querySelector('p')!; expect(p.textContent).toEqual('banner works!'); }); it('should find the <p> with fixture.debugElement.nativeElement', () => { const bannerDe: DebugElement = fixture.debugElement; cons",
    "id": "basics-of-testing-components-*-angular-36"
  },
  {
    "url": "https://angular.dev/guide/testing/components-basics",
    "title": "Basics of testing components • Angular",
    "chunk": "t bannerEl: HTMLElement = bannerDe.nativeElement; const p = bannerEl.querySelector('p')!; expect(p.textContent).toEqual('banner works!'); }); it('should find the <p> with fixture.debugElement.query(By.css)', () => { const bannerDe: DebugElement = fixture.debugElement; const paragraphDe = bannerDe.query(By.css('p')); const p: HTMLElement = paragraphDe.nativeElement; expect(p.textContent).toEqual('banner works!'); });}); Now add a test that gets the component's element from fixture.nativeElement a",
    "id": "basics-of-testing-components-*-angular-37"
  },
  {
    "url": "https://angular.dev/guide/testing/components-basics",
    "title": "Basics of testing components • Angular",
    "chunk": "nd looks for the expected text. import {DebugElement} from '@angular/core';import {ComponentFixture, TestBed, waitForAsync} from '@angular/core/testing';import {By} from '@angular/platform-browser';import {BannerComponent} from './banner-initial.component';/*import { BannerComponent } from './banner.component';describe('BannerComponent', () => {*/describe('BannerComponent (initial CLI generated)', () => { let component: BannerComponent; let fixture: ComponentFixture<BannerComponent>; beforeEach(",
    "id": "basics-of-testing-components-*-angular-38"
  },
  {
    "url": "https://angular.dev/guide/testing/components-basics",
    "title": "Basics of testing components • Angular",
    "chunk": "waitForAsync(() => { TestBed.configureTestingModule({imports: [BannerComponent]}); })); beforeEach(() => { fixture = TestBed.createComponent(BannerComponent); component = fixture.componentInstance; fixture.detectChanges(); }); it('should create', () => { expect(component).toBeDefined(); });});describe('BannerComponent (minimal)', () => { it('should create', () => { TestBed.configureTestingModule({imports: [BannerComponent]}); const fixture = TestBed.createComponent(BannerComponent); const compon",
    "id": "basics-of-testing-components-*-angular-39"
  },
  {
    "url": "https://angular.dev/guide/testing/components-basics",
    "title": "Basics of testing components • Angular",
    "chunk": "ent = fixture.componentInstance; expect(component).toBeDefined(); });});describe('BannerComponent (with beforeEach)', () => { let component: BannerComponent; let fixture: ComponentFixture<BannerComponent>; beforeEach(() => { TestBed.configureTestingModule({imports: [BannerComponent]}); fixture = TestBed.createComponent(BannerComponent); component = fixture.componentInstance; }); it('should create', () => { expect(component).toBeDefined(); }); it('should contain \"banner works!\"', () => { const ba",
    "id": "basics-of-testing-components-*-angular-40"
  },
  {
    "url": "https://angular.dev/guide/testing/components-basics",
    "title": "Basics of testing components • Angular",
    "chunk": "nnerElement: HTMLElement = fixture.nativeElement; expect(bannerElement.textContent).toContain('banner works!'); }); it('should have <p> with \"banner works!\"', () => { const bannerElement: HTMLElement = fixture.nativeElement; const p = bannerElement.querySelector('p')!; expect(p.textContent).toEqual('banner works!'); }); it('should find the <p> with fixture.debugElement.nativeElement', () => { const bannerDe: DebugElement = fixture.debugElement; const bannerEl: HTMLElement = bannerDe.nativeElemen",
    "id": "basics-of-testing-components-*-angular-41"
  },
  {
    "url": "https://angular.dev/guide/testing/components-basics",
    "title": "Basics of testing components • Angular",
    "chunk": "t; const p = bannerEl.querySelector('p')!; expect(p.textContent).toEqual('banner works!'); }); it('should find the <p> with fixture.debugElement.query(By.css)', () => { const bannerDe: DebugElement = fixture.debugElement; const paragraphDe = bannerDe.query(By.css('p')); const p: HTMLElement = paragraphDe.nativeElement; expect(p.textContent).toEqual('banner works!'); });}); nativeElement The value of ComponentFixture.nativeElement has the any type. Later you'll encounter the DebugElement.nativeEl",
    "id": "basics-of-testing-components-*-angular-42"
  },
  {
    "url": "https://angular.dev/guide/testing/components-basics",
    "title": "Basics of testing components • Angular",
    "chunk": "ement and it too has the any type. Angular can't know at compile time what kind of HTML element the nativeElement is or if it even is an HTML element. The application might be running on a non-browser platform, such as the server or a Web Worker, where the element might have a diminished API or not exist at all. The tests in this guide are designed to run in a browser so a nativeElement value will always be an HTMLElement or one of its derived classes. Knowing that it is an HTMLElement of some s",
    "id": "basics-of-testing-components-*-angular-43"
  },
  {
    "url": "https://angular.dev/guide/testing/components-basics",
    "title": "Basics of testing components • Angular",
    "chunk": "ort, use the standard HTML querySelector to dive deeper into the element tree. Here's another test that calls HTMLElement.querySelector to get the paragraph element and look for the banner text: import {DebugElement} from '@angular/core';import {ComponentFixture, TestBed, waitForAsync} from '@angular/core/testing';import {By} from '@angular/platform-browser';import {BannerComponent} from './banner-initial.component';/*import { BannerComponent } from './banner.component';describe('BannerComponent",
    "id": "basics-of-testing-components-*-angular-44"
  },
  {
    "url": "https://angular.dev/guide/testing/components-basics",
    "title": "Basics of testing components • Angular",
    "chunk": "', () => {*/describe('BannerComponent (initial CLI generated)', () => { let component: BannerComponent; let fixture: ComponentFixture<BannerComponent>; beforeEach(waitForAsync(() => { TestBed.configureTestingModule({imports: [BannerComponent]}); })); beforeEach(() => { fixture = TestBed.createComponent(BannerComponent); component = fixture.componentInstance; fixture.detectChanges(); }); it('should create', () => { expect(component).toBeDefined(); });});describe('BannerComponent (minimal)', () =>",
    "id": "basics-of-testing-components-*-angular-45"
  },
  {
    "url": "https://angular.dev/guide/testing/components-basics",
    "title": "Basics of testing components • Angular",
    "chunk": " { it('should create', () => { TestBed.configureTestingModule({imports: [BannerComponent]}); const fixture = TestBed.createComponent(BannerComponent); const component = fixture.componentInstance; expect(component).toBeDefined(); });});describe('BannerComponent (with beforeEach)', () => { let component: BannerComponent; let fixture: ComponentFixture<BannerComponent>; beforeEach(() => { TestBed.configureTestingModule({imports: [BannerComponent]}); fixture = TestBed.createComponent(BannerComponent)",
    "id": "basics-of-testing-components-*-angular-46"
  },
  {
    "url": "https://angular.dev/guide/testing/components-basics",
    "title": "Basics of testing components • Angular",
    "chunk": "; component = fixture.componentInstance; }); it('should create', () => { expect(component).toBeDefined(); }); it('should contain \"banner works!\"', () => { const bannerElement: HTMLElement = fixture.nativeElement; expect(bannerElement.textContent).toContain('banner works!'); }); it('should have <p> with \"banner works!\"', () => { const bannerElement: HTMLElement = fixture.nativeElement; const p = bannerElement.querySelector('p')!; expect(p.textContent).toEqual('banner works!'); }); it('should find",
    "id": "basics-of-testing-components-*-angular-47"
  },
  {
    "url": "https://angular.dev/guide/testing/components-basics",
    "title": "Basics of testing components • Angular",
    "chunk": " the <p> with fixture.debugElement.nativeElement', () => { const bannerDe: DebugElement = fixture.debugElement; const bannerEl: HTMLElement = bannerDe.nativeElement; const p = bannerEl.querySelector('p')!; expect(p.textContent).toEqual('banner works!'); }); it('should find the <p> with fixture.debugElement.query(By.css)', () => { const bannerDe: DebugElement = fixture.debugElement; const paragraphDe = bannerDe.query(By.css('p')); const p: HTMLElement = paragraphDe.nativeElement; expect(p.textCon",
    "id": "basics-of-testing-components-*-angular-48"
  },
  {
    "url": "https://angular.dev/guide/testing/components-basics",
    "title": "Basics of testing components • Angular",
    "chunk": "tent).toEqual('banner works!'); });}); DebugElement The Angular fixture provides the component's element directly through the fixture.nativeElement. import {DebugElement} from '@angular/core';import {ComponentFixture, TestBed, waitForAsync} from '@angular/core/testing';import {By} from '@angular/platform-browser';import {BannerComponent} from './banner-initial.component';/*import { BannerComponent } from './banner.component';describe('BannerComponent', () => {*/describe('BannerComponent (initial",
    "id": "basics-of-testing-components-*-angular-49"
  },
  {
    "url": "https://angular.dev/guide/testing/components-basics",
    "title": "Basics of testing components • Angular",
    "chunk": " CLI generated)', () => { let component: BannerComponent; let fixture: ComponentFixture<BannerComponent>; beforeEach(waitForAsync(() => { TestBed.configureTestingModule({imports: [BannerComponent]}); })); beforeEach(() => { fixture = TestBed.createComponent(BannerComponent); component = fixture.componentInstance; fixture.detectChanges(); }); it('should create', () => { expect(component).toBeDefined(); });});describe('BannerComponent (minimal)', () => { it('should create', () => { TestBed.configu",
    "id": "basics-of-testing-components-*-angular-50"
  },
  {
    "url": "https://angular.dev/guide/testing/components-basics",
    "title": "Basics of testing components • Angular",
    "chunk": "reTestingModule({imports: [BannerComponent]}); const fixture = TestBed.createComponent(BannerComponent); const component = fixture.componentInstance; expect(component).toBeDefined(); });});describe('BannerComponent (with beforeEach)', () => { let component: BannerComponent; let fixture: ComponentFixture<BannerComponent>; beforeEach(() => { TestBed.configureTestingModule({imports: [BannerComponent]}); fixture = TestBed.createComponent(BannerComponent); component = fixture.componentInstance; }); i",
    "id": "basics-of-testing-components-*-angular-51"
  },
  {
    "url": "https://angular.dev/guide/testing/components-basics",
    "title": "Basics of testing components • Angular",
    "chunk": "t('should create', () => { expect(component).toBeDefined(); }); it('should contain \"banner works!\"', () => { const bannerElement: HTMLElement = fixture.nativeElement; expect(bannerElement.textContent).toContain('banner works!'); }); it('should have <p> with \"banner works!\"', () => { const bannerElement: HTMLElement = fixture.nativeElement; const p = bannerElement.querySelector('p')!; expect(p.textContent).toEqual('banner works!'); }); it('should find the <p> with fixture.debugElement.nativeEleme",
    "id": "basics-of-testing-components-*-angular-52"
  },
  {
    "url": "https://angular.dev/guide/testing/components-basics",
    "title": "Basics of testing components • Angular",
    "chunk": "nt', () => { const bannerDe: DebugElement = fixture.debugElement; const bannerEl: HTMLElement = bannerDe.nativeElement; const p = bannerEl.querySelector('p')!; expect(p.textContent).toEqual('banner works!'); }); it('should find the <p> with fixture.debugElement.query(By.css)', () => { const bannerDe: DebugElement = fixture.debugElement; const paragraphDe = bannerDe.query(By.css('p')); const p: HTMLElement = paragraphDe.nativeElement; expect(p.textContent).toEqual('banner works!'); });}); This is",
    "id": "basics-of-testing-components-*-angular-53"
  },
  {
    "url": "https://angular.dev/guide/testing/components-basics",
    "title": "Basics of testing components • Angular",
    "chunk": " actually a convenience method, implemented as fixture.debugElement.nativeElement. import {DebugElement} from '@angular/core';import {ComponentFixture, TestBed, waitForAsync} from '@angular/core/testing';import {By} from '@angular/platform-browser';import {BannerComponent} from './banner-initial.component';/*import { BannerComponent } from './banner.component';describe('BannerComponent', () => {*/describe('BannerComponent (initial CLI generated)', () => { let component: BannerComponent; let fixt",
    "id": "basics-of-testing-components-*-angular-54"
  },
  {
    "url": "https://angular.dev/guide/testing/components-basics",
    "title": "Basics of testing components • Angular",
    "chunk": "ure: ComponentFixture<BannerComponent>; beforeEach(waitForAsync(() => { TestBed.configureTestingModule({imports: [BannerComponent]}); })); beforeEach(() => { fixture = TestBed.createComponent(BannerComponent); component = fixture.componentInstance; fixture.detectChanges(); }); it('should create', () => { expect(component).toBeDefined(); });});describe('BannerComponent (minimal)', () => { it('should create', () => { TestBed.configureTestingModule({imports: [BannerComponent]}); const fixture = Tes",
    "id": "basics-of-testing-components-*-angular-55"
  },
  {
    "url": "https://angular.dev/guide/testing/components-basics",
    "title": "Basics of testing components • Angular",
    "chunk": "tBed.createComponent(BannerComponent); const component = fixture.componentInstance; expect(component).toBeDefined(); });});describe('BannerComponent (with beforeEach)', () => { let component: BannerComponent; let fixture: ComponentFixture<BannerComponent>; beforeEach(() => { TestBed.configureTestingModule({imports: [BannerComponent]}); fixture = TestBed.createComponent(BannerComponent); component = fixture.componentInstance; }); it('should create', () => { expect(component).toBeDefined(); }); it",
    "id": "basics-of-testing-components-*-angular-56"
  },
  {
    "url": "https://angular.dev/guide/testing/components-basics",
    "title": "Basics of testing components • Angular",
    "chunk": "('should contain \"banner works!\"', () => { const bannerElement: HTMLElement = fixture.nativeElement; expect(bannerElement.textContent).toContain('banner works!'); }); it('should have <p> with \"banner works!\"', () => { const bannerElement: HTMLElement = fixture.nativeElement; const p = bannerElement.querySelector('p')!; expect(p.textContent).toEqual('banner works!'); }); it('should find the <p> with fixture.debugElement.nativeElement', () => { const bannerDe: DebugElement = fixture.debugElement; ",
    "id": "basics-of-testing-components-*-angular-57"
  },
  {
    "url": "https://angular.dev/guide/testing/components-basics",
    "title": "Basics of testing components • Angular",
    "chunk": "const bannerEl: HTMLElement = bannerDe.nativeElement; const p = bannerEl.querySelector('p')!; expect(p.textContent).toEqual('banner works!'); }); it('should find the <p> with fixture.debugElement.query(By.css)', () => { const bannerDe: DebugElement = fixture.debugElement; const paragraphDe = bannerDe.query(By.css('p')); const p: HTMLElement = paragraphDe.nativeElement; expect(p.textContent).toEqual('banner works!'); });}); There's a good reason for this circuitous path to the element. The proper",
    "id": "basics-of-testing-components-*-angular-58"
  },
  {
    "url": "https://angular.dev/guide/testing/components-basics",
    "title": "Basics of testing components • Angular",
    "chunk": "ties of the nativeElement depend upon the runtime environment. You could be running these tests on a non-browser platform that doesn't have a DOM or whose DOM-emulation doesn't support the full HTMLElement API. Angular relies on the DebugElement abstraction to work safely across all supported platforms. Instead of creating an HTML element tree, Angular creates a DebugElement tree that wraps the native elements for the runtime platform. The nativeElement property unwraps the DebugElement and retu",
    "id": "basics-of-testing-components-*-angular-59"
  },
  {
    "url": "https://angular.dev/guide/testing/components-basics",
    "title": "Basics of testing components • Angular",
    "chunk": "rns the platform-specific element object. Because the sample tests for this guide are designed to run only in a browser, a nativeElement in these tests is always an HTMLElement whose familiar methods and properties you can explore within a test. Here's the previous test, re-implemented with fixture.debugElement.nativeElement: import {DebugElement} from '@angular/core';import {ComponentFixture, TestBed, waitForAsync} from '@angular/core/testing';import {By} from '@angular/platform-browser';import",
    "id": "basics-of-testing-components-*-angular-60"
  },
  {
    "url": "https://angular.dev/guide/testing/components-basics",
    "title": "Basics of testing components • Angular",
    "chunk": " {BannerComponent} from './banner-initial.component';/*import { BannerComponent } from './banner.component';describe('BannerComponent', () => {*/describe('BannerComponent (initial CLI generated)', () => { let component: BannerComponent; let fixture: ComponentFixture<BannerComponent>; beforeEach(waitForAsync(() => { TestBed.configureTestingModule({imports: [BannerComponent]}); })); beforeEach(() => { fixture = TestBed.createComponent(BannerComponent); component = fixture.componentInstance; fixtur",
    "id": "basics-of-testing-components-*-angular-61"
  },
  {
    "url": "https://angular.dev/guide/testing/components-basics",
    "title": "Basics of testing components • Angular",
    "chunk": "e.detectChanges(); }); it('should create', () => { expect(component).toBeDefined(); });});describe('BannerComponent (minimal)', () => { it('should create', () => { TestBed.configureTestingModule({imports: [BannerComponent]}); const fixture = TestBed.createComponent(BannerComponent); const component = fixture.componentInstance; expect(component).toBeDefined(); });});describe('BannerComponent (with beforeEach)', () => { let component: BannerComponent; let fixture: ComponentFixture<BannerComponent>",
    "id": "basics-of-testing-components-*-angular-62"
  },
  {
    "url": "https://angular.dev/guide/testing/components-basics",
    "title": "Basics of testing components • Angular",
    "chunk": "; beforeEach(() => { TestBed.configureTestingModule({imports: [BannerComponent]}); fixture = TestBed.createComponent(BannerComponent); component = fixture.componentInstance; }); it('should create', () => { expect(component).toBeDefined(); }); it('should contain \"banner works!\"', () => { const bannerElement: HTMLElement = fixture.nativeElement; expect(bannerElement.textContent).toContain('banner works!'); }); it('should have <p> with \"banner works!\"', () => { const bannerElement: HTMLElement = fi",
    "id": "basics-of-testing-components-*-angular-63"
  },
  {
    "url": "https://angular.dev/guide/testing/components-basics",
    "title": "Basics of testing components • Angular",
    "chunk": "xture.nativeElement; const p = bannerElement.querySelector('p')!; expect(p.textContent).toEqual('banner works!'); }); it('should find the <p> with fixture.debugElement.nativeElement', () => { const bannerDe: DebugElement = fixture.debugElement; const bannerEl: HTMLElement = bannerDe.nativeElement; const p = bannerEl.querySelector('p')!; expect(p.textContent).toEqual('banner works!'); }); it('should find the <p> with fixture.debugElement.query(By.css)', () => { const bannerDe: DebugElement = fixt",
    "id": "basics-of-testing-components-*-angular-64"
  },
  {
    "url": "https://angular.dev/guide/testing/components-basics",
    "title": "Basics of testing components • Angular",
    "chunk": "ure.debugElement; const paragraphDe = bannerDe.query(By.css('p')); const p: HTMLElement = paragraphDe.nativeElement; expect(p.textContent).toEqual('banner works!'); });}); The DebugElement has other methods and properties that are useful in tests, as you'll see elsewhere in this guide. You import the DebugElement symbol from the Angular core library. import {DebugElement} from '@angular/core';import {ComponentFixture, TestBed, waitForAsync} from '@angular/core/testing';import {By} from '@angular",
    "id": "basics-of-testing-components-*-angular-65"
  },
  {
    "url": "https://angular.dev/guide/testing/components-basics",
    "title": "Basics of testing components • Angular",
    "chunk": "/platform-browser';import {BannerComponent} from './banner-initial.component';/*import { BannerComponent } from './banner.component';describe('BannerComponent', () => {*/describe('BannerComponent (initial CLI generated)', () => { let component: BannerComponent; let fixture: ComponentFixture<BannerComponent>; beforeEach(waitForAsync(() => { TestBed.configureTestingModule({imports: [BannerComponent]}); })); beforeEach(() => { fixture = TestBed.createComponent(BannerComponent); component = fixture.",
    "id": "basics-of-testing-components-*-angular-66"
  },
  {
    "url": "https://angular.dev/guide/testing/components-basics",
    "title": "Basics of testing components • Angular",
    "chunk": "componentInstance; fixture.detectChanges(); }); it('should create', () => { expect(component).toBeDefined(); });});describe('BannerComponent (minimal)', () => { it('should create', () => { TestBed.configureTestingModule({imports: [BannerComponent]}); const fixture = TestBed.createComponent(BannerComponent); const component = fixture.componentInstance; expect(component).toBeDefined(); });});describe('BannerComponent (with beforeEach)', () => { let component: BannerComponent; let fixture: Componen",
    "id": "basics-of-testing-components-*-angular-67"
  },
  {
    "url": "https://angular.dev/guide/testing/components-basics",
    "title": "Basics of testing components • Angular",
    "chunk": "tFixture<BannerComponent>; beforeEach(() => { TestBed.configureTestingModule({imports: [BannerComponent]}); fixture = TestBed.createComponent(BannerComponent); component = fixture.componentInstance; }); it('should create', () => { expect(component).toBeDefined(); }); it('should contain \"banner works!\"', () => { const bannerElement: HTMLElement = fixture.nativeElement; expect(bannerElement.textContent).toContain('banner works!'); }); it('should have <p> with \"banner works!\"', () => { const banner",
    "id": "basics-of-testing-components-*-angular-68"
  },
  {
    "url": "https://angular.dev/guide/testing/components-basics",
    "title": "Basics of testing components • Angular",
    "chunk": "Element: HTMLElement = fixture.nativeElement; const p = bannerElement.querySelector('p')!; expect(p.textContent).toEqual('banner works!'); }); it('should find the <p> with fixture.debugElement.nativeElement', () => { const bannerDe: DebugElement = fixture.debugElement; const bannerEl: HTMLElement = bannerDe.nativeElement; const p = bannerEl.querySelector('p')!; expect(p.textContent).toEqual('banner works!'); }); it('should find the <p> with fixture.debugElement.query(By.css)', () => { const bann",
    "id": "basics-of-testing-components-*-angular-69"
  },
  {
    "url": "https://angular.dev/guide/testing/components-basics",
    "title": "Basics of testing components • Angular",
    "chunk": "erDe: DebugElement = fixture.debugElement; const paragraphDe = bannerDe.query(By.css('p')); const p: HTMLElement = paragraphDe.nativeElement; expect(p.textContent).toEqual('banner works!'); });}); By.css() Although the tests in this guide all run in the browser, some applications might run on a different platform at least some of the time. For example, the component might render first on the server as part of a strategy to make the application launch faster on poorly connected devices. The serve",
    "id": "basics-of-testing-components-*-angular-70"
  },
  {
    "url": "https://angular.dev/guide/testing/components-basics",
    "title": "Basics of testing components • Angular",
    "chunk": "r-side renderer might not support the full HTML element API. If it doesn't support querySelector, the previous test could fail. The DebugElement offers query methods that work for all supported platforms. These query methods take a predicate function that returns true when a node in the DebugElement tree matches the selection criteria. You create a predicate with the help of a By class imported from a library for the runtime platform. Here's the By import for the browser platform: import {DebugE",
    "id": "basics-of-testing-components-*-angular-71"
  },
  {
    "url": "https://angular.dev/guide/testing/components-basics",
    "title": "Basics of testing components • Angular",
    "chunk": "lement} from '@angular/core';import {ComponentFixture, TestBed, waitForAsync} from '@angular/core/testing';import {By} from '@angular/platform-browser';import {BannerComponent} from './banner-initial.component';/*import { BannerComponent } from './banner.component';describe('BannerComponent', () => {*/describe('BannerComponent (initial CLI generated)', () => { let component: BannerComponent; let fixture: ComponentFixture<BannerComponent>; beforeEach(waitForAsync(() => { TestBed.configureTestingM",
    "id": "basics-of-testing-components-*-angular-72"
  },
  {
    "url": "https://angular.dev/guide/testing/components-basics",
    "title": "Basics of testing components • Angular",
    "chunk": "odule({imports: [BannerComponent]}); })); beforeEach(() => { fixture = TestBed.createComponent(BannerComponent); component = fixture.componentInstance; fixture.detectChanges(); }); it('should create', () => { expect(component).toBeDefined(); });});describe('BannerComponent (minimal)', () => { it('should create', () => { TestBed.configureTestingModule({imports: [BannerComponent]}); const fixture = TestBed.createComponent(BannerComponent); const component = fixture.componentInstance; expect(compon",
    "id": "basics-of-testing-components-*-angular-73"
  },
  {
    "url": "https://angular.dev/guide/testing/components-basics",
    "title": "Basics of testing components • Angular",
    "chunk": "ent).toBeDefined(); });});describe('BannerComponent (with beforeEach)', () => { let component: BannerComponent; let fixture: ComponentFixture<BannerComponent>; beforeEach(() => { TestBed.configureTestingModule({imports: [BannerComponent]}); fixture = TestBed.createComponent(BannerComponent); component = fixture.componentInstance; }); it('should create', () => { expect(component).toBeDefined(); }); it('should contain \"banner works!\"', () => { const bannerElement: HTMLElement = fixture.nativeEleme",
    "id": "basics-of-testing-components-*-angular-74"
  },
  {
    "url": "https://angular.dev/guide/testing/components-basics",
    "title": "Basics of testing components • Angular",
    "chunk": "nt; expect(bannerElement.textContent).toContain('banner works!'); }); it('should have <p> with \"banner works!\"', () => { const bannerElement: HTMLElement = fixture.nativeElement; const p = bannerElement.querySelector('p')!; expect(p.textContent).toEqual('banner works!'); }); it('should find the <p> with fixture.debugElement.nativeElement', () => { const bannerDe: DebugElement = fixture.debugElement; const bannerEl: HTMLElement = bannerDe.nativeElement; const p = bannerEl.querySelector('p')!; exp",
    "id": "basics-of-testing-components-*-angular-75"
  },
  {
    "url": "https://angular.dev/guide/testing/components-basics",
    "title": "Basics of testing components • Angular",
    "chunk": "ect(p.textContent).toEqual('banner works!'); }); it('should find the <p> with fixture.debugElement.query(By.css)', () => { const bannerDe: DebugElement = fixture.debugElement; const paragraphDe = bannerDe.query(By.css('p')); const p: HTMLElement = paragraphDe.nativeElement; expect(p.textContent).toEqual('banner works!'); });}); The following example re-implements the previous test with DebugElement.query() and the browser's By.css method. import {DebugElement} from '@angular/core';import {Compon",
    "id": "basics-of-testing-components-*-angular-76"
  },
  {
    "url": "https://angular.dev/guide/testing/components-basics",
    "title": "Basics of testing components • Angular",
    "chunk": "entFixture, TestBed, waitForAsync} from '@angular/core/testing';import {By} from '@angular/platform-browser';import {BannerComponent} from './banner-initial.component';/*import { BannerComponent } from './banner.component';describe('BannerComponent', () => {*/describe('BannerComponent (initial CLI generated)', () => { let component: BannerComponent; let fixture: ComponentFixture<BannerComponent>; beforeEach(waitForAsync(() => { TestBed.configureTestingModule({imports: [BannerComponent]}); })); b",
    "id": "basics-of-testing-components-*-angular-77"
  },
  {
    "url": "https://angular.dev/guide/testing/components-basics",
    "title": "Basics of testing components • Angular",
    "chunk": "eforeEach(() => { fixture = TestBed.createComponent(BannerComponent); component = fixture.componentInstance; fixture.detectChanges(); }); it('should create', () => { expect(component).toBeDefined(); });});describe('BannerComponent (minimal)', () => { it('should create', () => { TestBed.configureTestingModule({imports: [BannerComponent]}); const fixture = TestBed.createComponent(BannerComponent); const component = fixture.componentInstance; expect(component).toBeDefined(); });});describe('BannerC",
    "id": "basics-of-testing-components-*-angular-78"
  },
  {
    "url": "https://angular.dev/guide/testing/components-basics",
    "title": "Basics of testing components • Angular",
    "chunk": "omponent (with beforeEach)', () => { let component: BannerComponent; let fixture: ComponentFixture<BannerComponent>; beforeEach(() => { TestBed.configureTestingModule({imports: [BannerComponent]}); fixture = TestBed.createComponent(BannerComponent); component = fixture.componentInstance; }); it('should create', () => { expect(component).toBeDefined(); }); it('should contain \"banner works!\"', () => { const bannerElement: HTMLElement = fixture.nativeElement; expect(bannerElement.textContent).toCon",
    "id": "basics-of-testing-components-*-angular-79"
  },
  {
    "url": "https://angular.dev/guide/testing/components-basics",
    "title": "Basics of testing components • Angular",
    "chunk": "tain('banner works!'); }); it('should have <p> with \"banner works!\"', () => { const bannerElement: HTMLElement = fixture.nativeElement; const p = bannerElement.querySelector('p')!; expect(p.textContent).toEqual('banner works!'); }); it('should find the <p> with fixture.debugElement.nativeElement', () => { const bannerDe: DebugElement = fixture.debugElement; const bannerEl: HTMLElement = bannerDe.nativeElement; const p = bannerEl.querySelector('p')!; expect(p.textContent).toEqual('banner works!')",
    "id": "basics-of-testing-components-*-angular-80"
  },
  {
    "url": "https://angular.dev/guide/testing/components-basics",
    "title": "Basics of testing components • Angular",
    "chunk": "; }); it('should find the <p> with fixture.debugElement.query(By.css)', () => { const bannerDe: DebugElement = fixture.debugElement; const paragraphDe = bannerDe.query(By.css('p')); const p: HTMLElement = paragraphDe.nativeElement; expect(p.textContent).toEqual('banner works!'); });}); Some noteworthy observations: The By.css() static method selects DebugElement nodes with a standard CSS selector. The query returns a DebugElement for the paragraph. You must unwrap that result to get the paragrap",
    "id": "basics-of-testing-components-*-angular-81"
  },
  {
    "url": "https://angular.dev/guide/testing/components-basics",
    "title": "Basics of testing components • Angular",
    "chunk": "h element. When you're filtering by CSS selector and only testing properties of a browser's native element, the By.css approach might be overkill. It's often more straightforward and clear to filter with a standard HTMLElement method such as querySelector() or querySelectorAll(). Social MediaBlogX (formerly Twitter)BlueskyYouTube Discord GitHub Stack Overflow Community Contribute Code of Conduct Report Issues Google's DevLibrary Angular Google Developer Experts ResourcesPress KitRoadmapLanguages",
    "id": "basics-of-testing-components-*-angular-82"
  },
  {
    "url": "https://angular.dev/guide/testing/components-basics",
    "title": "Basics of testing components • Angular",
    "chunk": "简体中文版正體中文版日本語版한국어 Ελληνικά Super-powered by Google ©2010-2025. Code licensed under an MIT-style License . Documentation licensed under CC BY 4.0 .",
    "id": "basics-of-testing-components-*-angular-83"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": "In-depth GuidesTesting Component testing scenarios This guide explores common component testing use cases. On this pagearrow_upward_alt Back to the top Component binding In the example application, the BannerComponent presents static title text in the HTML template. After a few changes, the BannerComponent presents a dynamic title by binding to the component's title property like this. app/banner/banner.component.ts import {Component, signal} from '@angular/core';@Component({ selector: 'app-bann",
    "id": "component-testing-scenarios-*-angular-0"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": "er', template: '<h1>{{title()}}</h1>', styles: ['h1 { color: green; font-size: 350%}'],})export class BannerComponent { title = signal('Test Tour of Heroes');} As minimal as this is, you decide to add a test to confirm that component actually displays the right content where you think it should. Query for the <h1> You'll write a sequence of tests that inspect the value of the <h1> element that wraps the title property interpolation binding. You update the beforeEach to find that element with a s",
    "id": "component-testing-scenarios-*-angular-1"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": "tandard HTML querySelector and assign it to the h1 variable. app/banner/banner.component.spec.ts (setup) import {ComponentFixture, TestBed} from '@angular/core/testing';import {BannerComponent} from './banner.component';describe('BannerComponent (inline template)', () => { let component: BannerComponent; let fixture: ComponentFixture<BannerComponent>; let h1: HTMLElement; beforeEach(() => { TestBed.configureTestingModule({ imports: [BannerComponent], }); fixture = TestBed.createComponent(BannerC",
    "id": "component-testing-scenarios-*-angular-2"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": "omponent); component = fixture.componentInstance; // BannerComponent test instance h1 = fixture.nativeElement.querySelector('h1'); }); it('no title in the DOM after createComponent()', () => { expect(h1.textContent).toEqual(''); }); it('should display original title', () => { fixture.detectChanges(); expect(h1.textContent).toContain(component.title); }); it('should display original title after detectChanges()', () => { fixture.detectChanges(); expect(h1.textContent).toContain(component.title); }",
    "id": "component-testing-scenarios-*-angular-3"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": "); it('should display a different test title', () => { component.title = 'Test Title'; fixture.detectChanges(); expect(h1.textContent).toContain('Test Title'); });}); createComponent() does not bind data For your first test you'd like to see that the screen displays the default title. Your instinct is to write a test that immediately inspects the <h1> like this: import {ComponentFixture, TestBed} from '@angular/core/testing';import {BannerComponent} from './banner.component';describe('BannerComp",
    "id": "component-testing-scenarios-*-angular-4"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": "onent (inline template)', () => { let component: BannerComponent; let fixture: ComponentFixture<BannerComponent>; let h1: HTMLElement; beforeEach(() => { TestBed.configureTestingModule({ imports: [BannerComponent], }); fixture = TestBed.createComponent(BannerComponent); component = fixture.componentInstance; // BannerComponent test instance h1 = fixture.nativeElement.querySelector('h1'); }); it('no title in the DOM after createComponent()', () => { expect(h1.textContent).toEqual(''); }); it('sho",
    "id": "component-testing-scenarios-*-angular-5"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": "uld display original title', () => { fixture.detectChanges(); expect(h1.textContent).toContain(component.title); }); it('should display original title after detectChanges()', () => { fixture.detectChanges(); expect(h1.textContent).toContain(component.title); }); it('should display a different test title', () => { component.title = 'Test Title'; fixture.detectChanges(); expect(h1.textContent).toContain('Test Title'); });}); That test fails with the message: expected '' to contain 'Test Tour of He",
    "id": "component-testing-scenarios-*-angular-6"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": "roes'. Binding happens when Angular performs change detection. In production, change detection kicks in automatically when Angular creates a component or the user enters a keystroke, for example. The TestBed.createComponent does not trigger change detection by default; a fact confirmed in the revised test: import {ComponentFixture, TestBed} from '@angular/core/testing';import {BannerComponent} from './banner.component';describe('BannerComponent (inline template)', () => { let component: BannerCo",
    "id": "component-testing-scenarios-*-angular-7"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": "mponent; let fixture: ComponentFixture<BannerComponent>; let h1: HTMLElement; beforeEach(() => { TestBed.configureTestingModule({ imports: [BannerComponent], }); fixture = TestBed.createComponent(BannerComponent); component = fixture.componentInstance; // BannerComponent test instance h1 = fixture.nativeElement.querySelector('h1'); }); it('no title in the DOM after createComponent()', () => { expect(h1.textContent).toEqual(''); }); it('should display original title', () => { fixture.detectChange",
    "id": "component-testing-scenarios-*-angular-8"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": "s(); expect(h1.textContent).toContain(component.title); }); it('should display original title after detectChanges()', () => { fixture.detectChanges(); expect(h1.textContent).toContain(component.title); }); it('should display a different test title', () => { component.title = 'Test Title'; fixture.detectChanges(); expect(h1.textContent).toContain('Test Title'); });}); detectChanges() You can tell the TestBed to perform data binding by calling fixture.detectChanges(). Only then does the <h1> have ",
    "id": "component-testing-scenarios-*-angular-9"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": "the expected title. import {ComponentFixture, TestBed} from '@angular/core/testing';import {BannerComponent} from './banner.component';describe('BannerComponent (inline template)', () => { let component: BannerComponent; let fixture: ComponentFixture<BannerComponent>; let h1: HTMLElement; beforeEach(() => { TestBed.configureTestingModule({ imports: [BannerComponent], }); fixture = TestBed.createComponent(BannerComponent); component = fixture.componentInstance; // BannerComponent test instance h1",
    "id": "component-testing-scenarios-*-angular-10"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": " = fixture.nativeElement.querySelector('h1'); }); it('no title in the DOM after createComponent()', () => { expect(h1.textContent).toEqual(''); }); it('should display original title', () => { fixture.detectChanges(); expect(h1.textContent).toContain(component.title); }); it('should display original title after detectChanges()', () => { fixture.detectChanges(); expect(h1.textContent).toContain(component.title); }); it('should display a different test title', () => { component.title = 'Test Title'",
    "id": "component-testing-scenarios-*-angular-11"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": "; fixture.detectChanges(); expect(h1.textContent).toContain('Test Title'); });}); Delayed change detection is intentional and useful. It gives the tester an opportunity to inspect and change the state of the component before Angular initiates data binding and calls lifecycle hooks. Here's another test that changes the component's title property before calling fixture.detectChanges(). import {ComponentFixture, TestBed} from '@angular/core/testing';import {BannerComponent} from './banner.component",
    "id": "component-testing-scenarios-*-angular-12"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": "';describe('BannerComponent (inline template)', () => { let component: BannerComponent; let fixture: ComponentFixture<BannerComponent>; let h1: HTMLElement; beforeEach(() => { TestBed.configureTestingModule({ imports: [BannerComponent], }); fixture = TestBed.createComponent(BannerComponent); component = fixture.componentInstance; // BannerComponent test instance h1 = fixture.nativeElement.querySelector('h1'); }); it('no title in the DOM after createComponent()', () => { expect(h1.textContent).to",
    "id": "component-testing-scenarios-*-angular-13"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": "Equal(''); }); it('should display original title', () => { fixture.detectChanges(); expect(h1.textContent).toContain(component.title); }); it('should display original title after detectChanges()', () => { fixture.detectChanges(); expect(h1.textContent).toContain(component.title); }); it('should display a different test title', () => { component.title = 'Test Title'; fixture.detectChanges(); expect(h1.textContent).toContain('Test Title'); });}); Automatic change detection The BannerComponent test",
    "id": "component-testing-scenarios-*-angular-14"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": "s frequently call detectChanges. Many testers prefer that the Angular test environment run change detection automatically like it does in production. That's possible by configuring the TestBed with the ComponentFixtureAutoDetect provider. First import it from the testing utility library: app/banner/banner.component.detect-changes.spec.ts (import) import {ComponentFixtureAutoDetect} from '@angular/core/testing';import {ComponentFixture, TestBed} from '@angular/core/testing';import {BannerComponen",
    "id": "component-testing-scenarios-*-angular-15"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": "t} from './banner.component';describe('BannerComponent (AutoChangeDetect)', () => { let comp: BannerComponent; let fixture: ComponentFixture<BannerComponent>; let h1: HTMLElement; beforeEach(() => { TestBed.configureTestingModule({ providers: [{provide: ComponentFixtureAutoDetect, useValue: true}], }); fixture = TestBed.createComponent(BannerComponent); comp = fixture.componentInstance; h1 = fixture.nativeElement.querySelector('h1'); }); it('should display original title', () => { // Hooray! No ",
    "id": "component-testing-scenarios-*-angular-16"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": "`fixture.detectChanges()` needed expect(h1.textContent).toContain(comp.title); }); it('should still see original title after comp.title change', async () => { const oldTitle = comp.title; const newTitle = 'Test Title'; comp.title.set(newTitle); // Displayed title is old because Angular didn't yet run change detection expect(h1.textContent).toContain(oldTitle); await fixture.whenStable(); expect(h1.textContent).toContain(newTitle); }); it('should display updated title after detectChanges', () => ",
    "id": "component-testing-scenarios-*-angular-17"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": "{ comp.title.set('Test Title'); fixture.detectChanges(); // detect changes explicitly expect(h1.textContent).toContain(comp.title); });}); Then add it to the providers array of the testing module configuration: app/banner/banner.component.detect-changes.spec.ts (AutoDetect) import {ComponentFixtureAutoDetect} from '@angular/core/testing';import {ComponentFixture, TestBed} from '@angular/core/testing';import {BannerComponent} from './banner.component';describe('BannerComponent (AutoChangeDetect)'",
    "id": "component-testing-scenarios-*-angular-18"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": ", () => { let comp: BannerComponent; let fixture: ComponentFixture<BannerComponent>; let h1: HTMLElement; beforeEach(() => { TestBed.configureTestingModule({ providers: [{provide: ComponentFixtureAutoDetect, useValue: true}], }); fixture = TestBed.createComponent(BannerComponent); comp = fixture.componentInstance; h1 = fixture.nativeElement.querySelector('h1'); }); it('should display original title', () => { // Hooray! No `fixture.detectChanges()` needed expect(h1.textContent).toContain(comp.tit",
    "id": "component-testing-scenarios-*-angular-19"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": "le); }); it('should still see original title after comp.title change', async () => { const oldTitle = comp.title; const newTitle = 'Test Title'; comp.title.set(newTitle); // Displayed title is old because Angular didn't yet run change detection expect(h1.textContent).toContain(oldTitle); await fixture.whenStable(); expect(h1.textContent).toContain(newTitle); }); it('should display updated title after detectChanges', () => { comp.title.set('Test Title'); fixture.detectChanges(); // detect changes",
    "id": "component-testing-scenarios-*-angular-20"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": " explicitly expect(h1.textContent).toContain(comp.title); });}); HELPFUL: You can also use the fixture.autoDetectChanges() function instead if you only want to enable automatic change detection after making updates to the state of the fixture's component. In addition, automatic change detection is on by default when using provideZonelessChangeDetection and turning it off is not recommended. Here are three tests that illustrate how automatic change detection works. app/banner/banner.component.det",
    "id": "component-testing-scenarios-*-angular-21"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": "ect-changes.spec.ts (AutoDetect Tests) import {ComponentFixtureAutoDetect} from '@angular/core/testing';import {ComponentFixture, TestBed} from '@angular/core/testing';import {BannerComponent} from './banner.component';describe('BannerComponent (AutoChangeDetect)', () => { let comp: BannerComponent; let fixture: ComponentFixture<BannerComponent>; let h1: HTMLElement; beforeEach(() => { TestBed.configureTestingModule({ providers: [{provide: ComponentFixtureAutoDetect, useValue: true}], }); fixtur",
    "id": "component-testing-scenarios-*-angular-22"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": "e = TestBed.createComponent(BannerComponent); comp = fixture.componentInstance; h1 = fixture.nativeElement.querySelector('h1'); }); it('should display original title', () => { // Hooray! No `fixture.detectChanges()` needed expect(h1.textContent).toContain(comp.title); }); it('should still see original title after comp.title change', async () => { const oldTitle = comp.title; const newTitle = 'Test Title'; comp.title.set(newTitle); // Displayed title is old because Angular didn't yet run change d",
    "id": "component-testing-scenarios-*-angular-23"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": "etection expect(h1.textContent).toContain(oldTitle); await fixture.whenStable(); expect(h1.textContent).toContain(newTitle); }); it('should display updated title after detectChanges', () => { comp.title.set('Test Title'); fixture.detectChanges(); // detect changes explicitly expect(h1.textContent).toContain(comp.title); });}); The first test shows the benefit of automatic change detection. The second and third test reveal an important limitation. The Angular testing environment does not run chan",
    "id": "component-testing-scenarios-*-angular-24"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": "ge detection synchronously when updates happen inside the test case that changed the component's title. The test must call await fixture.whenStable to wait for another round of change detection. HELPFUL: Angular does not know about direct updates to values that are not signals. The easiest way to ensure that change detection will be scheduled is to use signals for values read in the template. Change an input value with dispatchEvent() To simulate user input, find the input element and set its va",
    "id": "component-testing-scenarios-*-angular-25"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": "lue property. But there is an essential, intermediate step. Angular doesn't know that you set the input element's value property. It won't read that property until you raise the element's input event by calling dispatchEvent(). The following example demonstrates the proper sequence. app/hero/hero-detail.component.spec.ts (pipe test) import {HttpClient, HttpHandler, provideHttpClient} from '@angular/common/http';import {HttpTestingController, provideHttpClientTesting} from '@angular/common/http/t",
    "id": "component-testing-scenarios-*-angular-26"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": "esting';import {fakeAsync, TestBed, tick} from '@angular/core/testing';import {provideRouter, Router} from '@angular/router';import {RouterTestingHarness} from '@angular/router/testing';import {asyncData, click} from '../../testing';import {Hero} from '../model/hero';import {sharedImports} from '../shared/shared';import {HeroDetailComponent} from './hero-detail.component';import {HeroDetailService} from './hero-detail.service';import {HeroListComponent} from './hero-list.component';////// Testin",
    "id": "component-testing-scenarios-*-angular-27"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": "g Vars //////let component: HeroDetailComponent;let harness: RouterTestingHarness;let page: Page;////// Tests //////describe('HeroDetailComponent', () => { describe('with HeroModule setup', heroModuleSetup); describe('when override its provided HeroDetailService', overrideSetup); describe('with FormsModule setup', formsModuleSetup); describe('with SharedModule setup', sharedModuleSetup);});///////////////////const testHero = getTestHeroes()[0];function overrideSetup() { class HeroDetailServiceSp",
    "id": "component-testing-scenarios-*-angular-28"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": "y { testHero: Hero = {...testHero}; /* emit cloned test hero */ getHero = jasmine .createSpy('getHero') .and.callFake(() => asyncData(Object.assign({}, this.testHero))); /* emit clone of test hero, with changes merged in */ saveHero = jasmine .createSpy('saveHero') .and.callFake((hero: Hero) => asyncData(Object.assign(this.testHero, hero))); } beforeEach(async () => { await TestBed.configureTestingModule( Object.assign({}, appConfig, { imports: [HeroDetailComponent, HeroListComponent], providers",
    "id": "component-testing-scenarios-*-angular-29"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": ": [ provideRouter([ {path: 'heroes', component: HeroListComponent}, {path: 'heroes/:id', component: HeroDetailComponent}, ]), HttpClient, HttpHandler, // HeroDetailService at this level is IRRELEVANT! {provide: HeroDetailService, useValue: {}}, ], }), ) .overrideComponent(HeroDetailComponent, { set: {providers: [{provide: HeroDetailService, useClass: HeroDetailServiceSpy}]}, }); }); let hdsSpy: HeroDetailServiceSpy; beforeEach(async () => { harness = await RouterTestingHarness.create(); componen",
    "id": "component-testing-scenarios-*-angular-30"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": "t = await harness.navigateByUrl(`/heroes/${testHero.id}`, HeroDetailComponent); page = new Page(); // get the component's injected HeroDetailServiceSpy hdsSpy = harness.routeDebugElement!.injector.get(HeroDetailService) as any; harness.detectChanges(); }); it('should have called `getHero`', () => { expect(hdsSpy.getHero.calls.count()) .withContext('getHero called once') .toBe(1, 'getHero called once'); }); it(\"should display stub hero's name\", () => { expect(page.nameDisplay.textContent).toBe(hd",
    "id": "component-testing-scenarios-*-angular-31"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": "sSpy.testHero.name); }); it('should save stub hero change', fakeAsync(() => { const origName = hdsSpy.testHero.name; const newName = 'New Name'; page.nameInput.value = newName; page.nameInput.dispatchEvent(new Event('input')); // tell Angular expect(component.hero.name).withContext('component hero has new name').toBe(newName); expect(hdsSpy.testHero.name).withContext('service hero unchanged before save').toBe(origName); click(page.saveBtn); expect(hdsSpy.saveHero.calls.count()).withContext('save",
    "id": "component-testing-scenarios-*-angular-32"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": "Hero called once').toBe(1); tick(); // wait for async save to complete expect(hdsSpy.testHero.name).withContext('service hero has new name after save').toBe(newName); expect(TestBed.inject(Router).url).toEqual('/heroes'); }));}////////////////////import {getTestHeroes} from '../model/testing/test-hero.service';const firstHero = getTestHeroes()[0];function heroModuleSetup() { beforeEach(async () => { await TestBed.configureTestingModule( Object.assign({}, appConfig, { imports: [HeroDetailComponen",
    "id": "component-testing-scenarios-*-angular-33"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": "t, HeroListComponent], providers: [ provideRouter([ {path: 'heroes/:id', component: HeroDetailComponent}, {path: 'heroes', component: HeroListComponent}, ]), provideHttpClient(), provideHttpClientTesting(), ], }), ); }); describe('when navigate to existing hero', () => { let expectedHero: Hero; beforeEach(async () => { expectedHero = firstHero; await createComponent(expectedHero.id); }); it(\"should display that hero's name\", () => { expect(page.nameDisplay.textContent).toBe(expectedHero.name); }",
    "id": "component-testing-scenarios-*-angular-34"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": "); it('should navigate when click cancel', () => { click(page.cancelBtn); expect(TestBed.inject(Router).url).toEqual(`/heroes/${expectedHero.id}`); }); it('should save when click save but not navigate immediately', () => { click(page.saveBtn); expect(TestBed.inject(HttpTestingController).expectOne({method: 'PUT', url: 'api/heroes'})); expect(TestBed.inject(Router).url).toEqual('/heroes/41'); }); it('should navigate when click save and save resolves', fakeAsync(() => { click(page.saveBtn); tick()",
    "id": "component-testing-scenarios-*-angular-35"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": "; // wait for async save to complete expect(TestBed.inject(Router).url).toEqual('/heroes/41'); })); it('should convert hero name to Title Case', async () => { harness.fixture.autoDetectChanges(); // get the name's input and display elements from the DOM const hostElement: HTMLElement = harness.routeNativeElement!; const nameInput: HTMLInputElement = hostElement.querySelector('input')!; const nameDisplay: HTMLElement = hostElement.querySelector('span')!; // simulate user entering a new name into ",
    "id": "component-testing-scenarios-*-angular-36"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": "the input box nameInput.value = 'quick BROWN fOx'; // Dispatch a DOM event so that Angular learns of input value change. nameInput.dispatchEvent(new Event('input')); // Wait for Angular to update the display binding through the title pipe await harness.fixture.whenStable(); expect(nameDisplay.textContent).toBe('Quick Brown Fox'); }); }); describe('when navigate to non-existent hero id', () => { beforeEach(async () => { await createComponent(999); }); it('should try to navigate back to hero list'",
    "id": "component-testing-scenarios-*-angular-37"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": ", () => { expect(TestBed.inject(Router).url).toEqual('/heroes'); }); });}/////////////////////import {FormsModule} from '@angular/forms';import {TitleCasePipe} from '../shared/title-case.pipe';import {appConfig} from '../app.config';function formsModuleSetup() { beforeEach(async () => { await TestBed.configureTestingModule( Object.assign({}, appConfig, { imports: [FormsModule, HeroDetailComponent, TitleCasePipe], providers: [ provideHttpClient(), provideHttpClientTesting(), provideRouter([{path:",
    "id": "component-testing-scenarios-*-angular-38"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": " 'heroes/:id', component: HeroDetailComponent}]), ], }), ); }); it(\"should display 1st hero's name\", async () => { const expectedHero = firstHero; await createComponent(expectedHero.id).then(() => { expect(page.nameDisplay.textContent).toBe(expectedHero.name); }); });}///////////////////////function sharedModuleSetup() { beforeEach(async () => { await TestBed.configureTestingModule( Object.assign({}, appConfig, { imports: [HeroDetailComponent, sharedImports], providers: [ provideRouter([{path: '",
    "id": "component-testing-scenarios-*-angular-39"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": "heroes/:id', component: HeroDetailComponent}]), provideHttpClient(), provideHttpClientTesting(), ], }), ); }); it(\"should display 1st hero's name\", async () => { const expectedHero = firstHero; await createComponent(expectedHero.id).then(() => { expect(page.nameDisplay.textContent).toBe(expectedHero.name); }); });}/////////// Helpers //////** Create the HeroDetailComponent, initialize it, set test variables */async function createComponent(id: number) { harness = await RouterTestingHarness.creat",
    "id": "component-testing-scenarios-*-angular-40"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": "e(); component = await harness.navigateByUrl(`/heroes/${id}`, HeroDetailComponent); page = new Page(); const request = TestBed.inject(HttpTestingController).expectOne(`api/heroes/?id=${id}`); const hero = getTestHeroes().find((h) => h.id === Number(id)); request.flush(hero ? [hero] : []); harness.detectChanges();}class Page { // getter properties wait to query the DOM until called. get buttons() { return this.queryAll<HTMLButtonElement>('button'); } get saveBtn() { return this.buttons[0]; } get ",
    "id": "component-testing-scenarios-*-angular-41"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": "cancelBtn() { return this.buttons[1]; } get nameDisplay() { return this.query<HTMLElement>('span'); } get nameInput() { return this.query<HTMLInputElement>('input'); } //// query helpers //// private query<T>(selector: string): T { return harness.routeNativeElement!.querySelector(selector)! as T; } private queryAll<T>(selector: string): T[] { return harness.routeNativeElement!.querySelectorAll(selector) as any as T[]; }} Component with external files The preceding BannerComponent is defined with",
    "id": "component-testing-scenarios-*-angular-42"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": " an inline template and inline css, specified in the @Component.template and @Component.styles properties respectively. Many components specify external templates and external css with the @Component.templateUrl and @Component.styleUrls properties respectively, as the following variant of BannerComponent does. app/banner/banner-external.component.ts (metadata) import {Component} from '@angular/core';@Component({ selector: 'app-banner', templateUrl: './banner-external.component.html', styleUrls: ",
    "id": "component-testing-scenarios-*-angular-43"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": "['./banner-external.component.css'],})export class BannerComponent { title = 'Test Tour of Heroes';} This syntax tells the Angular compiler to read the external files during component compilation. That's not a problem when you run the CLI ng test command because it compiles the application before running the tests. However, if you run the tests in a non-CLI environment, tests of this component might fail. For example, if you run the BannerComponent tests in a web coding environment such as plunk",
    "id": "component-testing-scenarios-*-angular-44"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": "er, you'll see a message like this one: Error: This test module uses the component BannerComponentwhich is using a \"templateUrl\" or \"styleUrls\", but they were never compiled.Please call \"TestBed.compileComponents\" before your test. You get this test failure message when the runtime environment compiles the source code during the tests themselves. To correct the problem, call compileComponents() as explained in the following Calling compileComponents section. Component with a dependency Component",
    "id": "component-testing-scenarios-*-angular-45"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": "s often have service dependencies. The WelcomeComponent displays a welcome message to the logged-in user. It knows who the user is based on a property of the injected UserService: app/welcome/welcome.component.ts import {Component, inject, OnInit, signal} from '@angular/core';import {UserService} from '../model/user.service';@Component({ selector: 'app-welcome', template: '<h3 class=\"welcome\"><i>{{welcome()}}</i></h3>',})export class WelcomeComponent { welcome = signal(''); private userService =",
    "id": "component-testing-scenarios-*-angular-46"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": " inject(UserService); constructor() { this.welcome.set( this.userService.isLoggedIn() ? 'Welcome, ' + this.userService.user().name : 'Please log in.', ); }} The WelcomeComponent has decision logic that interacts with the service, logic that makes this component worth testing. Provide service test doubles A component-under-test doesn't have to be provided with real services. Injecting the real UserService could be difficult. The real service might ask the user for login credentials and attempt to",
    "id": "component-testing-scenarios-*-angular-47"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": " reach an authentication server. These behaviors can be hard to intercept. Be aware that using test doubles makes the test behave differently from production so use them sparingly. Get injected services The tests need access to the UserService injected into the WelcomeComponent. Angular has a hierarchical injection system. There can be injectors at multiple levels, from the root injector created by the TestBed down through the component tree. The safest way to get the injected service, the way t",
    "id": "component-testing-scenarios-*-angular-48"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": "hat always works, is to get it from the injector of the component-under-test. The component injector is a property of the fixture's DebugElement. WelcomeComponent's injector import {ComponentFixture, inject, TestBed} from '@angular/core/testing';import {UserService} from '../model/user.service';import {WelcomeComponent} from './welcome.component';class MockUserService { isLoggedIn = true; user = {name: 'Test User'};}describe('WelcomeComponent', () => { let comp: WelcomeComponent; let fixture: Co",
    "id": "component-testing-scenarios-*-angular-49"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": "mponentFixture<WelcomeComponent>; let componentUserService: UserService; // the actually injected service let userService: UserService; // the TestBed injected service let el: HTMLElement; // the DOM element with the welcome message beforeEach(() => { fixture = TestBed.createComponent(WelcomeComponent); fixture.autoDetectChanges(); comp = fixture.componentInstance; // UserService actually injected into the component userService = fixture.debugElement.injector.get(UserService); componentUserServi",
    "id": "component-testing-scenarios-*-angular-50"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": "ce = userService; // UserService from the root injector userService = TestBed.inject(UserService); // get the \"welcome\" element by CSS selector (e.g., by class name) el = fixture.nativeElement.querySelector('.welcome'); }); it('should welcome the user', async () => { await fixture.whenStable(); const content = el.textContent; expect(content).withContext('\"Welcome ...\"').toContain('Welcome'); expect(content).withContext('expected name').toContain('Test User'); }); it('should welcome \"Bubba\"', asy",
    "id": "component-testing-scenarios-*-angular-51"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": "nc () => { userService.user.set({name: 'Bubba'}); // welcome message hasn't been shown yet await fixture.whenStable(); expect(el.textContent).toContain('Bubba'); }); it('should request login if not logged in', async () => { userService.isLoggedIn.set(false); // welcome message hasn't been shown yet await fixture.whenStable(); const content = el.textContent; expect(content).withContext('not welcomed').not.toContain('Welcome'); expect(content) .withContext('\"log in\"') .toMatch(/log in/i); }); it(\"",
    "id": "component-testing-scenarios-*-angular-52"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": "should inject the component's UserService instance\", inject( [UserService], (service: UserService) => { expect(service).toBe(componentUserService); }, )); it('TestBed and Component UserService should be the same', () => { expect(userService).toBe(componentUserService); });}); HELPFUL: This is usually not necessary. Services are often provided in the root or the TestBed overrides and can be retrieved more easily with TestBed.inject() (see below). TestBed.inject() This is easier to remember and le",
    "id": "component-testing-scenarios-*-angular-53"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": "ss verbose than retrieving a service using the fixture's DebugElement. In this test suite, the only provider of UserService is the root testing module, so it is safe to call TestBed.inject() as follows: TestBed injector import {ComponentFixture, inject, TestBed} from '@angular/core/testing';import {UserService} from '../model/user.service';import {WelcomeComponent} from './welcome.component';class MockUserService { isLoggedIn = true; user = {name: 'Test User'};}describe('WelcomeComponent', () =>",
    "id": "component-testing-scenarios-*-angular-54"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": " { let comp: WelcomeComponent; let fixture: ComponentFixture<WelcomeComponent>; let componentUserService: UserService; // the actually injected service let userService: UserService; // the TestBed injected service let el: HTMLElement; // the DOM element with the welcome message beforeEach(() => { fixture = TestBed.createComponent(WelcomeComponent); fixture.autoDetectChanges(); comp = fixture.componentInstance; // UserService actually injected into the component userService = fixture.debugElement",
    "id": "component-testing-scenarios-*-angular-55"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": ".injector.get(UserService); componentUserService = userService; // UserService from the root injector userService = TestBed.inject(UserService); // get the \"welcome\" element by CSS selector (e.g., by class name) el = fixture.nativeElement.querySelector('.welcome'); }); it('should welcome the user', async () => { await fixture.whenStable(); const content = el.textContent; expect(content).withContext('\"Welcome ...\"').toContain('Welcome'); expect(content).withContext('expected name').toContain('Tes",
    "id": "component-testing-scenarios-*-angular-56"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": "t User'); }); it('should welcome \"Bubba\"', async () => { userService.user.set({name: 'Bubba'}); // welcome message hasn't been shown yet await fixture.whenStable(); expect(el.textContent).toContain('Bubba'); }); it('should request login if not logged in', async () => { userService.isLoggedIn.set(false); // welcome message hasn't been shown yet await fixture.whenStable(); const content = el.textContent; expect(content).withContext('not welcomed').not.toContain('Welcome'); expect(content) .withCon",
    "id": "component-testing-scenarios-*-angular-57"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": "text('\"log in\"') .toMatch(/log in/i); }); it(\"should inject the component's UserService instance\", inject( [UserService], (service: UserService) => { expect(service).toBe(componentUserService); }, )); it('TestBed and Component UserService should be the same', () => { expect(userService).toBe(componentUserService); });}); HELPFUL: For a use case in which TestBed.inject() does not work, see the Override component providers section that explains when and why you must get the service from the compon",
    "id": "component-testing-scenarios-*-angular-58"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": "ent's injector instead. Final setup and tests Here's the complete beforeEach(), using TestBed.inject(): app/welcome/welcome.component.spec.ts import {ComponentFixture, inject, TestBed} from '@angular/core/testing';import {UserService} from '../model/user.service';import {WelcomeComponent} from './welcome.component';class MockUserService { isLoggedIn = true; user = {name: 'Test User'};}describe('WelcomeComponent', () => { let comp: WelcomeComponent; let fixture: ComponentFixture<WelcomeComponent>",
    "id": "component-testing-scenarios-*-angular-59"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": "; let componentUserService: UserService; // the actually injected service let userService: UserService; // the TestBed injected service let el: HTMLElement; // the DOM element with the welcome message beforeEach(() => { fixture = TestBed.createComponent(WelcomeComponent); fixture.autoDetectChanges(); comp = fixture.componentInstance; // UserService actually injected into the component userService = fixture.debugElement.injector.get(UserService); componentUserService = userService; // UserService",
    "id": "component-testing-scenarios-*-angular-60"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": " from the root injector userService = TestBed.inject(UserService); // get the \"welcome\" element by CSS selector (e.g., by class name) el = fixture.nativeElement.querySelector('.welcome'); }); it('should welcome the user', async () => { await fixture.whenStable(); const content = el.textContent; expect(content).withContext('\"Welcome ...\"').toContain('Welcome'); expect(content).withContext('expected name').toContain('Test User'); }); it('should welcome \"Bubba\"', async () => { userService.user.set(",
    "id": "component-testing-scenarios-*-angular-61"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": "{name: 'Bubba'}); // welcome message hasn't been shown yet await fixture.whenStable(); expect(el.textContent).toContain('Bubba'); }); it('should request login if not logged in', async () => { userService.isLoggedIn.set(false); // welcome message hasn't been shown yet await fixture.whenStable(); const content = el.textContent; expect(content).withContext('not welcomed').not.toContain('Welcome'); expect(content) .withContext('\"log in\"') .toMatch(/log in/i); }); it(\"should inject the component's Us",
    "id": "component-testing-scenarios-*-angular-62"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": "erService instance\", inject( [UserService], (service: UserService) => { expect(service).toBe(componentUserService); }, )); it('TestBed and Component UserService should be the same', () => { expect(userService).toBe(componentUserService); });}); And here are some tests: app/welcome/welcome.component.spec.ts import {ComponentFixture, inject, TestBed} from '@angular/core/testing';import {UserService} from '../model/user.service';import {WelcomeComponent} from './welcome.component';class MockUserSer",
    "id": "component-testing-scenarios-*-angular-63"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": "vice { isLoggedIn = true; user = {name: 'Test User'};}describe('WelcomeComponent', () => { let comp: WelcomeComponent; let fixture: ComponentFixture<WelcomeComponent>; let componentUserService: UserService; // the actually injected service let userService: UserService; // the TestBed injected service let el: HTMLElement; // the DOM element with the welcome message beforeEach(() => { fixture = TestBed.createComponent(WelcomeComponent); fixture.autoDetectChanges(); comp = fixture.componentInstance",
    "id": "component-testing-scenarios-*-angular-64"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": "; // UserService actually injected into the component userService = fixture.debugElement.injector.get(UserService); componentUserService = userService; // UserService from the root injector userService = TestBed.inject(UserService); // get the \"welcome\" element by CSS selector (e.g., by class name) el = fixture.nativeElement.querySelector('.welcome'); }); it('should welcome the user', async () => { await fixture.whenStable(); const content = el.textContent; expect(content).withContext('\"Welcome ",
    "id": "component-testing-scenarios-*-angular-65"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": "...\"').toContain('Welcome'); expect(content).withContext('expected name').toContain('Test User'); }); it('should welcome \"Bubba\"', async () => { userService.user.set({name: 'Bubba'}); // welcome message hasn't been shown yet await fixture.whenStable(); expect(el.textContent).toContain('Bubba'); }); it('should request login if not logged in', async () => { userService.isLoggedIn.set(false); // welcome message hasn't been shown yet await fixture.whenStable(); const content = el.textContent; expect",
    "id": "component-testing-scenarios-*-angular-66"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": "(content).withContext('not welcomed').not.toContain('Welcome'); expect(content) .withContext('\"log in\"') .toMatch(/log in/i); }); it(\"should inject the component's UserService instance\", inject( [UserService], (service: UserService) => { expect(service).toBe(componentUserService); }, )); it('TestBed and Component UserService should be the same', () => { expect(userService).toBe(componentUserService); });}); The first is a sanity test; it confirms that the UserService is called and working. HELPF",
    "id": "component-testing-scenarios-*-angular-67"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": "UL: The withContext function (for example, 'expected name') is an optional failure label. If the expectation fails, Jasmine appends this label to the expectation failure message. In a spec with multiple expectations, it can help clarify what went wrong and which expectation failed. The remaining tests confirm the logic of the component when the service returns different values. The second test validates the effect of changing the user name. The third test checks that the component displays the p",
    "id": "component-testing-scenarios-*-angular-68"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": "roper message when there is no logged-in user. Component with async service In this sample, the AboutComponent template hosts a TwainComponent. The TwainComponent displays Mark Twain quotes. app/twain/twain.component.ts (template) import {Component, inject, OnInit, signal} from '@angular/core';import {AsyncPipe} from '@angular/common';import {sharedImports} from '../shared/shared';import {Observable, of} from 'rxjs';import {catchError, startWith} from 'rxjs/operators';import {TwainService} from ",
    "id": "component-testing-scenarios-*-angular-69"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": "'./twain.service';@Component({ selector: 'twain-quote', template: ` <p class=\"twain\"> <i>{{ quote | async }}</i> </p> <button type=\"button\" (click)=\"getQuote()\">Next quote</button> @if (errorMessage()) { <p class=\"error\">{{ errorMessage() }}</p> }`, styles: ['.twain { font-style: italic; } .error { color: red; }'], imports: [AsyncPipe, sharedImports],})export class TwainComponent { errorMessage = signal(''); quote?: Observable<string>; private twainService = inject(TwainService); constructor() {",
    "id": "component-testing-scenarios-*-angular-70"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": " this.getQuote(); } getQuote() { this.errorMessage.set(''); this.quote = this.twainService.getQuote().pipe( startWith('...'), catchError((err: any) => { this.errorMessage.set(err.message || err.toString()); return of('...'); // reset message to placeholder }), ); }} HELPFUL: The value of the component's quote property passes through an AsyncPipe. That means the property returns either a Promise or an Observable. In this example, the TwainComponent.getQuote() method tells you that the quote prope",
    "id": "component-testing-scenarios-*-angular-71"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": "rty returns an Observable. app/twain/twain.component.ts (getQuote) import {Component, inject, OnInit, signal} from '@angular/core';import {AsyncPipe} from '@angular/common';import {sharedImports} from '../shared/shared';import {Observable, of} from 'rxjs';import {catchError, startWith} from 'rxjs/operators';import {TwainService} from './twain.service';@Component({ selector: 'twain-quote', template: ` <p class=\"twain\"> <i>{{ quote | async }}</i> </p> <button type=\"button\" (click)=\"getQuote()\">Nex",
    "id": "component-testing-scenarios-*-angular-72"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": "t quote</button> @if (errorMessage()) { <p class=\"error\">{{ errorMessage() }}</p> }`, styles: ['.twain { font-style: italic; } .error { color: red; }'], imports: [AsyncPipe, sharedImports],})export class TwainComponent { errorMessage = signal(''); quote?: Observable<string>; private twainService = inject(TwainService); constructor() { this.getQuote(); } getQuote() { this.errorMessage.set(''); this.quote = this.twainService.getQuote().pipe( startWith('...'), catchError((err: any) => { this.errorM",
    "id": "component-testing-scenarios-*-angular-73"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": "essage.set(err.message || err.toString()); return of('...'); // reset message to placeholder }), ); }} The TwainComponent gets quotes from an injected TwainService. The component starts the returned Observable with a placeholder value ('...'), before the service can return its first quote. The catchError intercepts service errors, prepares an error message, and returns the placeholder value on the success channel. These are all features you'll want to test. Testing with a spy When testing a comp",
    "id": "component-testing-scenarios-*-angular-74"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": "onent, only the service's public API should matter. In general, tests themselves should not make calls to remote servers. They should emulate such calls. The setup in this app/twain/twain.component.spec.ts shows one way to do that: app/twain/twain.component.spec.ts (setup) import {fakeAsync, ComponentFixture, TestBed, tick, waitForAsync} from '@angular/core/testing';import {asyncData, asyncError} from '../../testing';import {Subject, defer, of, throwError} from 'rxjs';import {last} from 'rxjs/op",
    "id": "component-testing-scenarios-*-angular-75"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": "erators';import {TwainComponent} from './twain.component';import {TwainService} from './twain.service';describe('TwainComponent', () => { let component: TwainComponent; let fixture: ComponentFixture<TwainComponent>; let getQuoteSpy: jasmine.Spy; let quoteEl: HTMLElement; let testQuote: string; // Helper function to get the error message element value // An *ngIf keeps it out of the DOM until there is an error const errorMessage = () => { const el = fixture.nativeElement.querySelector('.error'); ",
    "id": "component-testing-scenarios-*-angular-76"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": "return el ? el.textContent : null; }; beforeEach(() => { TestBed.configureTestingModule({ imports: [TwainComponent], providers: [TwainService], }); testQuote = 'Test Quote'; // Create a fake TwainService object with a `getQuote()` spy const twainService = TestBed.inject(TwainService); // Make the spy return a synchronous Observable with the test data getQuoteSpy = spyOn(twainService, 'getQuote').and.returnValue(of(testQuote)); fixture = TestBed.createComponent(TwainComponent); fixture.autoDetect",
    "id": "component-testing-scenarios-*-angular-77"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": "Changes(); component = fixture.componentInstance; quoteEl = fixture.nativeElement.querySelector('.twain'); }); describe('when test with synchronous observable', () => { it('should not show quote before OnInit', () => { expect(quoteEl.textContent).withContext('nothing displayed').toBe(''); expect(errorMessage()).withContext('should not show error element').toBeNull(); expect(getQuoteSpy.calls.any()).withContext('getQuote not yet called').toBe(false); }); // The quote would not be immediately avai",
    "id": "component-testing-scenarios-*-angular-78"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": "lable if the service were truly async. it('should show quote after component initialized', async () => { await fixture.whenStable(); // onInit() // sync spy result shows testQuote immediately after init expect(quoteEl.textContent).toBe(testQuote); expect(getQuoteSpy.calls.any()).withContext('getQuote called').toBe(true); }); // The error would not be immediately available if the service were truly async. // Use `fakeAsync` because the component error calls `setTimeout` it('should display error w",
    "id": "component-testing-scenarios-*-angular-79"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": "hen TwainService fails', fakeAsync(() => { // tell spy to return an error observable after a timeout getQuoteSpy.and.returnValue( defer(() => { return new Promise((resolve, reject) => { setTimeout(() => { reject('TwainService test failure'); }); }); }), ); fixture.detectChanges(); // onInit() // sync spy errors immediately after init tick(); // flush the setTimeout() fixture.detectChanges(); // update errorMessage within setTimeout() expect(errorMessage()) .withContext('should display error') .t",
    "id": "component-testing-scenarios-*-angular-80"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": "oMatch(/test failure/); expect(quoteEl.textContent).withContext('should show placeholder').toBe('...'); })); }); describe('when test with asynchronous observable', () => { beforeEach(() => { // Simulate delayed observable values with the `asyncData()` helper getQuoteSpy.and.returnValue(asyncData(testQuote)); }); it('should not show quote before OnInit', () => { expect(quoteEl.textContent).withContext('nothing displayed').toBe(''); expect(errorMessage()).withContext('should not show error element",
    "id": "component-testing-scenarios-*-angular-81"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": "').toBeNull(); expect(getQuoteSpy.calls.any()).withContext('getQuote not yet called').toBe(false); }); it('should still not show quote after component initialized', () => { fixture.detectChanges(); // getQuote service is async => still has not returned with quote // so should show the start value, '...' expect(quoteEl.textContent).withContext('should show placeholder').toBe('...'); expect(errorMessage()).withContext('should not show error').toBeNull(); expect(getQuoteSpy.calls.any()).withContext",
    "id": "component-testing-scenarios-*-angular-82"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": "('getQuote called').toBe(true); }); it('should show quote after getQuote (fakeAsync)', fakeAsync(() => { fixture.detectChanges(); // ngOnInit() expect(quoteEl.textContent).withContext('should show placeholder').toBe('...'); tick(); // flush the observable to get the quote fixture.detectChanges(); // update view expect(quoteEl.textContent).withContext('should show quote').toBe(testQuote); expect(errorMessage()).withContext('should not show error').toBeNull(); })); it('should show quote after getQ",
    "id": "component-testing-scenarios-*-angular-83"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": "uote (async)', async () => { fixture.detectChanges(); // ngOnInit() expect(quoteEl.textContent).withContext('should show placeholder').toBe('...'); await fixture.whenStable(); // wait for async getQuote fixture.detectChanges(); // update view with quote expect(quoteEl.textContent).toBe(testQuote); expect(errorMessage()).withContext('should not show error').toBeNull(); }); it('should display error when TwainService fails', fakeAsync(() => { // tell spy to return an async error observable getQuote",
    "id": "component-testing-scenarios-*-angular-84"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": "Spy.and.returnValue(asyncError<string>('TwainService test failure')); fixture.detectChanges(); tick(); // component shows error after a setTimeout() fixture.detectChanges(); // update error message expect(errorMessage()) .withContext('should display error') .toMatch(/test failure/); expect(quoteEl.textContent).withContext('should show placeholder').toBe('...'); })); });}); Focus on the spy. import {fakeAsync, ComponentFixture, TestBed, tick, waitForAsync} from '@angular/core/testing';import {asy",
    "id": "component-testing-scenarios-*-angular-85"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": "ncData, asyncError} from '../../testing';import {Subject, defer, of, throwError} from 'rxjs';import {last} from 'rxjs/operators';import {TwainComponent} from './twain.component';import {TwainService} from './twain.service';describe('TwainComponent', () => { let component: TwainComponent; let fixture: ComponentFixture<TwainComponent>; let getQuoteSpy: jasmine.Spy; let quoteEl: HTMLElement; let testQuote: string; // Helper function to get the error message element value // An *ngIf keeps it out of",
    "id": "component-testing-scenarios-*-angular-86"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": " the DOM until there is an error const errorMessage = () => { const el = fixture.nativeElement.querySelector('.error'); return el ? el.textContent : null; }; beforeEach(() => { TestBed.configureTestingModule({ imports: [TwainComponent], providers: [TwainService], }); testQuote = 'Test Quote'; // Create a fake TwainService object with a `getQuote()` spy const twainService = TestBed.inject(TwainService); // Make the spy return a synchronous Observable with the test data getQuoteSpy = spyOn(twainSe",
    "id": "component-testing-scenarios-*-angular-87"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": "rvice, 'getQuote').and.returnValue(of(testQuote)); fixture = TestBed.createComponent(TwainComponent); fixture.autoDetectChanges(); component = fixture.componentInstance; quoteEl = fixture.nativeElement.querySelector('.twain'); }); describe('when test with synchronous observable', () => { it('should not show quote before OnInit', () => { expect(quoteEl.textContent).withContext('nothing displayed').toBe(''); expect(errorMessage()).withContext('should not show error element').toBeNull(); expect(get",
    "id": "component-testing-scenarios-*-angular-88"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": "QuoteSpy.calls.any()).withContext('getQuote not yet called').toBe(false); }); // The quote would not be immediately available if the service were truly async. it('should show quote after component initialized', async () => { await fixture.whenStable(); // onInit() // sync spy result shows testQuote immediately after init expect(quoteEl.textContent).toBe(testQuote); expect(getQuoteSpy.calls.any()).withContext('getQuote called').toBe(true); }); // The error would not be immediately available if th",
    "id": "component-testing-scenarios-*-angular-89"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": "e service were truly async. // Use `fakeAsync` because the component error calls `setTimeout` it('should display error when TwainService fails', fakeAsync(() => { // tell spy to return an error observable after a timeout getQuoteSpy.and.returnValue( defer(() => { return new Promise((resolve, reject) => { setTimeout(() => { reject('TwainService test failure'); }); }); }), ); fixture.detectChanges(); // onInit() // sync spy errors immediately after init tick(); // flush the setTimeout() fixture.de",
    "id": "component-testing-scenarios-*-angular-90"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": "tectChanges(); // update errorMessage within setTimeout() expect(errorMessage()) .withContext('should display error') .toMatch(/test failure/); expect(quoteEl.textContent).withContext('should show placeholder').toBe('...'); })); }); describe('when test with asynchronous observable', () => { beforeEach(() => { // Simulate delayed observable values with the `asyncData()` helper getQuoteSpy.and.returnValue(asyncData(testQuote)); }); it('should not show quote before OnInit', () => { expect(quoteEl.t",
    "id": "component-testing-scenarios-*-angular-91"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": "extContent).withContext('nothing displayed').toBe(''); expect(errorMessage()).withContext('should not show error element').toBeNull(); expect(getQuoteSpy.calls.any()).withContext('getQuote not yet called').toBe(false); }); it('should still not show quote after component initialized', () => { fixture.detectChanges(); // getQuote service is async => still has not returned with quote // so should show the start value, '...' expect(quoteEl.textContent).withContext('should show placeholder').toBe('..",
    "id": "component-testing-scenarios-*-angular-92"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": ".'); expect(errorMessage()).withContext('should not show error').toBeNull(); expect(getQuoteSpy.calls.any()).withContext('getQuote called').toBe(true); }); it('should show quote after getQuote (fakeAsync)', fakeAsync(() => { fixture.detectChanges(); // ngOnInit() expect(quoteEl.textContent).withContext('should show placeholder').toBe('...'); tick(); // flush the observable to get the quote fixture.detectChanges(); // update view expect(quoteEl.textContent).withContext('should show quote').toBe(t",
    "id": "component-testing-scenarios-*-angular-93"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": "estQuote); expect(errorMessage()).withContext('should not show error').toBeNull(); })); it('should show quote after getQuote (async)', async () => { fixture.detectChanges(); // ngOnInit() expect(quoteEl.textContent).withContext('should show placeholder').toBe('...'); await fixture.whenStable(); // wait for async getQuote fixture.detectChanges(); // update view with quote expect(quoteEl.textContent).toBe(testQuote); expect(errorMessage()).withContext('should not show error').toBeNull(); }); it('s",
    "id": "component-testing-scenarios-*-angular-94"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": "hould display error when TwainService fails', fakeAsync(() => { // tell spy to return an async error observable getQuoteSpy.and.returnValue(asyncError<string>('TwainService test failure')); fixture.detectChanges(); tick(); // component shows error after a setTimeout() fixture.detectChanges(); // update error message expect(errorMessage()) .withContext('should display error') .toMatch(/test failure/); expect(quoteEl.textContent).withContext('should show placeholder').toBe('...'); })); });}); The ",
    "id": "component-testing-scenarios-*-angular-95"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": "spy is designed such that any call to getQuote receives an observable with a test quote. Unlike the real getQuote() method, this spy bypasses the server and returns a synchronous observable whose value is available immediately. You can write many useful tests with this spy, even though its Observable is synchronous. HELPFUL: It is best to limit the usage of spies to only what is necessary for the test. Creating mocks or spies for more than what's necessary can be brittle. As the component and in",
    "id": "component-testing-scenarios-*-angular-96"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": "jectable evolves, the unrelated tests can fail because they no longer mock enough behaviors that would otherwise not affect the test. Async test with fakeAsync() To use fakeAsync() functionality, you must import zone.js/testing in your test setup file. If you created your project with the Angular CLI, zone-testing is already imported in src/test.ts. The following test confirms the expected behavior when the service returns an ErrorObservable. import {fakeAsync, ComponentFixture, TestBed, tick, w",
    "id": "component-testing-scenarios-*-angular-97"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": "aitForAsync} from '@angular/core/testing';import {asyncData, asyncError} from '../../testing';import {Subject, defer, of, throwError} from 'rxjs';import {last} from 'rxjs/operators';import {TwainComponent} from './twain.component';import {TwainService} from './twain.service';describe('TwainComponent', () => { let component: TwainComponent; let fixture: ComponentFixture<TwainComponent>; let getQuoteSpy: jasmine.Spy; let quoteEl: HTMLElement; let testQuote: string; // Helper function to get the er",
    "id": "component-testing-scenarios-*-angular-98"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": "ror message element value // An *ngIf keeps it out of the DOM until there is an error const errorMessage = () => { const el = fixture.nativeElement.querySelector('.error'); return el ? el.textContent : null; }; beforeEach(() => { TestBed.configureTestingModule({ imports: [TwainComponent], providers: [TwainService], }); testQuote = 'Test Quote'; // Create a fake TwainService object with a `getQuote()` spy const twainService = TestBed.inject(TwainService); // Make the spy return a synchronous Obse",
    "id": "component-testing-scenarios-*-angular-99"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": "rvable with the test data getQuoteSpy = spyOn(twainService, 'getQuote').and.returnValue(of(testQuote)); fixture = TestBed.createComponent(TwainComponent); fixture.autoDetectChanges(); component = fixture.componentInstance; quoteEl = fixture.nativeElement.querySelector('.twain'); }); describe('when test with synchronous observable', () => { it('should not show quote before OnInit', () => { expect(quoteEl.textContent).withContext('nothing displayed').toBe(''); expect(errorMessage()).withContext('s",
    "id": "component-testing-scenarios-*-angular-100"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": "hould not show error element').toBeNull(); expect(getQuoteSpy.calls.any()).withContext('getQuote not yet called').toBe(false); }); // The quote would not be immediately available if the service were truly async. it('should show quote after component initialized', async () => { await fixture.whenStable(); // onInit() // sync spy result shows testQuote immediately after init expect(quoteEl.textContent).toBe(testQuote); expect(getQuoteSpy.calls.any()).withContext('getQuote called').toBe(true); }); ",
    "id": "component-testing-scenarios-*-angular-101"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": "// The error would not be immediately available if the service were truly async. // Use `fakeAsync` because the component error calls `setTimeout` it('should display error when TwainService fails', fakeAsync(() => { // tell spy to return an error observable after a timeout getQuoteSpy.and.returnValue( defer(() => { return new Promise((resolve, reject) => { setTimeout(() => { reject('TwainService test failure'); }); }); }), ); fixture.detectChanges(); // onInit() // sync spy errors immediately af",
    "id": "component-testing-scenarios-*-angular-102"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": "ter init tick(); // flush the setTimeout() fixture.detectChanges(); // update errorMessage within setTimeout() expect(errorMessage()) .withContext('should display error') .toMatch(/test failure/); expect(quoteEl.textContent).withContext('should show placeholder').toBe('...'); })); }); describe('when test with asynchronous observable', () => { beforeEach(() => { // Simulate delayed observable values with the `asyncData()` helper getQuoteSpy.and.returnValue(asyncData(testQuote)); }); it('should no",
    "id": "component-testing-scenarios-*-angular-103"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": "t show quote before OnInit', () => { expect(quoteEl.textContent).withContext('nothing displayed').toBe(''); expect(errorMessage()).withContext('should not show error element').toBeNull(); expect(getQuoteSpy.calls.any()).withContext('getQuote not yet called').toBe(false); }); it('should still not show quote after component initialized', () => { fixture.detectChanges(); // getQuote service is async => still has not returned with quote // so should show the start value, '...' expect(quoteEl.textCon",
    "id": "component-testing-scenarios-*-angular-104"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": "tent).withContext('should show placeholder').toBe('...'); expect(errorMessage()).withContext('should not show error').toBeNull(); expect(getQuoteSpy.calls.any()).withContext('getQuote called').toBe(true); }); it('should show quote after getQuote (fakeAsync)', fakeAsync(() => { fixture.detectChanges(); // ngOnInit() expect(quoteEl.textContent).withContext('should show placeholder').toBe('...'); tick(); // flush the observable to get the quote fixture.detectChanges(); // update view expect(quoteEl",
    "id": "component-testing-scenarios-*-angular-105"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": ".textContent).withContext('should show quote').toBe(testQuote); expect(errorMessage()).withContext('should not show error').toBeNull(); })); it('should show quote after getQuote (async)', async () => { fixture.detectChanges(); // ngOnInit() expect(quoteEl.textContent).withContext('should show placeholder').toBe('...'); await fixture.whenStable(); // wait for async getQuote fixture.detectChanges(); // update view with quote expect(quoteEl.textContent).toBe(testQuote); expect(errorMessage()).withC",
    "id": "component-testing-scenarios-*-angular-106"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": "ontext('should not show error').toBeNull(); }); it('should display error when TwainService fails', fakeAsync(() => { // tell spy to return an async error observable getQuoteSpy.and.returnValue(asyncError<string>('TwainService test failure')); fixture.detectChanges(); tick(); // component shows error after a setTimeout() fixture.detectChanges(); // update error message expect(errorMessage()) .withContext('should display error') .toMatch(/test failure/); expect(quoteEl.textContent).withContext('sh",
    "id": "component-testing-scenarios-*-angular-107"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": "ould show placeholder').toBe('...'); })); });}); HELPFUL: The it() function receives an argument of the following form. fakeAsync(() => { /*test body*/ }) The fakeAsync() function enables a linear coding style by running the test body in a special fakeAsync test zone. The test body appears to be synchronous. There is no nested syntax (like a Promise.then()) to disrupt the flow of control. HELPFUL: Limitation: The fakeAsync() function won't work if the test body makes an XMLHttpRequest (XHR) call",
    "id": "component-testing-scenarios-*-angular-108"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": ". XHR calls within a test are rare, but if you need to call XHR, see the waitForAsync() section. IMPORTANT: Be aware that asynchronous tasks that happen inside the fakeAsync zone need to be manually executed with flush or tick. If you attempt to wait for them to complete (i.e. using fixture.whenStable) without using the fakeAsync test helpers to advance time, your test will likely fail. See below for more information. The tick() function You do have to call tick() to advance the virtual clock. C",
    "id": "component-testing-scenarios-*-angular-109"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": "alling tick() simulates the passage of time until all pending asynchronous activities finish. In this case, it waits for the observable's setTimeout(). The tick() function accepts millis and tickOptions as parameters. The millis parameter specifies how much the virtual clock advances and defaults to 0 if not provided. For example, if you have a setTimeout(fn, 100) in a fakeAsync() test, you need to use tick(100) to trigger the fn callback. The optional tickOptions parameter has a property named ",
    "id": "component-testing-scenarios-*-angular-110"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": "processNewMacroTasksSynchronously. The processNewMacroTasksSynchronously property represents whether to invoke new generated macro tasks when ticking and defaults to true. import {fakeAsync, tick, waitForAsync} from '@angular/core/testing';import {interval, of} from 'rxjs';import {delay, take} from 'rxjs/operators';describe('Angular async helper', () => { describe('async', () => { let actuallyDone = false; beforeEach(() => { actuallyDone = false; }); afterEach(() => { expect(actuallyDone).withCo",
    "id": "component-testing-scenarios-*-angular-111"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": "ntext('actuallyDone should be true').toBe(true); }); it('should run normal test', () => { actuallyDone = true; }); it('should run normal async test', (done: DoneFn) => { setTimeout(() => { actuallyDone = true; done(); }, 0); }); it('should run async test with task', waitForAsync(() => { setTimeout(() => { actuallyDone = true; }, 0); })); it('should run async test with task', waitForAsync(() => { const id = setInterval(() => { actuallyDone = true; clearInterval(id); }, 100); })); it('should run a",
    "id": "component-testing-scenarios-*-angular-112"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": "sync test with successful promise', waitForAsync(() => { const p = new Promise((resolve) => { setTimeout(resolve, 10); }); p.then(() => { actuallyDone = true; }); })); it('should run async test with failed promise', waitForAsync(() => { const p = new Promise((resolve, reject) => { setTimeout(reject, 10); }); p.catch(() => { actuallyDone = true; }); })); // Use done. Can also use async or fakeAsync. it('should run async test with successful delayed Observable', (done: DoneFn) => { const source = ",
    "id": "component-testing-scenarios-*-angular-113"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": "of(true).pipe(delay(10)); source.subscribe({ next: (val) => (actuallyDone = true), error: (err) => fail(err), complete: done, }); }); it('should run async test with successful delayed Observable', waitForAsync(() => { const source = of(true).pipe(delay(10)); source.subscribe({ next: (val) => (actuallyDone = true), error: (err) => fail(err), }); })); it('should run async test with successful delayed Observable', fakeAsync(() => { const source = of(true).pipe(delay(10)); source.subscribe({ next: (",
    "id": "component-testing-scenarios-*-angular-114"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": "val) => (actuallyDone = true), error: (err) => fail(err), }); tick(10); })); }); describe('fakeAsync', () => { it('should run timeout callback with delay after call tick with millis', fakeAsync(() => { let called = false; setTimeout(() => { called = true; }, 100); tick(100); expect(called).toBe(true); })); it('should run new macro task callback with delay after call tick with millis', fakeAsync(() => { function nestedTimer(cb: () => any): void { setTimeout(() => setTimeout(() => cb())); } const ",
    "id": "component-testing-scenarios-*-angular-115"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": "callback = jasmine.createSpy('callback'); nestedTimer(callback); expect(callback).not.toHaveBeenCalled(); tick(0); // the nested timeout will also be triggered expect(callback).toHaveBeenCalled(); })); it('should not run new macro task callback with delay after call tick with millis', fakeAsync(() => { function nestedTimer(cb: () => any): void { setTimeout(() => setTimeout(() => cb())); } const callback = jasmine.createSpy('callback'); nestedTimer(callback); expect(callback).not.toHaveBeenCalled",
    "id": "component-testing-scenarios-*-angular-116"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": "(); tick(0, {processNewMacroTasksSynchronously: false}); // the nested timeout will not be triggered expect(callback).not.toHaveBeenCalled(); tick(0); expect(callback).toHaveBeenCalled(); })); it('should get Date diff correctly in fakeAsync', fakeAsync(() => { const start = Date.now(); tick(100); const end = Date.now(); expect(end - start).toBe(100); })); it('should get Date diff correctly in fakeAsync with rxjs scheduler', fakeAsync(() => { // need to add `import 'zone.js/plugins/zone-patch-rxj",
    "id": "component-testing-scenarios-*-angular-117"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": "s-fake-async' // to patch rxjs scheduler let result = ''; of('hello') .pipe(delay(1000)) .subscribe((v) => { result = v; }); expect(result).toBe(''); tick(1000); expect(result).toBe('hello'); const start = new Date().getTime(); let dateDiff = 0; interval(1000) .pipe(take(2)) .subscribe(() => (dateDiff = new Date().getTime() - start)); tick(1000); expect(dateDiff).toBe(1000); tick(1000); expect(dateDiff).toBe(2000); })); }); describe('use jasmine.clock()', () => { // need to config __zone_symbol_",
    "id": "component-testing-scenarios-*-angular-118"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": "_fakeAsyncPatchLock flag // before loading zone.js/testing beforeEach(() => { jasmine.clock().install(); }); afterEach(() => { jasmine.clock().uninstall(); }); it('should auto enter fakeAsync', () => { // is in fakeAsync now, don't need to call fakeAsync(testFn) let called = false; setTimeout(() => { called = true; }, 100); jasmine.clock().tick(100); expect(called).toBe(true); }); }); describe('test jsonp', () => { function jsonp(url: string, callback: () => void) { // do a jsonp call which is n",
    "id": "component-testing-scenarios-*-angular-119"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": "ot zone aware } // need to config __zone_symbol__supportWaitUnResolvedChainedPromise flag // before loading zone.js/testing it('should wait until promise.then is called', waitForAsync(() => { let finished = false; new Promise<void>((res) => { jsonp('localhost:8080/jsonp', () => { // success callback and resolve the promise finished = true; res(); }); }).then(() => { // async will wait until promise.then is called // if __zone_symbol__supportWaitUnResolvedChainedPromise is set expect(finished).to",
    "id": "component-testing-scenarios-*-angular-120"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": "Be(true); }); })); });}); The tick() function is one of the Angular testing utilities that you import with TestBed. It's a companion to fakeAsync() and you can only call it within a fakeAsync() body. tickOptions In this example, you have a new macro task, the nested setTimeout function. By default, when the tick is setTimeout, outside and nested will both be triggered. import {fakeAsync, tick, waitForAsync} from '@angular/core/testing';import {interval, of} from 'rxjs';import {delay, take} from ",
    "id": "component-testing-scenarios-*-angular-121"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": "'rxjs/operators';describe('Angular async helper', () => { describe('async', () => { let actuallyDone = false; beforeEach(() => { actuallyDone = false; }); afterEach(() => { expect(actuallyDone).withContext('actuallyDone should be true').toBe(true); }); it('should run normal test', () => { actuallyDone = true; }); it('should run normal async test', (done: DoneFn) => { setTimeout(() => { actuallyDone = true; done(); }, 0); }); it('should run async test with task', waitForAsync(() => { setTimeout((",
    "id": "component-testing-scenarios-*-angular-122"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": ") => { actuallyDone = true; }, 0); })); it('should run async test with task', waitForAsync(() => { const id = setInterval(() => { actuallyDone = true; clearInterval(id); }, 100); })); it('should run async test with successful promise', waitForAsync(() => { const p = new Promise((resolve) => { setTimeout(resolve, 10); }); p.then(() => { actuallyDone = true; }); })); it('should run async test with failed promise', waitForAsync(() => { const p = new Promise((resolve, reject) => { setTimeout(reject,",
    "id": "component-testing-scenarios-*-angular-123"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": " 10); }); p.catch(() => { actuallyDone = true; }); })); // Use done. Can also use async or fakeAsync. it('should run async test with successful delayed Observable', (done: DoneFn) => { const source = of(true).pipe(delay(10)); source.subscribe({ next: (val) => (actuallyDone = true), error: (err) => fail(err), complete: done, }); }); it('should run async test with successful delayed Observable', waitForAsync(() => { const source = of(true).pipe(delay(10)); source.subscribe({ next: (val) => (actual",
    "id": "component-testing-scenarios-*-angular-124"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": "lyDone = true), error: (err) => fail(err), }); })); it('should run async test with successful delayed Observable', fakeAsync(() => { const source = of(true).pipe(delay(10)); source.subscribe({ next: (val) => (actuallyDone = true), error: (err) => fail(err), }); tick(10); })); }); describe('fakeAsync', () => { it('should run timeout callback with delay after call tick with millis', fakeAsync(() => { let called = false; setTimeout(() => { called = true; }, 100); tick(100); expect(called).toBe(true",
    "id": "component-testing-scenarios-*-angular-125"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": "); })); it('should run new macro task callback with delay after call tick with millis', fakeAsync(() => { function nestedTimer(cb: () => any): void { setTimeout(() => setTimeout(() => cb())); } const callback = jasmine.createSpy('callback'); nestedTimer(callback); expect(callback).not.toHaveBeenCalled(); tick(0); // the nested timeout will also be triggered expect(callback).toHaveBeenCalled(); })); it('should not run new macro task callback with delay after call tick with millis', fakeAsync(() =",
    "id": "component-testing-scenarios-*-angular-126"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": "> { function nestedTimer(cb: () => any): void { setTimeout(() => setTimeout(() => cb())); } const callback = jasmine.createSpy('callback'); nestedTimer(callback); expect(callback).not.toHaveBeenCalled(); tick(0, {processNewMacroTasksSynchronously: false}); // the nested timeout will not be triggered expect(callback).not.toHaveBeenCalled(); tick(0); expect(callback).toHaveBeenCalled(); })); it('should get Date diff correctly in fakeAsync', fakeAsync(() => { const start = Date.now(); tick(100); co",
    "id": "component-testing-scenarios-*-angular-127"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": "nst end = Date.now(); expect(end - start).toBe(100); })); it('should get Date diff correctly in fakeAsync with rxjs scheduler', fakeAsync(() => { // need to add `import 'zone.js/plugins/zone-patch-rxjs-fake-async' // to patch rxjs scheduler let result = ''; of('hello') .pipe(delay(1000)) .subscribe((v) => { result = v; }); expect(result).toBe(''); tick(1000); expect(result).toBe('hello'); const start = new Date().getTime(); let dateDiff = 0; interval(1000) .pipe(take(2)) .subscribe(() => (dateDi",
    "id": "component-testing-scenarios-*-angular-128"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": "ff = new Date().getTime() - start)); tick(1000); expect(dateDiff).toBe(1000); tick(1000); expect(dateDiff).toBe(2000); })); }); describe('use jasmine.clock()', () => { // need to config __zone_symbol__fakeAsyncPatchLock flag // before loading zone.js/testing beforeEach(() => { jasmine.clock().install(); }); afterEach(() => { jasmine.clock().uninstall(); }); it('should auto enter fakeAsync', () => { // is in fakeAsync now, don't need to call fakeAsync(testFn) let called = false; setTimeout(() => ",
    "id": "component-testing-scenarios-*-angular-129"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": "{ called = true; }, 100); jasmine.clock().tick(100); expect(called).toBe(true); }); }); describe('test jsonp', () => { function jsonp(url: string, callback: () => void) { // do a jsonp call which is not zone aware } // need to config __zone_symbol__supportWaitUnResolvedChainedPromise flag // before loading zone.js/testing it('should wait until promise.then is called', waitForAsync(() => { let finished = false; new Promise<void>((res) => { jsonp('localhost:8080/jsonp', () => { // success callback",
    "id": "component-testing-scenarios-*-angular-130"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": " and resolve the promise finished = true; res(); }); }).then(() => { // async will wait until promise.then is called // if __zone_symbol__supportWaitUnResolvedChainedPromise is set expect(finished).toBe(true); }); })); });}); In some case, you don't want to trigger the new macro task when ticking. You can use tick(millis, {processNewMacroTasksSynchronously: false}) to not invoke a new macro task. import {fakeAsync, tick, waitForAsync} from '@angular/core/testing';import {interval, of} from 'rxjs",
    "id": "component-testing-scenarios-*-angular-131"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": "';import {delay, take} from 'rxjs/operators';describe('Angular async helper', () => { describe('async', () => { let actuallyDone = false; beforeEach(() => { actuallyDone = false; }); afterEach(() => { expect(actuallyDone).withContext('actuallyDone should be true').toBe(true); }); it('should run normal test', () => { actuallyDone = true; }); it('should run normal async test', (done: DoneFn) => { setTimeout(() => { actuallyDone = true; done(); }, 0); }); it('should run async test with task', waitF",
    "id": "component-testing-scenarios-*-angular-132"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": "orAsync(() => { setTimeout(() => { actuallyDone = true; }, 0); })); it('should run async test with task', waitForAsync(() => { const id = setInterval(() => { actuallyDone = true; clearInterval(id); }, 100); })); it('should run async test with successful promise', waitForAsync(() => { const p = new Promise((resolve) => { setTimeout(resolve, 10); }); p.then(() => { actuallyDone = true; }); })); it('should run async test with failed promise', waitForAsync(() => { const p = new Promise((resolve, rej",
    "id": "component-testing-scenarios-*-angular-133"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": "ect) => { setTimeout(reject, 10); }); p.catch(() => { actuallyDone = true; }); })); // Use done. Can also use async or fakeAsync. it('should run async test with successful delayed Observable', (done: DoneFn) => { const source = of(true).pipe(delay(10)); source.subscribe({ next: (val) => (actuallyDone = true), error: (err) => fail(err), complete: done, }); }); it('should run async test with successful delayed Observable', waitForAsync(() => { const source = of(true).pipe(delay(10)); source.subscr",
    "id": "component-testing-scenarios-*-angular-134"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": "ibe({ next: (val) => (actuallyDone = true), error: (err) => fail(err), }); })); it('should run async test with successful delayed Observable', fakeAsync(() => { const source = of(true).pipe(delay(10)); source.subscribe({ next: (val) => (actuallyDone = true), error: (err) => fail(err), }); tick(10); })); }); describe('fakeAsync', () => { it('should run timeout callback with delay after call tick with millis', fakeAsync(() => { let called = false; setTimeout(() => { called = true; }, 100); tick(10",
    "id": "component-testing-scenarios-*-angular-135"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": "0); expect(called).toBe(true); })); it('should run new macro task callback with delay after call tick with millis', fakeAsync(() => { function nestedTimer(cb: () => any): void { setTimeout(() => setTimeout(() => cb())); } const callback = jasmine.createSpy('callback'); nestedTimer(callback); expect(callback).not.toHaveBeenCalled(); tick(0); // the nested timeout will also be triggered expect(callback).toHaveBeenCalled(); })); it('should not run new macro task callback with delay after call tick ",
    "id": "component-testing-scenarios-*-angular-136"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": "with millis', fakeAsync(() => { function nestedTimer(cb: () => any): void { setTimeout(() => setTimeout(() => cb())); } const callback = jasmine.createSpy('callback'); nestedTimer(callback); expect(callback).not.toHaveBeenCalled(); tick(0, {processNewMacroTasksSynchronously: false}); // the nested timeout will not be triggered expect(callback).not.toHaveBeenCalled(); tick(0); expect(callback).toHaveBeenCalled(); })); it('should get Date diff correctly in fakeAsync', fakeAsync(() => { const start",
    "id": "component-testing-scenarios-*-angular-137"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": " = Date.now(); tick(100); const end = Date.now(); expect(end - start).toBe(100); })); it('should get Date diff correctly in fakeAsync with rxjs scheduler', fakeAsync(() => { // need to add `import 'zone.js/plugins/zone-patch-rxjs-fake-async' // to patch rxjs scheduler let result = ''; of('hello') .pipe(delay(1000)) .subscribe((v) => { result = v; }); expect(result).toBe(''); tick(1000); expect(result).toBe('hello'); const start = new Date().getTime(); let dateDiff = 0; interval(1000) .pipe(take(",
    "id": "component-testing-scenarios-*-angular-138"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": "2)) .subscribe(() => (dateDiff = new Date().getTime() - start)); tick(1000); expect(dateDiff).toBe(1000); tick(1000); expect(dateDiff).toBe(2000); })); }); describe('use jasmine.clock()', () => { // need to config __zone_symbol__fakeAsyncPatchLock flag // before loading zone.js/testing beforeEach(() => { jasmine.clock().install(); }); afterEach(() => { jasmine.clock().uninstall(); }); it('should auto enter fakeAsync', () => { // is in fakeAsync now, don't need to call fakeAsync(testFn) let calle",
    "id": "component-testing-scenarios-*-angular-139"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": "d = false; setTimeout(() => { called = true; }, 100); jasmine.clock().tick(100); expect(called).toBe(true); }); }); describe('test jsonp', () => { function jsonp(url: string, callback: () => void) { // do a jsonp call which is not zone aware } // need to config __zone_symbol__supportWaitUnResolvedChainedPromise flag // before loading zone.js/testing it('should wait until promise.then is called', waitForAsync(() => { let finished = false; new Promise<void>((res) => { jsonp('localhost:8080/jsonp',",
    "id": "component-testing-scenarios-*-angular-140"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": " () => { // success callback and resolve the promise finished = true; res(); }); }).then(() => { // async will wait until promise.then is called // if __zone_symbol__supportWaitUnResolvedChainedPromise is set expect(finished).toBe(true); }); })); });}); Comparing dates inside fakeAsync() fakeAsync() simulates passage of time, which lets you calculate the difference between dates inside fakeAsync(). import {fakeAsync, tick, waitForAsync} from '@angular/core/testing';import {interval, of} from 'rx",
    "id": "component-testing-scenarios-*-angular-141"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": "js';import {delay, take} from 'rxjs/operators';describe('Angular async helper', () => { describe('async', () => { let actuallyDone = false; beforeEach(() => { actuallyDone = false; }); afterEach(() => { expect(actuallyDone).withContext('actuallyDone should be true').toBe(true); }); it('should run normal test', () => { actuallyDone = true; }); it('should run normal async test', (done: DoneFn) => { setTimeout(() => { actuallyDone = true; done(); }, 0); }); it('should run async test with task', wai",
    "id": "component-testing-scenarios-*-angular-142"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": "tForAsync(() => { setTimeout(() => { actuallyDone = true; }, 0); })); it('should run async test with task', waitForAsync(() => { const id = setInterval(() => { actuallyDone = true; clearInterval(id); }, 100); })); it('should run async test with successful promise', waitForAsync(() => { const p = new Promise((resolve) => { setTimeout(resolve, 10); }); p.then(() => { actuallyDone = true; }); })); it('should run async test with failed promise', waitForAsync(() => { const p = new Promise((resolve, r",
    "id": "component-testing-scenarios-*-angular-143"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": "eject) => { setTimeout(reject, 10); }); p.catch(() => { actuallyDone = true; }); })); // Use done. Can also use async or fakeAsync. it('should run async test with successful delayed Observable', (done: DoneFn) => { const source = of(true).pipe(delay(10)); source.subscribe({ next: (val) => (actuallyDone = true), error: (err) => fail(err), complete: done, }); }); it('should run async test with successful delayed Observable', waitForAsync(() => { const source = of(true).pipe(delay(10)); source.subs",
    "id": "component-testing-scenarios-*-angular-144"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": "cribe({ next: (val) => (actuallyDone = true), error: (err) => fail(err), }); })); it('should run async test with successful delayed Observable', fakeAsync(() => { const source = of(true).pipe(delay(10)); source.subscribe({ next: (val) => (actuallyDone = true), error: (err) => fail(err), }); tick(10); })); }); describe('fakeAsync', () => { it('should run timeout callback with delay after call tick with millis', fakeAsync(() => { let called = false; setTimeout(() => { called = true; }, 100); tick(",
    "id": "component-testing-scenarios-*-angular-145"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": "100); expect(called).toBe(true); })); it('should run new macro task callback with delay after call tick with millis', fakeAsync(() => { function nestedTimer(cb: () => any): void { setTimeout(() => setTimeout(() => cb())); } const callback = jasmine.createSpy('callback'); nestedTimer(callback); expect(callback).not.toHaveBeenCalled(); tick(0); // the nested timeout will also be triggered expect(callback).toHaveBeenCalled(); })); it('should not run new macro task callback with delay after call tic",
    "id": "component-testing-scenarios-*-angular-146"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": "k with millis', fakeAsync(() => { function nestedTimer(cb: () => any): void { setTimeout(() => setTimeout(() => cb())); } const callback = jasmine.createSpy('callback'); nestedTimer(callback); expect(callback).not.toHaveBeenCalled(); tick(0, {processNewMacroTasksSynchronously: false}); // the nested timeout will not be triggered expect(callback).not.toHaveBeenCalled(); tick(0); expect(callback).toHaveBeenCalled(); })); it('should get Date diff correctly in fakeAsync', fakeAsync(() => { const sta",
    "id": "component-testing-scenarios-*-angular-147"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": "rt = Date.now(); tick(100); const end = Date.now(); expect(end - start).toBe(100); })); it('should get Date diff correctly in fakeAsync with rxjs scheduler', fakeAsync(() => { // need to add `import 'zone.js/plugins/zone-patch-rxjs-fake-async' // to patch rxjs scheduler let result = ''; of('hello') .pipe(delay(1000)) .subscribe((v) => { result = v; }); expect(result).toBe(''); tick(1000); expect(result).toBe('hello'); const start = new Date().getTime(); let dateDiff = 0; interval(1000) .pipe(tak",
    "id": "component-testing-scenarios-*-angular-148"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": "e(2)) .subscribe(() => (dateDiff = new Date().getTime() - start)); tick(1000); expect(dateDiff).toBe(1000); tick(1000); expect(dateDiff).toBe(2000); })); }); describe('use jasmine.clock()', () => { // need to config __zone_symbol__fakeAsyncPatchLock flag // before loading zone.js/testing beforeEach(() => { jasmine.clock().install(); }); afterEach(() => { jasmine.clock().uninstall(); }); it('should auto enter fakeAsync', () => { // is in fakeAsync now, don't need to call fakeAsync(testFn) let cal",
    "id": "component-testing-scenarios-*-angular-149"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": "led = false; setTimeout(() => { called = true; }, 100); jasmine.clock().tick(100); expect(called).toBe(true); }); }); describe('test jsonp', () => { function jsonp(url: string, callback: () => void) { // do a jsonp call which is not zone aware } // need to config __zone_symbol__supportWaitUnResolvedChainedPromise flag // before loading zone.js/testing it('should wait until promise.then is called', waitForAsync(() => { let finished = false; new Promise<void>((res) => { jsonp('localhost:8080/jsonp",
    "id": "component-testing-scenarios-*-angular-150"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": "', () => { // success callback and resolve the promise finished = true; res(); }); }).then(() => { // async will wait until promise.then is called // if __zone_symbol__supportWaitUnResolvedChainedPromise is set expect(finished).toBe(true); }); })); });}); jasmine.clock with fakeAsync() Jasmine also provides a clock feature to mock dates. Angular automatically runs tests that are run after jasmine.clock().install() is called inside a fakeAsync() method until jasmine.clock().uninstall() is called.",
    "id": "component-testing-scenarios-*-angular-151"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": " fakeAsync() is not needed and throws an error if nested. By default, this feature is disabled. To enable it, set a global flag before importing zone-testing. If you use the Angular CLI, configure this flag in src/test.ts. [window as any]('__zone_symbol__fakeAsyncPatchLock') = true;import 'zone.js/testing'; import {fakeAsync, tick, waitForAsync} from '@angular/core/testing';import {interval, of} from 'rxjs';import {delay, take} from 'rxjs/operators';describe('Angular async helper', () => { descr",
    "id": "component-testing-scenarios-*-angular-152"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": "ibe('async', () => { let actuallyDone = false; beforeEach(() => { actuallyDone = false; }); afterEach(() => { expect(actuallyDone).withContext('actuallyDone should be true').toBe(true); }); it('should run normal test', () => { actuallyDone = true; }); it('should run normal async test', (done: DoneFn) => { setTimeout(() => { actuallyDone = true; done(); }, 0); }); it('should run async test with task', waitForAsync(() => { setTimeout(() => { actuallyDone = true; }, 0); })); it('should run async te",
    "id": "component-testing-scenarios-*-angular-153"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": "st with task', waitForAsync(() => { const id = setInterval(() => { actuallyDone = true; clearInterval(id); }, 100); })); it('should run async test with successful promise', waitForAsync(() => { const p = new Promise((resolve) => { setTimeout(resolve, 10); }); p.then(() => { actuallyDone = true; }); })); it('should run async test with failed promise', waitForAsync(() => { const p = new Promise((resolve, reject) => { setTimeout(reject, 10); }); p.catch(() => { actuallyDone = true; }); })); // Use ",
    "id": "component-testing-scenarios-*-angular-154"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": "done. Can also use async or fakeAsync. it('should run async test with successful delayed Observable', (done: DoneFn) => { const source = of(true).pipe(delay(10)); source.subscribe({ next: (val) => (actuallyDone = true), error: (err) => fail(err), complete: done, }); }); it('should run async test with successful delayed Observable', waitForAsync(() => { const source = of(true).pipe(delay(10)); source.subscribe({ next: (val) => (actuallyDone = true), error: (err) => fail(err), }); })); it('should ",
    "id": "component-testing-scenarios-*-angular-155"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": "run async test with successful delayed Observable', fakeAsync(() => { const source = of(true).pipe(delay(10)); source.subscribe({ next: (val) => (actuallyDone = true), error: (err) => fail(err), }); tick(10); })); }); describe('fakeAsync', () => { it('should run timeout callback with delay after call tick with millis', fakeAsync(() => { let called = false; setTimeout(() => { called = true; }, 100); tick(100); expect(called).toBe(true); })); it('should run new macro task callback with delay after",
    "id": "component-testing-scenarios-*-angular-156"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": " call tick with millis', fakeAsync(() => { function nestedTimer(cb: () => any): void { setTimeout(() => setTimeout(() => cb())); } const callback = jasmine.createSpy('callback'); nestedTimer(callback); expect(callback).not.toHaveBeenCalled(); tick(0); // the nested timeout will also be triggered expect(callback).toHaveBeenCalled(); })); it('should not run new macro task callback with delay after call tick with millis', fakeAsync(() => { function nestedTimer(cb: () => any): void { setTimeout(() =",
    "id": "component-testing-scenarios-*-angular-157"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": "> setTimeout(() => cb())); } const callback = jasmine.createSpy('callback'); nestedTimer(callback); expect(callback).not.toHaveBeenCalled(); tick(0, {processNewMacroTasksSynchronously: false}); // the nested timeout will not be triggered expect(callback).not.toHaveBeenCalled(); tick(0); expect(callback).toHaveBeenCalled(); })); it('should get Date diff correctly in fakeAsync', fakeAsync(() => { const start = Date.now(); tick(100); const end = Date.now(); expect(end - start).toBe(100); })); it('s",
    "id": "component-testing-scenarios-*-angular-158"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": "hould get Date diff correctly in fakeAsync with rxjs scheduler', fakeAsync(() => { // need to add `import 'zone.js/plugins/zone-patch-rxjs-fake-async' // to patch rxjs scheduler let result = ''; of('hello') .pipe(delay(1000)) .subscribe((v) => { result = v; }); expect(result).toBe(''); tick(1000); expect(result).toBe('hello'); const start = new Date().getTime(); let dateDiff = 0; interval(1000) .pipe(take(2)) .subscribe(() => (dateDiff = new Date().getTime() - start)); tick(1000); expect(dateDif",
    "id": "component-testing-scenarios-*-angular-159"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": "f).toBe(1000); tick(1000); expect(dateDiff).toBe(2000); })); }); describe('use jasmine.clock()', () => { // need to config __zone_symbol__fakeAsyncPatchLock flag // before loading zone.js/testing beforeEach(() => { jasmine.clock().install(); }); afterEach(() => { jasmine.clock().uninstall(); }); it('should auto enter fakeAsync', () => { // is in fakeAsync now, don't need to call fakeAsync(testFn) let called = false; setTimeout(() => { called = true; }, 100); jasmine.clock().tick(100); expect(cal",
    "id": "component-testing-scenarios-*-angular-160"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": "led).toBe(true); }); }); describe('test jsonp', () => { function jsonp(url: string, callback: () => void) { // do a jsonp call which is not zone aware } // need to config __zone_symbol__supportWaitUnResolvedChainedPromise flag // before loading zone.js/testing it('should wait until promise.then is called', waitForAsync(() => { let finished = false; new Promise<void>((res) => { jsonp('localhost:8080/jsonp', () => { // success callback and resolve the promise finished = true; res(); }); }).then(()",
    "id": "component-testing-scenarios-*-angular-161"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": " => { // async will wait until promise.then is called // if __zone_symbol__supportWaitUnResolvedChainedPromise is set expect(finished).toBe(true); }); })); });}); Using the RxJS scheduler inside fakeAsync() You can also use RxJS scheduler in fakeAsync() just like using setTimeout() or setInterval(), but you need to import zone.js/plugins/zone-patch-rxjs-fake-async to patch RxJS scheduler. import {fakeAsync, tick, waitForAsync} from '@angular/core/testing';import {interval, of} from 'rxjs';import",
    "id": "component-testing-scenarios-*-angular-162"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": " {delay, take} from 'rxjs/operators';describe('Angular async helper', () => { describe('async', () => { let actuallyDone = false; beforeEach(() => { actuallyDone = false; }); afterEach(() => { expect(actuallyDone).withContext('actuallyDone should be true').toBe(true); }); it('should run normal test', () => { actuallyDone = true; }); it('should run normal async test', (done: DoneFn) => { setTimeout(() => { actuallyDone = true; done(); }, 0); }); it('should run async test with task', waitForAsync(",
    "id": "component-testing-scenarios-*-angular-163"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": "() => { setTimeout(() => { actuallyDone = true; }, 0); })); it('should run async test with task', waitForAsync(() => { const id = setInterval(() => { actuallyDone = true; clearInterval(id); }, 100); })); it('should run async test with successful promise', waitForAsync(() => { const p = new Promise((resolve) => { setTimeout(resolve, 10); }); p.then(() => { actuallyDone = true; }); })); it('should run async test with failed promise', waitForAsync(() => { const p = new Promise((resolve, reject) => ",
    "id": "component-testing-scenarios-*-angular-164"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": "{ setTimeout(reject, 10); }); p.catch(() => { actuallyDone = true; }); })); // Use done. Can also use async or fakeAsync. it('should run async test with successful delayed Observable', (done: DoneFn) => { const source = of(true).pipe(delay(10)); source.subscribe({ next: (val) => (actuallyDone = true), error: (err) => fail(err), complete: done, }); }); it('should run async test with successful delayed Observable', waitForAsync(() => { const source = of(true).pipe(delay(10)); source.subscribe({ ne",
    "id": "component-testing-scenarios-*-angular-165"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": "xt: (val) => (actuallyDone = true), error: (err) => fail(err), }); })); it('should run async test with successful delayed Observable', fakeAsync(() => { const source = of(true).pipe(delay(10)); source.subscribe({ next: (val) => (actuallyDone = true), error: (err) => fail(err), }); tick(10); })); }); describe('fakeAsync', () => { it('should run timeout callback with delay after call tick with millis', fakeAsync(() => { let called = false; setTimeout(() => { called = true; }, 100); tick(100); expe",
    "id": "component-testing-scenarios-*-angular-166"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": "ct(called).toBe(true); })); it('should run new macro task callback with delay after call tick with millis', fakeAsync(() => { function nestedTimer(cb: () => any): void { setTimeout(() => setTimeout(() => cb())); } const callback = jasmine.createSpy('callback'); nestedTimer(callback); expect(callback).not.toHaveBeenCalled(); tick(0); // the nested timeout will also be triggered expect(callback).toHaveBeenCalled(); })); it('should not run new macro task callback with delay after call tick with mil",
    "id": "component-testing-scenarios-*-angular-167"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": "lis', fakeAsync(() => { function nestedTimer(cb: () => any): void { setTimeout(() => setTimeout(() => cb())); } const callback = jasmine.createSpy('callback'); nestedTimer(callback); expect(callback).not.toHaveBeenCalled(); tick(0, {processNewMacroTasksSynchronously: false}); // the nested timeout will not be triggered expect(callback).not.toHaveBeenCalled(); tick(0); expect(callback).toHaveBeenCalled(); })); it('should get Date diff correctly in fakeAsync', fakeAsync(() => { const start = Date.",
    "id": "component-testing-scenarios-*-angular-168"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": "now(); tick(100); const end = Date.now(); expect(end - start).toBe(100); })); it('should get Date diff correctly in fakeAsync with rxjs scheduler', fakeAsync(() => { // need to add `import 'zone.js/plugins/zone-patch-rxjs-fake-async' // to patch rxjs scheduler let result = ''; of('hello') .pipe(delay(1000)) .subscribe((v) => { result = v; }); expect(result).toBe(''); tick(1000); expect(result).toBe('hello'); const start = new Date().getTime(); let dateDiff = 0; interval(1000) .pipe(take(2)) .sub",
    "id": "component-testing-scenarios-*-angular-169"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": "scribe(() => (dateDiff = new Date().getTime() - start)); tick(1000); expect(dateDiff).toBe(1000); tick(1000); expect(dateDiff).toBe(2000); })); }); describe('use jasmine.clock()', () => { // need to config __zone_symbol__fakeAsyncPatchLock flag // before loading zone.js/testing beforeEach(() => { jasmine.clock().install(); }); afterEach(() => { jasmine.clock().uninstall(); }); it('should auto enter fakeAsync', () => { // is in fakeAsync now, don't need to call fakeAsync(testFn) let called = fals",
    "id": "component-testing-scenarios-*-angular-170"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": "e; setTimeout(() => { called = true; }, 100); jasmine.clock().tick(100); expect(called).toBe(true); }); }); describe('test jsonp', () => { function jsonp(url: string, callback: () => void) { // do a jsonp call which is not zone aware } // need to config __zone_symbol__supportWaitUnResolvedChainedPromise flag // before loading zone.js/testing it('should wait until promise.then is called', waitForAsync(() => { let finished = false; new Promise<void>((res) => { jsonp('localhost:8080/jsonp', () => {",
    "id": "component-testing-scenarios-*-angular-171"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": " // success callback and resolve the promise finished = true; res(); }); }).then(() => { // async will wait until promise.then is called // if __zone_symbol__supportWaitUnResolvedChainedPromise is set expect(finished).toBe(true); }); })); });}); Support more macroTasks By default, fakeAsync() supports the following macro tasks. setTimeout setInterval requestAnimationFrame webkitRequestAnimationFrame mozRequestAnimationFrame If you run other macro tasks such as HTMLCanvasElement.toBlob(), an \"Unk",
    "id": "component-testing-scenarios-*-angular-172"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": "nown macroTask scheduled in fake async test\" error is thrown. src/app/shared/canvas.component.spec.ts (failing) import {fakeAsync, TestBed, tick} from '@angular/core/testing';import {CanvasComponent} from './canvas.component';describe('CanvasComponent', () => { beforeEach(() => { (window as any).__zone_symbol__FakeAsyncTestMacroTask = [ { source: 'HTMLCanvasElement.toBlob', callbackArgs: [{size: 200}], }, ]; }); beforeEach(async () => { await TestBed.configureTestingModule({ imports: [CanvasComp",
    "id": "component-testing-scenarios-*-angular-173"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": "onent], }); }); it('should be able to generate blob data from canvas', fakeAsync(() => { const fixture = TestBed.createComponent(CanvasComponent); const canvasComp = fixture.componentInstance; fixture.detectChanges(); expect(canvasComp.blobSize).toBe(0); tick(); expect(canvasComp.blobSize).toBeGreaterThan(0); }));}); src/app/shared/canvas.component.ts // Import patch to make async `HTMLCanvasElement` methods (such as `.toBlob()`) Zone.js-aware.// Either import in `polyfills.ts` (if used in more ",
    "id": "component-testing-scenarios-*-angular-174"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": "than one places in the app) or in the component// file using `HTMLCanvasElement` (if it is only used in a single file).import 'zone.js/plugins/zone-patch-canvas';import {Component, AfterViewInit, ViewChild, ElementRef} from '@angular/core';@Component({ selector: 'sample-canvas', template: '<canvas #sampleCanvas width=\"200\" height=\"200\"></canvas>',})export class CanvasComponent implements AfterViewInit { blobSize = 0; @ViewChild('sampleCanvas') sampleCanvas!: ElementRef; ngAfterViewInit() { const",
    "id": "component-testing-scenarios-*-angular-175"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": " canvas: HTMLCanvasElement = this.sampleCanvas.nativeElement; const context = canvas.getContext('2d')!; context.clearRect(0, 0, 200, 200); context.fillStyle = '#FF1122'; context.fillRect(0, 0, 200, 200); canvas.toBlob((blob) => { this.blobSize = blob?.size ?? 0; }); }} If you want to support such a case, you need to define the macro task you want to support in beforeEach(). For example: src/app/shared/canvas.component.spec.ts (excerpt) import {fakeAsync, TestBed, tick} from '@angular/core/testin",
    "id": "component-testing-scenarios-*-angular-176"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": "g';import {CanvasComponent} from './canvas.component';describe('CanvasComponent', () => { beforeEach(() => { (window as any).__zone_symbol__FakeAsyncTestMacroTask = [ { source: 'HTMLCanvasElement.toBlob', callbackArgs: [{size: 200}], }, ]; }); beforeEach(async () => { await TestBed.configureTestingModule({ imports: [CanvasComponent], }); }); it('should be able to generate blob data from canvas', fakeAsync(() => { const fixture = TestBed.createComponent(CanvasComponent); const canvasComp = fixtur",
    "id": "component-testing-scenarios-*-angular-177"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": "e.componentInstance; fixture.detectChanges(); expect(canvasComp.blobSize).toBe(0); tick(); expect(canvasComp.blobSize).toBeGreaterThan(0); }));}); HELPFUL: In order to make the <canvas> element Zone.js-aware in your app, you need to import the zone-patch-canvas patch (either in polyfills.ts or in the specific file that uses <canvas>): src/polyfills.ts or src/app/shared/canvas.component.ts // Import patch to make async `HTMLCanvasElement` methods (such as `.toBlob()`) Zone.js-aware.// Either impo",
    "id": "component-testing-scenarios-*-angular-178"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": "rt in `polyfills.ts` (if used in more than one places in the app) or in the component// file using `HTMLCanvasElement` (if it is only used in a single file).import 'zone.js/plugins/zone-patch-canvas';import {Component, AfterViewInit, ViewChild, ElementRef} from '@angular/core';@Component({ selector: 'sample-canvas', template: '<canvas #sampleCanvas width=\"200\" height=\"200\"></canvas>',})export class CanvasComponent implements AfterViewInit { blobSize = 0; @ViewChild('sampleCanvas') sampleCanvas!:",
    "id": "component-testing-scenarios-*-angular-179"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": " ElementRef; ngAfterViewInit() { const canvas: HTMLCanvasElement = this.sampleCanvas.nativeElement; const context = canvas.getContext('2d')!; context.clearRect(0, 0, 200, 200); context.fillStyle = '#FF1122'; context.fillRect(0, 0, 200, 200); canvas.toBlob((blob) => { this.blobSize = blob?.size ?? 0; }); }} Async observables You might be satisfied with the test coverage of these tests. However, you might be troubled by the fact that the real service doesn't quite behave this way. The real service",
    "id": "component-testing-scenarios-*-angular-180"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": " sends requests to a remote server. A server takes time to respond and the response certainly won't be available immediately as in the previous two tests. Your tests will reflect the real world more faithfully if you return an asynchronous observable from the getQuote() spy like this. import {fakeAsync, ComponentFixture, TestBed, tick, waitForAsync} from '@angular/core/testing';import {asyncData, asyncError} from '../../testing';import {Subject, defer, of, throwError} from 'rxjs';import {last} f",
    "id": "component-testing-scenarios-*-angular-181"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": "rom 'rxjs/operators';import {TwainComponent} from './twain.component';import {TwainService} from './twain.service';describe('TwainComponent', () => { let component: TwainComponent; let fixture: ComponentFixture<TwainComponent>; let getQuoteSpy: jasmine.Spy; let quoteEl: HTMLElement; let testQuote: string; // Helper function to get the error message element value // An *ngIf keeps it out of the DOM until there is an error const errorMessage = () => { const el = fixture.nativeElement.querySelector",
    "id": "component-testing-scenarios-*-angular-182"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": "('.error'); return el ? el.textContent : null; }; beforeEach(() => { TestBed.configureTestingModule({ imports: [TwainComponent], providers: [TwainService], }); testQuote = 'Test Quote'; // Create a fake TwainService object with a `getQuote()` spy const twainService = TestBed.inject(TwainService); // Make the spy return a synchronous Observable with the test data getQuoteSpy = spyOn(twainService, 'getQuote').and.returnValue(of(testQuote)); fixture = TestBed.createComponent(TwainComponent); fixtur",
    "id": "component-testing-scenarios-*-angular-183"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": "e.autoDetectChanges(); component = fixture.componentInstance; quoteEl = fixture.nativeElement.querySelector('.twain'); }); describe('when test with synchronous observable', () => { it('should not show quote before OnInit', () => { expect(quoteEl.textContent).withContext('nothing displayed').toBe(''); expect(errorMessage()).withContext('should not show error element').toBeNull(); expect(getQuoteSpy.calls.any()).withContext('getQuote not yet called').toBe(false); }); // The quote would not be imme",
    "id": "component-testing-scenarios-*-angular-184"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": "diately available if the service were truly async. it('should show quote after component initialized', async () => { await fixture.whenStable(); // onInit() // sync spy result shows testQuote immediately after init expect(quoteEl.textContent).toBe(testQuote); expect(getQuoteSpy.calls.any()).withContext('getQuote called').toBe(true); }); // The error would not be immediately available if the service were truly async. // Use `fakeAsync` because the component error calls `setTimeout` it('should dis",
    "id": "component-testing-scenarios-*-angular-185"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": "play error when TwainService fails', fakeAsync(() => { // tell spy to return an error observable after a timeout getQuoteSpy.and.returnValue( defer(() => { return new Promise((resolve, reject) => { setTimeout(() => { reject('TwainService test failure'); }); }); }), ); fixture.detectChanges(); // onInit() // sync spy errors immediately after init tick(); // flush the setTimeout() fixture.detectChanges(); // update errorMessage within setTimeout() expect(errorMessage()) .withContext('should displa",
    "id": "component-testing-scenarios-*-angular-186"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": "y error') .toMatch(/test failure/); expect(quoteEl.textContent).withContext('should show placeholder').toBe('...'); })); }); describe('when test with asynchronous observable', () => { beforeEach(() => { // Simulate delayed observable values with the `asyncData()` helper getQuoteSpy.and.returnValue(asyncData(testQuote)); }); it('should not show quote before OnInit', () => { expect(quoteEl.textContent).withContext('nothing displayed').toBe(''); expect(errorMessage()).withContext('should not show e",
    "id": "component-testing-scenarios-*-angular-187"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": "rror element').toBeNull(); expect(getQuoteSpy.calls.any()).withContext('getQuote not yet called').toBe(false); }); it('should still not show quote after component initialized', () => { fixture.detectChanges(); // getQuote service is async => still has not returned with quote // so should show the start value, '...' expect(quoteEl.textContent).withContext('should show placeholder').toBe('...'); expect(errorMessage()).withContext('should not show error').toBeNull(); expect(getQuoteSpy.calls.any())",
    "id": "component-testing-scenarios-*-angular-188"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": ".withContext('getQuote called').toBe(true); }); it('should show quote after getQuote (fakeAsync)', fakeAsync(() => { fixture.detectChanges(); // ngOnInit() expect(quoteEl.textContent).withContext('should show placeholder').toBe('...'); tick(); // flush the observable to get the quote fixture.detectChanges(); // update view expect(quoteEl.textContent).withContext('should show quote').toBe(testQuote); expect(errorMessage()).withContext('should not show error').toBeNull(); })); it('should show quot",
    "id": "component-testing-scenarios-*-angular-189"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": "e after getQuote (async)', async () => { fixture.detectChanges(); // ngOnInit() expect(quoteEl.textContent).withContext('should show placeholder').toBe('...'); await fixture.whenStable(); // wait for async getQuote fixture.detectChanges(); // update view with quote expect(quoteEl.textContent).toBe(testQuote); expect(errorMessage()).withContext('should not show error').toBeNull(); }); it('should display error when TwainService fails', fakeAsync(() => { // tell spy to return an async error observa",
    "id": "component-testing-scenarios-*-angular-190"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": "ble getQuoteSpy.and.returnValue(asyncError<string>('TwainService test failure')); fixture.detectChanges(); tick(); // component shows error after a setTimeout() fixture.detectChanges(); // update error message expect(errorMessage()) .withContext('should display error') .toMatch(/test failure/); expect(quoteEl.textContent).withContext('should show placeholder').toBe('...'); })); });}); Async observable helpers The async observable was produced by an asyncData helper. The asyncData helper is a uti",
    "id": "component-testing-scenarios-*-angular-191"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": "lity function that you'll have to write yourself, or copy this one from the sample code. testing/async-observable-helpers.ts /* * Mock async observables that return asynchronously. * The observable either emits once and completes or errors. * * Must call `tick()` when test with `fakeAsync()`. * * THE FOLLOWING DON'T WORK * Using `of().delay()` triggers TestBed errors; * see https://github.com/angular/angular/issues/10127 . * * Using `asap` scheduler - as in `of(value, asap)` - doesn't work eithe",
    "id": "component-testing-scenarios-*-angular-192"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": "r. */import {defer} from 'rxjs';/** * Create async observable that emits-once and completes * after a JS engine turn */export function asyncData<T>(data: T) { return defer(() => Promise.resolve(data));}/** * Create async observable error that errors * after a JS engine turn */export function asyncError<T>(errorObject: any) { return defer(() => Promise.reject(errorObject));} This helper's observable emits the data value in the next turn of the JavaScript engine. The RxJS defer() operator returns ",
    "id": "component-testing-scenarios-*-angular-193"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": "an observable. It takes a factory function that returns either a promise or an observable. When something subscribes to defer's observable, it adds the subscriber to a new observable created with that factory. The defer() operator transforms the Promise.resolve() into a new observable that, like HttpClient, emits once and completes. Subscribers are unsubscribed after they receive the data value. There's a similar helper for producing an async error. /* * Mock async observables that return asynch",
    "id": "component-testing-scenarios-*-angular-194"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": "ronously. * The observable either emits once and completes or errors. * * Must call `tick()` when test with `fakeAsync()`. * * THE FOLLOWING DON'T WORK * Using `of().delay()` triggers TestBed errors; * see https://github.com/angular/angular/issues/10127 . * * Using `asap` scheduler - as in `of(value, asap)` - doesn't work either. */import {defer} from 'rxjs';/** * Create async observable that emits-once and completes * after a JS engine turn */export function asyncData<T>(data: T) { return defer",
    "id": "component-testing-scenarios-*-angular-195"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": "(() => Promise.resolve(data));}/** * Create async observable error that errors * after a JS engine turn */export function asyncError<T>(errorObject: any) { return defer(() => Promise.reject(errorObject));} More async tests Now that the getQuote() spy is returning async observables, most of your tests will have to be async as well. Here's a fakeAsync() test that demonstrates the data flow you'd expect in the real world. import {fakeAsync, ComponentFixture, TestBed, tick, waitForAsync} from '@angu",
    "id": "component-testing-scenarios-*-angular-196"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": "lar/core/testing';import {asyncData, asyncError} from '../../testing';import {Subject, defer, of, throwError} from 'rxjs';import {last} from 'rxjs/operators';import {TwainComponent} from './twain.component';import {TwainService} from './twain.service';describe('TwainComponent', () => { let component: TwainComponent; let fixture: ComponentFixture<TwainComponent>; let getQuoteSpy: jasmine.Spy; let quoteEl: HTMLElement; let testQuote: string; // Helper function to get the error message element valu",
    "id": "component-testing-scenarios-*-angular-197"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": "e // An *ngIf keeps it out of the DOM until there is an error const errorMessage = () => { const el = fixture.nativeElement.querySelector('.error'); return el ? el.textContent : null; }; beforeEach(() => { TestBed.configureTestingModule({ imports: [TwainComponent], providers: [TwainService], }); testQuote = 'Test Quote'; // Create a fake TwainService object with a `getQuote()` spy const twainService = TestBed.inject(TwainService); // Make the spy return a synchronous Observable with the test dat",
    "id": "component-testing-scenarios-*-angular-198"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": "a getQuoteSpy = spyOn(twainService, 'getQuote').and.returnValue(of(testQuote)); fixture = TestBed.createComponent(TwainComponent); fixture.autoDetectChanges(); component = fixture.componentInstance; quoteEl = fixture.nativeElement.querySelector('.twain'); }); describe('when test with synchronous observable', () => { it('should not show quote before OnInit', () => { expect(quoteEl.textContent).withContext('nothing displayed').toBe(''); expect(errorMessage()).withContext('should not show error ele",
    "id": "component-testing-scenarios-*-angular-199"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": "ment').toBeNull(); expect(getQuoteSpy.calls.any()).withContext('getQuote not yet called').toBe(false); }); // The quote would not be immediately available if the service were truly async. it('should show quote after component initialized', async () => { await fixture.whenStable(); // onInit() // sync spy result shows testQuote immediately after init expect(quoteEl.textContent).toBe(testQuote); expect(getQuoteSpy.calls.any()).withContext('getQuote called').toBe(true); }); // The error would not b",
    "id": "component-testing-scenarios-*-angular-200"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": "e immediately available if the service were truly async. // Use `fakeAsync` because the component error calls `setTimeout` it('should display error when TwainService fails', fakeAsync(() => { // tell spy to return an error observable after a timeout getQuoteSpy.and.returnValue( defer(() => { return new Promise((resolve, reject) => { setTimeout(() => { reject('TwainService test failure'); }); }); }), ); fixture.detectChanges(); // onInit() // sync spy errors immediately after init tick(); // flus",
    "id": "component-testing-scenarios-*-angular-201"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": "h the setTimeout() fixture.detectChanges(); // update errorMessage within setTimeout() expect(errorMessage()) .withContext('should display error') .toMatch(/test failure/); expect(quoteEl.textContent).withContext('should show placeholder').toBe('...'); })); }); describe('when test with asynchronous observable', () => { beforeEach(() => { // Simulate delayed observable values with the `asyncData()` helper getQuoteSpy.and.returnValue(asyncData(testQuote)); }); it('should not show quote before OnIn",
    "id": "component-testing-scenarios-*-angular-202"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": "it', () => { expect(quoteEl.textContent).withContext('nothing displayed').toBe(''); expect(errorMessage()).withContext('should not show error element').toBeNull(); expect(getQuoteSpy.calls.any()).withContext('getQuote not yet called').toBe(false); }); it('should still not show quote after component initialized', () => { fixture.detectChanges(); // getQuote service is async => still has not returned with quote // so should show the start value, '...' expect(quoteEl.textContent).withContext('shoul",
    "id": "component-testing-scenarios-*-angular-203"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": "d show placeholder').toBe('...'); expect(errorMessage()).withContext('should not show error').toBeNull(); expect(getQuoteSpy.calls.any()).withContext('getQuote called').toBe(true); }); it('should show quote after getQuote (fakeAsync)', fakeAsync(() => { fixture.detectChanges(); // ngOnInit() expect(quoteEl.textContent).withContext('should show placeholder').toBe('...'); tick(); // flush the observable to get the quote fixture.detectChanges(); // update view expect(quoteEl.textContent).withContex",
    "id": "component-testing-scenarios-*-angular-204"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": "t('should show quote').toBe(testQuote); expect(errorMessage()).withContext('should not show error').toBeNull(); })); it('should show quote after getQuote (async)', async () => { fixture.detectChanges(); // ngOnInit() expect(quoteEl.textContent).withContext('should show placeholder').toBe('...'); await fixture.whenStable(); // wait for async getQuote fixture.detectChanges(); // update view with quote expect(quoteEl.textContent).toBe(testQuote); expect(errorMessage()).withContext('should not show ",
    "id": "component-testing-scenarios-*-angular-205"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": "error').toBeNull(); }); it('should display error when TwainService fails', fakeAsync(() => { // tell spy to return an async error observable getQuoteSpy.and.returnValue(asyncError<string>('TwainService test failure')); fixture.detectChanges(); tick(); // component shows error after a setTimeout() fixture.detectChanges(); // update error message expect(errorMessage()) .withContext('should display error') .toMatch(/test failure/); expect(quoteEl.textContent).withContext('should show placeholder').",
    "id": "component-testing-scenarios-*-angular-206"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": "toBe('...'); })); });}); Notice that the quote element displays the placeholder value ('...') after ngOnInit(). The first quote hasn't arrived yet. To flush the first quote from the observable, you call tick(). Then call detectChanges() to tell Angular to update the screen. Then you can assert that the quote element displays the expected text. Async test without fakeAsync() Here's the previous fakeAsync() test, re-written with the async. import {fakeAsync, ComponentFixture, TestBed, tick, waitFo",
    "id": "component-testing-scenarios-*-angular-207"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": "rAsync} from '@angular/core/testing';import {asyncData, asyncError} from '../../testing';import {Subject, defer, of, throwError} from 'rxjs';import {last} from 'rxjs/operators';import {TwainComponent} from './twain.component';import {TwainService} from './twain.service';describe('TwainComponent', () => { let component: TwainComponent; let fixture: ComponentFixture<TwainComponent>; let getQuoteSpy: jasmine.Spy; let quoteEl: HTMLElement; let testQuote: string; // Helper function to get the error m",
    "id": "component-testing-scenarios-*-angular-208"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": "essage element value // An *ngIf keeps it out of the DOM until there is an error const errorMessage = () => { const el = fixture.nativeElement.querySelector('.error'); return el ? el.textContent : null; }; beforeEach(() => { TestBed.configureTestingModule({ imports: [TwainComponent], providers: [TwainService], }); testQuote = 'Test Quote'; // Create a fake TwainService object with a `getQuote()` spy const twainService = TestBed.inject(TwainService); // Make the spy return a synchronous Observabl",
    "id": "component-testing-scenarios-*-angular-209"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": "e with the test data getQuoteSpy = spyOn(twainService, 'getQuote').and.returnValue(of(testQuote)); fixture = TestBed.createComponent(TwainComponent); fixture.autoDetectChanges(); component = fixture.componentInstance; quoteEl = fixture.nativeElement.querySelector('.twain'); }); describe('when test with synchronous observable', () => { it('should not show quote before OnInit', () => { expect(quoteEl.textContent).withContext('nothing displayed').toBe(''); expect(errorMessage()).withContext('should",
    "id": "component-testing-scenarios-*-angular-210"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": " not show error element').toBeNull(); expect(getQuoteSpy.calls.any()).withContext('getQuote not yet called').toBe(false); }); // The quote would not be immediately available if the service were truly async. it('should show quote after component initialized', async () => { await fixture.whenStable(); // onInit() // sync spy result shows testQuote immediately after init expect(quoteEl.textContent).toBe(testQuote); expect(getQuoteSpy.calls.any()).withContext('getQuote called').toBe(true); }); // Th",
    "id": "component-testing-scenarios-*-angular-211"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": "e error would not be immediately available if the service were truly async. // Use `fakeAsync` because the component error calls `setTimeout` it('should display error when TwainService fails', fakeAsync(() => { // tell spy to return an error observable after a timeout getQuoteSpy.and.returnValue( defer(() => { return new Promise((resolve, reject) => { setTimeout(() => { reject('TwainService test failure'); }); }); }), ); fixture.detectChanges(); // onInit() // sync spy errors immediately after i",
    "id": "component-testing-scenarios-*-angular-212"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": "nit tick(); // flush the setTimeout() fixture.detectChanges(); // update errorMessage within setTimeout() expect(errorMessage()) .withContext('should display error') .toMatch(/test failure/); expect(quoteEl.textContent).withContext('should show placeholder').toBe('...'); })); }); describe('when test with asynchronous observable', () => { beforeEach(() => { // Simulate delayed observable values with the `asyncData()` helper getQuoteSpy.and.returnValue(asyncData(testQuote)); }); it('should not sho",
    "id": "component-testing-scenarios-*-angular-213"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": "w quote before OnInit', () => { expect(quoteEl.textContent).withContext('nothing displayed').toBe(''); expect(errorMessage()).withContext('should not show error element').toBeNull(); expect(getQuoteSpy.calls.any()).withContext('getQuote not yet called').toBe(false); }); it('should still not show quote after component initialized', () => { fixture.detectChanges(); // getQuote service is async => still has not returned with quote // so should show the start value, '...' expect(quoteEl.textContent)",
    "id": "component-testing-scenarios-*-angular-214"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": ".withContext('should show placeholder').toBe('...'); expect(errorMessage()).withContext('should not show error').toBeNull(); expect(getQuoteSpy.calls.any()).withContext('getQuote called').toBe(true); }); it('should show quote after getQuote (fakeAsync)', fakeAsync(() => { fixture.detectChanges(); // ngOnInit() expect(quoteEl.textContent).withContext('should show placeholder').toBe('...'); tick(); // flush the observable to get the quote fixture.detectChanges(); // update view expect(quoteEl.text",
    "id": "component-testing-scenarios-*-angular-215"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": "Content).withContext('should show quote').toBe(testQuote); expect(errorMessage()).withContext('should not show error').toBeNull(); })); it('should show quote after getQuote (async)', async () => { fixture.detectChanges(); // ngOnInit() expect(quoteEl.textContent).withContext('should show placeholder').toBe('...'); await fixture.whenStable(); // wait for async getQuote fixture.detectChanges(); // update view with quote expect(quoteEl.textContent).toBe(testQuote); expect(errorMessage()).withContex",
    "id": "component-testing-scenarios-*-angular-216"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": "t('should not show error').toBeNull(); }); it('should display error when TwainService fails', fakeAsync(() => { // tell spy to return an async error observable getQuoteSpy.and.returnValue(asyncError<string>('TwainService test failure')); fixture.detectChanges(); tick(); // component shows error after a setTimeout() fixture.detectChanges(); // update error message expect(errorMessage()) .withContext('should display error') .toMatch(/test failure/); expect(quoteEl.textContent).withContext('should ",
    "id": "component-testing-scenarios-*-angular-217"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": "show placeholder').toBe('...'); })); });}); whenStable The test must wait for the getQuote() observable to emit the next quote. Instead of calling tick(), it calls fixture.whenStable(). The fixture.whenStable() returns a promise that resolves when the JavaScript engine's task queue becomes empty. In this example, the task queue becomes empty when the observable emits the first quote. Component with inputs and outputs A component with inputs and outputs typically appears inside the view template ",
    "id": "component-testing-scenarios-*-angular-218"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": "of a host component. The host uses a property binding to set the input property and an event binding to listen to events raised by the output property. The testing goal is to verify that such bindings work as expected. The tests should set input values and listen for output events. The DashboardHeroComponent is a tiny example of a component in this role. It displays an individual hero provided by the DashboardComponent. Clicking that hero tells the DashboardComponent that the user has selected t",
    "id": "component-testing-scenarios-*-angular-219"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": "he hero. The DashboardHeroComponent is embedded in the DashboardComponent template like this: app/dashboard/dashboard.component.html (excerpt) <h2 highlight>{{ title }}</h2><div class=\"grid grid-pad\"> @for (hero of heroes; track hero) { <dashboard-hero class=\"col-1-4\" [hero]=\"hero\" (selected)=\"gotoDetail($event)\" > </dashboard-hero> }</div> The DashboardHeroComponent appears in an @for block, which sets each component's hero input property to the looping value and listens for the component's sel",
    "id": "component-testing-scenarios-*-angular-220"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": "ected event. Here's the component's full definition: app/dashboard/dashboard-hero.component.ts (component) import {Component, input, output} from '@angular/core';import {UpperCasePipe} from '@angular/common';import {Hero} from '../model/hero';@Component({ selector: 'dashboard-hero', template: ` <button type=\"button\" (click)=\"click()\" class=\"hero\"> {{ hero().name | uppercase }} </button> `, styleUrls: ['./dashboard-hero.component.css'], imports: [UpperCasePipe],})export class DashboardHeroCompone",
    "id": "component-testing-scenarios-*-angular-221"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": "nt { hero = input.required<Hero>(); selected = output<Hero>(); click() { this.selected.emit(this.hero()); }} While testing a component this simple has little intrinsic value, it's worth knowing how. Use one of these approaches: Test it as used by DashboardComponent Test it as a standalone component Test it as used by a substitute for DashboardComponent The immediate goal is to test the DashboardHeroComponent, not the DashboardComponent, so, try the second and third options. Test DashboardHeroCom",
    "id": "component-testing-scenarios-*-angular-222"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": "ponent standalone Here's the meat of the spec file setup. app/dashboard/dashboard-hero.component.spec.ts (setup) import {DebugElement} from '@angular/core';import {ComponentFixture, TestBed, waitForAsync} from '@angular/core/testing';import {By} from '@angular/platform-browser';import {first} from 'rxjs/operators';import {addMatchers, click} from '../../testing';import {appProviders} from '../app.config';import {Hero} from '../model/hero';import {DashboardHeroComponent} from './dashboard-hero.co",
    "id": "component-testing-scenarios-*-angular-223"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": "mponent';beforeEach(addMatchers);describe('DashboardHeroComponent when tested directly', () => { let comp: DashboardHeroComponent; let expectedHero: Hero; let fixture: ComponentFixture<DashboardHeroComponent>; let heroDe: DebugElement; let heroEl: HTMLElement; beforeEach(() => { TestBed.configureTestingModule({ providers: appProviders, }); }); beforeEach(async () => { fixture = TestBed.createComponent(DashboardHeroComponent); fixture.autoDetectChanges(); comp = fixture.componentInstance; // find",
    "id": "component-testing-scenarios-*-angular-224"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": " the hero's DebugElement and element heroDe = fixture.debugElement.query(By.css('.hero')); heroEl = heroDe.nativeElement; // mock the hero supplied by the parent component expectedHero = {id: 42, name: 'Test Name'}; // simulate the parent setting the input property with that hero fixture.componentRef.setInput('hero', expectedHero); // wait for initial data binding await fixture.whenStable(); }); it('should display hero name in uppercase', () => { const expectedPipedName = expectedHero.name.toUpp",
    "id": "component-testing-scenarios-*-angular-225"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": "erCase(); expect(heroEl.textContent).toContain(expectedPipedName); }); it('should raise selected event when clicked (triggerEventHandler)', () => { let selectedHero: Hero | undefined; comp.selected.subscribe((hero: Hero) => (selectedHero = hero)); heroDe.triggerEventHandler('click'); expect(selectedHero).toBe(expectedHero); }); it('should raise selected event when clicked (element.click)', () => { let selectedHero: Hero | undefined; comp.selected.subscribe((hero: Hero) => (selectedHero = hero));",
    "id": "component-testing-scenarios-*-angular-226"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": " heroEl.click(); expect(selectedHero).toBe(expectedHero); }); it('should raise selected event when clicked (click helper with DebugElement)', () => { let selectedHero: Hero | undefined; comp.selected.subscribe((hero: Hero) => (selectedHero = hero)); click(heroDe); // click helper with DebugElement expect(selectedHero).toBe(expectedHero); }); it('should raise selected event when clicked (click helper with native element)', () => { let selectedHero: Hero | undefined; comp.selected.subscribe((hero:",
    "id": "component-testing-scenarios-*-angular-227"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": " Hero) => (selectedHero = hero)); click(heroEl); // click helper with native element expect(selectedHero).toBe(expectedHero); });});//////////////////describe('DashboardHeroComponent when inside a test host', () => { let testHost: TestHostComponent; let fixture: ComponentFixture<TestHostComponent>; let heroEl: HTMLElement; beforeEach(waitForAsync(() => { TestBed.configureTestingModule({ providers: appProviders, imports: [DashboardHeroComponent, TestHostComponent], }); })); beforeEach(() => { // ",
    "id": "component-testing-scenarios-*-angular-228"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": "create TestHostComponent instead of DashboardHeroComponent fixture = TestBed.createComponent(TestHostComponent); testHost = fixture.componentInstance; heroEl = fixture.nativeElement.querySelector('.hero'); fixture.detectChanges(); // trigger initial data binding }); it('should display hero name', () => { const expectedPipedName = testHost.hero.name.toUpperCase(); expect(heroEl.textContent).toContain(expectedPipedName); }); it('should raise selected event when clicked', () => { click(heroEl); // ",
    "id": "component-testing-scenarios-*-angular-229"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": "selected hero should be the same data bound hero expect(testHost.selectedHero).toBe(testHost.hero); });});////// Test Host Component //////import {Component} from '@angular/core';@Component({ imports: [DashboardHeroComponent], template: ` <dashboard-hero [hero]=\"hero\" (selected)=\"onSelected($event)\"> </dashboard-hero>`,})class TestHostComponent { hero: Hero = {id: 42, name: 'Test Name'}; selectedHero: Hero | undefined; onSelected(hero: Hero) { this.selectedHero = hero; }} Notice how the setup co",
    "id": "component-testing-scenarios-*-angular-230"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": "de assigns a test hero (expectedHero) to the component's hero property, emulating the way the DashboardComponent would set it using the property binding in its repeater. The following test verifies that the hero name is propagated to the template using a binding. import {DebugElement} from '@angular/core';import {ComponentFixture, TestBed, waitForAsync} from '@angular/core/testing';import {By} from '@angular/platform-browser';import {first} from 'rxjs/operators';import {addMatchers, click} from ",
    "id": "component-testing-scenarios-*-angular-231"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": "'../../testing';import {appProviders} from '../app.config';import {Hero} from '../model/hero';import {DashboardHeroComponent} from './dashboard-hero.component';beforeEach(addMatchers);describe('DashboardHeroComponent when tested directly', () => { let comp: DashboardHeroComponent; let expectedHero: Hero; let fixture: ComponentFixture<DashboardHeroComponent>; let heroDe: DebugElement; let heroEl: HTMLElement; beforeEach(() => { TestBed.configureTestingModule({ providers: appProviders, }); }); bef",
    "id": "component-testing-scenarios-*-angular-232"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": "oreEach(async () => { fixture = TestBed.createComponent(DashboardHeroComponent); fixture.autoDetectChanges(); comp = fixture.componentInstance; // find the hero's DebugElement and element heroDe = fixture.debugElement.query(By.css('.hero')); heroEl = heroDe.nativeElement; // mock the hero supplied by the parent component expectedHero = {id: 42, name: 'Test Name'}; // simulate the parent setting the input property with that hero fixture.componentRef.setInput('hero', expectedHero); // wait for ini",
    "id": "component-testing-scenarios-*-angular-233"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": "tial data binding await fixture.whenStable(); }); it('should display hero name in uppercase', () => { const expectedPipedName = expectedHero.name.toUpperCase(); expect(heroEl.textContent).toContain(expectedPipedName); }); it('should raise selected event when clicked (triggerEventHandler)', () => { let selectedHero: Hero | undefined; comp.selected.subscribe((hero: Hero) => (selectedHero = hero)); heroDe.triggerEventHandler('click'); expect(selectedHero).toBe(expectedHero); }); it('should raise se",
    "id": "component-testing-scenarios-*-angular-234"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": "lected event when clicked (element.click)', () => { let selectedHero: Hero | undefined; comp.selected.subscribe((hero: Hero) => (selectedHero = hero)); heroEl.click(); expect(selectedHero).toBe(expectedHero); }); it('should raise selected event when clicked (click helper with DebugElement)', () => { let selectedHero: Hero | undefined; comp.selected.subscribe((hero: Hero) => (selectedHero = hero)); click(heroDe); // click helper with DebugElement expect(selectedHero).toBe(expectedHero); }); it('s",
    "id": "component-testing-scenarios-*-angular-235"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": "hould raise selected event when clicked (click helper with native element)', () => { let selectedHero: Hero | undefined; comp.selected.subscribe((hero: Hero) => (selectedHero = hero)); click(heroEl); // click helper with native element expect(selectedHero).toBe(expectedHero); });});//////////////////describe('DashboardHeroComponent when inside a test host', () => { let testHost: TestHostComponent; let fixture: ComponentFixture<TestHostComponent>; let heroEl: HTMLElement; beforeEach(waitForAsync(",
    "id": "component-testing-scenarios-*-angular-236"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": "() => { TestBed.configureTestingModule({ providers: appProviders, imports: [DashboardHeroComponent, TestHostComponent], }); })); beforeEach(() => { // create TestHostComponent instead of DashboardHeroComponent fixture = TestBed.createComponent(TestHostComponent); testHost = fixture.componentInstance; heroEl = fixture.nativeElement.querySelector('.hero'); fixture.detectChanges(); // trigger initial data binding }); it('should display hero name', () => { const expectedPipedName = testHost.hero.nam",
    "id": "component-testing-scenarios-*-angular-237"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": "e.toUpperCase(); expect(heroEl.textContent).toContain(expectedPipedName); }); it('should raise selected event when clicked', () => { click(heroEl); // selected hero should be the same data bound hero expect(testHost.selectedHero).toBe(testHost.hero); });});////// Test Host Component //////import {Component} from '@angular/core';@Component({ imports: [DashboardHeroComponent], template: ` <dashboard-hero [hero]=\"hero\" (selected)=\"onSelected($event)\"> </dashboard-hero>`,})class TestHostComponent { ",
    "id": "component-testing-scenarios-*-angular-238"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": "hero: Hero = {id: 42, name: 'Test Name'}; selectedHero: Hero | undefined; onSelected(hero: Hero) { this.selectedHero = hero; }} Because the template passes the hero name through the Angular UpperCasePipe, the test must match the element value with the upper-cased name. Clicking Clicking the hero should raise a selected event that the host component (DashboardComponent presumably) can hear: import {DebugElement} from '@angular/core';import {ComponentFixture, TestBed, waitForAsync} from '@angular/",
    "id": "component-testing-scenarios-*-angular-239"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": "core/testing';import {By} from '@angular/platform-browser';import {first} from 'rxjs/operators';import {addMatchers, click} from '../../testing';import {appProviders} from '../app.config';import {Hero} from '../model/hero';import {DashboardHeroComponent} from './dashboard-hero.component';beforeEach(addMatchers);describe('DashboardHeroComponent when tested directly', () => { let comp: DashboardHeroComponent; let expectedHero: Hero; let fixture: ComponentFixture<DashboardHeroComponent>; let heroDe",
    "id": "component-testing-scenarios-*-angular-240"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": ": DebugElement; let heroEl: HTMLElement; beforeEach(() => { TestBed.configureTestingModule({ providers: appProviders, }); }); beforeEach(async () => { fixture = TestBed.createComponent(DashboardHeroComponent); fixture.autoDetectChanges(); comp = fixture.componentInstance; // find the hero's DebugElement and element heroDe = fixture.debugElement.query(By.css('.hero')); heroEl = heroDe.nativeElement; // mock the hero supplied by the parent component expectedHero = {id: 42, name: 'Test Name'}; // s",
    "id": "component-testing-scenarios-*-angular-241"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": "imulate the parent setting the input property with that hero fixture.componentRef.setInput('hero', expectedHero); // wait for initial data binding await fixture.whenStable(); }); it('should display hero name in uppercase', () => { const expectedPipedName = expectedHero.name.toUpperCase(); expect(heroEl.textContent).toContain(expectedPipedName); }); it('should raise selected event when clicked (triggerEventHandler)', () => { let selectedHero: Hero | undefined; comp.selected.subscribe((hero: Hero)",
    "id": "component-testing-scenarios-*-angular-242"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": " => (selectedHero = hero)); heroDe.triggerEventHandler('click'); expect(selectedHero).toBe(expectedHero); }); it('should raise selected event when clicked (element.click)', () => { let selectedHero: Hero | undefined; comp.selected.subscribe((hero: Hero) => (selectedHero = hero)); heroEl.click(); expect(selectedHero).toBe(expectedHero); }); it('should raise selected event when clicked (click helper with DebugElement)', () => { let selectedHero: Hero | undefined; comp.selected.subscribe((hero: Her",
    "id": "component-testing-scenarios-*-angular-243"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": "o) => (selectedHero = hero)); click(heroDe); // click helper with DebugElement expect(selectedHero).toBe(expectedHero); }); it('should raise selected event when clicked (click helper with native element)', () => { let selectedHero: Hero | undefined; comp.selected.subscribe((hero: Hero) => (selectedHero = hero)); click(heroEl); // click helper with native element expect(selectedHero).toBe(expectedHero); });});//////////////////describe('DashboardHeroComponent when inside a test host', () => { let",
    "id": "component-testing-scenarios-*-angular-244"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": " testHost: TestHostComponent; let fixture: ComponentFixture<TestHostComponent>; let heroEl: HTMLElement; beforeEach(waitForAsync(() => { TestBed.configureTestingModule({ providers: appProviders, imports: [DashboardHeroComponent, TestHostComponent], }); })); beforeEach(() => { // create TestHostComponent instead of DashboardHeroComponent fixture = TestBed.createComponent(TestHostComponent); testHost = fixture.componentInstance; heroEl = fixture.nativeElement.querySelector('.hero'); fixture.detect",
    "id": "component-testing-scenarios-*-angular-245"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": "Changes(); // trigger initial data binding }); it('should display hero name', () => { const expectedPipedName = testHost.hero.name.toUpperCase(); expect(heroEl.textContent).toContain(expectedPipedName); }); it('should raise selected event when clicked', () => { click(heroEl); // selected hero should be the same data bound hero expect(testHost.selectedHero).toBe(testHost.hero); });});////// Test Host Component //////import {Component} from '@angular/core';@Component({ imports: [DashboardHeroCompo",
    "id": "component-testing-scenarios-*-angular-246"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": "nent], template: ` <dashboard-hero [hero]=\"hero\" (selected)=\"onSelected($event)\"> </dashboard-hero>`,})class TestHostComponent { hero: Hero = {id: 42, name: 'Test Name'}; selectedHero: Hero | undefined; onSelected(hero: Hero) { this.selectedHero = hero; }} The component's selected property returns an EventEmitter, which looks like an RxJS synchronous Observable to consumers. The test subscribes to it explicitly just as the host component does implicitly. If the component behaves as expected, cli",
    "id": "component-testing-scenarios-*-angular-247"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": "cking the hero's element should tell the component's selected property to emit the hero object. The test detects that event through its subscription to selected. triggerEventHandler The heroDe in the previous test is a DebugElement that represents the hero <div>. It has Angular properties and methods that abstract interaction with the native element. This test calls the DebugElement.triggerEventHandler with the \"click\" event name. The \"click\" event binding responds by calling DashboardHeroCompon",
    "id": "component-testing-scenarios-*-angular-248"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": "ent.click(). The Angular DebugElement.triggerEventHandler can raise any data-bound event by its event name. The second parameter is the event object passed to the handler. The test triggered a \"click\" event. import {DebugElement} from '@angular/core';import {ComponentFixture, TestBed, waitForAsync} from '@angular/core/testing';import {By} from '@angular/platform-browser';import {first} from 'rxjs/operators';import {addMatchers, click} from '../../testing';import {appProviders} from '../app.confi",
    "id": "component-testing-scenarios-*-angular-249"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": "g';import {Hero} from '../model/hero';import {DashboardHeroComponent} from './dashboard-hero.component';beforeEach(addMatchers);describe('DashboardHeroComponent when tested directly', () => { let comp: DashboardHeroComponent; let expectedHero: Hero; let fixture: ComponentFixture<DashboardHeroComponent>; let heroDe: DebugElement; let heroEl: HTMLElement; beforeEach(() => { TestBed.configureTestingModule({ providers: appProviders, }); }); beforeEach(async () => { fixture = TestBed.createComponent(",
    "id": "component-testing-scenarios-*-angular-250"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": "DashboardHeroComponent); fixture.autoDetectChanges(); comp = fixture.componentInstance; // find the hero's DebugElement and element heroDe = fixture.debugElement.query(By.css('.hero')); heroEl = heroDe.nativeElement; // mock the hero supplied by the parent component expectedHero = {id: 42, name: 'Test Name'}; // simulate the parent setting the input property with that hero fixture.componentRef.setInput('hero', expectedHero); // wait for initial data binding await fixture.whenStable(); }); it('sh",
    "id": "component-testing-scenarios-*-angular-251"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": "ould display hero name in uppercase', () => { const expectedPipedName = expectedHero.name.toUpperCase(); expect(heroEl.textContent).toContain(expectedPipedName); }); it('should raise selected event when clicked (triggerEventHandler)', () => { let selectedHero: Hero | undefined; comp.selected.subscribe((hero: Hero) => (selectedHero = hero)); heroDe.triggerEventHandler('click'); expect(selectedHero).toBe(expectedHero); }); it('should raise selected event when clicked (element.click)', () => { let ",
    "id": "component-testing-scenarios-*-angular-252"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": "selectedHero: Hero | undefined; comp.selected.subscribe((hero: Hero) => (selectedHero = hero)); heroEl.click(); expect(selectedHero).toBe(expectedHero); }); it('should raise selected event when clicked (click helper with DebugElement)', () => { let selectedHero: Hero | undefined; comp.selected.subscribe((hero: Hero) => (selectedHero = hero)); click(heroDe); // click helper with DebugElement expect(selectedHero).toBe(expectedHero); }); it('should raise selected event when clicked (click helper wi",
    "id": "component-testing-scenarios-*-angular-253"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": "th native element)', () => { let selectedHero: Hero | undefined; comp.selected.subscribe((hero: Hero) => (selectedHero = hero)); click(heroEl); // click helper with native element expect(selectedHero).toBe(expectedHero); });});//////////////////describe('DashboardHeroComponent when inside a test host', () => { let testHost: TestHostComponent; let fixture: ComponentFixture<TestHostComponent>; let heroEl: HTMLElement; beforeEach(waitForAsync(() => { TestBed.configureTestingModule({ providers: appP",
    "id": "component-testing-scenarios-*-angular-254"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": "roviders, imports: [DashboardHeroComponent, TestHostComponent], }); })); beforeEach(() => { // create TestHostComponent instead of DashboardHeroComponent fixture = TestBed.createComponent(TestHostComponent); testHost = fixture.componentInstance; heroEl = fixture.nativeElement.querySelector('.hero'); fixture.detectChanges(); // trigger initial data binding }); it('should display hero name', () => { const expectedPipedName = testHost.hero.name.toUpperCase(); expect(heroEl.textContent).toContain(ex",
    "id": "component-testing-scenarios-*-angular-255"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": "pectedPipedName); }); it('should raise selected event when clicked', () => { click(heroEl); // selected hero should be the same data bound hero expect(testHost.selectedHero).toBe(testHost.hero); });});////// Test Host Component //////import {Component} from '@angular/core';@Component({ imports: [DashboardHeroComponent], template: ` <dashboard-hero [hero]=\"hero\" (selected)=\"onSelected($event)\"> </dashboard-hero>`,})class TestHostComponent { hero: Hero = {id: 42, name: 'Test Name'}; selectedHero: ",
    "id": "component-testing-scenarios-*-angular-256"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": "Hero | undefined; onSelected(hero: Hero) { this.selectedHero = hero; }} In this case, the test correctly assumes that the runtime event handler, the component's click() method, doesn't care about the event object. HELPFUL: Other handlers are less forgiving. For example, the RouterLink directive expects an object with a button property that identifies which mouse button, if any, was pressed during the click. The RouterLink directive throws an error if the event object is missing. Click the elemen",
    "id": "component-testing-scenarios-*-angular-257"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": "t The following test alternative calls the native element's own click() method, which is perfectly fine for this component. import {DebugElement} from '@angular/core';import {ComponentFixture, TestBed, waitForAsync} from '@angular/core/testing';import {By} from '@angular/platform-browser';import {first} from 'rxjs/operators';import {addMatchers, click} from '../../testing';import {appProviders} from '../app.config';import {Hero} from '../model/hero';import {DashboardHeroComponent} from './dashbo",
    "id": "component-testing-scenarios-*-angular-258"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": "ard-hero.component';beforeEach(addMatchers);describe('DashboardHeroComponent when tested directly', () => { let comp: DashboardHeroComponent; let expectedHero: Hero; let fixture: ComponentFixture<DashboardHeroComponent>; let heroDe: DebugElement; let heroEl: HTMLElement; beforeEach(() => { TestBed.configureTestingModule({ providers: appProviders, }); }); beforeEach(async () => { fixture = TestBed.createComponent(DashboardHeroComponent); fixture.autoDetectChanges(); comp = fixture.componentInstan",
    "id": "component-testing-scenarios-*-angular-259"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": "ce; // find the hero's DebugElement and element heroDe = fixture.debugElement.query(By.css('.hero')); heroEl = heroDe.nativeElement; // mock the hero supplied by the parent component expectedHero = {id: 42, name: 'Test Name'}; // simulate the parent setting the input property with that hero fixture.componentRef.setInput('hero', expectedHero); // wait for initial data binding await fixture.whenStable(); }); it('should display hero name in uppercase', () => { const expectedPipedName = expectedHero",
    "id": "component-testing-scenarios-*-angular-260"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": ".name.toUpperCase(); expect(heroEl.textContent).toContain(expectedPipedName); }); it('should raise selected event when clicked (triggerEventHandler)', () => { let selectedHero: Hero | undefined; comp.selected.subscribe((hero: Hero) => (selectedHero = hero)); heroDe.triggerEventHandler('click'); expect(selectedHero).toBe(expectedHero); }); it('should raise selected event when clicked (element.click)', () => { let selectedHero: Hero | undefined; comp.selected.subscribe((hero: Hero) => (selectedHer",
    "id": "component-testing-scenarios-*-angular-261"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": "o = hero)); heroEl.click(); expect(selectedHero).toBe(expectedHero); }); it('should raise selected event when clicked (click helper with DebugElement)', () => { let selectedHero: Hero | undefined; comp.selected.subscribe((hero: Hero) => (selectedHero = hero)); click(heroDe); // click helper with DebugElement expect(selectedHero).toBe(expectedHero); }); it('should raise selected event when clicked (click helper with native element)', () => { let selectedHero: Hero | undefined; comp.selected.subsc",
    "id": "component-testing-scenarios-*-angular-262"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": "ribe((hero: Hero) => (selectedHero = hero)); click(heroEl); // click helper with native element expect(selectedHero).toBe(expectedHero); });});//////////////////describe('DashboardHeroComponent when inside a test host', () => { let testHost: TestHostComponent; let fixture: ComponentFixture<TestHostComponent>; let heroEl: HTMLElement; beforeEach(waitForAsync(() => { TestBed.configureTestingModule({ providers: appProviders, imports: [DashboardHeroComponent, TestHostComponent], }); })); beforeEach(",
    "id": "component-testing-scenarios-*-angular-263"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": "() => { // create TestHostComponent instead of DashboardHeroComponent fixture = TestBed.createComponent(TestHostComponent); testHost = fixture.componentInstance; heroEl = fixture.nativeElement.querySelector('.hero'); fixture.detectChanges(); // trigger initial data binding }); it('should display hero name', () => { const expectedPipedName = testHost.hero.name.toUpperCase(); expect(heroEl.textContent).toContain(expectedPipedName); }); it('should raise selected event when clicked', () => { click(h",
    "id": "component-testing-scenarios-*-angular-264"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": "eroEl); // selected hero should be the same data bound hero expect(testHost.selectedHero).toBe(testHost.hero); });});////// Test Host Component //////import {Component} from '@angular/core';@Component({ imports: [DashboardHeroComponent], template: ` <dashboard-hero [hero]=\"hero\" (selected)=\"onSelected($event)\"> </dashboard-hero>`,})class TestHostComponent { hero: Hero = {id: 42, name: 'Test Name'}; selectedHero: Hero | undefined; onSelected(hero: Hero) { this.selectedHero = hero; }} click() help",
    "id": "component-testing-scenarios-*-angular-265"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": "er Clicking a button, an anchor, or an arbitrary HTML element is a common test task. Make that consistent and straightforward by encapsulating the click-triggering process in a helper such as the following click() function: testing/index.ts (click helper) import {DebugElement} from '@angular/core';import {ComponentFixture, tick} from '@angular/core/testing';export * from './async-observable-helpers';export * from './jasmine-matchers';///// Short utilities //////** Wait a tick, then detect change",
    "id": "component-testing-scenarios-*-angular-266"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": "s */export function advance(f: ComponentFixture<any>): void { tick(); f.detectChanges();}// See https://developer.mozilla.org/docs/Web/API/MouseEvent/button/** Button events to pass to `DebugElement.triggerEventHandler` for RouterLink event handler */export const ButtonClickEvents = { left: {button: 0}, right: {button: 2},};/** Simulate element click. Defaults to mouse left-button click event. */export function click( el: DebugElement | HTMLElement, eventObj: any = ButtonClickEvents.left,): void",
    "id": "component-testing-scenarios-*-angular-267"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": " { if (el instanceof HTMLElement) { el.click(); } else { el.triggerEventHandler('click', eventObj); }} The first parameter is the element-to-click. If you want, pass a custom event object as the second parameter. The default is a partial left-button mouse event object accepted by many handlers including the RouterLink directive. IMPORTANT: The click() helper function is not one of the Angular testing utilities. It's a function defined in this guide's sample code. All of the sample tests use it. ",
    "id": "component-testing-scenarios-*-angular-268"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": "If you like it, add it to your own collection of helpers. Here's the previous test, rewritten using the click helper. app/dashboard/dashboard-hero.component.spec.ts (test with click helper) import {DebugElement} from '@angular/core';import {ComponentFixture, TestBed, waitForAsync} from '@angular/core/testing';import {By} from '@angular/platform-browser';import {first} from 'rxjs/operators';import {addMatchers, click} from '../../testing';import {appProviders} from '../app.config';import {Hero} f",
    "id": "component-testing-scenarios-*-angular-269"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": "rom '../model/hero';import {DashboardHeroComponent} from './dashboard-hero.component';beforeEach(addMatchers);describe('DashboardHeroComponent when tested directly', () => { let comp: DashboardHeroComponent; let expectedHero: Hero; let fixture: ComponentFixture<DashboardHeroComponent>; let heroDe: DebugElement; let heroEl: HTMLElement; beforeEach(() => { TestBed.configureTestingModule({ providers: appProviders, }); }); beforeEach(async () => { fixture = TestBed.createComponent(DashboardHeroCompo",
    "id": "component-testing-scenarios-*-angular-270"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": "nent); fixture.autoDetectChanges(); comp = fixture.componentInstance; // find the hero's DebugElement and element heroDe = fixture.debugElement.query(By.css('.hero')); heroEl = heroDe.nativeElement; // mock the hero supplied by the parent component expectedHero = {id: 42, name: 'Test Name'}; // simulate the parent setting the input property with that hero fixture.componentRef.setInput('hero', expectedHero); // wait for initial data binding await fixture.whenStable(); }); it('should display hero ",
    "id": "component-testing-scenarios-*-angular-271"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": "name in uppercase', () => { const expectedPipedName = expectedHero.name.toUpperCase(); expect(heroEl.textContent).toContain(expectedPipedName); }); it('should raise selected event when clicked (triggerEventHandler)', () => { let selectedHero: Hero | undefined; comp.selected.subscribe((hero: Hero) => (selectedHero = hero)); heroDe.triggerEventHandler('click'); expect(selectedHero).toBe(expectedHero); }); it('should raise selected event when clicked (element.click)', () => { let selectedHero: Hero",
    "id": "component-testing-scenarios-*-angular-272"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": " | undefined; comp.selected.subscribe((hero: Hero) => (selectedHero = hero)); heroEl.click(); expect(selectedHero).toBe(expectedHero); }); it('should raise selected event when clicked (click helper with DebugElement)', () => { let selectedHero: Hero | undefined; comp.selected.subscribe((hero: Hero) => (selectedHero = hero)); click(heroDe); // click helper with DebugElement expect(selectedHero).toBe(expectedHero); }); it('should raise selected event when clicked (click helper with native element)",
    "id": "component-testing-scenarios-*-angular-273"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": "', () => { let selectedHero: Hero | undefined; comp.selected.subscribe((hero: Hero) => (selectedHero = hero)); click(heroEl); // click helper with native element expect(selectedHero).toBe(expectedHero); });});//////////////////describe('DashboardHeroComponent when inside a test host', () => { let testHost: TestHostComponent; let fixture: ComponentFixture<TestHostComponent>; let heroEl: HTMLElement; beforeEach(waitForAsync(() => { TestBed.configureTestingModule({ providers: appProviders, imports:",
    "id": "component-testing-scenarios-*-angular-274"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": " [DashboardHeroComponent, TestHostComponent], }); })); beforeEach(() => { // create TestHostComponent instead of DashboardHeroComponent fixture = TestBed.createComponent(TestHostComponent); testHost = fixture.componentInstance; heroEl = fixture.nativeElement.querySelector('.hero'); fixture.detectChanges(); // trigger initial data binding }); it('should display hero name', () => { const expectedPipedName = testHost.hero.name.toUpperCase(); expect(heroEl.textContent).toContain(expectedPipedName); ",
    "id": "component-testing-scenarios-*-angular-275"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": "}); it('should raise selected event when clicked', () => { click(heroEl); // selected hero should be the same data bound hero expect(testHost.selectedHero).toBe(testHost.hero); });});////// Test Host Component //////import {Component} from '@angular/core';@Component({ imports: [DashboardHeroComponent], template: ` <dashboard-hero [hero]=\"hero\" (selected)=\"onSelected($event)\"> </dashboard-hero>`,})class TestHostComponent { hero: Hero = {id: 42, name: 'Test Name'}; selectedHero: Hero | undefined; ",
    "id": "component-testing-scenarios-*-angular-276"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": "onSelected(hero: Hero) { this.selectedHero = hero; }} Component inside a test host The previous tests played the role of the host DashboardComponent themselves. But does the DashboardHeroComponent work correctly when properly data-bound to a host component? app/dashboard/dashboard-hero.component.spec.ts (test host) import {DebugElement} from '@angular/core';import {ComponentFixture, TestBed, waitForAsync} from '@angular/core/testing';import {By} from '@angular/platform-browser';import {first} fr",
    "id": "component-testing-scenarios-*-angular-277"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": "om 'rxjs/operators';import {addMatchers, click} from '../../testing';import {appProviders} from '../app.config';import {Hero} from '../model/hero';import {DashboardHeroComponent} from './dashboard-hero.component';beforeEach(addMatchers);describe('DashboardHeroComponent when tested directly', () => { let comp: DashboardHeroComponent; let expectedHero: Hero; let fixture: ComponentFixture<DashboardHeroComponent>; let heroDe: DebugElement; let heroEl: HTMLElement; beforeEach(() => { TestBed.configur",
    "id": "component-testing-scenarios-*-angular-278"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": "eTestingModule({ providers: appProviders, }); }); beforeEach(async () => { fixture = TestBed.createComponent(DashboardHeroComponent); fixture.autoDetectChanges(); comp = fixture.componentInstance; // find the hero's DebugElement and element heroDe = fixture.debugElement.query(By.css('.hero')); heroEl = heroDe.nativeElement; // mock the hero supplied by the parent component expectedHero = {id: 42, name: 'Test Name'}; // simulate the parent setting the input property with that hero fixture.compone",
    "id": "component-testing-scenarios-*-angular-279"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": "ntRef.setInput('hero', expectedHero); // wait for initial data binding await fixture.whenStable(); }); it('should display hero name in uppercase', () => { const expectedPipedName = expectedHero.name.toUpperCase(); expect(heroEl.textContent).toContain(expectedPipedName); }); it('should raise selected event when clicked (triggerEventHandler)', () => { let selectedHero: Hero | undefined; comp.selected.subscribe((hero: Hero) => (selectedHero = hero)); heroDe.triggerEventHandler('click'); expect(sele",
    "id": "component-testing-scenarios-*-angular-280"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": "ctedHero).toBe(expectedHero); }); it('should raise selected event when clicked (element.click)', () => { let selectedHero: Hero | undefined; comp.selected.subscribe((hero: Hero) => (selectedHero = hero)); heroEl.click(); expect(selectedHero).toBe(expectedHero); }); it('should raise selected event when clicked (click helper with DebugElement)', () => { let selectedHero: Hero | undefined; comp.selected.subscribe((hero: Hero) => (selectedHero = hero)); click(heroDe); // click helper with DebugEleme",
    "id": "component-testing-scenarios-*-angular-281"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": "nt expect(selectedHero).toBe(expectedHero); }); it('should raise selected event when clicked (click helper with native element)', () => { let selectedHero: Hero | undefined; comp.selected.subscribe((hero: Hero) => (selectedHero = hero)); click(heroEl); // click helper with native element expect(selectedHero).toBe(expectedHero); });});//////////////////describe('DashboardHeroComponent when inside a test host', () => { let testHost: TestHostComponent; let fixture: ComponentFixture<TestHostComponen",
    "id": "component-testing-scenarios-*-angular-282"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": "t>; let heroEl: HTMLElement; beforeEach(waitForAsync(() => { TestBed.configureTestingModule({ providers: appProviders, imports: [DashboardHeroComponent, TestHostComponent], }); })); beforeEach(() => { // create TestHostComponent instead of DashboardHeroComponent fixture = TestBed.createComponent(TestHostComponent); testHost = fixture.componentInstance; heroEl = fixture.nativeElement.querySelector('.hero'); fixture.detectChanges(); // trigger initial data binding }); it('should display hero name'",
    "id": "component-testing-scenarios-*-angular-283"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": ", () => { const expectedPipedName = testHost.hero.name.toUpperCase(); expect(heroEl.textContent).toContain(expectedPipedName); }); it('should raise selected event when clicked', () => { click(heroEl); // selected hero should be the same data bound hero expect(testHost.selectedHero).toBe(testHost.hero); });});////// Test Host Component //////import {Component} from '@angular/core';@Component({ imports: [DashboardHeroComponent], template: ` <dashboard-hero [hero]=\"hero\" (selected)=\"onSelected($eve",
    "id": "component-testing-scenarios-*-angular-284"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": "nt)\"> </dashboard-hero>`,})class TestHostComponent { hero: Hero = {id: 42, name: 'Test Name'}; selectedHero: Hero | undefined; onSelected(hero: Hero) { this.selectedHero = hero; }} The test host sets the component's hero input property with its test hero. It binds the component's selected event with its onSelected handler, which records the emitted hero in its selectedHero property. Later, the tests will be able to check selectedHero to verify that the DashboardHeroComponent.selected event emitt",
    "id": "component-testing-scenarios-*-angular-285"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": "ed the expected hero. The setup for the test-host tests is similar to the setup for the stand-alone tests: app/dashboard/dashboard-hero.component.spec.ts (test host setup) import {DebugElement} from '@angular/core';import {ComponentFixture, TestBed, waitForAsync} from '@angular/core/testing';import {By} from '@angular/platform-browser';import {first} from 'rxjs/operators';import {addMatchers, click} from '../../testing';import {appProviders} from '../app.config';import {Hero} from '../model/hero",
    "id": "component-testing-scenarios-*-angular-286"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": "';import {DashboardHeroComponent} from './dashboard-hero.component';beforeEach(addMatchers);describe('DashboardHeroComponent when tested directly', () => { let comp: DashboardHeroComponent; let expectedHero: Hero; let fixture: ComponentFixture<DashboardHeroComponent>; let heroDe: DebugElement; let heroEl: HTMLElement; beforeEach(() => { TestBed.configureTestingModule({ providers: appProviders, }); }); beforeEach(async () => { fixture = TestBed.createComponent(DashboardHeroComponent); fixture.aut",
    "id": "component-testing-scenarios-*-angular-287"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": "oDetectChanges(); comp = fixture.componentInstance; // find the hero's DebugElement and element heroDe = fixture.debugElement.query(By.css('.hero')); heroEl = heroDe.nativeElement; // mock the hero supplied by the parent component expectedHero = {id: 42, name: 'Test Name'}; // simulate the parent setting the input property with that hero fixture.componentRef.setInput('hero', expectedHero); // wait for initial data binding await fixture.whenStable(); }); it('should display hero name in uppercase'",
    "id": "component-testing-scenarios-*-angular-288"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": ", () => { const expectedPipedName = expectedHero.name.toUpperCase(); expect(heroEl.textContent).toContain(expectedPipedName); }); it('should raise selected event when clicked (triggerEventHandler)', () => { let selectedHero: Hero | undefined; comp.selected.subscribe((hero: Hero) => (selectedHero = hero)); heroDe.triggerEventHandler('click'); expect(selectedHero).toBe(expectedHero); }); it('should raise selected event when clicked (element.click)', () => { let selectedHero: Hero | undefined; comp",
    "id": "component-testing-scenarios-*-angular-289"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": ".selected.subscribe((hero: Hero) => (selectedHero = hero)); heroEl.click(); expect(selectedHero).toBe(expectedHero); }); it('should raise selected event when clicked (click helper with DebugElement)', () => { let selectedHero: Hero | undefined; comp.selected.subscribe((hero: Hero) => (selectedHero = hero)); click(heroDe); // click helper with DebugElement expect(selectedHero).toBe(expectedHero); }); it('should raise selected event when clicked (click helper with native element)', () => { let sel",
    "id": "component-testing-scenarios-*-angular-290"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": "ectedHero: Hero | undefined; comp.selected.subscribe((hero: Hero) => (selectedHero = hero)); click(heroEl); // click helper with native element expect(selectedHero).toBe(expectedHero); });});//////////////////describe('DashboardHeroComponent when inside a test host', () => { let testHost: TestHostComponent; let fixture: ComponentFixture<TestHostComponent>; let heroEl: HTMLElement; beforeEach(waitForAsync(() => { TestBed.configureTestingModule({ providers: appProviders, imports: [DashboardHeroCom",
    "id": "component-testing-scenarios-*-angular-291"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": "ponent, TestHostComponent], }); })); beforeEach(() => { // create TestHostComponent instead of DashboardHeroComponent fixture = TestBed.createComponent(TestHostComponent); testHost = fixture.componentInstance; heroEl = fixture.nativeElement.querySelector('.hero'); fixture.detectChanges(); // trigger initial data binding }); it('should display hero name', () => { const expectedPipedName = testHost.hero.name.toUpperCase(); expect(heroEl.textContent).toContain(expectedPipedName); }); it('should rai",
    "id": "component-testing-scenarios-*-angular-292"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": "se selected event when clicked', () => { click(heroEl); // selected hero should be the same data bound hero expect(testHost.selectedHero).toBe(testHost.hero); });});////// Test Host Component //////import {Component} from '@angular/core';@Component({ imports: [DashboardHeroComponent], template: ` <dashboard-hero [hero]=\"hero\" (selected)=\"onSelected($event)\"> </dashboard-hero>`,})class TestHostComponent { hero: Hero = {id: 42, name: 'Test Name'}; selectedHero: Hero | undefined; onSelected(hero: H",
    "id": "component-testing-scenarios-*-angular-293"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": "ero) { this.selectedHero = hero; }} This testing module configuration shows three important differences: It imports both the DashboardHeroComponent and the TestHostComponent It creates the TestHostComponent instead of the DashboardHeroComponent The TestHostComponent sets the DashboardHeroComponent.hero with a binding The createComponent returns a fixture that holds an instance of TestHostComponent instead of an instance of DashboardHeroComponent. Creating the TestHostComponent has the side effec",
    "id": "component-testing-scenarios-*-angular-294"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": "t of creating a DashboardHeroComponent because the latter appears within the template of the former. The query for the hero element (heroEl) still finds it in the test DOM, albeit at greater depth in the element tree than before. The tests themselves are almost identical to the stand-alone version: app/dashboard/dashboard-hero.component.spec.ts (test-host) import {DebugElement} from '@angular/core';import {ComponentFixture, TestBed, waitForAsync} from '@angular/core/testing';import {By} from '@a",
    "id": "component-testing-scenarios-*-angular-295"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": "ngular/platform-browser';import {first} from 'rxjs/operators';import {addMatchers, click} from '../../testing';import {appProviders} from '../app.config';import {Hero} from '../model/hero';import {DashboardHeroComponent} from './dashboard-hero.component';beforeEach(addMatchers);describe('DashboardHeroComponent when tested directly', () => { let comp: DashboardHeroComponent; let expectedHero: Hero; let fixture: ComponentFixture<DashboardHeroComponent>; let heroDe: DebugElement; let heroEl: HTMLEl",
    "id": "component-testing-scenarios-*-angular-296"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": "ement; beforeEach(() => { TestBed.configureTestingModule({ providers: appProviders, }); }); beforeEach(async () => { fixture = TestBed.createComponent(DashboardHeroComponent); fixture.autoDetectChanges(); comp = fixture.componentInstance; // find the hero's DebugElement and element heroDe = fixture.debugElement.query(By.css('.hero')); heroEl = heroDe.nativeElement; // mock the hero supplied by the parent component expectedHero = {id: 42, name: 'Test Name'}; // simulate the parent setting the inp",
    "id": "component-testing-scenarios-*-angular-297"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": "ut property with that hero fixture.componentRef.setInput('hero', expectedHero); // wait for initial data binding await fixture.whenStable(); }); it('should display hero name in uppercase', () => { const expectedPipedName = expectedHero.name.toUpperCase(); expect(heroEl.textContent).toContain(expectedPipedName); }); it('should raise selected event when clicked (triggerEventHandler)', () => { let selectedHero: Hero | undefined; comp.selected.subscribe((hero: Hero) => (selectedHero = hero)); heroDe",
    "id": "component-testing-scenarios-*-angular-298"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": ".triggerEventHandler('click'); expect(selectedHero).toBe(expectedHero); }); it('should raise selected event when clicked (element.click)', () => { let selectedHero: Hero | undefined; comp.selected.subscribe((hero: Hero) => (selectedHero = hero)); heroEl.click(); expect(selectedHero).toBe(expectedHero); }); it('should raise selected event when clicked (click helper with DebugElement)', () => { let selectedHero: Hero | undefined; comp.selected.subscribe((hero: Hero) => (selectedHero = hero)); clic",
    "id": "component-testing-scenarios-*-angular-299"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": "k(heroDe); // click helper with DebugElement expect(selectedHero).toBe(expectedHero); }); it('should raise selected event when clicked (click helper with native element)', () => { let selectedHero: Hero | undefined; comp.selected.subscribe((hero: Hero) => (selectedHero = hero)); click(heroEl); // click helper with native element expect(selectedHero).toBe(expectedHero); });});//////////////////describe('DashboardHeroComponent when inside a test host', () => { let testHost: TestHostComponent; let ",
    "id": "component-testing-scenarios-*-angular-300"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": "fixture: ComponentFixture<TestHostComponent>; let heroEl: HTMLElement; beforeEach(waitForAsync(() => { TestBed.configureTestingModule({ providers: appProviders, imports: [DashboardHeroComponent, TestHostComponent], }); })); beforeEach(() => { // create TestHostComponent instead of DashboardHeroComponent fixture = TestBed.createComponent(TestHostComponent); testHost = fixture.componentInstance; heroEl = fixture.nativeElement.querySelector('.hero'); fixture.detectChanges(); // trigger initial data",
    "id": "component-testing-scenarios-*-angular-301"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": " binding }); it('should display hero name', () => { const expectedPipedName = testHost.hero.name.toUpperCase(); expect(heroEl.textContent).toContain(expectedPipedName); }); it('should raise selected event when clicked', () => { click(heroEl); // selected hero should be the same data bound hero expect(testHost.selectedHero).toBe(testHost.hero); });});////// Test Host Component //////import {Component} from '@angular/core';@Component({ imports: [DashboardHeroComponent], template: ` <dashboard-hero",
    "id": "component-testing-scenarios-*-angular-302"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": " [hero]=\"hero\" (selected)=\"onSelected($event)\"> </dashboard-hero>`,})class TestHostComponent { hero: Hero = {id: 42, name: 'Test Name'}; selectedHero: Hero | undefined; onSelected(hero: Hero) { this.selectedHero = hero; }} Only the selected event test differs. It confirms that the selected DashboardHeroComponent hero really does find its way up through the event binding to the host component. Routing component A routing component is a component that tells the Router to navigate to another compon",
    "id": "component-testing-scenarios-*-angular-303"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": "ent. The DashboardComponent is a routing component because the user can navigate to the HeroDetailComponent by clicking on one of the hero buttons on the dashboard. Angular provides test helpers to reduce boilerplate and more effectively test code which depends on HttpClient. The provideRouter function can be used directly in the test module as well. app/dashboard/dashboard.component.spec.ts import {provideHttpClient} from '@angular/common/http';import {HttpTestingController, provideHttpClientTe",
    "id": "component-testing-scenarios-*-angular-304"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": "sting} from '@angular/common/http/testing';import {NO_ERRORS_SCHEMA} from '@angular/core';import {TestBed, waitForAsync} from '@angular/core/testing';import {By} from '@angular/platform-browser';import {NavigationEnd, provideRouter, Router} from '@angular/router';import {RouterTestingHarness} from '@angular/router/testing';import {firstValueFrom} from 'rxjs';import {filter} from 'rxjs/operators';import {addMatchers, click} from '../../testing';import {HeroService} from '../model/hero.service';im",
    "id": "component-testing-scenarios-*-angular-305"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": "port {getTestHeroes} from '../model/testing/test-heroes';import {DashboardComponent} from './dashboard.component';import {appConfig} from '../app.config';import {HeroDetailComponent} from '../hero/hero-detail.component';beforeEach(addMatchers);let comp: DashboardComponent;let harness: RouterTestingHarness;//////// Deep ////////////////describe('DashboardComponent (deep)', () => { compileAndCreate(); tests(clickForDeep); function clickForDeep() { // get first <div class=\"hero\"> const heroEl: HTML",
    "id": "component-testing-scenarios-*-angular-306"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": "Element = harness.routeNativeElement!.querySelector('.hero')!; click(heroEl); return firstValueFrom( TestBed.inject(Router).events.pipe(filter((e) => e instanceof NavigationEnd)), ); }});//////// Shallow ////////////////describe('DashboardComponent (shallow)', () => { beforeEach(() => { TestBed.configureTestingModule( Object.assign({}, appConfig, { imports: [DashboardComponent, HeroDetailComponent], providers: [provideRouter([{path: 'heroes/:id', component: HeroDetailComponent}])], schemas: [NO_",
    "id": "component-testing-scenarios-*-angular-307"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": "ERRORS_SCHEMA], }), ); }); compileAndCreate(); tests(clickForShallow); function clickForShallow() { // get first <dashboard-hero> DebugElement const heroDe = harness.routeDebugElement!.query(By.css('dashboard-hero')); heroDe.triggerEventHandler('selected', comp.heroes[0]); return Promise.resolve(); }});/** Add TestBed providers, compile, and create DashboardComponent */function compileAndCreate() { beforeEach(async () => { TestBed.configureTestingModule( Object.assign({}, appConfig, { imports: [",
    "id": "component-testing-scenarios-*-angular-308"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": "DashboardComponent], providers: [ provideRouter([{path: '**', component: DashboardComponent}]), provideHttpClient(), provideHttpClientTesting(), HeroService, ], }), ); harness = await RouterTestingHarness.create(); comp = await harness.navigateByUrl('/', DashboardComponent); TestBed.inject(HttpTestingController).expectOne('api/heroes').flush(getTestHeroes()); });}/** * The (almost) same tests for both. * Only change: the way that the first hero is clicked */function tests(heroClick: () => Promis",
    "id": "component-testing-scenarios-*-angular-309"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": "e<unknown>) { describe('after get dashboard heroes', () => { let router: Router; // Trigger component so it gets heroes and binds to them beforeEach(waitForAsync(() => { router = TestBed.inject(Router); harness.detectChanges(); // runs ngOnInit -> getHeroes })); it('should HAVE heroes', () => { expect(comp.heroes.length) .withContext('should have heroes after service promise resolves') .toBeGreaterThan(0); }); it('should DISPLAY heroes', () => { // Find and examine the displayed heroes // Look f",
    "id": "component-testing-scenarios-*-angular-310"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": "or them in the DOM by css class const heroes = harness.routeNativeElement!.querySelectorAll('dashboard-hero'); expect(heroes.length).withContext('should display 4 heroes').toBe(4); }); it('should tell navigate when hero clicked', async () => { await heroClick(); // trigger click on first inner <div class=\"hero\"> // expecting to navigate to id of the component's first hero const id = comp.heroes[0].id; expect(TestBed.inject(Router).url) .withContext('should nav to HeroDetail for first hero') .toE",
    "id": "component-testing-scenarios-*-angular-311"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": "qual(`/heroes/${id}`); }); });} The following test clicks the displayed hero and confirms that we navigate to the expected URL. app/dashboard/dashboard.component.spec.ts (navigate test) import {provideHttpClient} from '@angular/common/http';import {HttpTestingController, provideHttpClientTesting} from '@angular/common/http/testing';import {NO_ERRORS_SCHEMA} from '@angular/core';import {TestBed, waitForAsync} from '@angular/core/testing';import {By} from '@angular/platform-browser';import {Naviga",
    "id": "component-testing-scenarios-*-angular-312"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": "tionEnd, provideRouter, Router} from '@angular/router';import {RouterTestingHarness} from '@angular/router/testing';import {firstValueFrom} from 'rxjs';import {filter} from 'rxjs/operators';import {addMatchers, click} from '../../testing';import {HeroService} from '../model/hero.service';import {getTestHeroes} from '../model/testing/test-heroes';import {DashboardComponent} from './dashboard.component';import {appConfig} from '../app.config';import {HeroDetailComponent} from '../hero/hero-detail.",
    "id": "component-testing-scenarios-*-angular-313"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": "component';beforeEach(addMatchers);let comp: DashboardComponent;let harness: RouterTestingHarness;//////// Deep ////////////////describe('DashboardComponent (deep)', () => { compileAndCreate(); tests(clickForDeep); function clickForDeep() { // get first <div class=\"hero\"> const heroEl: HTMLElement = harness.routeNativeElement!.querySelector('.hero')!; click(heroEl); return firstValueFrom( TestBed.inject(Router).events.pipe(filter((e) => e instanceof NavigationEnd)), ); }});//////// Shallow /////",
    "id": "component-testing-scenarios-*-angular-314"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": "///////////describe('DashboardComponent (shallow)', () => { beforeEach(() => { TestBed.configureTestingModule( Object.assign({}, appConfig, { imports: [DashboardComponent, HeroDetailComponent], providers: [provideRouter([{path: 'heroes/:id', component: HeroDetailComponent}])], schemas: [NO_ERRORS_SCHEMA], }), ); }); compileAndCreate(); tests(clickForShallow); function clickForShallow() { // get first <dashboard-hero> DebugElement const heroDe = harness.routeDebugElement!.query(By.css('dashboard-",
    "id": "component-testing-scenarios-*-angular-315"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": "hero')); heroDe.triggerEventHandler('selected', comp.heroes[0]); return Promise.resolve(); }});/** Add TestBed providers, compile, and create DashboardComponent */function compileAndCreate() { beforeEach(async () => { TestBed.configureTestingModule( Object.assign({}, appConfig, { imports: [DashboardComponent], providers: [ provideRouter([{path: '**', component: DashboardComponent}]), provideHttpClient(), provideHttpClientTesting(), HeroService, ], }), ); harness = await RouterTestingHarness.crea",
    "id": "component-testing-scenarios-*-angular-316"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": "te(); comp = await harness.navigateByUrl('/', DashboardComponent); TestBed.inject(HttpTestingController).expectOne('api/heroes').flush(getTestHeroes()); });}/** * The (almost) same tests for both. * Only change: the way that the first hero is clicked */function tests(heroClick: () => Promise<unknown>) { describe('after get dashboard heroes', () => { let router: Router; // Trigger component so it gets heroes and binds to them beforeEach(waitForAsync(() => { router = TestBed.inject(Router); harnes",
    "id": "component-testing-scenarios-*-angular-317"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": "s.detectChanges(); // runs ngOnInit -> getHeroes })); it('should HAVE heroes', () => { expect(comp.heroes.length) .withContext('should have heroes after service promise resolves') .toBeGreaterThan(0); }); it('should DISPLAY heroes', () => { // Find and examine the displayed heroes // Look for them in the DOM by css class const heroes = harness.routeNativeElement!.querySelectorAll('dashboard-hero'); expect(heroes.length).withContext('should display 4 heroes').toBe(4); }); it('should tell navigate",
    "id": "component-testing-scenarios-*-angular-318"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": " when hero clicked', async () => { await heroClick(); // trigger click on first inner <div class=\"hero\"> // expecting to navigate to id of the component's first hero const id = comp.heroes[0].id; expect(TestBed.inject(Router).url) .withContext('should nav to HeroDetail for first hero') .toEqual(`/heroes/${id}`); }); });} Routed components A routed component is the destination of a Router navigation. It can be trickier to test, especially when the route to the component includes parameters. The H",
    "id": "component-testing-scenarios-*-angular-319"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": "eroDetailComponent is a routed component that is the destination of such a route. When a user clicks a Dashboard hero, the DashboardComponent tells the Router to navigate to heroes/:id. The :id is a route parameter whose value is the id of the hero to edit. The Router matches that URL to a route to the HeroDetailComponent. It creates an ActivatedRoute object with the routing information and injects it into a new instance of the HeroDetailComponent. Here are the services injected into HeroDetailC",
    "id": "component-testing-scenarios-*-angular-320"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": "omponent: app/hero/hero-detail.component.ts (inject) import {Component, inject} from '@angular/core';import {ActivatedRoute, Router, RouterLink} from '@angular/router';import {Hero} from '../model/hero';import {sharedImports} from '../shared/shared';import {HeroDetailService} from './hero-detail.service';@Component({ selector: 'app-hero-detail', templateUrl: './hero-detail.component.html', styleUrls: ['./hero-detail.component.css'], providers: [HeroDetailService], imports: [sharedImports, Router",
    "id": "component-testing-scenarios-*-angular-321"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": "Link],})export class HeroDetailComponent { private heroDetailService = inject(HeroDetailService); private route = inject(ActivatedRoute); private router = inject(Router); hero!: Hero; constructor() { // get hero when `id` param changes this.route.paramMap.subscribe((pmap) => this.getHero(pmap.get('id'))); } private getHero(id: string | null): void { // when no id or id===0, create new blank hero if (!id) { this.hero = {id: 0, name: ''} as Hero; return; } this.heroDetailService.getHero(id).subscr",
    "id": "component-testing-scenarios-*-angular-322"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": "ibe((hero) => { if (hero) { this.hero = hero; } else { this.gotoList(); // id not found; navigate to list } }); } save(): void { this.heroDetailService.saveHero(this.hero).subscribe(() => this.gotoList()); } cancel() { this.gotoList(); } gotoList() { this.router.navigate(['../'], {relativeTo: this.route}); }} The HeroDetail component needs the id parameter so it can fetch the corresponding hero using the HeroDetailService. The component has to get the id from the ActivatedRoute.paramMap property",
    "id": "component-testing-scenarios-*-angular-323"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": " which is an Observable. It can't just reference the id property of the ActivatedRoute.paramMap. The component has to subscribe to the ActivatedRoute.paramMap observable and be prepared for the id to change during its lifetime. app/hero/hero-detail.component.ts (constructor) import {Component, inject} from '@angular/core';import {ActivatedRoute, Router, RouterLink} from '@angular/router';import {Hero} from '../model/hero';import {sharedImports} from '../shared/shared';import {HeroDetailService} ",
    "id": "component-testing-scenarios-*-angular-324"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": "from './hero-detail.service';@Component({ selector: 'app-hero-detail', templateUrl: './hero-detail.component.html', styleUrls: ['./hero-detail.component.css'], providers: [HeroDetailService], imports: [sharedImports, RouterLink],})export class HeroDetailComponent { private heroDetailService = inject(HeroDetailService); private route = inject(ActivatedRoute); private router = inject(Router); hero!: Hero; constructor() { // get hero when `id` param changes this.route.paramMap.subscribe((pmap) => t",
    "id": "component-testing-scenarios-*-angular-325"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": "his.getHero(pmap.get('id'))); } private getHero(id: string | null): void { // when no id or id===0, create new blank hero if (!id) { this.hero = {id: 0, name: ''} as Hero; return; } this.heroDetailService.getHero(id).subscribe((hero) => { if (hero) { this.hero = hero; } else { this.gotoList(); // id not found; navigate to list } }); } save(): void { this.heroDetailService.saveHero(this.hero).subscribe(() => this.gotoList()); } cancel() { this.gotoList(); } gotoList() { this.router.navigate(['../",
    "id": "component-testing-scenarios-*-angular-326"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": "'], {relativeTo: this.route}); }} Tests can explore how the HeroDetailComponent responds to different id parameter values by navigating to different routes. Testing with the RouterTestingHarness Here's a test demonstrating the component's behavior when the observed id refers to an existing hero: app/hero/hero-detail.component.spec.ts (existing id) import {HttpClient, HttpHandler, provideHttpClient} from '@angular/common/http';import {HttpTestingController, provideHttpClientTesting} from '@angula",
    "id": "component-testing-scenarios-*-angular-327"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": "r/common/http/testing';import {fakeAsync, TestBed, tick} from '@angular/core/testing';import {provideRouter, Router} from '@angular/router';import {RouterTestingHarness} from '@angular/router/testing';import {asyncData, click} from '../../testing';import {Hero} from '../model/hero';import {sharedImports} from '../shared/shared';import {HeroDetailComponent} from './hero-detail.component';import {HeroDetailService} from './hero-detail.service';import {HeroListComponent} from './hero-list.component",
    "id": "component-testing-scenarios-*-angular-328"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": "';////// Testing Vars //////let component: HeroDetailComponent;let harness: RouterTestingHarness;let page: Page;////// Tests //////describe('HeroDetailComponent', () => { describe('with HeroModule setup', heroModuleSetup); describe('when override its provided HeroDetailService', overrideSetup); describe('with FormsModule setup', formsModuleSetup); describe('with SharedModule setup', sharedModuleSetup);});///////////////////const testHero = getTestHeroes()[0];function overrideSetup() { class Hero",
    "id": "component-testing-scenarios-*-angular-329"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": "DetailServiceSpy { testHero: Hero = {...testHero}; /* emit cloned test hero */ getHero = jasmine .createSpy('getHero') .and.callFake(() => asyncData(Object.assign({}, this.testHero))); /* emit clone of test hero, with changes merged in */ saveHero = jasmine .createSpy('saveHero') .and.callFake((hero: Hero) => asyncData(Object.assign(this.testHero, hero))); } beforeEach(async () => { await TestBed.configureTestingModule( Object.assign({}, appConfig, { imports: [HeroDetailComponent, HeroListCompon",
    "id": "component-testing-scenarios-*-angular-330"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": "ent], providers: [ provideRouter([ {path: 'heroes', component: HeroListComponent}, {path: 'heroes/:id', component: HeroDetailComponent}, ]), HttpClient, HttpHandler, // HeroDetailService at this level is IRRELEVANT! {provide: HeroDetailService, useValue: {}}, ], }), ) .overrideComponent(HeroDetailComponent, { set: {providers: [{provide: HeroDetailService, useClass: HeroDetailServiceSpy}]}, }); }); let hdsSpy: HeroDetailServiceSpy; beforeEach(async () => { harness = await RouterTestingHarness.cre",
    "id": "component-testing-scenarios-*-angular-331"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": "ate(); component = await harness.navigateByUrl(`/heroes/${testHero.id}`, HeroDetailComponent); page = new Page(); // get the component's injected HeroDetailServiceSpy hdsSpy = harness.routeDebugElement!.injector.get(HeroDetailService) as any; harness.detectChanges(); }); it('should have called `getHero`', () => { expect(hdsSpy.getHero.calls.count()) .withContext('getHero called once') .toBe(1, 'getHero called once'); }); it(\"should display stub hero's name\", () => { expect(page.nameDisplay.textC",
    "id": "component-testing-scenarios-*-angular-332"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": "ontent).toBe(hdsSpy.testHero.name); }); it('should save stub hero change', fakeAsync(() => { const origName = hdsSpy.testHero.name; const newName = 'New Name'; page.nameInput.value = newName; page.nameInput.dispatchEvent(new Event('input')); // tell Angular expect(component.hero.name).withContext('component hero has new name').toBe(newName); expect(hdsSpy.testHero.name).withContext('service hero unchanged before save').toBe(origName); click(page.saveBtn); expect(hdsSpy.saveHero.calls.count()).wi",
    "id": "component-testing-scenarios-*-angular-333"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": "thContext('saveHero called once').toBe(1); tick(); // wait for async save to complete expect(hdsSpy.testHero.name).withContext('service hero has new name after save').toBe(newName); expect(TestBed.inject(Router).url).toEqual('/heroes'); }));}////////////////////import {getTestHeroes} from '../model/testing/test-hero.service';const firstHero = getTestHeroes()[0];function heroModuleSetup() { beforeEach(async () => { await TestBed.configureTestingModule( Object.assign({}, appConfig, { imports: [Her",
    "id": "component-testing-scenarios-*-angular-334"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": "oDetailComponent, HeroListComponent], providers: [ provideRouter([ {path: 'heroes/:id', component: HeroDetailComponent}, {path: 'heroes', component: HeroListComponent}, ]), provideHttpClient(), provideHttpClientTesting(), ], }), ); }); describe('when navigate to existing hero', () => { let expectedHero: Hero; beforeEach(async () => { expectedHero = firstHero; await createComponent(expectedHero.id); }); it(\"should display that hero's name\", () => { expect(page.nameDisplay.textContent).toBe(expect",
    "id": "component-testing-scenarios-*-angular-335"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": "edHero.name); }); it('should navigate when click cancel', () => { click(page.cancelBtn); expect(TestBed.inject(Router).url).toEqual(`/heroes/${expectedHero.id}`); }); it('should save when click save but not navigate immediately', () => { click(page.saveBtn); expect(TestBed.inject(HttpTestingController).expectOne({method: 'PUT', url: 'api/heroes'})); expect(TestBed.inject(Router).url).toEqual('/heroes/41'); }); it('should navigate when click save and save resolves', fakeAsync(() => { click(page.s",
    "id": "component-testing-scenarios-*-angular-336"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": "aveBtn); tick(); // wait for async save to complete expect(TestBed.inject(Router).url).toEqual('/heroes/41'); })); it('should convert hero name to Title Case', async () => { harness.fixture.autoDetectChanges(); // get the name's input and display elements from the DOM const hostElement: HTMLElement = harness.routeNativeElement!; const nameInput: HTMLInputElement = hostElement.querySelector('input')!; const nameDisplay: HTMLElement = hostElement.querySelector('span')!; // simulate user entering a",
    "id": "component-testing-scenarios-*-angular-337"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": " new name into the input box nameInput.value = 'quick BROWN fOx'; // Dispatch a DOM event so that Angular learns of input value change. nameInput.dispatchEvent(new Event('input')); // Wait for Angular to update the display binding through the title pipe await harness.fixture.whenStable(); expect(nameDisplay.textContent).toBe('Quick Brown Fox'); }); }); describe('when navigate to non-existent hero id', () => { beforeEach(async () => { await createComponent(999); }); it('should try to navigate bac",
    "id": "component-testing-scenarios-*-angular-338"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": "k to hero list', () => { expect(TestBed.inject(Router).url).toEqual('/heroes'); }); });}/////////////////////import {FormsModule} from '@angular/forms';import {TitleCasePipe} from '../shared/title-case.pipe';import {appConfig} from '../app.config';function formsModuleSetup() { beforeEach(async () => { await TestBed.configureTestingModule( Object.assign({}, appConfig, { imports: [FormsModule, HeroDetailComponent, TitleCasePipe], providers: [ provideHttpClient(), provideHttpClientTesting(), provid",
    "id": "component-testing-scenarios-*-angular-339"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": "eRouter([{path: 'heroes/:id', component: HeroDetailComponent}]), ], }), ); }); it(\"should display 1st hero's name\", async () => { const expectedHero = firstHero; await createComponent(expectedHero.id).then(() => { expect(page.nameDisplay.textContent).toBe(expectedHero.name); }); });}///////////////////////function sharedModuleSetup() { beforeEach(async () => { await TestBed.configureTestingModule( Object.assign({}, appConfig, { imports: [HeroDetailComponent, sharedImports], providers: [ provideR",
    "id": "component-testing-scenarios-*-angular-340"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": "outer([{path: 'heroes/:id', component: HeroDetailComponent}]), provideHttpClient(), provideHttpClientTesting(), ], }), ); }); it(\"should display 1st hero's name\", async () => { const expectedHero = firstHero; await createComponent(expectedHero.id).then(() => { expect(page.nameDisplay.textContent).toBe(expectedHero.name); }); });}/////////// Helpers //////** Create the HeroDetailComponent, initialize it, set test variables */async function createComponent(id: number) { harness = await RouterTesti",
    "id": "component-testing-scenarios-*-angular-341"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": "ngHarness.create(); component = await harness.navigateByUrl(`/heroes/${id}`, HeroDetailComponent); page = new Page(); const request = TestBed.inject(HttpTestingController).expectOne(`api/heroes/?id=${id}`); const hero = getTestHeroes().find((h) => h.id === Number(id)); request.flush(hero ? [hero] : []); harness.detectChanges();}class Page { // getter properties wait to query the DOM until called. get buttons() { return this.queryAll<HTMLButtonElement>('button'); } get saveBtn() { return this.but",
    "id": "component-testing-scenarios-*-angular-342"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": "tons[0]; } get cancelBtn() { return this.buttons[1]; } get nameDisplay() { return this.query<HTMLElement>('span'); } get nameInput() { return this.query<HTMLInputElement>('input'); } //// query helpers //// private query<T>(selector: string): T { return harness.routeNativeElement!.querySelector(selector)! as T; } private queryAll<T>(selector: string): T[] { return harness.routeNativeElement!.querySelectorAll(selector) as any as T[]; }} HELPFUL: In the following section, the createComponent() met",
    "id": "component-testing-scenarios-*-angular-343"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": "hod and page object are discussed. Rely on your intuition for now. When the id cannot be found, the component should re-route to the HeroListComponent. The test suite setup provided the same router harness described above. This test expects the component to try to navigate to the HeroListComponent. app/hero/hero-detail.component.spec.ts (bad id) import {HttpClient, HttpHandler, provideHttpClient} from '@angular/common/http';import {HttpTestingController, provideHttpClientTesting} from '@angular/",
    "id": "component-testing-scenarios-*-angular-344"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": "common/http/testing';import {fakeAsync, TestBed, tick} from '@angular/core/testing';import {provideRouter, Router} from '@angular/router';import {RouterTestingHarness} from '@angular/router/testing';import {asyncData, click} from '../../testing';import {Hero} from '../model/hero';import {sharedImports} from '../shared/shared';import {HeroDetailComponent} from './hero-detail.component';import {HeroDetailService} from './hero-detail.service';import {HeroListComponent} from './hero-list.component';",
    "id": "component-testing-scenarios-*-angular-345"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": "////// Testing Vars //////let component: HeroDetailComponent;let harness: RouterTestingHarness;let page: Page;////// Tests //////describe('HeroDetailComponent', () => { describe('with HeroModule setup', heroModuleSetup); describe('when override its provided HeroDetailService', overrideSetup); describe('with FormsModule setup', formsModuleSetup); describe('with SharedModule setup', sharedModuleSetup);});///////////////////const testHero = getTestHeroes()[0];function overrideSetup() { class HeroDe",
    "id": "component-testing-scenarios-*-angular-346"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": "tailServiceSpy { testHero: Hero = {...testHero}; /* emit cloned test hero */ getHero = jasmine .createSpy('getHero') .and.callFake(() => asyncData(Object.assign({}, this.testHero))); /* emit clone of test hero, with changes merged in */ saveHero = jasmine .createSpy('saveHero') .and.callFake((hero: Hero) => asyncData(Object.assign(this.testHero, hero))); } beforeEach(async () => { await TestBed.configureTestingModule( Object.assign({}, appConfig, { imports: [HeroDetailComponent, HeroListComponen",
    "id": "component-testing-scenarios-*-angular-347"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": "t], providers: [ provideRouter([ {path: 'heroes', component: HeroListComponent}, {path: 'heroes/:id', component: HeroDetailComponent}, ]), HttpClient, HttpHandler, // HeroDetailService at this level is IRRELEVANT! {provide: HeroDetailService, useValue: {}}, ], }), ) .overrideComponent(HeroDetailComponent, { set: {providers: [{provide: HeroDetailService, useClass: HeroDetailServiceSpy}]}, }); }); let hdsSpy: HeroDetailServiceSpy; beforeEach(async () => { harness = await RouterTestingHarness.creat",
    "id": "component-testing-scenarios-*-angular-348"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": "e(); component = await harness.navigateByUrl(`/heroes/${testHero.id}`, HeroDetailComponent); page = new Page(); // get the component's injected HeroDetailServiceSpy hdsSpy = harness.routeDebugElement!.injector.get(HeroDetailService) as any; harness.detectChanges(); }); it('should have called `getHero`', () => { expect(hdsSpy.getHero.calls.count()) .withContext('getHero called once') .toBe(1, 'getHero called once'); }); it(\"should display stub hero's name\", () => { expect(page.nameDisplay.textCon",
    "id": "component-testing-scenarios-*-angular-349"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": "tent).toBe(hdsSpy.testHero.name); }); it('should save stub hero change', fakeAsync(() => { const origName = hdsSpy.testHero.name; const newName = 'New Name'; page.nameInput.value = newName; page.nameInput.dispatchEvent(new Event('input')); // tell Angular expect(component.hero.name).withContext('component hero has new name').toBe(newName); expect(hdsSpy.testHero.name).withContext('service hero unchanged before save').toBe(origName); click(page.saveBtn); expect(hdsSpy.saveHero.calls.count()).with",
    "id": "component-testing-scenarios-*-angular-350"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": "Context('saveHero called once').toBe(1); tick(); // wait for async save to complete expect(hdsSpy.testHero.name).withContext('service hero has new name after save').toBe(newName); expect(TestBed.inject(Router).url).toEqual('/heroes'); }));}////////////////////import {getTestHeroes} from '../model/testing/test-hero.service';const firstHero = getTestHeroes()[0];function heroModuleSetup() { beforeEach(async () => { await TestBed.configureTestingModule( Object.assign({}, appConfig, { imports: [HeroD",
    "id": "component-testing-scenarios-*-angular-351"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": "etailComponent, HeroListComponent], providers: [ provideRouter([ {path: 'heroes/:id', component: HeroDetailComponent}, {path: 'heroes', component: HeroListComponent}, ]), provideHttpClient(), provideHttpClientTesting(), ], }), ); }); describe('when navigate to existing hero', () => { let expectedHero: Hero; beforeEach(async () => { expectedHero = firstHero; await createComponent(expectedHero.id); }); it(\"should display that hero's name\", () => { expect(page.nameDisplay.textContent).toBe(expected",
    "id": "component-testing-scenarios-*-angular-352"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": "Hero.name); }); it('should navigate when click cancel', () => { click(page.cancelBtn); expect(TestBed.inject(Router).url).toEqual(`/heroes/${expectedHero.id}`); }); it('should save when click save but not navigate immediately', () => { click(page.saveBtn); expect(TestBed.inject(HttpTestingController).expectOne({method: 'PUT', url: 'api/heroes'})); expect(TestBed.inject(Router).url).toEqual('/heroes/41'); }); it('should navigate when click save and save resolves', fakeAsync(() => { click(page.sav",
    "id": "component-testing-scenarios-*-angular-353"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": "eBtn); tick(); // wait for async save to complete expect(TestBed.inject(Router).url).toEqual('/heroes/41'); })); it('should convert hero name to Title Case', async () => { harness.fixture.autoDetectChanges(); // get the name's input and display elements from the DOM const hostElement: HTMLElement = harness.routeNativeElement!; const nameInput: HTMLInputElement = hostElement.querySelector('input')!; const nameDisplay: HTMLElement = hostElement.querySelector('span')!; // simulate user entering a n",
    "id": "component-testing-scenarios-*-angular-354"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": "ew name into the input box nameInput.value = 'quick BROWN fOx'; // Dispatch a DOM event so that Angular learns of input value change. nameInput.dispatchEvent(new Event('input')); // Wait for Angular to update the display binding through the title pipe await harness.fixture.whenStable(); expect(nameDisplay.textContent).toBe('Quick Brown Fox'); }); }); describe('when navigate to non-existent hero id', () => { beforeEach(async () => { await createComponent(999); }); it('should try to navigate back ",
    "id": "component-testing-scenarios-*-angular-355"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": "to hero list', () => { expect(TestBed.inject(Router).url).toEqual('/heroes'); }); });}/////////////////////import {FormsModule} from '@angular/forms';import {TitleCasePipe} from '../shared/title-case.pipe';import {appConfig} from '../app.config';function formsModuleSetup() { beforeEach(async () => { await TestBed.configureTestingModule( Object.assign({}, appConfig, { imports: [FormsModule, HeroDetailComponent, TitleCasePipe], providers: [ provideHttpClient(), provideHttpClientTesting(), provideR",
    "id": "component-testing-scenarios-*-angular-356"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": "outer([{path: 'heroes/:id', component: HeroDetailComponent}]), ], }), ); }); it(\"should display 1st hero's name\", async () => { const expectedHero = firstHero; await createComponent(expectedHero.id).then(() => { expect(page.nameDisplay.textContent).toBe(expectedHero.name); }); });}///////////////////////function sharedModuleSetup() { beforeEach(async () => { await TestBed.configureTestingModule( Object.assign({}, appConfig, { imports: [HeroDetailComponent, sharedImports], providers: [ provideRou",
    "id": "component-testing-scenarios-*-angular-357"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": "ter([{path: 'heroes/:id', component: HeroDetailComponent}]), provideHttpClient(), provideHttpClientTesting(), ], }), ); }); it(\"should display 1st hero's name\", async () => { const expectedHero = firstHero; await createComponent(expectedHero.id).then(() => { expect(page.nameDisplay.textContent).toBe(expectedHero.name); }); });}/////////// Helpers //////** Create the HeroDetailComponent, initialize it, set test variables */async function createComponent(id: number) { harness = await RouterTesting",
    "id": "component-testing-scenarios-*-angular-358"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": "Harness.create(); component = await harness.navigateByUrl(`/heroes/${id}`, HeroDetailComponent); page = new Page(); const request = TestBed.inject(HttpTestingController).expectOne(`api/heroes/?id=${id}`); const hero = getTestHeroes().find((h) => h.id === Number(id)); request.flush(hero ? [hero] : []); harness.detectChanges();}class Page { // getter properties wait to query the DOM until called. get buttons() { return this.queryAll<HTMLButtonElement>('button'); } get saveBtn() { return this.butto",
    "id": "component-testing-scenarios-*-angular-359"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": "ns[0]; } get cancelBtn() { return this.buttons[1]; } get nameDisplay() { return this.query<HTMLElement>('span'); } get nameInput() { return this.query<HTMLInputElement>('input'); } //// query helpers //// private query<T>(selector: string): T { return harness.routeNativeElement!.querySelector(selector)! as T; } private queryAll<T>(selector: string): T[] { return harness.routeNativeElement!.querySelectorAll(selector) as any as T[]; }} Nested component tests Component templates often have nested c",
    "id": "component-testing-scenarios-*-angular-360"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": "omponents, whose templates might contain more components. The component tree can be very deep and sometimes the nested components play no role in testing the component at the top of the tree. The AppComponent, for example, displays a navigation bar with anchors and their RouterLink directives. app/app.component.html <app-banner></app-banner><app-welcome></app-welcome><nav> <a routerLink=\"/dashboard\">Dashboard</a> <a routerLink=\"/heroes\">Heroes</a> <a routerLink=\"/about\">About</a></nav><router-ou",
    "id": "component-testing-scenarios-*-angular-361"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": "tlet></router-outlet> To validate the links but not the navigation, you don't need the Router to navigate and you don't need the <router-outlet> to mark where the Router inserts routed components. The BannerComponent and WelcomeComponent (indicated by <app-banner> and <app-welcome>) are also irrelevant. Yet any test that creates the AppComponent in the DOM also creates instances of these three components and, if you let that happen, you'll have to configure the TestBed to create them. If you neg",
    "id": "component-testing-scenarios-*-angular-362"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": "lect to declare them, the Angular compiler won't recognize the <app-banner>, <app-welcome>, and <router-outlet> tags in the AppComponent template and will throw an error. If you declare the real components, you'll also have to declare their nested components and provide for all services injected in any component in the tree. This section describes two techniques for minimizing the setup. Use them, alone or in combination, to stay focused on testing the primary component. Stubbing unneeded compon",
    "id": "component-testing-scenarios-*-angular-363"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": "ents In the first technique, you create and declare stub versions of the components and directive that play little or no role in the tests. app/app.component.spec.ts (stub declaration) import {Component, DebugElement, NO_ERRORS_SCHEMA} from '@angular/core';import {ComponentFixture, fakeAsync, TestBed, tick, waitForAsync} from '@angular/core/testing';import {By} from '@angular/platform-browser';import {provideRouter, Router, RouterLink} from '@angular/router';import {AppComponent} from './app.com",
    "id": "component-testing-scenarios-*-angular-364"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": "ponent';import {appConfig} from './app.config';import {UserService} from './model';@Component({selector: 'app-banner', template: ''})class BannerStubComponent {}@Component({selector: 'router-outlet', template: ''})class RouterOutletStubComponent {}@Component({selector: 'app-welcome', template: ''})class WelcomeStubComponent {}let comp: AppComponent;let fixture: ComponentFixture<AppComponent>;describe('AppComponent & TestModule', () => { beforeEach(waitForAsync(() => { TestBed.configureTestingMod",
    "id": "component-testing-scenarios-*-angular-365"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": "ule( Object.assign({}, appConfig, { imports: [ AppComponent, BannerStubComponent, RouterLink, RouterOutletStubComponent, WelcomeStubComponent, ], providers: [provideRouter([]), UserService], }), ) .then(() => { fixture = TestBed.createComponent(AppComponent); comp = fixture.componentInstance; }); })); tests();});//////// Testing w/ NO_ERRORS_SCHEMA //////describe('AppComponent & NO_ERRORS_SCHEMA', () => { beforeEach(waitForAsync(() => { TestBed.configureTestingModule( Object.assign({}, appConfig",
    "id": "component-testing-scenarios-*-angular-366"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": ", { imports: [ AppComponent, BannerStubComponent, RouterLink, ], providers: [provideRouter([]), UserService], schemas: [NO_ERRORS_SCHEMA], }), ) .then(() => { fixture = TestBed.createComponent(AppComponent); comp = fixture.componentInstance; }); })); tests();});function tests() { let routerLinks: RouterLink[]; let linkDes: DebugElement[]; beforeEach(() => { fixture.detectChanges(); // trigger initial data binding // find DebugElements with an attached RouterLinkStubDirective linkDes = fixture.de",
    "id": "component-testing-scenarios-*-angular-367"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": "bugElement.queryAll(By.directive(RouterLink)); // get attached link directive instances // using each DebugElement's injector routerLinks = linkDes.map((de) => de.injector.get(RouterLink)); }); it('can instantiate the component', () => { expect(comp).not.toBeNull(); }); it('can get RouterLinks from template', () => { expect(routerLinks.length).withContext('should have 3 routerLinks').toBe(3); expect(routerLinks[0].href).toBe('/dashboard'); expect(routerLinks[1].href).toBe('/heroes'); expect(rout",
    "id": "component-testing-scenarios-*-angular-368"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": "erLinks[2].href).toBe('/about'); }); it('can click Heroes link in template', fakeAsync(() => { const heroesLinkDe = linkDes[1]; // heroes link DebugElement TestBed.inject(Router).resetConfig([{path: '**', children: []}]); heroesLinkDe.triggerEventHandler('click', {button: 0}); tick(); fixture.detectChanges(); expect(TestBed.inject(Router).url).toBe('/heroes'); }));} The stub selectors match the selectors for the corresponding real components. But their templates and classes are empty. Then decla",
    "id": "component-testing-scenarios-*-angular-369"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": "re them in the TestBed configuration next to the components, directives, and pipes that need to be real. app/app.component.spec.ts (TestBed stubs) import {Component, DebugElement, NO_ERRORS_SCHEMA} from '@angular/core';import {ComponentFixture, fakeAsync, TestBed, tick, waitForAsync} from '@angular/core/testing';import {By} from '@angular/platform-browser';import {provideRouter, Router, RouterLink} from '@angular/router';import {AppComponent} from './app.component';import {appConfig} from './app",
    "id": "component-testing-scenarios-*-angular-370"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": ".config';import {UserService} from './model';@Component({selector: 'app-banner', template: ''})class BannerStubComponent {}@Component({selector: 'router-outlet', template: ''})class RouterOutletStubComponent {}@Component({selector: 'app-welcome', template: ''})class WelcomeStubComponent {}let comp: AppComponent;let fixture: ComponentFixture<AppComponent>;describe('AppComponent & TestModule', () => { beforeEach(waitForAsync(() => { TestBed.configureTestingModule( Object.assign({}, appConfig, { im",
    "id": "component-testing-scenarios-*-angular-371"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": "ports: [ AppComponent, BannerStubComponent, RouterLink, RouterOutletStubComponent, WelcomeStubComponent, ], providers: [provideRouter([]), UserService], }), ) .then(() => { fixture = TestBed.createComponent(AppComponent); comp = fixture.componentInstance; }); })); tests();});//////// Testing w/ NO_ERRORS_SCHEMA //////describe('AppComponent & NO_ERRORS_SCHEMA', () => { beforeEach(waitForAsync(() => { TestBed.configureTestingModule( Object.assign({}, appConfig, { imports: [ AppComponent, BannerStu",
    "id": "component-testing-scenarios-*-angular-372"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": "bComponent, RouterLink, ], providers: [provideRouter([]), UserService], schemas: [NO_ERRORS_SCHEMA], }), ) .then(() => { fixture = TestBed.createComponent(AppComponent); comp = fixture.componentInstance; }); })); tests();});function tests() { let routerLinks: RouterLink[]; let linkDes: DebugElement[]; beforeEach(() => { fixture.detectChanges(); // trigger initial data binding // find DebugElements with an attached RouterLinkStubDirective linkDes = fixture.debugElement.queryAll(By.directive(Route",
    "id": "component-testing-scenarios-*-angular-373"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": "rLink)); // get attached link directive instances // using each DebugElement's injector routerLinks = linkDes.map((de) => de.injector.get(RouterLink)); }); it('can instantiate the component', () => { expect(comp).not.toBeNull(); }); it('can get RouterLinks from template', () => { expect(routerLinks.length).withContext('should have 3 routerLinks').toBe(3); expect(routerLinks[0].href).toBe('/dashboard'); expect(routerLinks[1].href).toBe('/heroes'); expect(routerLinks[2].href).toBe('/about'); }); i",
    "id": "component-testing-scenarios-*-angular-374"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": "t('can click Heroes link in template', fakeAsync(() => { const heroesLinkDe = linkDes[1]; // heroes link DebugElement TestBed.inject(Router).resetConfig([{path: '**', children: []}]); heroesLinkDe.triggerEventHandler('click', {button: 0}); tick(); fixture.detectChanges(); expect(TestBed.inject(Router).url).toBe('/heroes'); }));} The AppComponent is the test subject, so of course you declare the real version. The rest are stubs. NO_ERRORS_SCHEMA In the second approach, add NO_ERRORS_SCHEMA to the",
    "id": "component-testing-scenarios-*-angular-375"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": " TestBed.schemas metadata. app/app.component.spec.ts (NO_ERRORS_SCHEMA) import {Component, DebugElement, NO_ERRORS_SCHEMA} from '@angular/core';import {ComponentFixture, fakeAsync, TestBed, tick, waitForAsync} from '@angular/core/testing';import {By} from '@angular/platform-browser';import {provideRouter, Router, RouterLink} from '@angular/router';import {AppComponent} from './app.component';import {appConfig} from './app.config';import {UserService} from './model';@Component({selector: 'app-ban",
    "id": "component-testing-scenarios-*-angular-376"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": "ner', template: ''})class BannerStubComponent {}@Component({selector: 'router-outlet', template: ''})class RouterOutletStubComponent {}@Component({selector: 'app-welcome', template: ''})class WelcomeStubComponent {}let comp: AppComponent;let fixture: ComponentFixture<AppComponent>;describe('AppComponent & TestModule', () => { beforeEach(waitForAsync(() => { TestBed.configureTestingModule( Object.assign({}, appConfig, { imports: [ AppComponent, BannerStubComponent, RouterLink, RouterOutletStubCom",
    "id": "component-testing-scenarios-*-angular-377"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": "ponent, WelcomeStubComponent, ], providers: [provideRouter([]), UserService], }), ) .then(() => { fixture = TestBed.createComponent(AppComponent); comp = fixture.componentInstance; }); })); tests();});//////// Testing w/ NO_ERRORS_SCHEMA //////describe('AppComponent & NO_ERRORS_SCHEMA', () => { beforeEach(waitForAsync(() => { TestBed.configureTestingModule( Object.assign({}, appConfig, { imports: [ AppComponent, BannerStubComponent, RouterLink, ], providers: [provideRouter([]), UserService], sch",
    "id": "component-testing-scenarios-*-angular-378"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": "emas: [NO_ERRORS_SCHEMA], }), ) .then(() => { fixture = TestBed.createComponent(AppComponent); comp = fixture.componentInstance; }); })); tests();});function tests() { let routerLinks: RouterLink[]; let linkDes: DebugElement[]; beforeEach(() => { fixture.detectChanges(); // trigger initial data binding // find DebugElements with an attached RouterLinkStubDirective linkDes = fixture.debugElement.queryAll(By.directive(RouterLink)); // get attached link directive instances // using each DebugElemen",
    "id": "component-testing-scenarios-*-angular-379"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": "t's injector routerLinks = linkDes.map((de) => de.injector.get(RouterLink)); }); it('can instantiate the component', () => { expect(comp).not.toBeNull(); }); it('can get RouterLinks from template', () => { expect(routerLinks.length).withContext('should have 3 routerLinks').toBe(3); expect(routerLinks[0].href).toBe('/dashboard'); expect(routerLinks[1].href).toBe('/heroes'); expect(routerLinks[2].href).toBe('/about'); }); it('can click Heroes link in template', fakeAsync(() => { const heroesLinkDe",
    "id": "component-testing-scenarios-*-angular-380"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": " = linkDes[1]; // heroes link DebugElement TestBed.inject(Router).resetConfig([{path: '**', children: []}]); heroesLinkDe.triggerEventHandler('click', {button: 0}); tick(); fixture.detectChanges(); expect(TestBed.inject(Router).url).toBe('/heroes'); }));} The NO_ERRORS_SCHEMA tells the Angular compiler to ignore unrecognized elements and attributes. The compiler recognizes the <app-root> element and the routerLink attribute because you declared a corresponding AppComponent and RouterLink in the ",
    "id": "component-testing-scenarios-*-angular-381"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": "TestBed configuration. But the compiler won't throw an error when it encounters <app-banner>, <app-welcome>, or <router-outlet>. It simply renders them as empty tags and the browser ignores them. You no longer need the stub components. Use both techniques together These are techniques for Shallow Component Testing, so-named because they reduce the visual surface of the component to just those elements in the component's template that matter for tests. The NO_ERRORS_SCHEMA approach is the easier ",
    "id": "component-testing-scenarios-*-angular-382"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": "of the two but don't overuse it. The NO_ERRORS_SCHEMA also prevents the compiler from telling you about the missing components and attributes that you omitted inadvertently or misspelled. You could waste hours chasing phantom bugs that the compiler would have caught in an instant. The stub component approach has another advantage. While the stubs in this example were empty, you could give them stripped-down templates and classes if your tests need to interact with them in some way. In practice y",
    "id": "component-testing-scenarios-*-angular-383"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": "ou will combine the two techniques in the same setup, as seen in this example. app/app.component.spec.ts (mixed setup) import {Component, DebugElement, NO_ERRORS_SCHEMA} from '@angular/core';import {ComponentFixture, fakeAsync, TestBed, tick, waitForAsync} from '@angular/core/testing';import {By} from '@angular/platform-browser';import {provideRouter, Router, RouterLink} from '@angular/router';import {AppComponent} from './app.component';import {appConfig} from './app.config';import {UserService",
    "id": "component-testing-scenarios-*-angular-384"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": "} from './model';@Component({selector: 'app-banner', template: ''})class BannerStubComponent {}@Component({selector: 'router-outlet', template: ''})class RouterOutletStubComponent {}@Component({selector: 'app-welcome', template: ''})class WelcomeStubComponent {}let comp: AppComponent;let fixture: ComponentFixture<AppComponent>;describe('AppComponent & TestModule', () => { beforeEach(waitForAsync(() => { TestBed.configureTestingModule( Object.assign({}, appConfig, { imports: [ AppComponent, Banne",
    "id": "component-testing-scenarios-*-angular-385"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": "rStubComponent, RouterLink, RouterOutletStubComponent, WelcomeStubComponent, ], providers: [provideRouter([]), UserService], }), ) .then(() => { fixture = TestBed.createComponent(AppComponent); comp = fixture.componentInstance; }); })); tests();});//////// Testing w/ NO_ERRORS_SCHEMA //////describe('AppComponent & NO_ERRORS_SCHEMA', () => { beforeEach(waitForAsync(() => { TestBed.configureTestingModule( Object.assign({}, appConfig, { imports: [ AppComponent, BannerStubComponent, RouterLink, ], p",
    "id": "component-testing-scenarios-*-angular-386"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": "roviders: [provideRouter([]), UserService], schemas: [NO_ERRORS_SCHEMA], }), ) .then(() => { fixture = TestBed.createComponent(AppComponent); comp = fixture.componentInstance; }); })); tests();});function tests() { let routerLinks: RouterLink[]; let linkDes: DebugElement[]; beforeEach(() => { fixture.detectChanges(); // trigger initial data binding // find DebugElements with an attached RouterLinkStubDirective linkDes = fixture.debugElement.queryAll(By.directive(RouterLink)); // get attached lin",
    "id": "component-testing-scenarios-*-angular-387"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": "k directive instances // using each DebugElement's injector routerLinks = linkDes.map((de) => de.injector.get(RouterLink)); }); it('can instantiate the component', () => { expect(comp).not.toBeNull(); }); it('can get RouterLinks from template', () => { expect(routerLinks.length).withContext('should have 3 routerLinks').toBe(3); expect(routerLinks[0].href).toBe('/dashboard'); expect(routerLinks[1].href).toBe('/heroes'); expect(routerLinks[2].href).toBe('/about'); }); it('can click Heroes link in ",
    "id": "component-testing-scenarios-*-angular-388"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": "template', fakeAsync(() => { const heroesLinkDe = linkDes[1]; // heroes link DebugElement TestBed.inject(Router).resetConfig([{path: '**', children: []}]); heroesLinkDe.triggerEventHandler('click', {button: 0}); tick(); fixture.detectChanges(); expect(TestBed.inject(Router).url).toBe('/heroes'); }));} The Angular compiler creates the BannerStubComponent for the <app-banner> element and applies the RouterLink to the anchors with the routerLink attribute, but it ignores the <app-welcome> and <rout",
    "id": "component-testing-scenarios-*-angular-389"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": "er-outlet> tags. By.directive and injected directives A little more setup triggers the initial data binding and gets references to the navigation links: app/app.component.spec.ts (test setup) import {Component, DebugElement, NO_ERRORS_SCHEMA} from '@angular/core';import {ComponentFixture, fakeAsync, TestBed, tick, waitForAsync} from '@angular/core/testing';import {By} from '@angular/platform-browser';import {provideRouter, Router, RouterLink} from '@angular/router';import {AppComponent} from './",
    "id": "component-testing-scenarios-*-angular-390"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": "app.component';import {appConfig} from './app.config';import {UserService} from './model';@Component({selector: 'app-banner', template: ''})class BannerStubComponent {}@Component({selector: 'router-outlet', template: ''})class RouterOutletStubComponent {}@Component({selector: 'app-welcome', template: ''})class WelcomeStubComponent {}let comp: AppComponent;let fixture: ComponentFixture<AppComponent>;describe('AppComponent & TestModule', () => { beforeEach(waitForAsync(() => { TestBed.configureTes",
    "id": "component-testing-scenarios-*-angular-391"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": "tingModule( Object.assign({}, appConfig, { imports: [ AppComponent, BannerStubComponent, RouterLink, RouterOutletStubComponent, WelcomeStubComponent, ], providers: [provideRouter([]), UserService], }), ) .then(() => { fixture = TestBed.createComponent(AppComponent); comp = fixture.componentInstance; }); })); tests();});//////// Testing w/ NO_ERRORS_SCHEMA //////describe('AppComponent & NO_ERRORS_SCHEMA', () => { beforeEach(waitForAsync(() => { TestBed.configureTestingModule( Object.assign({}, ap",
    "id": "component-testing-scenarios-*-angular-392"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": "pConfig, { imports: [ AppComponent, BannerStubComponent, RouterLink, ], providers: [provideRouter([]), UserService], schemas: [NO_ERRORS_SCHEMA], }), ) .then(() => { fixture = TestBed.createComponent(AppComponent); comp = fixture.componentInstance; }); })); tests();});function tests() { let routerLinks: RouterLink[]; let linkDes: DebugElement[]; beforeEach(() => { fixture.detectChanges(); // trigger initial data binding // find DebugElements with an attached RouterLinkStubDirective linkDes = fix",
    "id": "component-testing-scenarios-*-angular-393"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": "ture.debugElement.queryAll(By.directive(RouterLink)); // get attached link directive instances // using each DebugElement's injector routerLinks = linkDes.map((de) => de.injector.get(RouterLink)); }); it('can instantiate the component', () => { expect(comp).not.toBeNull(); }); it('can get RouterLinks from template', () => { expect(routerLinks.length).withContext('should have 3 routerLinks').toBe(3); expect(routerLinks[0].href).toBe('/dashboard'); expect(routerLinks[1].href).toBe('/heroes'); expe",
    "id": "component-testing-scenarios-*-angular-394"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": "ct(routerLinks[2].href).toBe('/about'); }); it('can click Heroes link in template', fakeAsync(() => { const heroesLinkDe = linkDes[1]; // heroes link DebugElement TestBed.inject(Router).resetConfig([{path: '**', children: []}]); heroesLinkDe.triggerEventHandler('click', {button: 0}); tick(); fixture.detectChanges(); expect(TestBed.inject(Router).url).toBe('/heroes'); }));} Three points of special interest: Locate the anchor elements with an attached directive using By.directive The query returns",
    "id": "component-testing-scenarios-*-angular-395"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": " DebugElement wrappers around the matching elements Each DebugElement exposes a dependency injector with the specific instance of the directive attached to that element The AppComponent links to validate are as follows: app/app.component.html (navigation links) <app-banner></app-banner><app-welcome></app-welcome><nav> <a routerLink=\"/dashboard\">Dashboard</a> <a routerLink=\"/heroes\">Heroes</a> <a routerLink=\"/about\">About</a></nav><router-outlet></router-outlet> Here are some tests that confirm t",
    "id": "component-testing-scenarios-*-angular-396"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": "hose links are wired to the routerLink directives as expected: app/app.component.spec.ts (selected tests) import {Component, DebugElement, NO_ERRORS_SCHEMA} from '@angular/core';import {ComponentFixture, fakeAsync, TestBed, tick, waitForAsync} from '@angular/core/testing';import {By} from '@angular/platform-browser';import {provideRouter, Router, RouterLink} from '@angular/router';import {AppComponent} from './app.component';import {appConfig} from './app.config';import {UserService} from './mod",
    "id": "component-testing-scenarios-*-angular-397"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": "el';@Component({selector: 'app-banner', template: ''})class BannerStubComponent {}@Component({selector: 'router-outlet', template: ''})class RouterOutletStubComponent {}@Component({selector: 'app-welcome', template: ''})class WelcomeStubComponent {}let comp: AppComponent;let fixture: ComponentFixture<AppComponent>;describe('AppComponent & TestModule', () => { beforeEach(waitForAsync(() => { TestBed.configureTestingModule( Object.assign({}, appConfig, { imports: [ AppComponent, BannerStubComponen",
    "id": "component-testing-scenarios-*-angular-398"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": "t, RouterLink, RouterOutletStubComponent, WelcomeStubComponent, ], providers: [provideRouter([]), UserService], }), ) .then(() => { fixture = TestBed.createComponent(AppComponent); comp = fixture.componentInstance; }); })); tests();});//////// Testing w/ NO_ERRORS_SCHEMA //////describe('AppComponent & NO_ERRORS_SCHEMA', () => { beforeEach(waitForAsync(() => { TestBed.configureTestingModule( Object.assign({}, appConfig, { imports: [ AppComponent, BannerStubComponent, RouterLink, ], providers: [pr",
    "id": "component-testing-scenarios-*-angular-399"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": "ovideRouter([]), UserService], schemas: [NO_ERRORS_SCHEMA], }), ) .then(() => { fixture = TestBed.createComponent(AppComponent); comp = fixture.componentInstance; }); })); tests();});function tests() { let routerLinks: RouterLink[]; let linkDes: DebugElement[]; beforeEach(() => { fixture.detectChanges(); // trigger initial data binding // find DebugElements with an attached RouterLinkStubDirective linkDes = fixture.debugElement.queryAll(By.directive(RouterLink)); // get attached link directive i",
    "id": "component-testing-scenarios-*-angular-400"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": "nstances // using each DebugElement's injector routerLinks = linkDes.map((de) => de.injector.get(RouterLink)); }); it('can instantiate the component', () => { expect(comp).not.toBeNull(); }); it('can get RouterLinks from template', () => { expect(routerLinks.length).withContext('should have 3 routerLinks').toBe(3); expect(routerLinks[0].href).toBe('/dashboard'); expect(routerLinks[1].href).toBe('/heroes'); expect(routerLinks[2].href).toBe('/about'); }); it('can click Heroes link in template', fa",
    "id": "component-testing-scenarios-*-angular-401"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": "keAsync(() => { const heroesLinkDe = linkDes[1]; // heroes link DebugElement TestBed.inject(Router).resetConfig([{path: '**', children: []}]); heroesLinkDe.triggerEventHandler('click', {button: 0}); tick(); fixture.detectChanges(); expect(TestBed.inject(Router).url).toBe('/heroes'); }));} Use a page object The HeroDetailComponent is a simple view with a title, two hero fields, and two buttons. But there's plenty of template complexity even in this simple form. app/hero/hero-detail.component.html",
    "id": "component-testing-scenarios-*-angular-402"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": " @if (hero) { <div> <h2> <span>{{ hero.name | titlecase }}</span> Details </h2> <div><span>id: </span>{{ hero.id }}</div> <div> <label for=\"name\">name: </label> <input id=\"name\" [(ngModel)]=\"hero.name\" placeholder=\"name\" /> </div> <button type=\"button\" (click)=\"save()\">Save</button> <button type=\"button\" (click)=\"cancel()\">Cancel</button> </div>} Tests that exercise the component need … To wait until a hero arrives before elements appear in the DOM A reference to the title text A reference to th",
    "id": "component-testing-scenarios-*-angular-403"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": "e name input box to inspect and set it References to the two buttons so they can click them Even a small form such as this one can produce a mess of tortured conditional setup and CSS element selection. Tame the complexity with a Page class that handles access to component properties and encapsulates the logic that sets them. Here is such a Page class for the hero-detail.component.spec.ts app/hero/hero-detail.component.spec.ts (Page) import {HttpClient, HttpHandler, provideHttpClient} from '@ang",
    "id": "component-testing-scenarios-*-angular-404"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": "ular/common/http';import {HttpTestingController, provideHttpClientTesting} from '@angular/common/http/testing';import {fakeAsync, TestBed, tick} from '@angular/core/testing';import {provideRouter, Router} from '@angular/router';import {RouterTestingHarness} from '@angular/router/testing';import {asyncData, click} from '../../testing';import {Hero} from '../model/hero';import {sharedImports} from '../shared/shared';import {HeroDetailComponent} from './hero-detail.component';import {HeroDetailServ",
    "id": "component-testing-scenarios-*-angular-405"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": "ice} from './hero-detail.service';import {HeroListComponent} from './hero-list.component';////// Testing Vars //////let component: HeroDetailComponent;let harness: RouterTestingHarness;let page: Page;////// Tests //////describe('HeroDetailComponent', () => { describe('with HeroModule setup', heroModuleSetup); describe('when override its provided HeroDetailService', overrideSetup); describe('with FormsModule setup', formsModuleSetup); describe('with SharedModule setup', sharedModuleSetup);});////",
    "id": "component-testing-scenarios-*-angular-406"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": "///////////////const testHero = getTestHeroes()[0];function overrideSetup() { class HeroDetailServiceSpy { testHero: Hero = {...testHero}; /* emit cloned test hero */ getHero = jasmine .createSpy('getHero') .and.callFake(() => asyncData(Object.assign({}, this.testHero))); /* emit clone of test hero, with changes merged in */ saveHero = jasmine .createSpy('saveHero') .and.callFake((hero: Hero) => asyncData(Object.assign(this.testHero, hero))); } beforeEach(async () => { await TestBed.configureTes",
    "id": "component-testing-scenarios-*-angular-407"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": "tingModule( Object.assign({}, appConfig, { imports: [HeroDetailComponent, HeroListComponent], providers: [ provideRouter([ {path: 'heroes', component: HeroListComponent}, {path: 'heroes/:id', component: HeroDetailComponent}, ]), HttpClient, HttpHandler, // HeroDetailService at this level is IRRELEVANT! {provide: HeroDetailService, useValue: {}}, ], }), ) .overrideComponent(HeroDetailComponent, { set: {providers: [{provide: HeroDetailService, useClass: HeroDetailServiceSpy}]}, }); }); let hdsSpy:",
    "id": "component-testing-scenarios-*-angular-408"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": " HeroDetailServiceSpy; beforeEach(async () => { harness = await RouterTestingHarness.create(); component = await harness.navigateByUrl(`/heroes/${testHero.id}`, HeroDetailComponent); page = new Page(); // get the component's injected HeroDetailServiceSpy hdsSpy = harness.routeDebugElement!.injector.get(HeroDetailService) as any; harness.detectChanges(); }); it('should have called `getHero`', () => { expect(hdsSpy.getHero.calls.count()) .withContext('getHero called once') .toBe(1, 'getHero called",
    "id": "component-testing-scenarios-*-angular-409"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": " once'); }); it(\"should display stub hero's name\", () => { expect(page.nameDisplay.textContent).toBe(hdsSpy.testHero.name); }); it('should save stub hero change', fakeAsync(() => { const origName = hdsSpy.testHero.name; const newName = 'New Name'; page.nameInput.value = newName; page.nameInput.dispatchEvent(new Event('input')); // tell Angular expect(component.hero.name).withContext('component hero has new name').toBe(newName); expect(hdsSpy.testHero.name).withContext('service hero unchanged bef",
    "id": "component-testing-scenarios-*-angular-410"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": "ore save').toBe(origName); click(page.saveBtn); expect(hdsSpy.saveHero.calls.count()).withContext('saveHero called once').toBe(1); tick(); // wait for async save to complete expect(hdsSpy.testHero.name).withContext('service hero has new name after save').toBe(newName); expect(TestBed.inject(Router).url).toEqual('/heroes'); }));}////////////////////import {getTestHeroes} from '../model/testing/test-hero.service';const firstHero = getTestHeroes()[0];function heroModuleSetup() { beforeEach(async ()",
    "id": "component-testing-scenarios-*-angular-411"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": " => { await TestBed.configureTestingModule( Object.assign({}, appConfig, { imports: [HeroDetailComponent, HeroListComponent], providers: [ provideRouter([ {path: 'heroes/:id', component: HeroDetailComponent}, {path: 'heroes', component: HeroListComponent}, ]), provideHttpClient(), provideHttpClientTesting(), ], }), ); }); describe('when navigate to existing hero', () => { let expectedHero: Hero; beforeEach(async () => { expectedHero = firstHero; await createComponent(expectedHero.id); }); it(\"sh",
    "id": "component-testing-scenarios-*-angular-412"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": "ould display that hero's name\", () => { expect(page.nameDisplay.textContent).toBe(expectedHero.name); }); it('should navigate when click cancel', () => { click(page.cancelBtn); expect(TestBed.inject(Router).url).toEqual(`/heroes/${expectedHero.id}`); }); it('should save when click save but not navigate immediately', () => { click(page.saveBtn); expect(TestBed.inject(HttpTestingController).expectOne({method: 'PUT', url: 'api/heroes'})); expect(TestBed.inject(Router).url).toEqual('/heroes/41'); })",
    "id": "component-testing-scenarios-*-angular-413"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": "; it('should navigate when click save and save resolves', fakeAsync(() => { click(page.saveBtn); tick(); // wait for async save to complete expect(TestBed.inject(Router).url).toEqual('/heroes/41'); })); it('should convert hero name to Title Case', async () => { harness.fixture.autoDetectChanges(); // get the name's input and display elements from the DOM const hostElement: HTMLElement = harness.routeNativeElement!; const nameInput: HTMLInputElement = hostElement.querySelector('input')!; const na",
    "id": "component-testing-scenarios-*-angular-414"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": "meDisplay: HTMLElement = hostElement.querySelector('span')!; // simulate user entering a new name into the input box nameInput.value = 'quick BROWN fOx'; // Dispatch a DOM event so that Angular learns of input value change. nameInput.dispatchEvent(new Event('input')); // Wait for Angular to update the display binding through the title pipe await harness.fixture.whenStable(); expect(nameDisplay.textContent).toBe('Quick Brown Fox'); }); }); describe('when navigate to non-existent hero id', () => {",
    "id": "component-testing-scenarios-*-angular-415"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": " beforeEach(async () => { await createComponent(999); }); it('should try to navigate back to hero list', () => { expect(TestBed.inject(Router).url).toEqual('/heroes'); }); });}/////////////////////import {FormsModule} from '@angular/forms';import {TitleCasePipe} from '../shared/title-case.pipe';import {appConfig} from '../app.config';function formsModuleSetup() { beforeEach(async () => { await TestBed.configureTestingModule( Object.assign({}, appConfig, { imports: [FormsModule, HeroDetailCompone",
    "id": "component-testing-scenarios-*-angular-416"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": "nt, TitleCasePipe], providers: [ provideHttpClient(), provideHttpClientTesting(), provideRouter([{path: 'heroes/:id', component: HeroDetailComponent}]), ], }), ); }); it(\"should display 1st hero's name\", async () => { const expectedHero = firstHero; await createComponent(expectedHero.id).then(() => { expect(page.nameDisplay.textContent).toBe(expectedHero.name); }); });}///////////////////////function sharedModuleSetup() { beforeEach(async () => { await TestBed.configureTestingModule( Object.assi",
    "id": "component-testing-scenarios-*-angular-417"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": "gn({}, appConfig, { imports: [HeroDetailComponent, sharedImports], providers: [ provideRouter([{path: 'heroes/:id', component: HeroDetailComponent}]), provideHttpClient(), provideHttpClientTesting(), ], }), ); }); it(\"should display 1st hero's name\", async () => { const expectedHero = firstHero; await createComponent(expectedHero.id).then(() => { expect(page.nameDisplay.textContent).toBe(expectedHero.name); }); });}/////////// Helpers //////** Create the HeroDetailComponent, initialize it, set t",
    "id": "component-testing-scenarios-*-angular-418"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": "est variables */async function createComponent(id: number) { harness = await RouterTestingHarness.create(); component = await harness.navigateByUrl(`/heroes/${id}`, HeroDetailComponent); page = new Page(); const request = TestBed.inject(HttpTestingController).expectOne(`api/heroes/?id=${id}`); const hero = getTestHeroes().find((h) => h.id === Number(id)); request.flush(hero ? [hero] : []); harness.detectChanges();}class Page { // getter properties wait to query the DOM until called. get buttons(",
    "id": "component-testing-scenarios-*-angular-419"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": ") { return this.queryAll<HTMLButtonElement>('button'); } get saveBtn() { return this.buttons[0]; } get cancelBtn() { return this.buttons[1]; } get nameDisplay() { return this.query<HTMLElement>('span'); } get nameInput() { return this.query<HTMLInputElement>('input'); } //// query helpers //// private query<T>(selector: string): T { return harness.routeNativeElement!.querySelector(selector)! as T; } private queryAll<T>(selector: string): T[] { return harness.routeNativeElement!.querySelectorAll(",
    "id": "component-testing-scenarios-*-angular-420"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": "selector) as any as T[]; }} Now the important hooks for component manipulation and inspection are neatly organized and accessible from an instance of Page. A createComponent method creates a page object and fills in the blanks once the hero arrives. app/hero/hero-detail.component.spec.ts (createComponent) import {HttpClient, HttpHandler, provideHttpClient} from '@angular/common/http';import {HttpTestingController, provideHttpClientTesting} from '@angular/common/http/testing';import {fakeAsync, T",
    "id": "component-testing-scenarios-*-angular-421"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": "estBed, tick} from '@angular/core/testing';import {provideRouter, Router} from '@angular/router';import {RouterTestingHarness} from '@angular/router/testing';import {asyncData, click} from '../../testing';import {Hero} from '../model/hero';import {sharedImports} from '../shared/shared';import {HeroDetailComponent} from './hero-detail.component';import {HeroDetailService} from './hero-detail.service';import {HeroListComponent} from './hero-list.component';////// Testing Vars //////let component: ",
    "id": "component-testing-scenarios-*-angular-422"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": "HeroDetailComponent;let harness: RouterTestingHarness;let page: Page;////// Tests //////describe('HeroDetailComponent', () => { describe('with HeroModule setup', heroModuleSetup); describe('when override its provided HeroDetailService', overrideSetup); describe('with FormsModule setup', formsModuleSetup); describe('with SharedModule setup', sharedModuleSetup);});///////////////////const testHero = getTestHeroes()[0];function overrideSetup() { class HeroDetailServiceSpy { testHero: Hero = {...tes",
    "id": "component-testing-scenarios-*-angular-423"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": "tHero}; /* emit cloned test hero */ getHero = jasmine .createSpy('getHero') .and.callFake(() => asyncData(Object.assign({}, this.testHero))); /* emit clone of test hero, with changes merged in */ saveHero = jasmine .createSpy('saveHero') .and.callFake((hero: Hero) => asyncData(Object.assign(this.testHero, hero))); } beforeEach(async () => { await TestBed.configureTestingModule( Object.assign({}, appConfig, { imports: [HeroDetailComponent, HeroListComponent], providers: [ provideRouter([ {path: '",
    "id": "component-testing-scenarios-*-angular-424"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": "heroes', component: HeroListComponent}, {path: 'heroes/:id', component: HeroDetailComponent}, ]), HttpClient, HttpHandler, // HeroDetailService at this level is IRRELEVANT! {provide: HeroDetailService, useValue: {}}, ], }), ) .overrideComponent(HeroDetailComponent, { set: {providers: [{provide: HeroDetailService, useClass: HeroDetailServiceSpy}]}, }); }); let hdsSpy: HeroDetailServiceSpy; beforeEach(async () => { harness = await RouterTestingHarness.create(); component = await harness.navigateBy",
    "id": "component-testing-scenarios-*-angular-425"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": "Url(`/heroes/${testHero.id}`, HeroDetailComponent); page = new Page(); // get the component's injected HeroDetailServiceSpy hdsSpy = harness.routeDebugElement!.injector.get(HeroDetailService) as any; harness.detectChanges(); }); it('should have called `getHero`', () => { expect(hdsSpy.getHero.calls.count()) .withContext('getHero called once') .toBe(1, 'getHero called once'); }); it(\"should display stub hero's name\", () => { expect(page.nameDisplay.textContent).toBe(hdsSpy.testHero.name); }); it(",
    "id": "component-testing-scenarios-*-angular-426"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": "'should save stub hero change', fakeAsync(() => { const origName = hdsSpy.testHero.name; const newName = 'New Name'; page.nameInput.value = newName; page.nameInput.dispatchEvent(new Event('input')); // tell Angular expect(component.hero.name).withContext('component hero has new name').toBe(newName); expect(hdsSpy.testHero.name).withContext('service hero unchanged before save').toBe(origName); click(page.saveBtn); expect(hdsSpy.saveHero.calls.count()).withContext('saveHero called once').toBe(1); ",
    "id": "component-testing-scenarios-*-angular-427"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": "tick(); // wait for async save to complete expect(hdsSpy.testHero.name).withContext('service hero has new name after save').toBe(newName); expect(TestBed.inject(Router).url).toEqual('/heroes'); }));}////////////////////import {getTestHeroes} from '../model/testing/test-hero.service';const firstHero = getTestHeroes()[0];function heroModuleSetup() { beforeEach(async () => { await TestBed.configureTestingModule( Object.assign({}, appConfig, { imports: [HeroDetailComponent, HeroListComponent], provi",
    "id": "component-testing-scenarios-*-angular-428"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": "ders: [ provideRouter([ {path: 'heroes/:id', component: HeroDetailComponent}, {path: 'heroes', component: HeroListComponent}, ]), provideHttpClient(), provideHttpClientTesting(), ], }), ); }); describe('when navigate to existing hero', () => { let expectedHero: Hero; beforeEach(async () => { expectedHero = firstHero; await createComponent(expectedHero.id); }); it(\"should display that hero's name\", () => { expect(page.nameDisplay.textContent).toBe(expectedHero.name); }); it('should navigate when ",
    "id": "component-testing-scenarios-*-angular-429"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": "click cancel', () => { click(page.cancelBtn); expect(TestBed.inject(Router).url).toEqual(`/heroes/${expectedHero.id}`); }); it('should save when click save but not navigate immediately', () => { click(page.saveBtn); expect(TestBed.inject(HttpTestingController).expectOne({method: 'PUT', url: 'api/heroes'})); expect(TestBed.inject(Router).url).toEqual('/heroes/41'); }); it('should navigate when click save and save resolves', fakeAsync(() => { click(page.saveBtn); tick(); // wait for async save to ",
    "id": "component-testing-scenarios-*-angular-430"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": "complete expect(TestBed.inject(Router).url).toEqual('/heroes/41'); })); it('should convert hero name to Title Case', async () => { harness.fixture.autoDetectChanges(); // get the name's input and display elements from the DOM const hostElement: HTMLElement = harness.routeNativeElement!; const nameInput: HTMLInputElement = hostElement.querySelector('input')!; const nameDisplay: HTMLElement = hostElement.querySelector('span')!; // simulate user entering a new name into the input box nameInput.valu",
    "id": "component-testing-scenarios-*-angular-431"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": "e = 'quick BROWN fOx'; // Dispatch a DOM event so that Angular learns of input value change. nameInput.dispatchEvent(new Event('input')); // Wait for Angular to update the display binding through the title pipe await harness.fixture.whenStable(); expect(nameDisplay.textContent).toBe('Quick Brown Fox'); }); }); describe('when navigate to non-existent hero id', () => { beforeEach(async () => { await createComponent(999); }); it('should try to navigate back to hero list', () => { expect(TestBed.inj",
    "id": "component-testing-scenarios-*-angular-432"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": "ect(Router).url).toEqual('/heroes'); }); });}/////////////////////import {FormsModule} from '@angular/forms';import {TitleCasePipe} from '../shared/title-case.pipe';import {appConfig} from '../app.config';function formsModuleSetup() { beforeEach(async () => { await TestBed.configureTestingModule( Object.assign({}, appConfig, { imports: [FormsModule, HeroDetailComponent, TitleCasePipe], providers: [ provideHttpClient(), provideHttpClientTesting(), provideRouter([{path: 'heroes/:id', component: He",
    "id": "component-testing-scenarios-*-angular-433"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": "roDetailComponent}]), ], }), ); }); it(\"should display 1st hero's name\", async () => { const expectedHero = firstHero; await createComponent(expectedHero.id).then(() => { expect(page.nameDisplay.textContent).toBe(expectedHero.name); }); });}///////////////////////function sharedModuleSetup() { beforeEach(async () => { await TestBed.configureTestingModule( Object.assign({}, appConfig, { imports: [HeroDetailComponent, sharedImports], providers: [ provideRouter([{path: 'heroes/:id', component: Hero",
    "id": "component-testing-scenarios-*-angular-434"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": "DetailComponent}]), provideHttpClient(), provideHttpClientTesting(), ], }), ); }); it(\"should display 1st hero's name\", async () => { const expectedHero = firstHero; await createComponent(expectedHero.id).then(() => { expect(page.nameDisplay.textContent).toBe(expectedHero.name); }); });}/////////// Helpers //////** Create the HeroDetailComponent, initialize it, set test variables */async function createComponent(id: number) { harness = await RouterTestingHarness.create(); component = await harne",
    "id": "component-testing-scenarios-*-angular-435"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": "ss.navigateByUrl(`/heroes/${id}`, HeroDetailComponent); page = new Page(); const request = TestBed.inject(HttpTestingController).expectOne(`api/heroes/?id=${id}`); const hero = getTestHeroes().find((h) => h.id === Number(id)); request.flush(hero ? [hero] : []); harness.detectChanges();}class Page { // getter properties wait to query the DOM until called. get buttons() { return this.queryAll<HTMLButtonElement>('button'); } get saveBtn() { return this.buttons[0]; } get cancelBtn() { return this.bu",
    "id": "component-testing-scenarios-*-angular-436"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": "ttons[1]; } get nameDisplay() { return this.query<HTMLElement>('span'); } get nameInput() { return this.query<HTMLInputElement>('input'); } //// query helpers //// private query<T>(selector: string): T { return harness.routeNativeElement!.querySelector(selector)! as T; } private queryAll<T>(selector: string): T[] { return harness.routeNativeElement!.querySelectorAll(selector) as any as T[]; }} Here are a few more HeroDetailComponent tests to reinforce the point. app/hero/hero-detail.component.sp",
    "id": "component-testing-scenarios-*-angular-437"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": "ec.ts (selected tests) import {HttpClient, HttpHandler, provideHttpClient} from '@angular/common/http';import {HttpTestingController, provideHttpClientTesting} from '@angular/common/http/testing';import {fakeAsync, TestBed, tick} from '@angular/core/testing';import {provideRouter, Router} from '@angular/router';import {RouterTestingHarness} from '@angular/router/testing';import {asyncData, click} from '../../testing';import {Hero} from '../model/hero';import {sharedImports} from '../shared/share",
    "id": "component-testing-scenarios-*-angular-438"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": "d';import {HeroDetailComponent} from './hero-detail.component';import {HeroDetailService} from './hero-detail.service';import {HeroListComponent} from './hero-list.component';////// Testing Vars //////let component: HeroDetailComponent;let harness: RouterTestingHarness;let page: Page;////// Tests //////describe('HeroDetailComponent', () => { describe('with HeroModule setup', heroModuleSetup); describe('when override its provided HeroDetailService', overrideSetup); describe('with FormsModule setu",
    "id": "component-testing-scenarios-*-angular-439"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": "p', formsModuleSetup); describe('with SharedModule setup', sharedModuleSetup);});///////////////////const testHero = getTestHeroes()[0];function overrideSetup() { class HeroDetailServiceSpy { testHero: Hero = {...testHero}; /* emit cloned test hero */ getHero = jasmine .createSpy('getHero') .and.callFake(() => asyncData(Object.assign({}, this.testHero))); /* emit clone of test hero, with changes merged in */ saveHero = jasmine .createSpy('saveHero') .and.callFake((hero: Hero) => asyncData(Object",
    "id": "component-testing-scenarios-*-angular-440"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": ".assign(this.testHero, hero))); } beforeEach(async () => { await TestBed.configureTestingModule( Object.assign({}, appConfig, { imports: [HeroDetailComponent, HeroListComponent], providers: [ provideRouter([ {path: 'heroes', component: HeroListComponent}, {path: 'heroes/:id', component: HeroDetailComponent}, ]), HttpClient, HttpHandler, // HeroDetailService at this level is IRRELEVANT! {provide: HeroDetailService, useValue: {}}, ], }), ) .overrideComponent(HeroDetailComponent, { set: {providers:",
    "id": "component-testing-scenarios-*-angular-441"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": " [{provide: HeroDetailService, useClass: HeroDetailServiceSpy}]}, }); }); let hdsSpy: HeroDetailServiceSpy; beforeEach(async () => { harness = await RouterTestingHarness.create(); component = await harness.navigateByUrl(`/heroes/${testHero.id}`, HeroDetailComponent); page = new Page(); // get the component's injected HeroDetailServiceSpy hdsSpy = harness.routeDebugElement!.injector.get(HeroDetailService) as any; harness.detectChanges(); }); it('should have called `getHero`', () => { expect(hdsSp",
    "id": "component-testing-scenarios-*-angular-442"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": "y.getHero.calls.count()) .withContext('getHero called once') .toBe(1, 'getHero called once'); }); it(\"should display stub hero's name\", () => { expect(page.nameDisplay.textContent).toBe(hdsSpy.testHero.name); }); it('should save stub hero change', fakeAsync(() => { const origName = hdsSpy.testHero.name; const newName = 'New Name'; page.nameInput.value = newName; page.nameInput.dispatchEvent(new Event('input')); // tell Angular expect(component.hero.name).withContext('component hero has new name'",
    "id": "component-testing-scenarios-*-angular-443"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": ").toBe(newName); expect(hdsSpy.testHero.name).withContext('service hero unchanged before save').toBe(origName); click(page.saveBtn); expect(hdsSpy.saveHero.calls.count()).withContext('saveHero called once').toBe(1); tick(); // wait for async save to complete expect(hdsSpy.testHero.name).withContext('service hero has new name after save').toBe(newName); expect(TestBed.inject(Router).url).toEqual('/heroes'); }));}////////////////////import {getTestHeroes} from '../model/testing/test-hero.service';",
    "id": "component-testing-scenarios-*-angular-444"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": "const firstHero = getTestHeroes()[0];function heroModuleSetup() { beforeEach(async () => { await TestBed.configureTestingModule( Object.assign({}, appConfig, { imports: [HeroDetailComponent, HeroListComponent], providers: [ provideRouter([ {path: 'heroes/:id', component: HeroDetailComponent}, {path: 'heroes', component: HeroListComponent}, ]), provideHttpClient(), provideHttpClientTesting(), ], }), ); }); describe('when navigate to existing hero', () => { let expectedHero: Hero; beforeEach(async",
    "id": "component-testing-scenarios-*-angular-445"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": " () => { expectedHero = firstHero; await createComponent(expectedHero.id); }); it(\"should display that hero's name\", () => { expect(page.nameDisplay.textContent).toBe(expectedHero.name); }); it('should navigate when click cancel', () => { click(page.cancelBtn); expect(TestBed.inject(Router).url).toEqual(`/heroes/${expectedHero.id}`); }); it('should save when click save but not navigate immediately', () => { click(page.saveBtn); expect(TestBed.inject(HttpTestingController).expectOne({method: 'PUT",
    "id": "component-testing-scenarios-*-angular-446"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": "', url: 'api/heroes'})); expect(TestBed.inject(Router).url).toEqual('/heroes/41'); }); it('should navigate when click save and save resolves', fakeAsync(() => { click(page.saveBtn); tick(); // wait for async save to complete expect(TestBed.inject(Router).url).toEqual('/heroes/41'); })); it('should convert hero name to Title Case', async () => { harness.fixture.autoDetectChanges(); // get the name's input and display elements from the DOM const hostElement: HTMLElement = harness.routeNativeElemen",
    "id": "component-testing-scenarios-*-angular-447"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": "t!; const nameInput: HTMLInputElement = hostElement.querySelector('input')!; const nameDisplay: HTMLElement = hostElement.querySelector('span')!; // simulate user entering a new name into the input box nameInput.value = 'quick BROWN fOx'; // Dispatch a DOM event so that Angular learns of input value change. nameInput.dispatchEvent(new Event('input')); // Wait for Angular to update the display binding through the title pipe await harness.fixture.whenStable(); expect(nameDisplay.textContent).toBe(",
    "id": "component-testing-scenarios-*-angular-448"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": "'Quick Brown Fox'); }); }); describe('when navigate to non-existent hero id', () => { beforeEach(async () => { await createComponent(999); }); it('should try to navigate back to hero list', () => { expect(TestBed.inject(Router).url).toEqual('/heroes'); }); });}/////////////////////import {FormsModule} from '@angular/forms';import {TitleCasePipe} from '../shared/title-case.pipe';import {appConfig} from '../app.config';function formsModuleSetup() { beforeEach(async () => { await TestBed.configureT",
    "id": "component-testing-scenarios-*-angular-449"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": "estingModule( Object.assign({}, appConfig, { imports: [FormsModule, HeroDetailComponent, TitleCasePipe], providers: [ provideHttpClient(), provideHttpClientTesting(), provideRouter([{path: 'heroes/:id', component: HeroDetailComponent}]), ], }), ); }); it(\"should display 1st hero's name\", async () => { const expectedHero = firstHero; await createComponent(expectedHero.id).then(() => { expect(page.nameDisplay.textContent).toBe(expectedHero.name); }); });}///////////////////////function sharedModul",
    "id": "component-testing-scenarios-*-angular-450"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": "eSetup() { beforeEach(async () => { await TestBed.configureTestingModule( Object.assign({}, appConfig, { imports: [HeroDetailComponent, sharedImports], providers: [ provideRouter([{path: 'heroes/:id', component: HeroDetailComponent}]), provideHttpClient(), provideHttpClientTesting(), ], }), ); }); it(\"should display 1st hero's name\", async () => { const expectedHero = firstHero; await createComponent(expectedHero.id).then(() => { expect(page.nameDisplay.textContent).toBe(expectedHero.name); }); ",
    "id": "component-testing-scenarios-*-angular-451"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": "});}/////////// Helpers //////** Create the HeroDetailComponent, initialize it, set test variables */async function createComponent(id: number) { harness = await RouterTestingHarness.create(); component = await harness.navigateByUrl(`/heroes/${id}`, HeroDetailComponent); page = new Page(); const request = TestBed.inject(HttpTestingController).expectOne(`api/heroes/?id=${id}`); const hero = getTestHeroes().find((h) => h.id === Number(id)); request.flush(hero ? [hero] : []); harness.detectChanges(",
    "id": "component-testing-scenarios-*-angular-452"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": ");}class Page { // getter properties wait to query the DOM until called. get buttons() { return this.queryAll<HTMLButtonElement>('button'); } get saveBtn() { return this.buttons[0]; } get cancelBtn() { return this.buttons[1]; } get nameDisplay() { return this.query<HTMLElement>('span'); } get nameInput() { return this.query<HTMLInputElement>('input'); } //// query helpers //// private query<T>(selector: string): T { return harness.routeNativeElement!.querySelector(selector)! as T; } private quer",
    "id": "component-testing-scenarios-*-angular-453"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": "yAll<T>(selector: string): T[] { return harness.routeNativeElement!.querySelectorAll(selector) as any as T[]; }} Calling compileComponents() HELPFUL: Ignore this section if you only run tests with the CLI ng test command because the CLI compiles the application before running the tests. If you run tests in a non-CLI environment, the tests might fail with a message like this one: Error: This test module uses the component BannerComponentwhich is using a \"templateUrl\" or \"styleUrls\", but they were",
    "id": "component-testing-scenarios-*-angular-454"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": " never compiled.Please call \"TestBed.compileComponents\" before your test. The root of the problem is at least one of the components involved in the test specifies an external template or CSS file as the following version of the BannerComponent does. app/banner/banner-external.component.ts (external template & css) import {Component} from '@angular/core';@Component({ selector: 'app-banner', templateUrl: './banner-external.component.html', styleUrls: ['./banner-external.component.css'],})export cl",
    "id": "component-testing-scenarios-*-angular-455"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": "ass BannerComponent { title = 'Test Tour of Heroes';} The test fails when the TestBed tries to create the component. app/banner/banner-external.component.spec.ts (setup that fails) import {ComponentFixture, TestBed} from '@angular/core/testing';import {BannerComponent} from './banner-external.component';describe('BannerComponent (external files)', () => { let component: BannerComponent; let fixture: ComponentFixture<BannerComponent>; let h1: HTMLElement; describe('setup that may fail', () => { b",
    "id": "component-testing-scenarios-*-angular-456"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": "eforeEach(async () => { await TestBed.configureTestingModule({ imports: [BannerComponent], }); // missing call to compileComponents() fixture = TestBed.createComponent(BannerComponent); }); it('should create', () => { expect(fixture.componentInstance).toBeDefined(); }); }); describe('Two beforeEach', () => { beforeEach(async () => { await TestBed.configureTestingModule({ imports: [BannerComponent], }); // compile template and css }); // synchronous beforeEach beforeEach(() => { fixture = TestBed",
    "id": "component-testing-scenarios-*-angular-457"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": ".createComponent(BannerComponent); component = fixture.componentInstance; // BannerComponent test instance h1 = fixture.nativeElement.querySelector('h1'); }); tests(); }); describe('One beforeEach', () => { beforeEach(async () => { await TestBed.configureTestingModule({ imports: [BannerComponent], }); fixture = TestBed.createComponent(BannerComponent); component = fixture.componentInstance; h1 = fixture.nativeElement.querySelector('h1'); }); tests(); }); function tests() { it('no title in the DO",
    "id": "component-testing-scenarios-*-angular-458"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": "M until manually call `detectChanges`', () => { expect(h1.textContent).toEqual(''); }); it('should display original title', () => { fixture.detectChanges(); expect(h1.textContent).toContain(component.title); }); it('should display a different test title', () => { component.title = 'Test Title'; fixture.detectChanges(); expect(h1.textContent).toContain('Test Title'); }); }}); Recall that the application hasn't been compiled. So when you call createComponent(), the TestBed compiles implicitly. Tha",
    "id": "component-testing-scenarios-*-angular-459"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": "t's not a problem when the source code is in memory. But the BannerComponent requires external files that the compiler must read from the file system, an inherently asynchronous operation. If the TestBed were allowed to continue, the tests would run and fail mysteriously before the compiler could finish. The preemptive error message tells you to compile explicitly with compileComponents(). compileComponents() is async You must call compileComponents() within an asynchronous test function. CRITIC",
    "id": "component-testing-scenarios-*-angular-460"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": "AL: If you neglect to make the test function async (for example, forget to use waitForAsync() as described), you'll see this error message Error: ViewDestroyedError: Attempt to use a destroyed view A typical approach is to divide the setup logic into two separate beforeEach() functions: Functions Details Asynchronous beforeEach() Compiles the components Synchronous beforeEach() Performs the remaining setup The async beforeEach Write the first async beforeEach like this. app/banner/banner-externa",
    "id": "component-testing-scenarios-*-angular-461"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": "l.component.spec.ts (async beforeEach) import {ComponentFixture, TestBed} from '@angular/core/testing';import {BannerComponent} from './banner-external.component';describe('BannerComponent (external files)', () => { let component: BannerComponent; let fixture: ComponentFixture<BannerComponent>; let h1: HTMLElement; describe('setup that may fail', () => { beforeEach(async () => { await TestBed.configureTestingModule({ imports: [BannerComponent], }); // missing call to compileComponents() fixture ",
    "id": "component-testing-scenarios-*-angular-462"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": "= TestBed.createComponent(BannerComponent); }); it('should create', () => { expect(fixture.componentInstance).toBeDefined(); }); }); describe('Two beforeEach', () => { beforeEach(async () => { await TestBed.configureTestingModule({ imports: [BannerComponent], }); // compile template and css }); // synchronous beforeEach beforeEach(() => { fixture = TestBed.createComponent(BannerComponent); component = fixture.componentInstance; // BannerComponent test instance h1 = fixture.nativeElement.querySel",
    "id": "component-testing-scenarios-*-angular-463"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": "ector('h1'); }); tests(); }); describe('One beforeEach', () => { beforeEach(async () => { await TestBed.configureTestingModule({ imports: [BannerComponent], }); fixture = TestBed.createComponent(BannerComponent); component = fixture.componentInstance; h1 = fixture.nativeElement.querySelector('h1'); }); tests(); }); function tests() { it('no title in the DOM until manually call `detectChanges`', () => { expect(h1.textContent).toEqual(''); }); it('should display original title', () => { fixture.de",
    "id": "component-testing-scenarios-*-angular-464"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": "tectChanges(); expect(h1.textContent).toContain(component.title); }); it('should display a different test title', () => { component.title = 'Test Title'; fixture.detectChanges(); expect(h1.textContent).toContain('Test Title'); }); }}); The TestBed.configureTestingModule() method returns the TestBed class so you can chain calls to other TestBed static methods such as compileComponents(). In this example, the BannerComponent is the only component to compile. Other examples configure the testing mo",
    "id": "component-testing-scenarios-*-angular-465"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": "dule with multiple components and might import application modules that hold yet more components. Any of them could require external files. The TestBed.compileComponents method asynchronously compiles all components configured in the testing module. IMPORTANT: Do not re-configure the TestBed after calling compileComponents(). Calling compileComponents() closes the current TestBed instance to further configuration. You cannot call any more TestBed configuration methods, not configureTestingModule",
    "id": "component-testing-scenarios-*-angular-466"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": "() nor any of the override... methods. The TestBed throws an error if you try. Make compileComponents() the last step before calling TestBed.createComponent(). The synchronous beforeEach The second, synchronous beforeEach() contains the remaining setup steps, which include creating the component and querying for elements to inspect. app/banner/banner-external.component.spec.ts (synchronous beforeEach) import {ComponentFixture, TestBed} from '@angular/core/testing';import {BannerComponent} from '",
    "id": "component-testing-scenarios-*-angular-467"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": "./banner-external.component';describe('BannerComponent (external files)', () => { let component: BannerComponent; let fixture: ComponentFixture<BannerComponent>; let h1: HTMLElement; describe('setup that may fail', () => { beforeEach(async () => { await TestBed.configureTestingModule({ imports: [BannerComponent], }); // missing call to compileComponents() fixture = TestBed.createComponent(BannerComponent); }); it('should create', () => { expect(fixture.componentInstance).toBeDefined(); }); }); d",
    "id": "component-testing-scenarios-*-angular-468"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": "escribe('Two beforeEach', () => { beforeEach(async () => { await TestBed.configureTestingModule({ imports: [BannerComponent], }); // compile template and css }); // synchronous beforeEach beforeEach(() => { fixture = TestBed.createComponent(BannerComponent); component = fixture.componentInstance; // BannerComponent test instance h1 = fixture.nativeElement.querySelector('h1'); }); tests(); }); describe('One beforeEach', () => { beforeEach(async () => { await TestBed.configureTestingModule({ impor",
    "id": "component-testing-scenarios-*-angular-469"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": "ts: [BannerComponent], }); fixture = TestBed.createComponent(BannerComponent); component = fixture.componentInstance; h1 = fixture.nativeElement.querySelector('h1'); }); tests(); }); function tests() { it('no title in the DOM until manually call `detectChanges`', () => { expect(h1.textContent).toEqual(''); }); it('should display original title', () => { fixture.detectChanges(); expect(h1.textContent).toContain(component.title); }); it('should display a different test title', () => { component.ti",
    "id": "component-testing-scenarios-*-angular-470"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": "tle = 'Test Title'; fixture.detectChanges(); expect(h1.textContent).toContain('Test Title'); }); }}); Count on the test runner to wait for the first asynchronous beforeEach to finish before calling the second. Consolidated setup You can consolidate the two beforeEach() functions into a single, async beforeEach(). The compileComponents() method returns a promise so you can perform the synchronous setup tasks after compilation by moving the synchronous code after the await keyword, where the promi",
    "id": "component-testing-scenarios-*-angular-471"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": "se has been resolved. app/banner/banner-external.component.spec.ts (one beforeEach) import {ComponentFixture, TestBed} from '@angular/core/testing';import {BannerComponent} from './banner-external.component';describe('BannerComponent (external files)', () => { let component: BannerComponent; let fixture: ComponentFixture<BannerComponent>; let h1: HTMLElement; describe('setup that may fail', () => { beforeEach(async () => { await TestBed.configureTestingModule({ imports: [BannerComponent], }); //",
    "id": "component-testing-scenarios-*-angular-472"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": " missing call to compileComponents() fixture = TestBed.createComponent(BannerComponent); }); it('should create', () => { expect(fixture.componentInstance).toBeDefined(); }); }); describe('Two beforeEach', () => { beforeEach(async () => { await TestBed.configureTestingModule({ imports: [BannerComponent], }); // compile template and css }); // synchronous beforeEach beforeEach(() => { fixture = TestBed.createComponent(BannerComponent); component = fixture.componentInstance; // BannerComponent test",
    "id": "component-testing-scenarios-*-angular-473"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": " instance h1 = fixture.nativeElement.querySelector('h1'); }); tests(); }); describe('One beforeEach', () => { beforeEach(async () => { await TestBed.configureTestingModule({ imports: [BannerComponent], }); fixture = TestBed.createComponent(BannerComponent); component = fixture.componentInstance; h1 = fixture.nativeElement.querySelector('h1'); }); tests(); }); function tests() { it('no title in the DOM until manually call `detectChanges`', () => { expect(h1.textContent).toEqual(''); }); it('shoul",
    "id": "component-testing-scenarios-*-angular-474"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": "d display original title', () => { fixture.detectChanges(); expect(h1.textContent).toContain(component.title); }); it('should display a different test title', () => { component.title = 'Test Title'; fixture.detectChanges(); expect(h1.textContent).toContain('Test Title'); }); }}); compileComponents() is harmless There's no harm in calling compileComponents() when it's not required. The component test file generated by the CLI calls compileComponents() even though it is never required when running",
    "id": "component-testing-scenarios-*-angular-475"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": " ng test. The tests in this guide only call compileComponents when necessary. Setup with module imports Earlier component tests configured the testing module with a few declarations like this: app/dashboard/dashboard-hero.component.spec.ts (configure TestBed) import {DebugElement} from '@angular/core';import {ComponentFixture, TestBed, waitForAsync} from '@angular/core/testing';import {By} from '@angular/platform-browser';import {first} from 'rxjs/operators';import {addMatchers, click} from '../",
    "id": "component-testing-scenarios-*-angular-476"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": "../testing';import {appProviders} from '../app.config';import {Hero} from '../model/hero';import {DashboardHeroComponent} from './dashboard-hero.component';beforeEach(addMatchers);describe('DashboardHeroComponent when tested directly', () => { let comp: DashboardHeroComponent; let expectedHero: Hero; let fixture: ComponentFixture<DashboardHeroComponent>; let heroDe: DebugElement; let heroEl: HTMLElement; beforeEach(() => { TestBed.configureTestingModule({ providers: appProviders, }); }); beforeE",
    "id": "component-testing-scenarios-*-angular-477"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": "ach(async () => { fixture = TestBed.createComponent(DashboardHeroComponent); fixture.autoDetectChanges(); comp = fixture.componentInstance; // find the hero's DebugElement and element heroDe = fixture.debugElement.query(By.css('.hero')); heroEl = heroDe.nativeElement; // mock the hero supplied by the parent component expectedHero = {id: 42, name: 'Test Name'}; // simulate the parent setting the input property with that hero fixture.componentRef.setInput('hero', expectedHero); // wait for initial",
    "id": "component-testing-scenarios-*-angular-478"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": " data binding await fixture.whenStable(); }); it('should display hero name in uppercase', () => { const expectedPipedName = expectedHero.name.toUpperCase(); expect(heroEl.textContent).toContain(expectedPipedName); }); it('should raise selected event when clicked (triggerEventHandler)', () => { let selectedHero: Hero | undefined; comp.selected.subscribe((hero: Hero) => (selectedHero = hero)); heroDe.triggerEventHandler('click'); expect(selectedHero).toBe(expectedHero); }); it('should raise select",
    "id": "component-testing-scenarios-*-angular-479"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": "ed event when clicked (element.click)', () => { let selectedHero: Hero | undefined; comp.selected.subscribe((hero: Hero) => (selectedHero = hero)); heroEl.click(); expect(selectedHero).toBe(expectedHero); }); it('should raise selected event when clicked (click helper with DebugElement)', () => { let selectedHero: Hero | undefined; comp.selected.subscribe((hero: Hero) => (selectedHero = hero)); click(heroDe); // click helper with DebugElement expect(selectedHero).toBe(expectedHero); }); it('shoul",
    "id": "component-testing-scenarios-*-angular-480"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": "d raise selected event when clicked (click helper with native element)', () => { let selectedHero: Hero | undefined; comp.selected.subscribe((hero: Hero) => (selectedHero = hero)); click(heroEl); // click helper with native element expect(selectedHero).toBe(expectedHero); });});//////////////////describe('DashboardHeroComponent when inside a test host', () => { let testHost: TestHostComponent; let fixture: ComponentFixture<TestHostComponent>; let heroEl: HTMLElement; beforeEach(waitForAsync(() =",
    "id": "component-testing-scenarios-*-angular-481"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": "> { TestBed.configureTestingModule({ providers: appProviders, imports: [DashboardHeroComponent, TestHostComponent], }); })); beforeEach(() => { // create TestHostComponent instead of DashboardHeroComponent fixture = TestBed.createComponent(TestHostComponent); testHost = fixture.componentInstance; heroEl = fixture.nativeElement.querySelector('.hero'); fixture.detectChanges(); // trigger initial data binding }); it('should display hero name', () => { const expectedPipedName = testHost.hero.name.to",
    "id": "component-testing-scenarios-*-angular-482"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": "UpperCase(); expect(heroEl.textContent).toContain(expectedPipedName); }); it('should raise selected event when clicked', () => { click(heroEl); // selected hero should be the same data bound hero expect(testHost.selectedHero).toBe(testHost.hero); });});////// Test Host Component //////import {Component} from '@angular/core';@Component({ imports: [DashboardHeroComponent], template: ` <dashboard-hero [hero]=\"hero\" (selected)=\"onSelected($event)\"> </dashboard-hero>`,})class TestHostComponent { hero",
    "id": "component-testing-scenarios-*-angular-483"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": ": Hero = {id: 42, name: 'Test Name'}; selectedHero: Hero | undefined; onSelected(hero: Hero) { this.selectedHero = hero; }} The DashboardComponent is simple. It needs no help. But more complex components often depend on other components, directives, pipes, and providers and these must be added to the testing module too. Fortunately, the TestBed.configureTestingModule parameter parallels the metadata passed to the @NgModule decorator which means you can also specify providers and imports. The Her",
    "id": "component-testing-scenarios-*-angular-484"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": "oDetailComponent requires a lot of help despite its small size and simple construction. In addition to the support it receives from the default testing module CommonModule, it needs: NgModel and friends in the FormsModule to enable two-way data binding The TitleCasePipe from the shared folder The Router services The Hero data access services One approach is to configure the testing module from the individual pieces as in this example: app/hero/hero-detail.component.spec.ts (FormsModule setup) im",
    "id": "component-testing-scenarios-*-angular-485"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": "port {HttpClient, HttpHandler, provideHttpClient} from '@angular/common/http';import {HttpTestingController, provideHttpClientTesting} from '@angular/common/http/testing';import {fakeAsync, TestBed, tick} from '@angular/core/testing';import {provideRouter, Router} from '@angular/router';import {RouterTestingHarness} from '@angular/router/testing';import {asyncData, click} from '../../testing';import {Hero} from '../model/hero';import {sharedImports} from '../shared/shared';import {HeroDetailComp",
    "id": "component-testing-scenarios-*-angular-486"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": "onent} from './hero-detail.component';import {HeroDetailService} from './hero-detail.service';import {HeroListComponent} from './hero-list.component';////// Testing Vars //////let component: HeroDetailComponent;let harness: RouterTestingHarness;let page: Page;////// Tests //////describe('HeroDetailComponent', () => { describe('with HeroModule setup', heroModuleSetup); describe('when override its provided HeroDetailService', overrideSetup); describe('with FormsModule setup', formsModuleSetup); de",
    "id": "component-testing-scenarios-*-angular-487"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": "scribe('with SharedModule setup', sharedModuleSetup);});///////////////////const testHero = getTestHeroes()[0];function overrideSetup() { class HeroDetailServiceSpy { testHero: Hero = {...testHero}; /* emit cloned test hero */ getHero = jasmine .createSpy('getHero') .and.callFake(() => asyncData(Object.assign({}, this.testHero))); /* emit clone of test hero, with changes merged in */ saveHero = jasmine .createSpy('saveHero') .and.callFake((hero: Hero) => asyncData(Object.assign(this.testHero, he",
    "id": "component-testing-scenarios-*-angular-488"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": "ro))); } beforeEach(async () => { await TestBed.configureTestingModule( Object.assign({}, appConfig, { imports: [HeroDetailComponent, HeroListComponent], providers: [ provideRouter([ {path: 'heroes', component: HeroListComponent}, {path: 'heroes/:id', component: HeroDetailComponent}, ]), HttpClient, HttpHandler, // HeroDetailService at this level is IRRELEVANT! {provide: HeroDetailService, useValue: {}}, ], }), ) .overrideComponent(HeroDetailComponent, { set: {providers: [{provide: HeroDetailSer",
    "id": "component-testing-scenarios-*-angular-489"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": "vice, useClass: HeroDetailServiceSpy}]}, }); }); let hdsSpy: HeroDetailServiceSpy; beforeEach(async () => { harness = await RouterTestingHarness.create(); component = await harness.navigateByUrl(`/heroes/${testHero.id}`, HeroDetailComponent); page = new Page(); // get the component's injected HeroDetailServiceSpy hdsSpy = harness.routeDebugElement!.injector.get(HeroDetailService) as any; harness.detectChanges(); }); it('should have called `getHero`', () => { expect(hdsSpy.getHero.calls.count()) ",
    "id": "component-testing-scenarios-*-angular-490"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": ".withContext('getHero called once') .toBe(1, 'getHero called once'); }); it(\"should display stub hero's name\", () => { expect(page.nameDisplay.textContent).toBe(hdsSpy.testHero.name); }); it('should save stub hero change', fakeAsync(() => { const origName = hdsSpy.testHero.name; const newName = 'New Name'; page.nameInput.value = newName; page.nameInput.dispatchEvent(new Event('input')); // tell Angular expect(component.hero.name).withContext('component hero has new name').toBe(newName); expect(h",
    "id": "component-testing-scenarios-*-angular-491"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": "dsSpy.testHero.name).withContext('service hero unchanged before save').toBe(origName); click(page.saveBtn); expect(hdsSpy.saveHero.calls.count()).withContext('saveHero called once').toBe(1); tick(); // wait for async save to complete expect(hdsSpy.testHero.name).withContext('service hero has new name after save').toBe(newName); expect(TestBed.inject(Router).url).toEqual('/heroes'); }));}////////////////////import {getTestHeroes} from '../model/testing/test-hero.service';const firstHero = getTest",
    "id": "component-testing-scenarios-*-angular-492"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": "Heroes()[0];function heroModuleSetup() { beforeEach(async () => { await TestBed.configureTestingModule( Object.assign({}, appConfig, { imports: [HeroDetailComponent, HeroListComponent], providers: [ provideRouter([ {path: 'heroes/:id', component: HeroDetailComponent}, {path: 'heroes', component: HeroListComponent}, ]), provideHttpClient(), provideHttpClientTesting(), ], }), ); }); describe('when navigate to existing hero', () => { let expectedHero: Hero; beforeEach(async () => { expectedHero = f",
    "id": "component-testing-scenarios-*-angular-493"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": "irstHero; await createComponent(expectedHero.id); }); it(\"should display that hero's name\", () => { expect(page.nameDisplay.textContent).toBe(expectedHero.name); }); it('should navigate when click cancel', () => { click(page.cancelBtn); expect(TestBed.inject(Router).url).toEqual(`/heroes/${expectedHero.id}`); }); it('should save when click save but not navigate immediately', () => { click(page.saveBtn); expect(TestBed.inject(HttpTestingController).expectOne({method: 'PUT', url: 'api/heroes'})); ",
    "id": "component-testing-scenarios-*-angular-494"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": "expect(TestBed.inject(Router).url).toEqual('/heroes/41'); }); it('should navigate when click save and save resolves', fakeAsync(() => { click(page.saveBtn); tick(); // wait for async save to complete expect(TestBed.inject(Router).url).toEqual('/heroes/41'); })); it('should convert hero name to Title Case', async () => { harness.fixture.autoDetectChanges(); // get the name's input and display elements from the DOM const hostElement: HTMLElement = harness.routeNativeElement!; const nameInput: HTML",
    "id": "component-testing-scenarios-*-angular-495"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": "InputElement = hostElement.querySelector('input')!; const nameDisplay: HTMLElement = hostElement.querySelector('span')!; // simulate user entering a new name into the input box nameInput.value = 'quick BROWN fOx'; // Dispatch a DOM event so that Angular learns of input value change. nameInput.dispatchEvent(new Event('input')); // Wait for Angular to update the display binding through the title pipe await harness.fixture.whenStable(); expect(nameDisplay.textContent).toBe('Quick Brown Fox'); }); }",
    "id": "component-testing-scenarios-*-angular-496"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": "); describe('when navigate to non-existent hero id', () => { beforeEach(async () => { await createComponent(999); }); it('should try to navigate back to hero list', () => { expect(TestBed.inject(Router).url).toEqual('/heroes'); }); });}/////////////////////import {FormsModule} from '@angular/forms';import {TitleCasePipe} from '../shared/title-case.pipe';import {appConfig} from '../app.config';function formsModuleSetup() { beforeEach(async () => { await TestBed.configureTestingModule( Object.assi",
    "id": "component-testing-scenarios-*-angular-497"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": "gn({}, appConfig, { imports: [FormsModule, HeroDetailComponent, TitleCasePipe], providers: [ provideHttpClient(), provideHttpClientTesting(), provideRouter([{path: 'heroes/:id', component: HeroDetailComponent}]), ], }), ); }); it(\"should display 1st hero's name\", async () => { const expectedHero = firstHero; await createComponent(expectedHero.id).then(() => { expect(page.nameDisplay.textContent).toBe(expectedHero.name); }); });}///////////////////////function sharedModuleSetup() { beforeEach(asy",
    "id": "component-testing-scenarios-*-angular-498"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": "nc () => { await TestBed.configureTestingModule( Object.assign({}, appConfig, { imports: [HeroDetailComponent, sharedImports], providers: [ provideRouter([{path: 'heroes/:id', component: HeroDetailComponent}]), provideHttpClient(), provideHttpClientTesting(), ], }), ); }); it(\"should display 1st hero's name\", async () => { const expectedHero = firstHero; await createComponent(expectedHero.id).then(() => { expect(page.nameDisplay.textContent).toBe(expectedHero.name); }); });}/////////// Helpers /",
    "id": "component-testing-scenarios-*-angular-499"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": "/////** Create the HeroDetailComponent, initialize it, set test variables */async function createComponent(id: number) { harness = await RouterTestingHarness.create(); component = await harness.navigateByUrl(`/heroes/${id}`, HeroDetailComponent); page = new Page(); const request = TestBed.inject(HttpTestingController).expectOne(`api/heroes/?id=${id}`); const hero = getTestHeroes().find((h) => h.id === Number(id)); request.flush(hero ? [hero] : []); harness.detectChanges();}class Page { // getter",
    "id": "component-testing-scenarios-*-angular-500"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": " properties wait to query the DOM until called. get buttons() { return this.queryAll<HTMLButtonElement>('button'); } get saveBtn() { return this.buttons[0]; } get cancelBtn() { return this.buttons[1]; } get nameDisplay() { return this.query<HTMLElement>('span'); } get nameInput() { return this.query<HTMLInputElement>('input'); } //// query helpers //// private query<T>(selector: string): T { return harness.routeNativeElement!.querySelector(selector)! as T; } private queryAll<T>(selector: string)",
    "id": "component-testing-scenarios-*-angular-501"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": ": T[] { return harness.routeNativeElement!.querySelectorAll(selector) as any as T[]; }} HELPFUL: Notice that the beforeEach() is asynchronous and calls TestBed.compileComponents because the HeroDetailComponent has an external template and css file. As explained in Calling compileComponents(), these tests could be run in a non-CLI environment where Angular would have to compile them in the browser. Import a shared module Because many application components need the FormsModule and the TitleCasePi",
    "id": "component-testing-scenarios-*-angular-502"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": "pe, the developer created a SharedModule to combine these and other frequently requested parts. The test configuration can use the SharedModule too as seen in this alternative setup: app/hero/hero-detail.component.spec.ts (SharedModule setup) import {HttpClient, HttpHandler, provideHttpClient} from '@angular/common/http';import {HttpTestingController, provideHttpClientTesting} from '@angular/common/http/testing';import {fakeAsync, TestBed, tick} from '@angular/core/testing';import {provideRouter",
    "id": "component-testing-scenarios-*-angular-503"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": ", Router} from '@angular/router';import {RouterTestingHarness} from '@angular/router/testing';import {asyncData, click} from '../../testing';import {Hero} from '../model/hero';import {sharedImports} from '../shared/shared';import {HeroDetailComponent} from './hero-detail.component';import {HeroDetailService} from './hero-detail.service';import {HeroListComponent} from './hero-list.component';////// Testing Vars //////let component: HeroDetailComponent;let harness: RouterTestingHarness;let page: ",
    "id": "component-testing-scenarios-*-angular-504"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": "Page;////// Tests //////describe('HeroDetailComponent', () => { describe('with HeroModule setup', heroModuleSetup); describe('when override its provided HeroDetailService', overrideSetup); describe('with FormsModule setup', formsModuleSetup); describe('with SharedModule setup', sharedModuleSetup);});///////////////////const testHero = getTestHeroes()[0];function overrideSetup() { class HeroDetailServiceSpy { testHero: Hero = {...testHero}; /* emit cloned test hero */ getHero = jasmine .createSpy",
    "id": "component-testing-scenarios-*-angular-505"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": "('getHero') .and.callFake(() => asyncData(Object.assign({}, this.testHero))); /* emit clone of test hero, with changes merged in */ saveHero = jasmine .createSpy('saveHero') .and.callFake((hero: Hero) => asyncData(Object.assign(this.testHero, hero))); } beforeEach(async () => { await TestBed.configureTestingModule( Object.assign({}, appConfig, { imports: [HeroDetailComponent, HeroListComponent], providers: [ provideRouter([ {path: 'heroes', component: HeroListComponent}, {path: 'heroes/:id', com",
    "id": "component-testing-scenarios-*-angular-506"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": "ponent: HeroDetailComponent}, ]), HttpClient, HttpHandler, // HeroDetailService at this level is IRRELEVANT! {provide: HeroDetailService, useValue: {}}, ], }), ) .overrideComponent(HeroDetailComponent, { set: {providers: [{provide: HeroDetailService, useClass: HeroDetailServiceSpy}]}, }); }); let hdsSpy: HeroDetailServiceSpy; beforeEach(async () => { harness = await RouterTestingHarness.create(); component = await harness.navigateByUrl(`/heroes/${testHero.id}`, HeroDetailComponent); page = new P",
    "id": "component-testing-scenarios-*-angular-507"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": "age(); // get the component's injected HeroDetailServiceSpy hdsSpy = harness.routeDebugElement!.injector.get(HeroDetailService) as any; harness.detectChanges(); }); it('should have called `getHero`', () => { expect(hdsSpy.getHero.calls.count()) .withContext('getHero called once') .toBe(1, 'getHero called once'); }); it(\"should display stub hero's name\", () => { expect(page.nameDisplay.textContent).toBe(hdsSpy.testHero.name); }); it('should save stub hero change', fakeAsync(() => { const origName",
    "id": "component-testing-scenarios-*-angular-508"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": " = hdsSpy.testHero.name; const newName = 'New Name'; page.nameInput.value = newName; page.nameInput.dispatchEvent(new Event('input')); // tell Angular expect(component.hero.name).withContext('component hero has new name').toBe(newName); expect(hdsSpy.testHero.name).withContext('service hero unchanged before save').toBe(origName); click(page.saveBtn); expect(hdsSpy.saveHero.calls.count()).withContext('saveHero called once').toBe(1); tick(); // wait for async save to complete expect(hdsSpy.testHer",
    "id": "component-testing-scenarios-*-angular-509"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": "o.name).withContext('service hero has new name after save').toBe(newName); expect(TestBed.inject(Router).url).toEqual('/heroes'); }));}////////////////////import {getTestHeroes} from '../model/testing/test-hero.service';const firstHero = getTestHeroes()[0];function heroModuleSetup() { beforeEach(async () => { await TestBed.configureTestingModule( Object.assign({}, appConfig, { imports: [HeroDetailComponent, HeroListComponent], providers: [ provideRouter([ {path: 'heroes/:id', component: HeroDeta",
    "id": "component-testing-scenarios-*-angular-510"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": "ilComponent}, {path: 'heroes', component: HeroListComponent}, ]), provideHttpClient(), provideHttpClientTesting(), ], }), ); }); describe('when navigate to existing hero', () => { let expectedHero: Hero; beforeEach(async () => { expectedHero = firstHero; await createComponent(expectedHero.id); }); it(\"should display that hero's name\", () => { expect(page.nameDisplay.textContent).toBe(expectedHero.name); }); it('should navigate when click cancel', () => { click(page.cancelBtn); expect(TestBed.inj",
    "id": "component-testing-scenarios-*-angular-511"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": "ect(Router).url).toEqual(`/heroes/${expectedHero.id}`); }); it('should save when click save but not navigate immediately', () => { click(page.saveBtn); expect(TestBed.inject(HttpTestingController).expectOne({method: 'PUT', url: 'api/heroes'})); expect(TestBed.inject(Router).url).toEqual('/heroes/41'); }); it('should navigate when click save and save resolves', fakeAsync(() => { click(page.saveBtn); tick(); // wait for async save to complete expect(TestBed.inject(Router).url).toEqual('/heroes/41'",
    "id": "component-testing-scenarios-*-angular-512"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": "); })); it('should convert hero name to Title Case', async () => { harness.fixture.autoDetectChanges(); // get the name's input and display elements from the DOM const hostElement: HTMLElement = harness.routeNativeElement!; const nameInput: HTMLInputElement = hostElement.querySelector('input')!; const nameDisplay: HTMLElement = hostElement.querySelector('span')!; // simulate user entering a new name into the input box nameInput.value = 'quick BROWN fOx'; // Dispatch a DOM event so that Angular l",
    "id": "component-testing-scenarios-*-angular-513"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": "earns of input value change. nameInput.dispatchEvent(new Event('input')); // Wait for Angular to update the display binding through the title pipe await harness.fixture.whenStable(); expect(nameDisplay.textContent).toBe('Quick Brown Fox'); }); }); describe('when navigate to non-existent hero id', () => { beforeEach(async () => { await createComponent(999); }); it('should try to navigate back to hero list', () => { expect(TestBed.inject(Router).url).toEqual('/heroes'); }); });}///////////////////",
    "id": "component-testing-scenarios-*-angular-514"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": "//import {FormsModule} from '@angular/forms';import {TitleCasePipe} from '../shared/title-case.pipe';import {appConfig} from '../app.config';function formsModuleSetup() { beforeEach(async () => { await TestBed.configureTestingModule( Object.assign({}, appConfig, { imports: [FormsModule, HeroDetailComponent, TitleCasePipe], providers: [ provideHttpClient(), provideHttpClientTesting(), provideRouter([{path: 'heroes/:id', component: HeroDetailComponent}]), ], }), ); }); it(\"should display 1st hero'",
    "id": "component-testing-scenarios-*-angular-515"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": "s name\", async () => { const expectedHero = firstHero; await createComponent(expectedHero.id).then(() => { expect(page.nameDisplay.textContent).toBe(expectedHero.name); }); });}///////////////////////function sharedModuleSetup() { beforeEach(async () => { await TestBed.configureTestingModule( Object.assign({}, appConfig, { imports: [HeroDetailComponent, sharedImports], providers: [ provideRouter([{path: 'heroes/:id', component: HeroDetailComponent}]), provideHttpClient(), provideHttpClientTestin",
    "id": "component-testing-scenarios-*-angular-516"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": "g(), ], }), ); }); it(\"should display 1st hero's name\", async () => { const expectedHero = firstHero; await createComponent(expectedHero.id).then(() => { expect(page.nameDisplay.textContent).toBe(expectedHero.name); }); });}/////////// Helpers //////** Create the HeroDetailComponent, initialize it, set test variables */async function createComponent(id: number) { harness = await RouterTestingHarness.create(); component = await harness.navigateByUrl(`/heroes/${id}`, HeroDetailComponent); page = n",
    "id": "component-testing-scenarios-*-angular-517"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": "ew Page(); const request = TestBed.inject(HttpTestingController).expectOne(`api/heroes/?id=${id}`); const hero = getTestHeroes().find((h) => h.id === Number(id)); request.flush(hero ? [hero] : []); harness.detectChanges();}class Page { // getter properties wait to query the DOM until called. get buttons() { return this.queryAll<HTMLButtonElement>('button'); } get saveBtn() { return this.buttons[0]; } get cancelBtn() { return this.buttons[1]; } get nameDisplay() { return this.query<HTMLElement>('",
    "id": "component-testing-scenarios-*-angular-518"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": "span'); } get nameInput() { return this.query<HTMLInputElement>('input'); } //// query helpers //// private query<T>(selector: string): T { return harness.routeNativeElement!.querySelector(selector)! as T; } private queryAll<T>(selector: string): T[] { return harness.routeNativeElement!.querySelectorAll(selector) as any as T[]; }} It's a bit tighter and smaller, with fewer import statements, which are not shown in this example. Import a feature module The HeroDetailComponent is part of the HeroM",
    "id": "component-testing-scenarios-*-angular-519"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": "odule Feature Module that aggregates more of the interdependent pieces including the SharedModule. Try a test configuration that imports the HeroModule like this one: app/hero/hero-detail.component.spec.ts (HeroModule setup) import {HttpClient, HttpHandler, provideHttpClient} from '@angular/common/http';import {HttpTestingController, provideHttpClientTesting} from '@angular/common/http/testing';import {fakeAsync, TestBed, tick} from '@angular/core/testing';import {provideRouter, Router} from '@a",
    "id": "component-testing-scenarios-*-angular-520"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": "ngular/router';import {RouterTestingHarness} from '@angular/router/testing';import {asyncData, click} from '../../testing';import {Hero} from '../model/hero';import {sharedImports} from '../shared/shared';import {HeroDetailComponent} from './hero-detail.component';import {HeroDetailService} from './hero-detail.service';import {HeroListComponent} from './hero-list.component';////// Testing Vars //////let component: HeroDetailComponent;let harness: RouterTestingHarness;let page: Page;////// Tests ",
    "id": "component-testing-scenarios-*-angular-521"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": "//////describe('HeroDetailComponent', () => { describe('with HeroModule setup', heroModuleSetup); describe('when override its provided HeroDetailService', overrideSetup); describe('with FormsModule setup', formsModuleSetup); describe('with SharedModule setup', sharedModuleSetup);});///////////////////const testHero = getTestHeroes()[0];function overrideSetup() { class HeroDetailServiceSpy { testHero: Hero = {...testHero}; /* emit cloned test hero */ getHero = jasmine .createSpy('getHero') .and.c",
    "id": "component-testing-scenarios-*-angular-522"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": "allFake(() => asyncData(Object.assign({}, this.testHero))); /* emit clone of test hero, with changes merged in */ saveHero = jasmine .createSpy('saveHero') .and.callFake((hero: Hero) => asyncData(Object.assign(this.testHero, hero))); } beforeEach(async () => { await TestBed.configureTestingModule( Object.assign({}, appConfig, { imports: [HeroDetailComponent, HeroListComponent], providers: [ provideRouter([ {path: 'heroes', component: HeroListComponent}, {path: 'heroes/:id', component: HeroDetail",
    "id": "component-testing-scenarios-*-angular-523"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": "Component}, ]), HttpClient, HttpHandler, // HeroDetailService at this level is IRRELEVANT! {provide: HeroDetailService, useValue: {}}, ], }), ) .overrideComponent(HeroDetailComponent, { set: {providers: [{provide: HeroDetailService, useClass: HeroDetailServiceSpy}]}, }); }); let hdsSpy: HeroDetailServiceSpy; beforeEach(async () => { harness = await RouterTestingHarness.create(); component = await harness.navigateByUrl(`/heroes/${testHero.id}`, HeroDetailComponent); page = new Page(); // get the ",
    "id": "component-testing-scenarios-*-angular-524"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": "component's injected HeroDetailServiceSpy hdsSpy = harness.routeDebugElement!.injector.get(HeroDetailService) as any; harness.detectChanges(); }); it('should have called `getHero`', () => { expect(hdsSpy.getHero.calls.count()) .withContext('getHero called once') .toBe(1, 'getHero called once'); }); it(\"should display stub hero's name\", () => { expect(page.nameDisplay.textContent).toBe(hdsSpy.testHero.name); }); it('should save stub hero change', fakeAsync(() => { const origName = hdsSpy.testHero",
    "id": "component-testing-scenarios-*-angular-525"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": ".name; const newName = 'New Name'; page.nameInput.value = newName; page.nameInput.dispatchEvent(new Event('input')); // tell Angular expect(component.hero.name).withContext('component hero has new name').toBe(newName); expect(hdsSpy.testHero.name).withContext('service hero unchanged before save').toBe(origName); click(page.saveBtn); expect(hdsSpy.saveHero.calls.count()).withContext('saveHero called once').toBe(1); tick(); // wait for async save to complete expect(hdsSpy.testHero.name).withContex",
    "id": "component-testing-scenarios-*-angular-526"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": "t('service hero has new name after save').toBe(newName); expect(TestBed.inject(Router).url).toEqual('/heroes'); }));}////////////////////import {getTestHeroes} from '../model/testing/test-hero.service';const firstHero = getTestHeroes()[0];function heroModuleSetup() { beforeEach(async () => { await TestBed.configureTestingModule( Object.assign({}, appConfig, { imports: [HeroDetailComponent, HeroListComponent], providers: [ provideRouter([ {path: 'heroes/:id', component: HeroDetailComponent}, {pat",
    "id": "component-testing-scenarios-*-angular-527"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": "h: 'heroes', component: HeroListComponent}, ]), provideHttpClient(), provideHttpClientTesting(), ], }), ); }); describe('when navigate to existing hero', () => { let expectedHero: Hero; beforeEach(async () => { expectedHero = firstHero; await createComponent(expectedHero.id); }); it(\"should display that hero's name\", () => { expect(page.nameDisplay.textContent).toBe(expectedHero.name); }); it('should navigate when click cancel', () => { click(page.cancelBtn); expect(TestBed.inject(Router).url).t",
    "id": "component-testing-scenarios-*-angular-528"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": "oEqual(`/heroes/${expectedHero.id}`); }); it('should save when click save but not navigate immediately', () => { click(page.saveBtn); expect(TestBed.inject(HttpTestingController).expectOne({method: 'PUT', url: 'api/heroes'})); expect(TestBed.inject(Router).url).toEqual('/heroes/41'); }); it('should navigate when click save and save resolves', fakeAsync(() => { click(page.saveBtn); tick(); // wait for async save to complete expect(TestBed.inject(Router).url).toEqual('/heroes/41'); })); it('should",
    "id": "component-testing-scenarios-*-angular-529"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": " convert hero name to Title Case', async () => { harness.fixture.autoDetectChanges(); // get the name's input and display elements from the DOM const hostElement: HTMLElement = harness.routeNativeElement!; const nameInput: HTMLInputElement = hostElement.querySelector('input')!; const nameDisplay: HTMLElement = hostElement.querySelector('span')!; // simulate user entering a new name into the input box nameInput.value = 'quick BROWN fOx'; // Dispatch a DOM event so that Angular learns of input val",
    "id": "component-testing-scenarios-*-angular-530"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": "ue change. nameInput.dispatchEvent(new Event('input')); // Wait for Angular to update the display binding through the title pipe await harness.fixture.whenStable(); expect(nameDisplay.textContent).toBe('Quick Brown Fox'); }); }); describe('when navigate to non-existent hero id', () => { beforeEach(async () => { await createComponent(999); }); it('should try to navigate back to hero list', () => { expect(TestBed.inject(Router).url).toEqual('/heroes'); }); });}/////////////////////import {FormsMod",
    "id": "component-testing-scenarios-*-angular-531"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": "ule} from '@angular/forms';import {TitleCasePipe} from '../shared/title-case.pipe';import {appConfig} from '../app.config';function formsModuleSetup() { beforeEach(async () => { await TestBed.configureTestingModule( Object.assign({}, appConfig, { imports: [FormsModule, HeroDetailComponent, TitleCasePipe], providers: [ provideHttpClient(), provideHttpClientTesting(), provideRouter([{path: 'heroes/:id', component: HeroDetailComponent}]), ], }), ); }); it(\"should display 1st hero's name\", async () ",
    "id": "component-testing-scenarios-*-angular-532"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": "=> { const expectedHero = firstHero; await createComponent(expectedHero.id).then(() => { expect(page.nameDisplay.textContent).toBe(expectedHero.name); }); });}///////////////////////function sharedModuleSetup() { beforeEach(async () => { await TestBed.configureTestingModule( Object.assign({}, appConfig, { imports: [HeroDetailComponent, sharedImports], providers: [ provideRouter([{path: 'heroes/:id', component: HeroDetailComponent}]), provideHttpClient(), provideHttpClientTesting(), ], }), ); });",
    "id": "component-testing-scenarios-*-angular-533"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": " it(\"should display 1st hero's name\", async () => { const expectedHero = firstHero; await createComponent(expectedHero.id).then(() => { expect(page.nameDisplay.textContent).toBe(expectedHero.name); }); });}/////////// Helpers //////** Create the HeroDetailComponent, initialize it, set test variables */async function createComponent(id: number) { harness = await RouterTestingHarness.create(); component = await harness.navigateByUrl(`/heroes/${id}`, HeroDetailComponent); page = new Page(); const r",
    "id": "component-testing-scenarios-*-angular-534"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": "equest = TestBed.inject(HttpTestingController).expectOne(`api/heroes/?id=${id}`); const hero = getTestHeroes().find((h) => h.id === Number(id)); request.flush(hero ? [hero] : []); harness.detectChanges();}class Page { // getter properties wait to query the DOM until called. get buttons() { return this.queryAll<HTMLButtonElement>('button'); } get saveBtn() { return this.buttons[0]; } get cancelBtn() { return this.buttons[1]; } get nameDisplay() { return this.query<HTMLElement>('span'); } get name",
    "id": "component-testing-scenarios-*-angular-535"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": "Input() { return this.query<HTMLInputElement>('input'); } //// query helpers //// private query<T>(selector: string): T { return harness.routeNativeElement!.querySelector(selector)! as T; } private queryAll<T>(selector: string): T[] { return harness.routeNativeElement!.querySelectorAll(selector) as any as T[]; }} Only the test doubles in the providers remain. Even the HeroDetailComponent declaration is gone. In fact, if you try to declare it, Angular will throw an error because HeroDetailCompone",
    "id": "component-testing-scenarios-*-angular-536"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": "nt is declared in both the HeroModule and the DynamicTestModule created by the TestBed. HELPFUL: Importing the component's feature module can be the best way to configure tests when there are many mutual dependencies within the module and the module is small, as feature modules tend to be. Override component providers The HeroDetailComponent provides its own HeroDetailService. app/hero/hero-detail.component.ts (prototype) import {Component, inject} from '@angular/core';import {ActivatedRoute, Ro",
    "id": "component-testing-scenarios-*-angular-537"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": "uter, RouterLink} from '@angular/router';import {Hero} from '../model/hero';import {sharedImports} from '../shared/shared';import {HeroDetailService} from './hero-detail.service';@Component({ selector: 'app-hero-detail', templateUrl: './hero-detail.component.html', styleUrls: ['./hero-detail.component.css'], providers: [HeroDetailService], imports: [sharedImports, RouterLink],})export class HeroDetailComponent { private heroDetailService = inject(HeroDetailService); private route = inject(Activa",
    "id": "component-testing-scenarios-*-angular-538"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": "tedRoute); private router = inject(Router); hero!: Hero; constructor() { // get hero when `id` param changes this.route.paramMap.subscribe((pmap) => this.getHero(pmap.get('id'))); } private getHero(id: string | null): void { // when no id or id===0, create new blank hero if (!id) { this.hero = {id: 0, name: ''} as Hero; return; } this.heroDetailService.getHero(id).subscribe((hero) => { if (hero) { this.hero = hero; } else { this.gotoList(); // id not found; navigate to list } }); } save(): void ",
    "id": "component-testing-scenarios-*-angular-539"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": "{ this.heroDetailService.saveHero(this.hero).subscribe(() => this.gotoList()); } cancel() { this.gotoList(); } gotoList() { this.router.navigate(['../'], {relativeTo: this.route}); }} It's not possible to stub the component's HeroDetailService in the providers of the TestBed.configureTestingModule. Those are providers for the testing module, not the component. They prepare the dependency injector at the fixture level. Angular creates the component with its own injector, which is a child of the f",
    "id": "component-testing-scenarios-*-angular-540"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": "ixture injector. It registers the component's providers (the HeroDetailService in this case) with the child injector. A test cannot get to child injector services from the fixture injector. And TestBed.configureTestingModule can't configure them either. Angular has created new instances of the real HeroDetailService all along! HELPFUL: These tests could fail or timeout if the HeroDetailService made its own XHR calls to a remote server. There might not be a remote server to call. Fortunately, the",
    "id": "component-testing-scenarios-*-angular-541"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": " HeroDetailService delegates responsibility for remote data access to an injected HeroService. app/hero/hero-detail.service.ts (prototype) import {inject, Injectable} from '@angular/core';import {Observable} from 'rxjs';import {map} from 'rxjs/operators';import {Hero} from '../model/hero';import {HeroService} from '../model/hero.service';@Injectable({providedIn: 'root'})export class HeroDetailService { private heroService = inject(HeroService); // Returns a clone which caller may modify safely g",
    "id": "component-testing-scenarios-*-angular-542"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": "etHero(id: number | string): Observable<Hero | null> { if (typeof id === 'string') { id = parseInt(id, 10); } return this.heroService.getHero(id).pipe( map((hero) => (hero ? Object.assign({}, hero) : null)), // clone or null ); } saveHero(hero: Hero) { return this.heroService.updateHero(hero); }} The previous test configuration replaces the real HeroService with a TestHeroService that intercepts server requests and fakes their responses. What if you aren't so lucky. What if faking the HeroServic",
    "id": "component-testing-scenarios-*-angular-543"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": "e is hard? What if HeroDetailService makes its own server requests? The TestBed.overrideComponent method can replace the component's providers with easy-to-manage test doubles as seen in the following setup variation: app/hero/hero-detail.component.spec.ts (Override setup) import {HttpClient, HttpHandler, provideHttpClient} from '@angular/common/http';import {HttpTestingController, provideHttpClientTesting} from '@angular/common/http/testing';import {fakeAsync, TestBed, tick} from '@angular/core",
    "id": "component-testing-scenarios-*-angular-544"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": "/testing';import {provideRouter, Router} from '@angular/router';import {RouterTestingHarness} from '@angular/router/testing';import {asyncData, click} from '../../testing';import {Hero} from '../model/hero';import {sharedImports} from '../shared/shared';import {HeroDetailComponent} from './hero-detail.component';import {HeroDetailService} from './hero-detail.service';import {HeroListComponent} from './hero-list.component';////// Testing Vars //////let component: HeroDetailComponent;let harness: ",
    "id": "component-testing-scenarios-*-angular-545"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": "RouterTestingHarness;let page: Page;////// Tests //////describe('HeroDetailComponent', () => { describe('with HeroModule setup', heroModuleSetup); describe('when override its provided HeroDetailService', overrideSetup); describe('with FormsModule setup', formsModuleSetup); describe('with SharedModule setup', sharedModuleSetup);});///////////////////const testHero = getTestHeroes()[0];function overrideSetup() { class HeroDetailServiceSpy { testHero: Hero = {...testHero}; /* emit cloned test hero ",
    "id": "component-testing-scenarios-*-angular-546"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": "*/ getHero = jasmine .createSpy('getHero') .and.callFake(() => asyncData(Object.assign({}, this.testHero))); /* emit clone of test hero, with changes merged in */ saveHero = jasmine .createSpy('saveHero') .and.callFake((hero: Hero) => asyncData(Object.assign(this.testHero, hero))); } beforeEach(async () => { await TestBed.configureTestingModule( Object.assign({}, appConfig, { imports: [HeroDetailComponent, HeroListComponent], providers: [ provideRouter([ {path: 'heroes', component: HeroListCompo",
    "id": "component-testing-scenarios-*-angular-547"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": "nent}, {path: 'heroes/:id', component: HeroDetailComponent}, ]), HttpClient, HttpHandler, // HeroDetailService at this level is IRRELEVANT! {provide: HeroDetailService, useValue: {}}, ], }), ) .overrideComponent(HeroDetailComponent, { set: {providers: [{provide: HeroDetailService, useClass: HeroDetailServiceSpy}]}, }); }); let hdsSpy: HeroDetailServiceSpy; beforeEach(async () => { harness = await RouterTestingHarness.create(); component = await harness.navigateByUrl(`/heroes/${testHero.id}`, Her",
    "id": "component-testing-scenarios-*-angular-548"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": "oDetailComponent); page = new Page(); // get the component's injected HeroDetailServiceSpy hdsSpy = harness.routeDebugElement!.injector.get(HeroDetailService) as any; harness.detectChanges(); }); it('should have called `getHero`', () => { expect(hdsSpy.getHero.calls.count()) .withContext('getHero called once') .toBe(1, 'getHero called once'); }); it(\"should display stub hero's name\", () => { expect(page.nameDisplay.textContent).toBe(hdsSpy.testHero.name); }); it('should save stub hero change', f",
    "id": "component-testing-scenarios-*-angular-549"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": "akeAsync(() => { const origName = hdsSpy.testHero.name; const newName = 'New Name'; page.nameInput.value = newName; page.nameInput.dispatchEvent(new Event('input')); // tell Angular expect(component.hero.name).withContext('component hero has new name').toBe(newName); expect(hdsSpy.testHero.name).withContext('service hero unchanged before save').toBe(origName); click(page.saveBtn); expect(hdsSpy.saveHero.calls.count()).withContext('saveHero called once').toBe(1); tick(); // wait for async save to",
    "id": "component-testing-scenarios-*-angular-550"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": " complete expect(hdsSpy.testHero.name).withContext('service hero has new name after save').toBe(newName); expect(TestBed.inject(Router).url).toEqual('/heroes'); }));}////////////////////import {getTestHeroes} from '../model/testing/test-hero.service';const firstHero = getTestHeroes()[0];function heroModuleSetup() { beforeEach(async () => { await TestBed.configureTestingModule( Object.assign({}, appConfig, { imports: [HeroDetailComponent, HeroListComponent], providers: [ provideRouter([ {path: 'h",
    "id": "component-testing-scenarios-*-angular-551"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": "eroes/:id', component: HeroDetailComponent}, {path: 'heroes', component: HeroListComponent}, ]), provideHttpClient(), provideHttpClientTesting(), ], }), ); }); describe('when navigate to existing hero', () => { let expectedHero: Hero; beforeEach(async () => { expectedHero = firstHero; await createComponent(expectedHero.id); }); it(\"should display that hero's name\", () => { expect(page.nameDisplay.textContent).toBe(expectedHero.name); }); it('should navigate when click cancel', () => { click(page",
    "id": "component-testing-scenarios-*-angular-552"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": ".cancelBtn); expect(TestBed.inject(Router).url).toEqual(`/heroes/${expectedHero.id}`); }); it('should save when click save but not navigate immediately', () => { click(page.saveBtn); expect(TestBed.inject(HttpTestingController).expectOne({method: 'PUT', url: 'api/heroes'})); expect(TestBed.inject(Router).url).toEqual('/heroes/41'); }); it('should navigate when click save and save resolves', fakeAsync(() => { click(page.saveBtn); tick(); // wait for async save to complete expect(TestBed.inject(Ro",
    "id": "component-testing-scenarios-*-angular-553"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": "uter).url).toEqual('/heroes/41'); })); it('should convert hero name to Title Case', async () => { harness.fixture.autoDetectChanges(); // get the name's input and display elements from the DOM const hostElement: HTMLElement = harness.routeNativeElement!; const nameInput: HTMLInputElement = hostElement.querySelector('input')!; const nameDisplay: HTMLElement = hostElement.querySelector('span')!; // simulate user entering a new name into the input box nameInput.value = 'quick BROWN fOx'; // Dispatc",
    "id": "component-testing-scenarios-*-angular-554"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": "h a DOM event so that Angular learns of input value change. nameInput.dispatchEvent(new Event('input')); // Wait for Angular to update the display binding through the title pipe await harness.fixture.whenStable(); expect(nameDisplay.textContent).toBe('Quick Brown Fox'); }); }); describe('when navigate to non-existent hero id', () => { beforeEach(async () => { await createComponent(999); }); it('should try to navigate back to hero list', () => { expect(TestBed.inject(Router).url).toEqual('/heroes",
    "id": "component-testing-scenarios-*-angular-555"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": "'); }); });}/////////////////////import {FormsModule} from '@angular/forms';import {TitleCasePipe} from '../shared/title-case.pipe';import {appConfig} from '../app.config';function formsModuleSetup() { beforeEach(async () => { await TestBed.configureTestingModule( Object.assign({}, appConfig, { imports: [FormsModule, HeroDetailComponent, TitleCasePipe], providers: [ provideHttpClient(), provideHttpClientTesting(), provideRouter([{path: 'heroes/:id', component: HeroDetailComponent}]), ], }), ); }",
    "id": "component-testing-scenarios-*-angular-556"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": "); it(\"should display 1st hero's name\", async () => { const expectedHero = firstHero; await createComponent(expectedHero.id).then(() => { expect(page.nameDisplay.textContent).toBe(expectedHero.name); }); });}///////////////////////function sharedModuleSetup() { beforeEach(async () => { await TestBed.configureTestingModule( Object.assign({}, appConfig, { imports: [HeroDetailComponent, sharedImports], providers: [ provideRouter([{path: 'heroes/:id', component: HeroDetailComponent}]), provideHttpCl",
    "id": "component-testing-scenarios-*-angular-557"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": "ient(), provideHttpClientTesting(), ], }), ); }); it(\"should display 1st hero's name\", async () => { const expectedHero = firstHero; await createComponent(expectedHero.id).then(() => { expect(page.nameDisplay.textContent).toBe(expectedHero.name); }); });}/////////// Helpers //////** Create the HeroDetailComponent, initialize it, set test variables */async function createComponent(id: number) { harness = await RouterTestingHarness.create(); component = await harness.navigateByUrl(`/heroes/${id}`,",
    "id": "component-testing-scenarios-*-angular-558"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": " HeroDetailComponent); page = new Page(); const request = TestBed.inject(HttpTestingController).expectOne(`api/heroes/?id=${id}`); const hero = getTestHeroes().find((h) => h.id === Number(id)); request.flush(hero ? [hero] : []); harness.detectChanges();}class Page { // getter properties wait to query the DOM until called. get buttons() { return this.queryAll<HTMLButtonElement>('button'); } get saveBtn() { return this.buttons[0]; } get cancelBtn() { return this.buttons[1]; } get nameDisplay() { r",
    "id": "component-testing-scenarios-*-angular-559"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": "eturn this.query<HTMLElement>('span'); } get nameInput() { return this.query<HTMLInputElement>('input'); } //// query helpers //// private query<T>(selector: string): T { return harness.routeNativeElement!.querySelector(selector)! as T; } private queryAll<T>(selector: string): T[] { return harness.routeNativeElement!.querySelectorAll(selector) as any as T[]; }} Notice that TestBed.configureTestingModule no longer provides a fake HeroService because it's not needed. The overrideComponent method F",
    "id": "component-testing-scenarios-*-angular-560"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": "ocus on the overrideComponent method. app/hero/hero-detail.component.spec.ts (overrideComponent) import {HttpClient, HttpHandler, provideHttpClient} from '@angular/common/http';import {HttpTestingController, provideHttpClientTesting} from '@angular/common/http/testing';import {fakeAsync, TestBed, tick} from '@angular/core/testing';import {provideRouter, Router} from '@angular/router';import {RouterTestingHarness} from '@angular/router/testing';import {asyncData, click} from '../../testing';impor",
    "id": "component-testing-scenarios-*-angular-561"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": "t {Hero} from '../model/hero';import {sharedImports} from '../shared/shared';import {HeroDetailComponent} from './hero-detail.component';import {HeroDetailService} from './hero-detail.service';import {HeroListComponent} from './hero-list.component';////// Testing Vars //////let component: HeroDetailComponent;let harness: RouterTestingHarness;let page: Page;////// Tests //////describe('HeroDetailComponent', () => { describe('with HeroModule setup', heroModuleSetup); describe('when override its pr",
    "id": "component-testing-scenarios-*-angular-562"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": "ovided HeroDetailService', overrideSetup); describe('with FormsModule setup', formsModuleSetup); describe('with SharedModule setup', sharedModuleSetup);});///////////////////const testHero = getTestHeroes()[0];function overrideSetup() { class HeroDetailServiceSpy { testHero: Hero = {...testHero}; /* emit cloned test hero */ getHero = jasmine .createSpy('getHero') .and.callFake(() => asyncData(Object.assign({}, this.testHero))); /* emit clone of test hero, with changes merged in */ saveHero = jas",
    "id": "component-testing-scenarios-*-angular-563"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": "mine .createSpy('saveHero') .and.callFake((hero: Hero) => asyncData(Object.assign(this.testHero, hero))); } beforeEach(async () => { await TestBed.configureTestingModule( Object.assign({}, appConfig, { imports: [HeroDetailComponent, HeroListComponent], providers: [ provideRouter([ {path: 'heroes', component: HeroListComponent}, {path: 'heroes/:id', component: HeroDetailComponent}, ]), HttpClient, HttpHandler, // HeroDetailService at this level is IRRELEVANT! {provide: HeroDetailService, useValue",
    "id": "component-testing-scenarios-*-angular-564"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": ": {}}, ], }), ) .overrideComponent(HeroDetailComponent, { set: {providers: [{provide: HeroDetailService, useClass: HeroDetailServiceSpy}]}, }); }); let hdsSpy: HeroDetailServiceSpy; beforeEach(async () => { harness = await RouterTestingHarness.create(); component = await harness.navigateByUrl(`/heroes/${testHero.id}`, HeroDetailComponent); page = new Page(); // get the component's injected HeroDetailServiceSpy hdsSpy = harness.routeDebugElement!.injector.get(HeroDetailService) as any; harness.de",
    "id": "component-testing-scenarios-*-angular-565"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": "tectChanges(); }); it('should have called `getHero`', () => { expect(hdsSpy.getHero.calls.count()) .withContext('getHero called once') .toBe(1, 'getHero called once'); }); it(\"should display stub hero's name\", () => { expect(page.nameDisplay.textContent).toBe(hdsSpy.testHero.name); }); it('should save stub hero change', fakeAsync(() => { const origName = hdsSpy.testHero.name; const newName = 'New Name'; page.nameInput.value = newName; page.nameInput.dispatchEvent(new Event('input')); // tell Ang",
    "id": "component-testing-scenarios-*-angular-566"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": "ular expect(component.hero.name).withContext('component hero has new name').toBe(newName); expect(hdsSpy.testHero.name).withContext('service hero unchanged before save').toBe(origName); click(page.saveBtn); expect(hdsSpy.saveHero.calls.count()).withContext('saveHero called once').toBe(1); tick(); // wait for async save to complete expect(hdsSpy.testHero.name).withContext('service hero has new name after save').toBe(newName); expect(TestBed.inject(Router).url).toEqual('/heroes'); }));}///////////",
    "id": "component-testing-scenarios-*-angular-567"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": "/////////import {getTestHeroes} from '../model/testing/test-hero.service';const firstHero = getTestHeroes()[0];function heroModuleSetup() { beforeEach(async () => { await TestBed.configureTestingModule( Object.assign({}, appConfig, { imports: [HeroDetailComponent, HeroListComponent], providers: [ provideRouter([ {path: 'heroes/:id', component: HeroDetailComponent}, {path: 'heroes', component: HeroListComponent}, ]), provideHttpClient(), provideHttpClientTesting(), ], }), ); }); describe('when na",
    "id": "component-testing-scenarios-*-angular-568"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": "vigate to existing hero', () => { let expectedHero: Hero; beforeEach(async () => { expectedHero = firstHero; await createComponent(expectedHero.id); }); it(\"should display that hero's name\", () => { expect(page.nameDisplay.textContent).toBe(expectedHero.name); }); it('should navigate when click cancel', () => { click(page.cancelBtn); expect(TestBed.inject(Router).url).toEqual(`/heroes/${expectedHero.id}`); }); it('should save when click save but not navigate immediately', () => { click(page.save",
    "id": "component-testing-scenarios-*-angular-569"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": "Btn); expect(TestBed.inject(HttpTestingController).expectOne({method: 'PUT', url: 'api/heroes'})); expect(TestBed.inject(Router).url).toEqual('/heroes/41'); }); it('should navigate when click save and save resolves', fakeAsync(() => { click(page.saveBtn); tick(); // wait for async save to complete expect(TestBed.inject(Router).url).toEqual('/heroes/41'); })); it('should convert hero name to Title Case', async () => { harness.fixture.autoDetectChanges(); // get the name's input and display elemen",
    "id": "component-testing-scenarios-*-angular-570"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": "ts from the DOM const hostElement: HTMLElement = harness.routeNativeElement!; const nameInput: HTMLInputElement = hostElement.querySelector('input')!; const nameDisplay: HTMLElement = hostElement.querySelector('span')!; // simulate user entering a new name into the input box nameInput.value = 'quick BROWN fOx'; // Dispatch a DOM event so that Angular learns of input value change. nameInput.dispatchEvent(new Event('input')); // Wait for Angular to update the display binding through the title pipe",
    "id": "component-testing-scenarios-*-angular-571"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": " await harness.fixture.whenStable(); expect(nameDisplay.textContent).toBe('Quick Brown Fox'); }); }); describe('when navigate to non-existent hero id', () => { beforeEach(async () => { await createComponent(999); }); it('should try to navigate back to hero list', () => { expect(TestBed.inject(Router).url).toEqual('/heroes'); }); });}/////////////////////import {FormsModule} from '@angular/forms';import {TitleCasePipe} from '../shared/title-case.pipe';import {appConfig} from '../app.config';funct",
    "id": "component-testing-scenarios-*-angular-572"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": "ion formsModuleSetup() { beforeEach(async () => { await TestBed.configureTestingModule( Object.assign({}, appConfig, { imports: [FormsModule, HeroDetailComponent, TitleCasePipe], providers: [ provideHttpClient(), provideHttpClientTesting(), provideRouter([{path: 'heroes/:id', component: HeroDetailComponent}]), ], }), ); }); it(\"should display 1st hero's name\", async () => { const expectedHero = firstHero; await createComponent(expectedHero.id).then(() => { expect(page.nameDisplay.textContent).to",
    "id": "component-testing-scenarios-*-angular-573"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": "Be(expectedHero.name); }); });}///////////////////////function sharedModuleSetup() { beforeEach(async () => { await TestBed.configureTestingModule( Object.assign({}, appConfig, { imports: [HeroDetailComponent, sharedImports], providers: [ provideRouter([{path: 'heroes/:id', component: HeroDetailComponent}]), provideHttpClient(), provideHttpClientTesting(), ], }), ); }); it(\"should display 1st hero's name\", async () => { const expectedHero = firstHero; await createComponent(expectedHero.id).then(",
    "id": "component-testing-scenarios-*-angular-574"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": "() => { expect(page.nameDisplay.textContent).toBe(expectedHero.name); }); });}/////////// Helpers //////** Create the HeroDetailComponent, initialize it, set test variables */async function createComponent(id: number) { harness = await RouterTestingHarness.create(); component = await harness.navigateByUrl(`/heroes/${id}`, HeroDetailComponent); page = new Page(); const request = TestBed.inject(HttpTestingController).expectOne(`api/heroes/?id=${id}`); const hero = getTestHeroes().find((h) => h.id ",
    "id": "component-testing-scenarios-*-angular-575"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": "=== Number(id)); request.flush(hero ? [hero] : []); harness.detectChanges();}class Page { // getter properties wait to query the DOM until called. get buttons() { return this.queryAll<HTMLButtonElement>('button'); } get saveBtn() { return this.buttons[0]; } get cancelBtn() { return this.buttons[1]; } get nameDisplay() { return this.query<HTMLElement>('span'); } get nameInput() { return this.query<HTMLInputElement>('input'); } //// query helpers //// private query<T>(selector: string): T { return",
    "id": "component-testing-scenarios-*-angular-576"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": " harness.routeNativeElement!.querySelector(selector)! as T; } private queryAll<T>(selector: string): T[] { return harness.routeNativeElement!.querySelectorAll(selector) as any as T[]; }} It takes two arguments: the component type to override (HeroDetailComponent) and an override metadata object. The override metadata object is a generic defined as follows: type MetadataOverride<T> = { add?: Partial<T>; remove?: Partial<T>; set?: Partial<T>;}; A metadata override object can either add-and-remove ",
    "id": "component-testing-scenarios-*-angular-577"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": "elements in metadata properties or completely reset those properties. This example resets the component's providers metadata. The type parameter, T, is the kind of metadata you'd pass to the @Component decorator: selector?: string;template?: string;templateUrl?: string;providers?: any[];… Provide a spy stub (HeroDetailServiceSpy) This example completely replaces the component's providers array with a new array containing a HeroDetailServiceSpy. The HeroDetailServiceSpy is a stubbed version of th",
    "id": "component-testing-scenarios-*-angular-578"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": "e real HeroDetailService that fakes all necessary features of that service. It neither injects nor delegates to the lower level HeroService so there's no need to provide a test double for that. The related HeroDetailComponent tests will assert that methods of the HeroDetailService were called by spying on the service methods. Accordingly, the stub implements its methods as spies: app/hero/hero-detail.component.spec.ts (HeroDetailServiceSpy) import {HttpClient, HttpHandler, provideHttpClient} fro",
    "id": "component-testing-scenarios-*-angular-579"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": "m '@angular/common/http';import {HttpTestingController, provideHttpClientTesting} from '@angular/common/http/testing';import {fakeAsync, TestBed, tick} from '@angular/core/testing';import {provideRouter, Router} from '@angular/router';import {RouterTestingHarness} from '@angular/router/testing';import {asyncData, click} from '../../testing';import {Hero} from '../model/hero';import {sharedImports} from '../shared/shared';import {HeroDetailComponent} from './hero-detail.component';import {HeroDet",
    "id": "component-testing-scenarios-*-angular-580"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": "ailService} from './hero-detail.service';import {HeroListComponent} from './hero-list.component';////// Testing Vars //////let component: HeroDetailComponent;let harness: RouterTestingHarness;let page: Page;////// Tests //////describe('HeroDetailComponent', () => { describe('with HeroModule setup', heroModuleSetup); describe('when override its provided HeroDetailService', overrideSetup); describe('with FormsModule setup', formsModuleSetup); describe('with SharedModule setup', sharedModuleSetup);",
    "id": "component-testing-scenarios-*-angular-581"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": "});///////////////////const testHero = getTestHeroes()[0];function overrideSetup() { class HeroDetailServiceSpy { testHero: Hero = {...testHero}; /* emit cloned test hero */ getHero = jasmine .createSpy('getHero') .and.callFake(() => asyncData(Object.assign({}, this.testHero))); /* emit clone of test hero, with changes merged in */ saveHero = jasmine .createSpy('saveHero') .and.callFake((hero: Hero) => asyncData(Object.assign(this.testHero, hero))); } beforeEach(async () => { await TestBed.confi",
    "id": "component-testing-scenarios-*-angular-582"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": "gureTestingModule( Object.assign({}, appConfig, { imports: [HeroDetailComponent, HeroListComponent], providers: [ provideRouter([ {path: 'heroes', component: HeroListComponent}, {path: 'heroes/:id', component: HeroDetailComponent}, ]), HttpClient, HttpHandler, // HeroDetailService at this level is IRRELEVANT! {provide: HeroDetailService, useValue: {}}, ], }), ) .overrideComponent(HeroDetailComponent, { set: {providers: [{provide: HeroDetailService, useClass: HeroDetailServiceSpy}]}, }); }); let ",
    "id": "component-testing-scenarios-*-angular-583"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": "hdsSpy: HeroDetailServiceSpy; beforeEach(async () => { harness = await RouterTestingHarness.create(); component = await harness.navigateByUrl(`/heroes/${testHero.id}`, HeroDetailComponent); page = new Page(); // get the component's injected HeroDetailServiceSpy hdsSpy = harness.routeDebugElement!.injector.get(HeroDetailService) as any; harness.detectChanges(); }); it('should have called `getHero`', () => { expect(hdsSpy.getHero.calls.count()) .withContext('getHero called once') .toBe(1, 'getHero",
    "id": "component-testing-scenarios-*-angular-584"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": " called once'); }); it(\"should display stub hero's name\", () => { expect(page.nameDisplay.textContent).toBe(hdsSpy.testHero.name); }); it('should save stub hero change', fakeAsync(() => { const origName = hdsSpy.testHero.name; const newName = 'New Name'; page.nameInput.value = newName; page.nameInput.dispatchEvent(new Event('input')); // tell Angular expect(component.hero.name).withContext('component hero has new name').toBe(newName); expect(hdsSpy.testHero.name).withContext('service hero unchan",
    "id": "component-testing-scenarios-*-angular-585"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": "ged before save').toBe(origName); click(page.saveBtn); expect(hdsSpy.saveHero.calls.count()).withContext('saveHero called once').toBe(1); tick(); // wait for async save to complete expect(hdsSpy.testHero.name).withContext('service hero has new name after save').toBe(newName); expect(TestBed.inject(Router).url).toEqual('/heroes'); }));}////////////////////import {getTestHeroes} from '../model/testing/test-hero.service';const firstHero = getTestHeroes()[0];function heroModuleSetup() { beforeEach(a",
    "id": "component-testing-scenarios-*-angular-586"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": "sync () => { await TestBed.configureTestingModule( Object.assign({}, appConfig, { imports: [HeroDetailComponent, HeroListComponent], providers: [ provideRouter([ {path: 'heroes/:id', component: HeroDetailComponent}, {path: 'heroes', component: HeroListComponent}, ]), provideHttpClient(), provideHttpClientTesting(), ], }), ); }); describe('when navigate to existing hero', () => { let expectedHero: Hero; beforeEach(async () => { expectedHero = firstHero; await createComponent(expectedHero.id); });",
    "id": "component-testing-scenarios-*-angular-587"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": " it(\"should display that hero's name\", () => { expect(page.nameDisplay.textContent).toBe(expectedHero.name); }); it('should navigate when click cancel', () => { click(page.cancelBtn); expect(TestBed.inject(Router).url).toEqual(`/heroes/${expectedHero.id}`); }); it('should save when click save but not navigate immediately', () => { click(page.saveBtn); expect(TestBed.inject(HttpTestingController).expectOne({method: 'PUT', url: 'api/heroes'})); expect(TestBed.inject(Router).url).toEqual('/heroes/4",
    "id": "component-testing-scenarios-*-angular-588"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": "1'); }); it('should navigate when click save and save resolves', fakeAsync(() => { click(page.saveBtn); tick(); // wait for async save to complete expect(TestBed.inject(Router).url).toEqual('/heroes/41'); })); it('should convert hero name to Title Case', async () => { harness.fixture.autoDetectChanges(); // get the name's input and display elements from the DOM const hostElement: HTMLElement = harness.routeNativeElement!; const nameInput: HTMLInputElement = hostElement.querySelector('input')!; c",
    "id": "component-testing-scenarios-*-angular-589"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": "onst nameDisplay: HTMLElement = hostElement.querySelector('span')!; // simulate user entering a new name into the input box nameInput.value = 'quick BROWN fOx'; // Dispatch a DOM event so that Angular learns of input value change. nameInput.dispatchEvent(new Event('input')); // Wait for Angular to update the display binding through the title pipe await harness.fixture.whenStable(); expect(nameDisplay.textContent).toBe('Quick Brown Fox'); }); }); describe('when navigate to non-existent hero id', ",
    "id": "component-testing-scenarios-*-angular-590"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": "() => { beforeEach(async () => { await createComponent(999); }); it('should try to navigate back to hero list', () => { expect(TestBed.inject(Router).url).toEqual('/heroes'); }); });}/////////////////////import {FormsModule} from '@angular/forms';import {TitleCasePipe} from '../shared/title-case.pipe';import {appConfig} from '../app.config';function formsModuleSetup() { beforeEach(async () => { await TestBed.configureTestingModule( Object.assign({}, appConfig, { imports: [FormsModule, HeroDetail",
    "id": "component-testing-scenarios-*-angular-591"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": "Component, TitleCasePipe], providers: [ provideHttpClient(), provideHttpClientTesting(), provideRouter([{path: 'heroes/:id', component: HeroDetailComponent}]), ], }), ); }); it(\"should display 1st hero's name\", async () => { const expectedHero = firstHero; await createComponent(expectedHero.id).then(() => { expect(page.nameDisplay.textContent).toBe(expectedHero.name); }); });}///////////////////////function sharedModuleSetup() { beforeEach(async () => { await TestBed.configureTestingModule( Obje",
    "id": "component-testing-scenarios-*-angular-592"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": "ct.assign({}, appConfig, { imports: [HeroDetailComponent, sharedImports], providers: [ provideRouter([{path: 'heroes/:id', component: HeroDetailComponent}]), provideHttpClient(), provideHttpClientTesting(), ], }), ); }); it(\"should display 1st hero's name\", async () => { const expectedHero = firstHero; await createComponent(expectedHero.id).then(() => { expect(page.nameDisplay.textContent).toBe(expectedHero.name); }); });}/////////// Helpers //////** Create the HeroDetailComponent, initialize it",
    "id": "component-testing-scenarios-*-angular-593"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": ", set test variables */async function createComponent(id: number) { harness = await RouterTestingHarness.create(); component = await harness.navigateByUrl(`/heroes/${id}`, HeroDetailComponent); page = new Page(); const request = TestBed.inject(HttpTestingController).expectOne(`api/heroes/?id=${id}`); const hero = getTestHeroes().find((h) => h.id === Number(id)); request.flush(hero ? [hero] : []); harness.detectChanges();}class Page { // getter properties wait to query the DOM until called. get b",
    "id": "component-testing-scenarios-*-angular-594"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": "uttons() { return this.queryAll<HTMLButtonElement>('button'); } get saveBtn() { return this.buttons[0]; } get cancelBtn() { return this.buttons[1]; } get nameDisplay() { return this.query<HTMLElement>('span'); } get nameInput() { return this.query<HTMLInputElement>('input'); } //// query helpers //// private query<T>(selector: string): T { return harness.routeNativeElement!.querySelector(selector)! as T; } private queryAll<T>(selector: string): T[] { return harness.routeNativeElement!.querySelec",
    "id": "component-testing-scenarios-*-angular-595"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": "torAll(selector) as any as T[]; }} The override tests Now the tests can control the component's hero directly by manipulating the spy-stub's testHero and confirm that service methods were called. app/hero/hero-detail.component.spec.ts (override tests) import {HttpClient, HttpHandler, provideHttpClient} from '@angular/common/http';import {HttpTestingController, provideHttpClientTesting} from '@angular/common/http/testing';import {fakeAsync, TestBed, tick} from '@angular/core/testing';import {prov",
    "id": "component-testing-scenarios-*-angular-596"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": "ideRouter, Router} from '@angular/router';import {RouterTestingHarness} from '@angular/router/testing';import {asyncData, click} from '../../testing';import {Hero} from '../model/hero';import {sharedImports} from '../shared/shared';import {HeroDetailComponent} from './hero-detail.component';import {HeroDetailService} from './hero-detail.service';import {HeroListComponent} from './hero-list.component';////// Testing Vars //////let component: HeroDetailComponent;let harness: RouterTestingHarness;l",
    "id": "component-testing-scenarios-*-angular-597"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": "et page: Page;////// Tests //////describe('HeroDetailComponent', () => { describe('with HeroModule setup', heroModuleSetup); describe('when override its provided HeroDetailService', overrideSetup); describe('with FormsModule setup', formsModuleSetup); describe('with SharedModule setup', sharedModuleSetup);});///////////////////const testHero = getTestHeroes()[0];function overrideSetup() { class HeroDetailServiceSpy { testHero: Hero = {...testHero}; /* emit cloned test hero */ getHero = jasmine .",
    "id": "component-testing-scenarios-*-angular-598"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": "createSpy('getHero') .and.callFake(() => asyncData(Object.assign({}, this.testHero))); /* emit clone of test hero, with changes merged in */ saveHero = jasmine .createSpy('saveHero') .and.callFake((hero: Hero) => asyncData(Object.assign(this.testHero, hero))); } beforeEach(async () => { await TestBed.configureTestingModule( Object.assign({}, appConfig, { imports: [HeroDetailComponent, HeroListComponent], providers: [ provideRouter([ {path: 'heroes', component: HeroListComponent}, {path: 'heroes/",
    "id": "component-testing-scenarios-*-angular-599"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": ":id', component: HeroDetailComponent}, ]), HttpClient, HttpHandler, // HeroDetailService at this level is IRRELEVANT! {provide: HeroDetailService, useValue: {}}, ], }), ) .overrideComponent(HeroDetailComponent, { set: {providers: [{provide: HeroDetailService, useClass: HeroDetailServiceSpy}]}, }); }); let hdsSpy: HeroDetailServiceSpy; beforeEach(async () => { harness = await RouterTestingHarness.create(); component = await harness.navigateByUrl(`/heroes/${testHero.id}`, HeroDetailComponent); pag",
    "id": "component-testing-scenarios-*-angular-600"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": "e = new Page(); // get the component's injected HeroDetailServiceSpy hdsSpy = harness.routeDebugElement!.injector.get(HeroDetailService) as any; harness.detectChanges(); }); it('should have called `getHero`', () => { expect(hdsSpy.getHero.calls.count()) .withContext('getHero called once') .toBe(1, 'getHero called once'); }); it(\"should display stub hero's name\", () => { expect(page.nameDisplay.textContent).toBe(hdsSpy.testHero.name); }); it('should save stub hero change', fakeAsync(() => { const",
    "id": "component-testing-scenarios-*-angular-601"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": " origName = hdsSpy.testHero.name; const newName = 'New Name'; page.nameInput.value = newName; page.nameInput.dispatchEvent(new Event('input')); // tell Angular expect(component.hero.name).withContext('component hero has new name').toBe(newName); expect(hdsSpy.testHero.name).withContext('service hero unchanged before save').toBe(origName); click(page.saveBtn); expect(hdsSpy.saveHero.calls.count()).withContext('saveHero called once').toBe(1); tick(); // wait for async save to complete expect(hdsSp",
    "id": "component-testing-scenarios-*-angular-602"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": "y.testHero.name).withContext('service hero has new name after save').toBe(newName); expect(TestBed.inject(Router).url).toEqual('/heroes'); }));}////////////////////import {getTestHeroes} from '../model/testing/test-hero.service';const firstHero = getTestHeroes()[0];function heroModuleSetup() { beforeEach(async () => { await TestBed.configureTestingModule( Object.assign({}, appConfig, { imports: [HeroDetailComponent, HeroListComponent], providers: [ provideRouter([ {path: 'heroes/:id', component:",
    "id": "component-testing-scenarios-*-angular-603"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": " HeroDetailComponent}, {path: 'heroes', component: HeroListComponent}, ]), provideHttpClient(), provideHttpClientTesting(), ], }), ); }); describe('when navigate to existing hero', () => { let expectedHero: Hero; beforeEach(async () => { expectedHero = firstHero; await createComponent(expectedHero.id); }); it(\"should display that hero's name\", () => { expect(page.nameDisplay.textContent).toBe(expectedHero.name); }); it('should navigate when click cancel', () => { click(page.cancelBtn); expect(Te",
    "id": "component-testing-scenarios-*-angular-604"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": "stBed.inject(Router).url).toEqual(`/heroes/${expectedHero.id}`); }); it('should save when click save but not navigate immediately', () => { click(page.saveBtn); expect(TestBed.inject(HttpTestingController).expectOne({method: 'PUT', url: 'api/heroes'})); expect(TestBed.inject(Router).url).toEqual('/heroes/41'); }); it('should navigate when click save and save resolves', fakeAsync(() => { click(page.saveBtn); tick(); // wait for async save to complete expect(TestBed.inject(Router).url).toEqual('/h",
    "id": "component-testing-scenarios-*-angular-605"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": "eroes/41'); })); it('should convert hero name to Title Case', async () => { harness.fixture.autoDetectChanges(); // get the name's input and display elements from the DOM const hostElement: HTMLElement = harness.routeNativeElement!; const nameInput: HTMLInputElement = hostElement.querySelector('input')!; const nameDisplay: HTMLElement = hostElement.querySelector('span')!; // simulate user entering a new name into the input box nameInput.value = 'quick BROWN fOx'; // Dispatch a DOM event so that ",
    "id": "component-testing-scenarios-*-angular-606"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": "Angular learns of input value change. nameInput.dispatchEvent(new Event('input')); // Wait for Angular to update the display binding through the title pipe await harness.fixture.whenStable(); expect(nameDisplay.textContent).toBe('Quick Brown Fox'); }); }); describe('when navigate to non-existent hero id', () => { beforeEach(async () => { await createComponent(999); }); it('should try to navigate back to hero list', () => { expect(TestBed.inject(Router).url).toEqual('/heroes'); }); });}//////////",
    "id": "component-testing-scenarios-*-angular-607"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": "///////////import {FormsModule} from '@angular/forms';import {TitleCasePipe} from '../shared/title-case.pipe';import {appConfig} from '../app.config';function formsModuleSetup() { beforeEach(async () => { await TestBed.configureTestingModule( Object.assign({}, appConfig, { imports: [FormsModule, HeroDetailComponent, TitleCasePipe], providers: [ provideHttpClient(), provideHttpClientTesting(), provideRouter([{path: 'heroes/:id', component: HeroDetailComponent}]), ], }), ); }); it(\"should display ",
    "id": "component-testing-scenarios-*-angular-608"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": "1st hero's name\", async () => { const expectedHero = firstHero; await createComponent(expectedHero.id).then(() => { expect(page.nameDisplay.textContent).toBe(expectedHero.name); }); });}///////////////////////function sharedModuleSetup() { beforeEach(async () => { await TestBed.configureTestingModule( Object.assign({}, appConfig, { imports: [HeroDetailComponent, sharedImports], providers: [ provideRouter([{path: 'heroes/:id', component: HeroDetailComponent}]), provideHttpClient(), provideHttpCli",
    "id": "component-testing-scenarios-*-angular-609"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": "entTesting(), ], }), ); }); it(\"should display 1st hero's name\", async () => { const expectedHero = firstHero; await createComponent(expectedHero.id).then(() => { expect(page.nameDisplay.textContent).toBe(expectedHero.name); }); });}/////////// Helpers //////** Create the HeroDetailComponent, initialize it, set test variables */async function createComponent(id: number) { harness = await RouterTestingHarness.create(); component = await harness.navigateByUrl(`/heroes/${id}`, HeroDetailComponent);",
    "id": "component-testing-scenarios-*-angular-610"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": " page = new Page(); const request = TestBed.inject(HttpTestingController).expectOne(`api/heroes/?id=${id}`); const hero = getTestHeroes().find((h) => h.id === Number(id)); request.flush(hero ? [hero] : []); harness.detectChanges();}class Page { // getter properties wait to query the DOM until called. get buttons() { return this.queryAll<HTMLButtonElement>('button'); } get saveBtn() { return this.buttons[0]; } get cancelBtn() { return this.buttons[1]; } get nameDisplay() { return this.query<HTMLE",
    "id": "component-testing-scenarios-*-angular-611"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": "lement>('span'); } get nameInput() { return this.query<HTMLInputElement>('input'); } //// query helpers //// private query<T>(selector: string): T { return harness.routeNativeElement!.querySelector(selector)! as T; } private queryAll<T>(selector: string): T[] { return harness.routeNativeElement!.querySelectorAll(selector) as any as T[]; }} More overrides The TestBed.overrideComponent method can be called multiple times for the same or different components. The TestBed offers similar overrideDire",
    "id": "component-testing-scenarios-*-angular-612"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": "ctive, overrideModule, and overridePipe methods for digging into and replacing parts of these other classes. Explore the options and combinations on your own. Social MediaBlogX (formerly Twitter)BlueskyYouTube Discord GitHub Stack Overflow Community Contribute Code of Conduct Report Issues Google's DevLibrary Angular Google Developer Experts ResourcesPress KitRoadmapLanguages简体中文版正體中文版日本語版한국어 Ελληνικά Super-powered by Google ©2010-2025. Code licensed under an MIT-style License . Documentation li",
    "id": "component-testing-scenarios-*-angular-613"
  },
  {
    "url": "https://angular.dev/guide/testing/components-scenarios",
    "title": "Component testing scenarios • Angular",
    "chunk": "censed under CC BY 4.0 .",
    "id": "component-testing-scenarios-*-angular-614"
  },
  {
    "url": "https://angular.dev/guide/testing/attribute-directives",
    "title": "Testing attribute directives • Angular",
    "chunk": "In-depth GuidesTesting Testing Attribute Directives An attribute directive modifies the behavior of an element, component or another directive. Its name reflects the way the directive is applied: as an attribute on a host element. On this pagearrow_upward_alt Back to the top Testing the HighlightDirective The sample application's HighlightDirective sets the background color of an element based on either a data bound color or a default color (lightgray). It also sets a custom property of the elem",
    "id": "testing-attribute-directives-*-angular-0"
  },
  {
    "url": "https://angular.dev/guide/testing/attribute-directives",
    "title": "Testing attribute directives • Angular",
    "chunk": "ent (customProperty) to true for no reason other than to show that it can. app/shared/highlight.directive.ts import {Directive, ElementRef, inject, input, OnChanges} from '@angular/core';@Directive({selector: '[highlight]'})/** * Set backgroundColor for the attached element to highlight color * and set the element's customProperty to true */export class HighlightDirective implements OnChanges { defaultColor = 'rgb(211, 211, 211)'; // lightgray bgColor = input('', {alias: 'highlight'}); private e",
    "id": "testing-attribute-directives-*-angular-1"
  },
  {
    "url": "https://angular.dev/guide/testing/attribute-directives",
    "title": "Testing attribute directives • Angular",
    "chunk": "l = inject(ElementRef); constructor() { this.el.nativeElement.style.customProperty = true; } ngOnChanges() { this.el.nativeElement.style.backgroundColor = this.bgColor || this.defaultColor; }} It's used throughout the application, perhaps most simply in the AboutComponent: app/about/about.component.ts import {Component} from '@angular/core';import {HighlightDirective} from '../shared/highlight.directive';import {TwainComponent} from '../twain/twain.component';@Component({ template: ` <h2 highlig",
    "id": "testing-attribute-directives-*-angular-2"
  },
  {
    "url": "https://angular.dev/guide/testing/attribute-directives",
    "title": "Testing attribute directives • Angular",
    "chunk": "ht=\"skyblue\">About</h2> <h3>Quote of the day:</h3> <twain-quote></twain-quote> `, imports: [TwainComponent, HighlightDirective],})export class AboutComponent {} Testing the specific use of the HighlightDirective within the AboutComponent requires only the techniques explored in the \"Nested component tests\" section of Component testing scenarios. app/about/about.component.spec.ts import {provideHttpClient} from '@angular/common/http';import {CUSTOM_ELEMENTS_SCHEMA} from '@angular/core';import {Co",
    "id": "testing-attribute-directives-*-angular-3"
  },
  {
    "url": "https://angular.dev/guide/testing/attribute-directives",
    "title": "Testing attribute directives • Angular",
    "chunk": "mponentFixture, TestBed} from '@angular/core/testing';import {UserService} from '../model';import {TwainService} from '../twain/twain.service';import {AboutComponent} from './about.component';let fixture: ComponentFixture<AboutComponent>;describe('AboutComponent (highlightDirective)', () => { beforeEach(() => { fixture = TestBed.configureTestingModule({ imports: [AboutComponent], providers: [provideHttpClient(), TwainService, UserService], schemas: [CUSTOM_ELEMENTS_SCHEMA], }).createComponent(Ab",
    "id": "testing-attribute-directives-*-angular-4"
  },
  {
    "url": "https://angular.dev/guide/testing/attribute-directives",
    "title": "Testing attribute directives • Angular",
    "chunk": "outComponent); fixture.detectChanges(); // initial binding }); it('should have skyblue <h2>', () => { const h2: HTMLElement = fixture.nativeElement.querySelector('h2'); const bgColor = h2.style.backgroundColor; expect(bgColor).toBe('skyblue'); });}); However, testing a single use case is unlikely to explore the full range of a directive's capabilities. Finding and testing all components that use the directive is tedious, brittle, and almost as unlikely to afford full coverage. Class-only tests m",
    "id": "testing-attribute-directives-*-angular-5"
  },
  {
    "url": "https://angular.dev/guide/testing/attribute-directives",
    "title": "Testing attribute directives • Angular",
    "chunk": "ight be helpful, but attribute directives like this one tend to manipulate the DOM. Isolated unit tests don't touch the DOM and, therefore, do not inspire confidence in the directive's efficacy. A better solution is to create an artificial test component that demonstrates all ways to apply the directive. app/shared/highlight.directive.spec.ts (TestComponent) import {Component, DebugElement} from '@angular/core';import {ComponentFixture, TestBed} from '@angular/core/testing';import {By} from '@an",
    "id": "testing-attribute-directives-*-angular-6"
  },
  {
    "url": "https://angular.dev/guide/testing/attribute-directives",
    "title": "Testing attribute directives • Angular",
    "chunk": "gular/platform-browser';import {HighlightDirective} from './highlight.directive';@Component({ template: ` <h2 highlight=\"yellow\">Something Yellow</h2> <h2 highlight>The Default (Gray)</h2> <h2>No Highlight</h2> <input #box [highlight]=\"box.value\" value=\"cyan\" />`, imports: [HighlightDirective],})class TestComponent {}describe('HighlightDirective', () => { let fixture: ComponentFixture<TestComponent>; let des: DebugElement[]; // the three elements w/ the directive let bareH2: DebugElement; // the",
    "id": "testing-attribute-directives-*-angular-7"
  },
  {
    "url": "https://angular.dev/guide/testing/attribute-directives",
    "title": "Testing attribute directives • Angular",
    "chunk": " <h2> w/o the directive beforeEach(() => { fixture = TestBed.configureTestingModule({ imports: [HighlightDirective, TestComponent], }).createComponent(TestComponent); fixture.detectChanges(); // initial binding // all elements with an attached HighlightDirective des = fixture.debugElement.queryAll(By.directive(HighlightDirective)); // the h2 without the HighlightDirective bareH2 = fixture.debugElement.query(By.css('h2:not([highlight])')); }); // color tests it('should have three highlighted elem",
    "id": "testing-attribute-directives-*-angular-8"
  },
  {
    "url": "https://angular.dev/guide/testing/attribute-directives",
    "title": "Testing attribute directives • Angular",
    "chunk": "ents', () => { expect(des.length).toBe(3); }); it('should color 1st <h2> background \"yellow\"', () => { const bgColor = des[0].nativeElement.style.backgroundColor; expect(bgColor).toBe('yellow'); }); it('should color 2nd <h2> background w/ default color', () => { const dir = des[1].injector.get(HighlightDirective) as HighlightDirective; const bgColor = des[1].nativeElement.style.backgroundColor; expect(bgColor).toBe(dir.defaultColor); }); it('should bind <input> background to value color', () => ",
    "id": "testing-attribute-directives-*-angular-9"
  },
  {
    "url": "https://angular.dev/guide/testing/attribute-directives",
    "title": "Testing attribute directives • Angular",
    "chunk": "{ // easier to work with nativeElement const input = des[2].nativeElement as HTMLInputElement; expect(input.style.backgroundColor).withContext('initial backgroundColor').toBe('cyan'); input.value = 'green'; // Dispatch a DOM event so that Angular responds to the input value change. input.dispatchEvent(new Event('input')); fixture.detectChanges(); expect(input.style.backgroundColor).withContext('changed backgroundColor').toBe('green'); }); it('bare <h2> should not have a customProperty', () => { ",
    "id": "testing-attribute-directives-*-angular-10"
  },
  {
    "url": "https://angular.dev/guide/testing/attribute-directives",
    "title": "Testing attribute directives • Angular",
    "chunk": "expect(bareH2.properties['customProperty']).toBeUndefined(); }); // Removed on 12/02/2016 when ceased public discussion of the `Renderer`. Revive in future? // // customProperty tests // it('all highlighted elements should have a true customProperty', () => { // const allTrue = des.map(de => !!de.properties['customProperty']).every(v => v === true); // expect(allTrue).toBe(true); // }); // injected directive // attached HighlightDirective can be injected it('can inject `HighlightDirective` in 1s",
    "id": "testing-attribute-directives-*-angular-11"
  },
  {
    "url": "https://angular.dev/guide/testing/attribute-directives",
    "title": "Testing attribute directives • Angular",
    "chunk": "t <h2>', () => { const dir = des[0].injector.get(HighlightDirective); expect(dir).toBeTruthy(); }); it('cannot inject `HighlightDirective` in 3rd <h2>', () => { const dir = bareH2.injector.get(HighlightDirective, null); expect(dir).toBe(null); }); // DebugElement.providerTokens // attached HighlightDirective should be listed in the providerTokens it('should have `HighlightDirective` in 1st <h2> providerTokens', () => { expect(des[0].providerTokens).toContain(HighlightDirective); }); it('should n",
    "id": "testing-attribute-directives-*-angular-12"
  },
  {
    "url": "https://angular.dev/guide/testing/attribute-directives",
    "title": "Testing attribute directives • Angular",
    "chunk": "ot have `HighlightDirective` in 3rd <h2> providerTokens', () => { expect(bareH2.providerTokens).not.toContain(HighlightDirective); });}); HELPFUL: The <input> case binds the HighlightDirective to the name of a color value in the input box. The initial value is the word \"cyan\" which should be the background color of the input box. Here are some tests of this component: app/shared/highlight.directive.spec.ts (selected tests) import {Component, DebugElement} from '@angular/core';import {ComponentFi",
    "id": "testing-attribute-directives-*-angular-13"
  },
  {
    "url": "https://angular.dev/guide/testing/attribute-directives",
    "title": "Testing attribute directives • Angular",
    "chunk": "xture, TestBed} from '@angular/core/testing';import {By} from '@angular/platform-browser';import {HighlightDirective} from './highlight.directive';@Component({ template: ` <h2 highlight=\"yellow\">Something Yellow</h2> <h2 highlight>The Default (Gray)</h2> <h2>No Highlight</h2> <input #box [highlight]=\"box.value\" value=\"cyan\" />`, imports: [HighlightDirective],})class TestComponent {}describe('HighlightDirective', () => { let fixture: ComponentFixture<TestComponent>; let des: DebugElement[]; // th",
    "id": "testing-attribute-directives-*-angular-14"
  },
  {
    "url": "https://angular.dev/guide/testing/attribute-directives",
    "title": "Testing attribute directives • Angular",
    "chunk": "e three elements w/ the directive let bareH2: DebugElement; // the <h2> w/o the directive beforeEach(() => { fixture = TestBed.configureTestingModule({ imports: [HighlightDirective, TestComponent], }).createComponent(TestComponent); fixture.detectChanges(); // initial binding // all elements with an attached HighlightDirective des = fixture.debugElement.queryAll(By.directive(HighlightDirective)); // the h2 without the HighlightDirective bareH2 = fixture.debugElement.query(By.css('h2:not([highlig",
    "id": "testing-attribute-directives-*-angular-15"
  },
  {
    "url": "https://angular.dev/guide/testing/attribute-directives",
    "title": "Testing attribute directives • Angular",
    "chunk": "ht])')); }); // color tests it('should have three highlighted elements', () => { expect(des.length).toBe(3); }); it('should color 1st <h2> background \"yellow\"', () => { const bgColor = des[0].nativeElement.style.backgroundColor; expect(bgColor).toBe('yellow'); }); it('should color 2nd <h2> background w/ default color', () => { const dir = des[1].injector.get(HighlightDirective) as HighlightDirective; const bgColor = des[1].nativeElement.style.backgroundColor; expect(bgColor).toBe(dir.defaultColo",
    "id": "testing-attribute-directives-*-angular-16"
  },
  {
    "url": "https://angular.dev/guide/testing/attribute-directives",
    "title": "Testing attribute directives • Angular",
    "chunk": "r); }); it('should bind <input> background to value color', () => { // easier to work with nativeElement const input = des[2].nativeElement as HTMLInputElement; expect(input.style.backgroundColor).withContext('initial backgroundColor').toBe('cyan'); input.value = 'green'; // Dispatch a DOM event so that Angular responds to the input value change. input.dispatchEvent(new Event('input')); fixture.detectChanges(); expect(input.style.backgroundColor).withContext('changed backgroundColor').toBe('gree",
    "id": "testing-attribute-directives-*-angular-17"
  },
  {
    "url": "https://angular.dev/guide/testing/attribute-directives",
    "title": "Testing attribute directives • Angular",
    "chunk": "n'); }); it('bare <h2> should not have a customProperty', () => { expect(bareH2.properties['customProperty']).toBeUndefined(); }); // Removed on 12/02/2016 when ceased public discussion of the `Renderer`. Revive in future? // // customProperty tests // it('all highlighted elements should have a true customProperty', () => { // const allTrue = des.map(de => !!de.properties['customProperty']).every(v => v === true); // expect(allTrue).toBe(true); // }); // injected directive // attached HighlightD",
    "id": "testing-attribute-directives-*-angular-18"
  },
  {
    "url": "https://angular.dev/guide/testing/attribute-directives",
    "title": "Testing attribute directives • Angular",
    "chunk": "irective can be injected it('can inject `HighlightDirective` in 1st <h2>', () => { const dir = des[0].injector.get(HighlightDirective); expect(dir).toBeTruthy(); }); it('cannot inject `HighlightDirective` in 3rd <h2>', () => { const dir = bareH2.injector.get(HighlightDirective, null); expect(dir).toBe(null); }); // DebugElement.providerTokens // attached HighlightDirective should be listed in the providerTokens it('should have `HighlightDirective` in 1st <h2> providerTokens', () => { expect(des[",
    "id": "testing-attribute-directives-*-angular-19"
  },
  {
    "url": "https://angular.dev/guide/testing/attribute-directives",
    "title": "Testing attribute directives • Angular",
    "chunk": "0].providerTokens).toContain(HighlightDirective); }); it('should not have `HighlightDirective` in 3rd <h2> providerTokens', () => { expect(bareH2.providerTokens).not.toContain(HighlightDirective); });}); A few techniques are noteworthy: The By.directive predicate is a great way to get the elements that have this directive when their element types are unknown The :not pseudo-class in By.css('h2:not([highlight])') helps find <h2> elements that do not have the directive. By.css('*:not([highlight])'",
    "id": "testing-attribute-directives-*-angular-20"
  },
  {
    "url": "https://angular.dev/guide/testing/attribute-directives",
    "title": "Testing attribute directives • Angular",
    "chunk": ") finds any element that does not have the directive. DebugElement.styles affords access to element styles even in the absence of a real browser, thanks to the DebugElement abstraction. But feel free to exploit the nativeElement when that seems easier or more clear than the abstraction. Angular adds a directive to the injector of the element to which it is applied. The test for the default color uses the injector of the second <h2> to get its HighlightDirective instance and its defaultColor. Deb",
    "id": "testing-attribute-directives-*-angular-21"
  },
  {
    "url": "https://angular.dev/guide/testing/attribute-directives",
    "title": "Testing attribute directives • Angular",
    "chunk": "ugElement.properties affords access to the artificial custom property that is set by the directive Social MediaBlogX (formerly Twitter)BlueskyYouTube Discord GitHub Stack Overflow Community Contribute Code of Conduct Report Issues Google's DevLibrary Angular Google Developer Experts ResourcesPress KitRoadmapLanguages简体中文版正體中文版日本語版한국어 Ελληνικά Super-powered by Google ©2010-2025. Code licensed under an MIT-style License . Documentation licensed under CC BY 4.0 .",
    "id": "testing-attribute-directives-*-angular-22"
  },
  {
    "url": "https://angular.dev/guide/testing/pipes",
    "title": "Testing pipes • Angular",
    "chunk": "In-depth GuidesTesting Testing Pipes You can test pipes without the Angular testing utilities. On this pagearrow_upward_alt Back to the top Testing the TitleCasePipe A pipe class has one method, transform, that manipulates the input value into a transformed output value. The transform implementation rarely interacts with the DOM. Most pipes have no dependence on Angular other than the @Pipe metadata and an interface. Consider a TitleCasePipe that capitalizes the first letter of each word. Here's",
    "id": "testing-pipes-*-angular-0"
  },
  {
    "url": "https://angular.dev/guide/testing/pipes",
    "title": "Testing pipes • Angular",
    "chunk": " an implementation with a regular expression. app/shared/title-case.pipe.ts import {Pipe, PipeTransform} from '@angular/core';@Pipe({name: 'titlecase', pure: true})/** Transform to Title Case: uppercase the first letter of the words in a string. */export class TitleCasePipe implements PipeTransform { transform(input: string): string { return input.length === 0 ? '' : input.replace(/\\w\\S*/g, (txt) => txt[0].toUpperCase() + txt.slice(1).toLowerCase()); }} Anything that uses a regular expression is",
    "id": "testing-pipes-*-angular-1"
  },
  {
    "url": "https://angular.dev/guide/testing/pipes",
    "title": "Testing pipes • Angular",
    "chunk": " worth testing thoroughly. Use simple Jasmine to explore the expected cases and the edge cases. app/shared/title-case.pipe.spec.ts import {TitleCasePipe} from './title-case.pipe';describe('TitleCasePipe', () => { // This pipe is a pure, stateless function so no need for BeforeEach const pipe = new TitleCasePipe(); it('transforms \"abc\" to \"Abc\"', () => { expect(pipe.transform('abc')).toBe('Abc'); }); it('transforms \"abc def\" to \"Abc Def\"', () => { expect(pipe.transform('abc def')).toBe('Abc Def')",
    "id": "testing-pipes-*-angular-2"
  },
  {
    "url": "https://angular.dev/guide/testing/pipes",
    "title": "Testing pipes • Angular",
    "chunk": "; }); // ... more tests ... it('leaves \"Abc Def\" unchanged', () => { expect(pipe.transform('Abc Def')).toBe('Abc Def'); }); it('transforms \"abc-def\" to \"Abc-def\"', () => { expect(pipe.transform('abc-def')).toBe('Abc-def'); }); it('transforms \" abc def\" to \" Abc Def\" (preserves spaces) ', () => { expect(pipe.transform(' abc def')).toBe(' Abc Def'); });}); Writing DOM tests to support a pipe test These are tests of the pipe in isolation. They can't tell if the TitleCasePipe is working properly as ",
    "id": "testing-pipes-*-angular-3"
  },
  {
    "url": "https://angular.dev/guide/testing/pipes",
    "title": "Testing pipes • Angular",
    "chunk": "applied in the application components. Consider adding component tests such as this one: app/hero/hero-detail.component.spec.ts (pipe test) import {HttpClient, HttpHandler, provideHttpClient} from '@angular/common/http';import {HttpTestingController, provideHttpClientTesting} from '@angular/common/http/testing';import {fakeAsync, TestBed, tick} from '@angular/core/testing';import {provideRouter, Router} from '@angular/router';import {RouterTestingHarness} from '@angular/router/testing';import {a",
    "id": "testing-pipes-*-angular-4"
  },
  {
    "url": "https://angular.dev/guide/testing/pipes",
    "title": "Testing pipes • Angular",
    "chunk": "syncData, click} from '../../testing';import {Hero} from '../model/hero';import {sharedImports} from '../shared/shared';import {HeroDetailComponent} from './hero-detail.component';import {HeroDetailService} from './hero-detail.service';import {HeroListComponent} from './hero-list.component';////// Testing Vars //////let component: HeroDetailComponent;let harness: RouterTestingHarness;let page: Page;////// Tests //////describe('HeroDetailComponent', () => { describe('with HeroModule setup', heroM",
    "id": "testing-pipes-*-angular-5"
  },
  {
    "url": "https://angular.dev/guide/testing/pipes",
    "title": "Testing pipes • Angular",
    "chunk": "oduleSetup); describe('when override its provided HeroDetailService', overrideSetup); describe('with FormsModule setup', formsModuleSetup); describe('with SharedModule setup', sharedModuleSetup);});///////////////////const testHero = getTestHeroes()[0];function overrideSetup() { class HeroDetailServiceSpy { testHero: Hero = {...testHero}; /* emit cloned test hero */ getHero = jasmine .createSpy('getHero') .and.callFake(() => asyncData(Object.assign({}, this.testHero))); /* emit clone of test her",
    "id": "testing-pipes-*-angular-6"
  },
  {
    "url": "https://angular.dev/guide/testing/pipes",
    "title": "Testing pipes • Angular",
    "chunk": "o, with changes merged in */ saveHero = jasmine .createSpy('saveHero') .and.callFake((hero: Hero) => asyncData(Object.assign(this.testHero, hero))); } beforeEach(async () => { await TestBed.configureTestingModule( Object.assign({}, appConfig, { imports: [HeroDetailComponent, HeroListComponent], providers: [ provideRouter([ {path: 'heroes', component: HeroListComponent}, {path: 'heroes/:id', component: HeroDetailComponent}, ]), HttpClient, HttpHandler, // HeroDetailService at this level is IRRELE",
    "id": "testing-pipes-*-angular-7"
  },
  {
    "url": "https://angular.dev/guide/testing/pipes",
    "title": "Testing pipes • Angular",
    "chunk": "VANT! {provide: HeroDetailService, useValue: {}}, ], }), ) .overrideComponent(HeroDetailComponent, { set: {providers: [{provide: HeroDetailService, useClass: HeroDetailServiceSpy}]}, }); }); let hdsSpy: HeroDetailServiceSpy; beforeEach(async () => { harness = await RouterTestingHarness.create(); component = await harness.navigateByUrl(`/heroes/${testHero.id}`, HeroDetailComponent); page = new Page(); // get the component's injected HeroDetailServiceSpy hdsSpy = harness.routeDebugElement!.injecto",
    "id": "testing-pipes-*-angular-8"
  },
  {
    "url": "https://angular.dev/guide/testing/pipes",
    "title": "Testing pipes • Angular",
    "chunk": "r.get(HeroDetailService) as any; harness.detectChanges(); }); it('should have called `getHero`', () => { expect(hdsSpy.getHero.calls.count()) .withContext('getHero called once') .toBe(1, 'getHero called once'); }); it(\"should display stub hero's name\", () => { expect(page.nameDisplay.textContent).toBe(hdsSpy.testHero.name); }); it('should save stub hero change', fakeAsync(() => { const origName = hdsSpy.testHero.name; const newName = 'New Name'; page.nameInput.value = newName; page.nameInput.dis",
    "id": "testing-pipes-*-angular-9"
  },
  {
    "url": "https://angular.dev/guide/testing/pipes",
    "title": "Testing pipes • Angular",
    "chunk": "patchEvent(new Event('input')); // tell Angular expect(component.hero.name).withContext('component hero has new name').toBe(newName); expect(hdsSpy.testHero.name).withContext('service hero unchanged before save').toBe(origName); click(page.saveBtn); expect(hdsSpy.saveHero.calls.count()).withContext('saveHero called once').toBe(1); tick(); // wait for async save to complete expect(hdsSpy.testHero.name).withContext('service hero has new name after save').toBe(newName); expect(TestBed.inject(Router",
    "id": "testing-pipes-*-angular-10"
  },
  {
    "url": "https://angular.dev/guide/testing/pipes",
    "title": "Testing pipes • Angular",
    "chunk": ").url).toEqual('/heroes'); }));}////////////////////import {getTestHeroes} from '../model/testing/test-hero.service';const firstHero = getTestHeroes()[0];function heroModuleSetup() { beforeEach(async () => { await TestBed.configureTestingModule( Object.assign({}, appConfig, { imports: [HeroDetailComponent, HeroListComponent], providers: [ provideRouter([ {path: 'heroes/:id', component: HeroDetailComponent}, {path: 'heroes', component: HeroListComponent}, ]), provideHttpClient(), provideHttpClien",
    "id": "testing-pipes-*-angular-11"
  },
  {
    "url": "https://angular.dev/guide/testing/pipes",
    "title": "Testing pipes • Angular",
    "chunk": "tTesting(), ], }), ); }); describe('when navigate to existing hero', () => { let expectedHero: Hero; beforeEach(async () => { expectedHero = firstHero; await createComponent(expectedHero.id); }); it(\"should display that hero's name\", () => { expect(page.nameDisplay.textContent).toBe(expectedHero.name); }); it('should navigate when click cancel', () => { click(page.cancelBtn); expect(TestBed.inject(Router).url).toEqual(`/heroes/${expectedHero.id}`); }); it('should save when click save but not nav",
    "id": "testing-pipes-*-angular-12"
  },
  {
    "url": "https://angular.dev/guide/testing/pipes",
    "title": "Testing pipes • Angular",
    "chunk": "igate immediately', () => { click(page.saveBtn); expect(TestBed.inject(HttpTestingController).expectOne({method: 'PUT', url: 'api/heroes'})); expect(TestBed.inject(Router).url).toEqual('/heroes/41'); }); it('should navigate when click save and save resolves', fakeAsync(() => { click(page.saveBtn); tick(); // wait for async save to complete expect(TestBed.inject(Router).url).toEqual('/heroes/41'); })); it('should convert hero name to Title Case', async () => { harness.fixture.autoDetectChanges();",
    "id": "testing-pipes-*-angular-13"
  },
  {
    "url": "https://angular.dev/guide/testing/pipes",
    "title": "Testing pipes • Angular",
    "chunk": " // get the name's input and display elements from the DOM const hostElement: HTMLElement = harness.routeNativeElement!; const nameInput: HTMLInputElement = hostElement.querySelector('input')!; const nameDisplay: HTMLElement = hostElement.querySelector('span')!; // simulate user entering a new name into the input box nameInput.value = 'quick BROWN fOx'; // Dispatch a DOM event so that Angular learns of input value change. nameInput.dispatchEvent(new Event('input')); // Wait for Angular to update",
    "id": "testing-pipes-*-angular-14"
  },
  {
    "url": "https://angular.dev/guide/testing/pipes",
    "title": "Testing pipes • Angular",
    "chunk": " the display binding through the title pipe await harness.fixture.whenStable(); expect(nameDisplay.textContent).toBe('Quick Brown Fox'); }); }); describe('when navigate to non-existent hero id', () => { beforeEach(async () => { await createComponent(999); }); it('should try to navigate back to hero list', () => { expect(TestBed.inject(Router).url).toEqual('/heroes'); }); });}/////////////////////import {FormsModule} from '@angular/forms';import {TitleCasePipe} from '../shared/title-case.pipe';im",
    "id": "testing-pipes-*-angular-15"
  },
  {
    "url": "https://angular.dev/guide/testing/pipes",
    "title": "Testing pipes • Angular",
    "chunk": "port {appConfig} from '../app.config';function formsModuleSetup() { beforeEach(async () => { await TestBed.configureTestingModule( Object.assign({}, appConfig, { imports: [FormsModule, HeroDetailComponent, TitleCasePipe], providers: [ provideHttpClient(), provideHttpClientTesting(), provideRouter([{path: 'heroes/:id', component: HeroDetailComponent}]), ], }), ); }); it(\"should display 1st hero's name\", async () => { const expectedHero = firstHero; await createComponent(expectedHero.id).then(() =",
    "id": "testing-pipes-*-angular-16"
  },
  {
    "url": "https://angular.dev/guide/testing/pipes",
    "title": "Testing pipes • Angular",
    "chunk": "> { expect(page.nameDisplay.textContent).toBe(expectedHero.name); }); });}///////////////////////function sharedModuleSetup() { beforeEach(async () => { await TestBed.configureTestingModule( Object.assign({}, appConfig, { imports: [HeroDetailComponent, sharedImports], providers: [ provideRouter([{path: 'heroes/:id', component: HeroDetailComponent}]), provideHttpClient(), provideHttpClientTesting(), ], }), ); }); it(\"should display 1st hero's name\", async () => { const expectedHero = firstHero; a",
    "id": "testing-pipes-*-angular-17"
  },
  {
    "url": "https://angular.dev/guide/testing/pipes",
    "title": "Testing pipes • Angular",
    "chunk": "wait createComponent(expectedHero.id).then(() => { expect(page.nameDisplay.textContent).toBe(expectedHero.name); }); });}/////////// Helpers //////** Create the HeroDetailComponent, initialize it, set test variables */async function createComponent(id: number) { harness = await RouterTestingHarness.create(); component = await harness.navigateByUrl(`/heroes/${id}`, HeroDetailComponent); page = new Page(); const request = TestBed.inject(HttpTestingController).expectOne(`api/heroes/?id=${id}`); con",
    "id": "testing-pipes-*-angular-18"
  },
  {
    "url": "https://angular.dev/guide/testing/pipes",
    "title": "Testing pipes • Angular",
    "chunk": "st hero = getTestHeroes().find((h) => h.id === Number(id)); request.flush(hero ? [hero] : []); harness.detectChanges();}class Page { // getter properties wait to query the DOM until called. get buttons() { return this.queryAll<HTMLButtonElement>('button'); } get saveBtn() { return this.buttons[0]; } get cancelBtn() { return this.buttons[1]; } get nameDisplay() { return this.query<HTMLElement>('span'); } get nameInput() { return this.query<HTMLInputElement>('input'); } //// query helpers //// pri",
    "id": "testing-pipes-*-angular-19"
  },
  {
    "url": "https://angular.dev/guide/testing/pipes",
    "title": "Testing pipes • Angular",
    "chunk": "vate query<T>(selector: string): T { return harness.routeNativeElement!.querySelector(selector)! as T; } private queryAll<T>(selector: string): T[] { return harness.routeNativeElement!.querySelectorAll(selector) as any as T[]; }} Social MediaBlogX (formerly Twitter)BlueskyYouTube Discord GitHub Stack Overflow Community Contribute Code of Conduct Report Issues Google's DevLibrary Angular Google Developer Experts ResourcesPress KitRoadmapLanguages简体中文版正體中文版日本語版한국어 Ελληνικά Super-powered by Google ",
    "id": "testing-pipes-*-angular-20"
  },
  {
    "url": "https://angular.dev/guide/testing/pipes",
    "title": "Testing pipes • Angular",
    "chunk": "©2010-2025. Code licensed under an MIT-style License . Documentation licensed under CC BY 4.0 .",
    "id": "testing-pipes-*-angular-21"
  },
  {
    "url": "https://angular.dev/guide/testing/debugging",
    "title": "Debugging tests • Angular",
    "chunk": "In-depth GuidesTesting Debugging tests If your tests aren't working as you expect them to, you can inspect and debug them in the browser. Debug specs in the browser in the same way that you debug an application. Reveal the Karma browser window. See Set up testing if you need help with this step. Click the DEBUG button to open a new browser tab and re-run the tests. Open the browser's Developer Tools. On Windows, press Ctrl-Shift-I. On macOS, press Command-Option-I. Pick the Sources section. Pres",
    "id": "debugging-tests-*-angular-0"
  },
  {
    "url": "https://angular.dev/guide/testing/debugging",
    "title": "Debugging tests • Angular",
    "chunk": "s Control/Command-P, and then start typing the name of your test file to open it. Set a breakpoint in the test. Refresh the browser, and notice how it stops at the breakpoint. Social MediaBlogX (formerly Twitter)BlueskyYouTube Discord GitHub Stack Overflow Community Contribute Code of Conduct Report Issues Google's DevLibrary Angular Google Developer Experts ResourcesPress KitRoadmapLanguages简体中文版正體中文版日本語版한국어 Ελληνικά Super-powered by Google ©2010-2025. Code licensed under an MIT-style License .",
    "id": "debugging-tests-*-angular-1"
  },
  {
    "url": "https://angular.dev/guide/testing/debugging",
    "title": "Debugging tests • Angular",
    "chunk": " Documentation licensed under CC BY 4.0 .",
    "id": "debugging-tests-*-angular-2"
  },
  {
    "url": "https://angular.dev/guide/testing/utility-apis",
    "title": "Testing utility APIs • Angular",
    "chunk": "In-depth GuidesTesting Testing Utility APIs This page describes the most useful Angular testing features. The Angular testing utilities include the TestBed, the ComponentFixture, and a handful of functions that control the test environment. The TestBed and ComponentFixture classes are covered separately. Here's a summary of the stand-alone functions, in order of likely utility: Function Details waitForAsync Runs the body of a test (it) or setup (beforeEach) function within a special async test z",
    "id": "testing-utility-apis-*-angular-0"
  },
  {
    "url": "https://angular.dev/guide/testing/utility-apis",
    "title": "Testing utility APIs • Angular",
    "chunk": "one. See waitForAsync. fakeAsync Runs the body of a test (it) within a special fakeAsync test zone, enabling a linear control flow coding style. See fakeAsync. tick Simulates the passage of time and the completion of pending asynchronous activities by flushing both timer and micro-task queues within the fakeAsync test zone. The curious, dedicated reader might enjoy this lengthy blog post, \"Tasks, microtasks, queues and schedules\". Accepts an optional argument that moves the virtual clock forward",
    "id": "testing-utility-apis-*-angular-1"
  },
  {
    "url": "https://angular.dev/guide/testing/utility-apis",
    "title": "Testing utility APIs • Angular",
    "chunk": " by the specified number of milliseconds, clearing asynchronous activities scheduled within that timeframe. See tick. inject Injects one or more services from the current TestBed injector into a test function. It cannot inject a service provided by the component itself. See discussion of the debugElement.injector. discardPeriodicTasks When a fakeAsync() test ends with pending timer event tasks (queued setTimeOut and setInterval callbacks), the test fails with a clear error message. In general, a",
    "id": "testing-utility-apis-*-angular-2"
  },
  {
    "url": "https://angular.dev/guide/testing/utility-apis",
    "title": "Testing utility APIs • Angular",
    "chunk": " test should end with no queued tasks. When pending timer tasks are expected, call discardPeriodicTasks to flush the task queue and avoid the error. flushMicrotasks When a fakeAsync() test ends with pending micro-tasks such as unresolved promises, the test fails with a clear error message. In general, a test should wait for micro-tasks to finish. When pending microtasks are expected, call flushMicrotasks to flush the micro-task queue and avoid the error. ComponentFixtureAutoDetect A provider tok",
    "id": "testing-utility-apis-*-angular-3"
  },
  {
    "url": "https://angular.dev/guide/testing/utility-apis",
    "title": "Testing utility APIs • Angular",
    "chunk": "en for a service that turns on automatic change detection. getTestBed Gets the current instance of the TestBed. Usually unnecessary because the static class methods of the TestBed class are typically sufficient. The TestBed instance exposes a few rarely used members that are not available as static methods. On this pagearrow_upward_alt Back to the top TestBed class summary The TestBed class is one of the principal Angular testing utilities. Its API is quite large and can be overwhelming until yo",
    "id": "testing-utility-apis-*-angular-4"
  },
  {
    "url": "https://angular.dev/guide/testing/utility-apis",
    "title": "Testing utility APIs • Angular",
    "chunk": "u've explored it, a little at a time. Read the early part of this guide first to get the basics before trying to absorb the full API. The module definition passed to configureTestingModule is a subset of the @NgModule metadata properties. type TestModuleMetadata = { providers?: any[]; declarations?: any[]; imports?: any[]; schemas?: Array<SchemaMetadata | any[]>;}; Each override method takes a MetadataOverride<T> where T is the kind of metadata appropriate to the method, that is, the parameter o",
    "id": "testing-utility-apis-*-angular-5"
  },
  {
    "url": "https://angular.dev/guide/testing/utility-apis",
    "title": "Testing utility APIs • Angular",
    "chunk": "f an @NgModule, @Component, @Directive, or @Pipe. type MetadataOverride<T> = { add?: Partial<T>; remove?: Partial<T>; set?: Partial<T>;}; The TestBed API consists of static class methods that either update or reference a global instance of the TestBed. Internally, all static methods cover methods of the current runtime TestBed instance, which is also returned by the getTestBed() function. Call TestBed methods within a beforeEach() to ensure a fresh start before each individual test. Here are the",
    "id": "testing-utility-apis-*-angular-6"
  },
  {
    "url": "https://angular.dev/guide/testing/utility-apis",
    "title": "Testing utility APIs • Angular",
    "chunk": " most important static methods, in order of likely utility. Methods Details configureTestingModule The testing shims (karma-test-shim, browser-test-shim) establish the initial test environment and a default testing module. The default testing module is configured with basic declaratives and some Angular service substitutes that every tester needs. Call configureTestingModule to refine the testing module configuration for a particular set of tests by adding and removing imports, declarations (of ",
    "id": "testing-utility-apis-*-angular-7"
  },
  {
    "url": "https://angular.dev/guide/testing/utility-apis",
    "title": "Testing utility APIs • Angular",
    "chunk": "components, directives, and pipes), and providers. compileComponents Compile the testing module asynchronously after you've finished configuring it. You must call this method if any of the testing module components have a templateUrl or styleUrls because fetching component template and style files is necessarily asynchronous. See compileComponents. After calling compileComponents, the TestBed configuration is frozen for the duration of the current spec. createComponent<T> Create an instance of a",
    "id": "testing-utility-apis-*-angular-8"
  },
  {
    "url": "https://angular.dev/guide/testing/utility-apis",
    "title": "Testing utility APIs • Angular",
    "chunk": " component of type T based on the current TestBed configuration. After calling createComponent, the TestBed configuration is frozen for the duration of the current spec. overrideModule Replace metadata for the given NgModule. Recall that modules can import other modules. The overrideModule method can reach deeply into the current testing module to modify one of these inner modules. overrideComponent Replace metadata for the given component class, which could be nested deeply within an inner modu",
    "id": "testing-utility-apis-*-angular-9"
  },
  {
    "url": "https://angular.dev/guide/testing/utility-apis",
    "title": "Testing utility APIs • Angular",
    "chunk": "le. overrideDirective Replace metadata for the given directive class, which could be nested deeply within an inner module. overridePipe Replace metadata for the given pipe class, which could be nested deeply within an inner module. inject Retrieve a service from the current TestBed injector. The inject function is often adequate for this purpose. But inject throws an error if it can't provide the service. What if the service is optional? The TestBed.inject() method takes an optional second param",
    "id": "testing-utility-apis-*-angular-10"
  },
  {
    "url": "https://angular.dev/guide/testing/utility-apis",
    "title": "Testing utility APIs • Angular",
    "chunk": "eter, the object to return if Angular can't find the provider (null in this example): After calling TestBed.inject, the TestBed configuration is frozen for the duration of the current spec. initTestEnvironment Initialize the testing environment for the entire test run. The testing shims (karma-test-shim, browser-test-shim) call it for you so there is rarely a reason for you to call it yourself. Call this method exactly once. To change this default in the middle of a test run, call resetTestEnvir",
    "id": "testing-utility-apis-*-angular-11"
  },
  {
    "url": "https://angular.dev/guide/testing/utility-apis",
    "title": "Testing utility APIs • Angular",
    "chunk": "onment first. Specify the Angular compiler factory, a PlatformRef, and a default Angular testing module. Alternatives for non-browser platforms are available in the general form @angular/platform-<platform_name>/testing/<platform_name>. resetTestEnvironment Reset the initial test environment, including the default testing module. A few of the TestBed instance methods are not covered by static TestBed class methods. These are rarely needed. The ComponentFixture The TestBed.createComponent<T> crea",
    "id": "testing-utility-apis-*-angular-12"
  },
  {
    "url": "https://angular.dev/guide/testing/utility-apis",
    "title": "Testing utility APIs • Angular",
    "chunk": "tes an instance of the component T and returns a strongly typed ComponentFixture for that component. The ComponentFixture properties and methods provide access to the component, its DOM representation, and aspects of its Angular environment. ComponentFixture properties Here are the most important properties for testers, in order of likely utility. Properties Details componentInstance The instance of the component class created by TestBed.createComponent. debugElement The DebugElement associated ",
    "id": "testing-utility-apis-*-angular-13"
  },
  {
    "url": "https://angular.dev/guide/testing/utility-apis",
    "title": "Testing utility APIs • Angular",
    "chunk": "with the root element of the component. The debugElement provides insight into the component and its DOM element during test and debugging. It's a critical property for testers. The most interesting members are covered below. nativeElement The native DOM element at the root of the component. changeDetectorRef The ChangeDetectorRef for the component. The ChangeDetectorRef is most valuable when testing a component that has the ChangeDetectionStrategy.OnPush method or the component's change detecti",
    "id": "testing-utility-apis-*-angular-14"
  },
  {
    "url": "https://angular.dev/guide/testing/utility-apis",
    "title": "Testing utility APIs • Angular",
    "chunk": "on is under your programmatic control. ComponentFixture methods The fixture methods cause Angular to perform certain tasks on the component tree. Call these method to trigger Angular behavior in response to simulated user action. Here are the most useful methods for testers. Methods Details detectChanges Trigger a change detection cycle for the component. Call it to initialize the component (it calls ngOnInit) and after your test code, change the component's data bound property values. Angular c",
    "id": "testing-utility-apis-*-angular-15"
  },
  {
    "url": "https://angular.dev/guide/testing/utility-apis",
    "title": "Testing utility APIs • Angular",
    "chunk": "an't see that you've changed personComponent.name and won't update the name binding until you call detectChanges. Runs checkNoChanges afterwards to confirm that there are no circular updates unless called as detectChanges(false); autoDetectChanges Set this to true when you want the fixture to detect changes automatically. When autodetect is true, the test fixture calls detectChanges immediately after creating the component. Then it listens for pertinent zone events and calls detectChanges accord",
    "id": "testing-utility-apis-*-angular-16"
  },
  {
    "url": "https://angular.dev/guide/testing/utility-apis",
    "title": "Testing utility APIs • Angular",
    "chunk": "ingly. When your test code modifies component property values directly, you probably still have to call fixture.detectChanges to trigger data binding updates. The default is false. Testers who prefer fine control over test behavior tend to keep it false. checkNoChanges Do a change detection run to make sure there are no pending changes. Throws an exceptions if there are. isStable If the fixture is currently stable, returns true. If there are async tasks that have not completed, returns false. wh",
    "id": "testing-utility-apis-*-angular-17"
  },
  {
    "url": "https://angular.dev/guide/testing/utility-apis",
    "title": "Testing utility APIs • Angular",
    "chunk": "enStable Returns a promise that resolves when the fixture is stable. To resume testing after completion of asynchronous activity or asynchronous change detection, hook that promise. See whenStable. destroy Trigger component destruction. DebugElement The DebugElement provides crucial insights into the component's DOM representation. From the test root component's DebugElement returned by fixture.debugElement, you can walk (and query) the fixture's entire element and component subtrees. Here are t",
    "id": "testing-utility-apis-*-angular-18"
  },
  {
    "url": "https://angular.dev/guide/testing/utility-apis",
    "title": "Testing utility APIs • Angular",
    "chunk": "he most useful DebugElement members for testers, in approximate order of utility: Members Details nativeElement The corresponding DOM element in the browser query Calling query(predicate: Predicate<DebugElement>) returns the first DebugElement that matches the predicate at any depth in the subtree. queryAll Calling queryAll(predicate: Predicate<DebugElement>) returns all DebugElements that matches the predicate at any depth in subtree. injector The host dependency injector. For example, the root",
    "id": "testing-utility-apis-*-angular-19"
  },
  {
    "url": "https://angular.dev/guide/testing/utility-apis",
    "title": "Testing utility APIs • Angular",
    "chunk": " element's component instance injector. componentInstance The element's own component instance, if it has one. context An object that provides parent context for this element. Often an ancestor component instance that governs this element. When an element is repeated within @for block, the context is an RepeaterContext whose $implicit property is the value of the row instance value. For example, the hero in @for(hero of heroes; ...). children The immediate DebugElement children. Walk the tree by",
    "id": "testing-utility-apis-*-angular-20"
  },
  {
    "url": "https://angular.dev/guide/testing/utility-apis",
    "title": "Testing utility APIs • Angular",
    "chunk": " descending through children. DebugElement also has childNodes, a list of DebugNode objects. DebugElement derives from DebugNode objects and there are often more nodes than elements. Testers can usually ignore plain nodes. parent The DebugElement parent. Null if this is the root element. name The element tag name, if it is an element. triggerEventHandler Triggers the event by its name if there is a corresponding listener in the element's listeners collection. The second parameter is the event ob",
    "id": "testing-utility-apis-*-angular-21"
  },
  {
    "url": "https://angular.dev/guide/testing/utility-apis",
    "title": "Testing utility APIs • Angular",
    "chunk": "ject expected by the handler. See triggerEventHandler. If the event lacks a listener or there's some other problem, consider calling nativeElement.dispatchEvent(eventObject). listeners The callbacks attached to the component's @Output properties and/or the element's event properties. providerTokens This component's injector lookup tokens. Includes the component itself plus the tokens that the component lists in its providers metadata. source Where to find this element in the source component tem",
    "id": "testing-utility-apis-*-angular-22"
  },
  {
    "url": "https://angular.dev/guide/testing/utility-apis",
    "title": "Testing utility APIs • Angular",
    "chunk": "plate. references Dictionary of objects associated with template local variables (for example, #foo), keyed by the local variable name. The DebugElement.query(predicate) and DebugElement.queryAll(predicate) methods take a predicate that filters the source element's subtree for matching DebugElement. The predicate is any method that takes a DebugElement and returns a truthy value. The following example finds all DebugElements with a reference to a template local variable named \"content\": app/demo",
    "id": "testing-utility-apis-*-angular-23"
  },
  {
    "url": "https://angular.dev/guide/testing/utility-apis",
    "title": "Testing utility APIs • Angular",
    "chunk": "/demo.testbed.spec.ts import {Component, DebugElement, Injectable} from '@angular/core';import { ComponentFixture, fakeAsync, inject, TestBed, tick, waitForAsync,} from '@angular/core/testing';import {FormsModule, NgControl, NgModel} from '@angular/forms';import {By} from '@angular/platform-browser';import {addMatchers, click} from '../../testing';import { BankAccountComponent, BankAccountParentComponent, Child1Component, Child2Component, Child3Component, ExternalTemplateComponent, InputComponen",
    "id": "testing-utility-apis-*-angular-24"
  },
  {
    "url": "https://angular.dev/guide/testing/utility-apis",
    "title": "Testing utility APIs • Angular",
    "chunk": "t, IoComponent, IoParentComponent, LightswitchComponent, MasterService, MyIfChildComponent, MyIfComponent, MyIfParentComponent, NeedsContentComponent, ParentComponent, ReversePipeComponent, ShellComponent, TestProvidersComponent, TestViewProvidersComponent, ValueService,} from './demo';export class NotProvided extends ValueService { /* example below */}beforeEach(addMatchers);describe('demo (with TestBed):', () => { //////// Service Tests ///////////// describe('ValueService', () => { let servic",
    "id": "testing-utility-apis-*-angular-25"
  },
  {
    "url": "https://angular.dev/guide/testing/utility-apis",
    "title": "Testing utility APIs • Angular",
    "chunk": "e: ValueService; beforeEach(() => { TestBed.configureTestingModule({providers: [ValueService]}); service = TestBed.inject(ValueService); }); it('should use ValueService', () => { service = TestBed.inject(ValueService); expect(service.getValue()).toBe('real value'); }); it('can inject a default value when service is not provided', () => { expect(TestBed.inject(NotProvided, null)).toBeNull(); }); it('test should wait for ValueService.getPromiseValue', waitForAsync(() => { service.getPromiseValue()",
    "id": "testing-utility-apis-*-angular-26"
  },
  {
    "url": "https://angular.dev/guide/testing/utility-apis",
    "title": "Testing utility APIs • Angular",
    "chunk": ".then((value) => expect(value).toBe('promise value')); })); it('test should wait for ValueService.getObservableValue', waitForAsync(() => { service.getObservableValue().subscribe((value) => expect(value).toBe('observable value')); })); // Must use done. See https://github.com/angular/angular/issues/10127 it('test should wait for ValueService.getObservableDelayValue', (done: DoneFn) => { service.getObservableDelayValue().subscribe((value) => { expect(value).toBe('observable delay value'); done();",
    "id": "testing-utility-apis-*-angular-27"
  },
  {
    "url": "https://angular.dev/guide/testing/utility-apis",
    "title": "Testing utility APIs • Angular",
    "chunk": " }); }); it('should allow the use of fakeAsync', fakeAsync(() => { let value: any; service.getPromiseValue().then((val: any) => (value = val)); tick(); // Trigger JS engine cycle until all promises resolve. expect(value).toBe('promise value'); })); }); describe('MasterService', () => { let masterService: MasterService; let valueServiceSpy: jasmine.SpyObj<ValueService>; beforeEach(() => { const spy = jasmine.createSpyObj('ValueService', ['getValue']); TestBed.configureTestingModule({ // Provide b",
    "id": "testing-utility-apis-*-angular-28"
  },
  {
    "url": "https://angular.dev/guide/testing/utility-apis",
    "title": "Testing utility APIs • Angular",
    "chunk": "oth the service-to-test and its (spy) dependency providers: [MasterService, {provide: ValueService, useValue: spy}], }); // Inject both the service-to-test and its (spy) dependency masterService = TestBed.inject(MasterService); valueServiceSpy = TestBed.inject(ValueService) as jasmine.SpyObj<ValueService>; }); it('#getValue should return stubbed value from a spy', () => { const stubValue = 'stub value'; valueServiceSpy.getValue.and.returnValue(stubValue); expect(masterService.getValue()).withCon",
    "id": "testing-utility-apis-*-angular-29"
  },
  {
    "url": "https://angular.dev/guide/testing/utility-apis",
    "title": "Testing utility APIs • Angular",
    "chunk": "text('service returned stub value').toBe(stubValue); expect(valueServiceSpy.getValue.calls.count()) .withContext('spy method was called once') .toBe(1); expect(valueServiceSpy.getValue.calls.mostRecent().returnValue).toBe(stubValue); }); }); describe('use inject within `it`', () => { beforeEach(() => { TestBed.configureTestingModule({providers: [ValueService]}); }); it('should use modified providers', inject([ValueService], (service: ValueService) => { service.setValue('value modified in beforeE",
    "id": "testing-utility-apis-*-angular-30"
  },
  {
    "url": "https://angular.dev/guide/testing/utility-apis",
    "title": "Testing utility APIs • Angular",
    "chunk": "ach'); expect(service.getValue()).toBe('value modified in beforeEach'); })); }); describe('using waitForAsync(inject) within beforeEach', () => { let serviceValue: string; beforeEach(() => { TestBed.configureTestingModule({providers: [ValueService]}); }); beforeEach(waitForAsync( inject([ValueService], (service: ValueService) => { service.getPromiseValue().then((value) => (serviceValue = value)); }), )); it('should use asynchronously modified value ... in synchronous test', () => { expect(servic",
    "id": "testing-utility-apis-*-angular-31"
  },
  {
    "url": "https://angular.dev/guide/testing/utility-apis",
    "title": "Testing utility APIs • Angular",
    "chunk": "eValue).toBe('promise value'); }); }); /////////// Component Tests ////////////////// describe('TestBed component tests', () => { // beforeEach(waitForAsync(() => { // TestBed.configureTestingModule() // // Compile everything in DemoModule // ; // })); it('should create a component with inline template', () => { const fixture = TestBed.createComponent(Child1Component); fixture.detectChanges(); expect(fixture).toHaveText('Child'); }); it('should create a component with external template', () => {",
    "id": "testing-utility-apis-*-angular-32"
  },
  {
    "url": "https://angular.dev/guide/testing/utility-apis",
    "title": "Testing utility APIs • Angular",
    "chunk": " const fixture = TestBed.createComponent(ExternalTemplateComponent); fixture.detectChanges(); expect(fixture).toHaveText('from external template'); }); it('should allow changing members of the component', () => { const fixture = TestBed.createComponent(MyIfComponent); fixture.detectChanges(); expect(fixture).toHaveText('MyIf()'); fixture.componentInstance.showMore = true; fixture.detectChanges(); expect(fixture).toHaveText('MyIf(More)'); }); it('should create a nested component bound to inputs/o",
    "id": "testing-utility-apis-*-angular-33"
  },
  {
    "url": "https://angular.dev/guide/testing/utility-apis",
    "title": "Testing utility APIs • Angular",
    "chunk": "utputs', () => { const fixture = TestBed.createComponent(IoParentComponent); fixture.detectChanges(); const heroes = fixture.debugElement.queryAll(By.css('.hero')); expect(heroes.length).withContext('has heroes').toBeGreaterThan(0); const comp = fixture.componentInstance; const hero = comp.heroes[0]; click(heroes[0]); fixture.detectChanges(); const selected = fixture.debugElement.query(By.css('p')); expect(selected).toHaveText(hero.name); }); it('can access the instance variable of an `*ngFor` r",
    "id": "testing-utility-apis-*-angular-34"
  },
  {
    "url": "https://angular.dev/guide/testing/utility-apis",
    "title": "Testing utility APIs • Angular",
    "chunk": "ow component', () => { const fixture = TestBed.createComponent(IoParentComponent); const comp = fixture.componentInstance; const heroName = comp.heroes[0].name; // first hero's name fixture.detectChanges(); const ngForRow = fixture.debugElement.query(By.directive(IoComponent)); // first hero ngForRow const hero = ngForRow.context.hero; // the hero object passed into the row expect(hero.name).withContext('ngRow.context.hero').toBe(heroName); const rowComp = ngForRow.componentInstance; // jasmine.",
    "id": "testing-utility-apis-*-angular-35"
  },
  {
    "url": "https://angular.dev/guide/testing/utility-apis",
    "title": "Testing utility APIs • Angular",
    "chunk": "any is an \"instance-of-type\" test. expect(rowComp).withContext('component is IoComp').toEqual(jasmine.any(IoComponent)); expect(rowComp.hero.name).withContext('component.hero').toBe(heroName); }); it('should support clicking a button', () => { const fixture = TestBed.createComponent(LightswitchComponent); const btn = fixture.debugElement.query(By.css('button')); const span = fixture.debugElement.query(By.css('span')).nativeElement; fixture.detectChanges(); expect(span.textContent) .withContext('",
    "id": "testing-utility-apis-*-angular-36"
  },
  {
    "url": "https://angular.dev/guide/testing/utility-apis",
    "title": "Testing utility APIs • Angular",
    "chunk": "before click') .toMatch(/is off/i); click(btn); fixture.detectChanges(); expect(span.textContent).withContext('after click').toMatch(/is on/i); }); // ngModel is async so we must wait for it with promise-based `whenStable` it('should support entering text in input box (ngModel)', waitForAsync(() => { const expectedOrigName = 'John'; const expectedNewName = 'Sally'; const fixture = TestBed.createComponent(InputComponent); fixture.detectChanges(); const comp = fixture.componentInstance; const inpu",
    "id": "testing-utility-apis-*-angular-37"
  },
  {
    "url": "https://angular.dev/guide/testing/utility-apis",
    "title": "Testing utility APIs • Angular",
    "chunk": "t = fixture.debugElement.query(By.css('input')).nativeElement as HTMLInputElement; expect(comp.name) .withContext(`At start name should be ${expectedOrigName} `) .toBe(expectedOrigName); // wait until ngModel binds comp.name to input box fixture .whenStable() .then(() => { expect(input.value) .withContext( `After ngModel updates input box, input.value should be ${expectedOrigName} `, ) .toBe(expectedOrigName); // simulate user entering new name in input input.value = expectedNewName; // that cha",
    "id": "testing-utility-apis-*-angular-38"
  },
  {
    "url": "https://angular.dev/guide/testing/utility-apis",
    "title": "Testing utility APIs • Angular",
    "chunk": "nge doesn't flow to the component immediately expect(comp.name()) .withContext( `comp.name should still be ${expectedOrigName} after value change, before binding happens`, ) .toBe(expectedOrigName); // Dispatch a DOM event so that Angular learns of input value change. // then wait while ngModel pushes input.box value to comp.name input.dispatchEvent(new Event('input')); return fixture.whenStable(); }) .then(() => { expect(comp.name()) .withContext(`After ngModel updates the model, comp.name shou",
    "id": "testing-utility-apis-*-angular-39"
  },
  {
    "url": "https://angular.dev/guide/testing/utility-apis",
    "title": "Testing utility APIs • Angular",
    "chunk": "ld be ${expectedNewName} `) .toBe(expectedNewName); }); })); // fakeAsync version of ngModel input test enables sync test style // synchronous `tick` replaces asynchronous promise-base `whenStable` it('should support entering text in input box (ngModel) - fakeAsync', fakeAsync(() => { const expectedOrigName = 'John'; const expectedNewName = 'Sally'; const fixture = TestBed.createComponent(InputComponent); fixture.detectChanges(); const comp = fixture.componentInstance; const input = fixture.debu",
    "id": "testing-utility-apis-*-angular-40"
  },
  {
    "url": "https://angular.dev/guide/testing/utility-apis",
    "title": "Testing utility APIs • Angular",
    "chunk": "gElement.query(By.css('input')).nativeElement as HTMLInputElement; expect(comp.name) .withContext(`At start name should be ${expectedOrigName} `) .toBe(expectedOrigName); // wait until ngModel binds comp.name to input box tick(); expect(input.value) .withContext(`After ngModel updates input box, input.value should be ${expectedOrigName} `) .toBe(expectedOrigName); // simulate user entering new name in input input.value = expectedNewName; // that change doesn't flow to the component immediately e",
    "id": "testing-utility-apis-*-angular-41"
  },
  {
    "url": "https://angular.dev/guide/testing/utility-apis",
    "title": "Testing utility APIs • Angular",
    "chunk": "xpect(comp.name) .withContext( `comp.name should still be ${expectedOrigName} after value change, before binding happens`, ) .toBe(expectedOrigName); // Dispatch a DOM event so that Angular learns of input value change. // then wait a tick while ngModel pushes input.box value to comp.name input.dispatchEvent(new Event('input')); tick(); expect(comp.name) .withContext(`After ngModel updates the model, comp.name should be ${expectedNewName} `) .toBe(expectedNewName); })); it('ReversePipeComp shoul",
    "id": "testing-utility-apis-*-angular-42"
  },
  {
    "url": "https://angular.dev/guide/testing/utility-apis",
    "title": "Testing utility APIs • Angular",
    "chunk": "d reverse the input text', fakeAsync(() => { const inputText = 'the quick brown fox.'; const expectedText = '.xof nworb kciuq eht'; const fixture = TestBed.createComponent(ReversePipeComponent); fixture.detectChanges(); const comp = fixture.componentInstance; const input = fixture.debugElement.query(By.css('input')).nativeElement as HTMLInputElement; const span = fixture.debugElement.query(By.css('span')).nativeElement as HTMLElement; // simulate user entering new name in input input.value = inp",
    "id": "testing-utility-apis-*-angular-43"
  },
  {
    "url": "https://angular.dev/guide/testing/utility-apis",
    "title": "Testing utility APIs • Angular",
    "chunk": "utText; // Dispatch a DOM event so that Angular learns of input value change. // then wait a tick while ngModel pushes input.box value to comp.text // and Angular updates the output span input.dispatchEvent(new Event('input')); tick(); fixture.detectChanges(); expect(span.textContent).withContext('output span').toBe(expectedText); expect(comp.text).withContext('component.text').toBe(inputText); })); // Use this technique to find attached directives of any kind it('can examine attached directives",
    "id": "testing-utility-apis-*-angular-44"
  },
  {
    "url": "https://angular.dev/guide/testing/utility-apis",
    "title": "Testing utility APIs • Angular",
    "chunk": " and listeners', () => { const fixture = TestBed.createComponent(InputComponent); fixture.detectChanges(); const inputEl = fixture.debugElement.query(By.css('input')); expect(inputEl.providerTokens).withContext('NgModel directive').toContain(NgModel); const ngControl = inputEl.injector.get(NgControl); expect(ngControl).withContext('NgControl directive').toEqual(jasmine.any(NgControl)); expect(inputEl.listeners.length).withContext('several listeners attached').toBeGreaterThan(2); }); it('BankAcco",
    "id": "testing-utility-apis-*-angular-45"
  },
  {
    "url": "https://angular.dev/guide/testing/utility-apis",
    "title": "Testing utility APIs • Angular",
    "chunk": "untComponent should set attributes, styles, classes, and properties', () => { const fixture = TestBed.createComponent(BankAccountParentComponent); fixture.detectChanges(); const comp = fixture.componentInstance; // the only child is debugElement of the BankAccount component const el = fixture.debugElement.children[0]; const childComp = el.componentInstance as BankAccountComponent; expect(childComp).toEqual(jasmine.any(BankAccountComponent)); expect(el.context).withContext('context is the child c",
    "id": "testing-utility-apis-*-angular-46"
  },
  {
    "url": "https://angular.dev/guide/testing/utility-apis",
    "title": "Testing utility APIs • Angular",
    "chunk": "omponent').toBe(childComp); expect(el.attributes['account']).withContext('account attribute').toBe(childComp.id); expect(el.attributes['bank']).withContext('bank attribute').toBe(childComp.bank); expect(el.classes['closed']).withContext('closed class').toBe(true); expect(el.classes['open']).withContext('open class').toBeFalsy(); expect(el.styles['color']).withContext('color style').toBe(comp.color); expect(el.styles['width']) .withContext('width style') .toBe(comp.width + 'px'); // Removed on 12",
    "id": "testing-utility-apis-*-angular-47"
  },
  {
    "url": "https://angular.dev/guide/testing/utility-apis",
    "title": "Testing utility APIs • Angular",
    "chunk": "/02/2016 when ceased public discussion of the `Renderer`. Revive in future? // expect(el.properties['customProperty']).toBe(true, 'customProperty'); }); }); describe('TestBed component overrides:', () => { it(\"should override ChildComp's template\", () => { const fixture = TestBed.configureTestingModule({ imports: [Child1Component], }) .overrideComponent(Child1Component, { set: {template: '<span>Fake</span>'}, }) .createComponent(Child1Component); fixture.detectChanges(); expect(fixture).toHaveTe",
    "id": "testing-utility-apis-*-angular-48"
  },
  {
    "url": "https://angular.dev/guide/testing/utility-apis",
    "title": "Testing utility APIs • Angular",
    "chunk": "xt('Fake'); }); it(\"should override TestProvidersComp's ValueService provider\", () => { const fixture = TestBed.configureTestingModule({ imports: [TestProvidersComponent], }) .overrideComponent(TestProvidersComponent, { remove: {providers: [ValueService]}, add: {providers: [{provide: ValueService, useClass: FakeValueService}]}, // Or replace them all (this component has only one provider) // set: { providers: [{ provide: ValueService, useClass: FakeValueService }] }, }) .createComponent(TestProv",
    "id": "testing-utility-apis-*-angular-49"
  },
  {
    "url": "https://angular.dev/guide/testing/utility-apis",
    "title": "Testing utility APIs • Angular",
    "chunk": "idersComponent); fixture.detectChanges(); expect(fixture).toHaveText('injected value: faked value', 'text'); // Explore the providerTokens const tokens = fixture.debugElement.providerTokens; expect(tokens).withContext('component ctor').toContain(fixture.componentInstance.constructor); expect(tokens).withContext('TestProvidersComp').toContain(TestProvidersComponent); expect(tokens).withContext('ValueService').toContain(ValueService); }); it(\"should override TestViewProvidersComp's ValueService vi",
    "id": "testing-utility-apis-*-angular-50"
  },
  {
    "url": "https://angular.dev/guide/testing/utility-apis",
    "title": "Testing utility APIs • Angular",
    "chunk": "ewProvider\", () => { const fixture = TestBed.configureTestingModule({ imports: [TestViewProvidersComponent], }) .overrideComponent(TestViewProvidersComponent, { // remove: { viewProviders: [ValueService]}, // add: { viewProviders: [{ provide: ValueService, useClass: FakeValueService }] // }, // Or replace them all (this component has only one viewProvider) set: {viewProviders: [{provide: ValueService, useClass: FakeValueService}]}, }) .createComponent(TestViewProvidersComponent); fixture.detectC",
    "id": "testing-utility-apis-*-angular-51"
  },
  {
    "url": "https://angular.dev/guide/testing/utility-apis",
    "title": "Testing utility APIs • Angular",
    "chunk": "hanges(); expect(fixture).toHaveText('injected value: faked value'); }); it(\"injected provider should not be same as component's provider\", () => { // TestComponent is parent of TestProvidersComponent @Component({ template: '<my-service-comp></my-service-comp>', imports: [TestProvidersComponent], }) class TestComponent {} // 3 levels of ValueService provider: module, TestComponent, TestProvidersComponent const fixture = TestBed.configureTestingModule({ imports: [TestComponent, TestProvidersCompo",
    "id": "testing-utility-apis-*-angular-52"
  },
  {
    "url": "https://angular.dev/guide/testing/utility-apis",
    "title": "Testing utility APIs • Angular",
    "chunk": "nent], providers: [ValueService], }) .overrideComponent(TestComponent, { set: {providers: [{provide: ValueService, useValue: {}}]}, }) .overrideComponent(TestProvidersComponent, { set: {providers: [{provide: ValueService, useClass: FakeValueService}]}, }) .createComponent(TestComponent); let testBedProvider!: ValueService; // `inject` uses TestBed's injector inject([ValueService], (s: ValueService) => (testBedProvider = s))(); const tcProvider = fixture.debugElement.injector.get(ValueService) as",
    "id": "testing-utility-apis-*-angular-53"
  },
  {
    "url": "https://angular.dev/guide/testing/utility-apis",
    "title": "Testing utility APIs • Angular",
    "chunk": " ValueService; const tpcProvider = fixture.debugElement.children[0].injector.get( ValueService, ) as FakeValueService; expect(testBedProvider).withContext('testBed/tc not same providers').not.toBe(tcProvider); expect(testBedProvider).withContext('testBed/tpc not same providers').not.toBe(tpcProvider); expect(testBedProvider instanceof ValueService) .withContext('testBedProvider is ValueService') .toBe(true); expect(tcProvider) .withContext('tcProvider is {}') .toEqual({} as ValueService); expect",
    "id": "testing-utility-apis-*-angular-54"
  },
  {
    "url": "https://angular.dev/guide/testing/utility-apis",
    "title": "Testing utility APIs • Angular",
    "chunk": "(tpcProvider instanceof FakeValueService) .withContext('tpcProvider is FakeValueService') .toBe(true); }); it('can access template local variables as references', () => { const fixture = TestBed.configureTestingModule({ imports: [ ShellComponent, NeedsContentComponent, Child1Component, Child2Component, Child3Component, ], }) .overrideComponent(ShellComponent, { set: { selector: 'test-shell', imports: [NeedsContentComponent, Child1Component, Child2Component, Child3Component], template: ` <needs-c",
    "id": "testing-utility-apis-*-angular-55"
  },
  {
    "url": "https://angular.dev/guide/testing/utility-apis",
    "title": "Testing utility APIs • Angular",
    "chunk": "ontent #nc> <child-1 #content text=\"My\"></child-1> <child-2 #content text=\"dog\"></child-2> <child-2 text=\"has\"></child-2> <child-3 #content text=\"fleas\"></child-3> <div #content>!</div> </needs-content> `, }, }) .createComponent(ShellComponent); fixture.detectChanges(); // NeedsContentComp is the child of ShellComp const el = fixture.debugElement.children[0]; const comp = el.componentInstance; expect(comp.children.toArray().length) .withContext('three different child components and an ElementRef",
    "id": "testing-utility-apis-*-angular-56"
  },
  {
    "url": "https://angular.dev/guide/testing/utility-apis",
    "title": "Testing utility APIs • Angular",
    "chunk": " with #content') .toBe(4); expect(el.references['nc']).withContext('#nc reference to component').toBe(comp); // Filter for DebugElements with a #content reference const contentRefs = el.queryAll((de) => de.references['content']); expect(contentRefs.length).withContext('elements w/ a #content reference').toBe(4); }); }); describe('nested (one-deep) component override', () => { beforeEach(() => { TestBed.configureTestingModule({ imports: [ParentComponent, FakeChildComponent], }).overrideComponent(",
    "id": "testing-utility-apis-*-angular-57"
  },
  {
    "url": "https://angular.dev/guide/testing/utility-apis",
    "title": "Testing utility APIs • Angular",
    "chunk": "ParentComponent, { set: {imports: [FakeChildComponent]}, }); }); it('ParentComp should use Fake Child component', () => { const fixture = TestBed.createComponent(ParentComponent); fixture.detectChanges(); expect(fixture).toHaveText('Parent(Fake Child)'); }); }); describe('nested (two-deep) component override', () => { beforeEach(() => { TestBed.configureTestingModule({ imports: [ParentComponent, FakeChildWithGrandchildComponent, FakeGrandchildComponent], }).overrideComponent(ParentComponent, { s",
    "id": "testing-utility-apis-*-angular-58"
  },
  {
    "url": "https://angular.dev/guide/testing/utility-apis",
    "title": "Testing utility APIs • Angular",
    "chunk": "et: {imports: [FakeChildWithGrandchildComponent, FakeGrandchildComponent]}, }); }); it('should use Fake Grandchild component', () => { const fixture = TestBed.createComponent(ParentComponent); fixture.detectChanges(); expect(fixture).toHaveText('Parent(Fake Child(Fake Grandchild))'); }); });});////////// Fakes ///////////@Component({ selector: 'child-1', template: 'Fake Child',})class FakeChildComponent {}@Component({ selector: 'grandchild-1', template: 'Fake Grandchild',})class FakeGrandchildCo",
    "id": "testing-utility-apis-*-angular-59"
  },
  {
    "url": "https://angular.dev/guide/testing/utility-apis",
    "title": "Testing utility APIs • Angular",
    "chunk": "mponent {}@Component({ selector: 'child-1', imports: [FakeGrandchildComponent], template: 'Fake Child(<grandchild-1></grandchild-1>)',})class FakeChildWithGrandchildComponent {}@Injectable()class FakeValueService extends ValueService { override value = 'faked value';} The Angular By class has three static methods for common predicates: Static method Details By.all Return all elements By.css(selector) Return elements with matching CSS selectors By.directive(directive) Return elements that Angular",
    "id": "testing-utility-apis-*-angular-60"
  },
  {
    "url": "https://angular.dev/guide/testing/utility-apis",
    "title": "Testing utility APIs • Angular",
    "chunk": " matched to an instance of the directive class app/hero/hero-list.component.spec.ts import {ComponentFixture, fakeAsync, TestBed, tick, waitForAsync} from '@angular/core/testing';import {By} from '@angular/platform-browser';import {DebugElement} from '@angular/core';import {Router} from '@angular/router';import {addMatchers} from '../../testing';import {HeroService} from '../model/hero.service';import {getTestHeroes, TestHeroService} from '../model/testing/test-hero.service';import {HeroListComp",
    "id": "testing-utility-apis-*-angular-61"
  },
  {
    "url": "https://angular.dev/guide/testing/utility-apis",
    "title": "Testing utility APIs • Angular",
    "chunk": "onent} from './hero-list.component';import {HighlightDirective} from '../shared/highlight.directive';import {appConfig} from '../app.config';const HEROES = getTestHeroes();let comp: HeroListComponent;let fixture: ComponentFixture<HeroListComponent>;let page: Page;/////// Tests //////describe('HeroListComponent', () => { beforeEach(waitForAsync(() => { addMatchers(); const routerSpy = jasmine.createSpyObj('Router', ['navigate']); TestBed.configureTestingModule( Object.assign({}, appConfig, { prov",
    "id": "testing-utility-apis-*-angular-62"
  },
  {
    "url": "https://angular.dev/guide/testing/utility-apis",
    "title": "Testing utility APIs • Angular",
    "chunk": "iders: [ {provide: HeroService, useClass: TestHeroService}, {provide: Router, useValue: routerSpy}, ], }), ) .then(createComponent); })); it('should display heroes', () => { expect(page.heroRows.length).toBeGreaterThan(0); }); it('1st hero should match 1st test hero', () => { const expectedHero = HEROES[0]; const actualHero = page.heroRows[0].textContent; expect(actualHero).withContext('hero.id').toContain(expectedHero.id.toString()); expect(actualHero).withContext('hero.name').toContain(expecte",
    "id": "testing-utility-apis-*-angular-63"
  },
  {
    "url": "https://angular.dev/guide/testing/utility-apis",
    "title": "Testing utility APIs • Angular",
    "chunk": "dHero.name); }); it('should select hero on click', fakeAsync(() => { const expectedHero = HEROES[1]; const btn = page.heroRows[1].querySelector('button'); btn!.dispatchEvent(new Event('click')); tick(); // `.toEqual` because selectedHero is clone of expectedHero; see FakeHeroService expect(comp.selectedHero).toEqual(expectedHero); })); it('should navigate to selected hero detail on click', fakeAsync(() => { const expectedHero = HEROES[1]; const btn = page.heroRows[1].querySelector('button'); btn",
    "id": "testing-utility-apis-*-angular-64"
  },
  {
    "url": "https://angular.dev/guide/testing/utility-apis",
    "title": "Testing utility APIs • Angular",
    "chunk": "!.dispatchEvent(new Event('click')); tick(); // should have navigated expect(page.navSpy.calls.any()).withContext('navigate called').toBe(true); // composed hero detail will be URL like 'heroes/42' // expect link array with the route path and hero id // first argument to router.navigate is link array const navArgs = page.navSpy.calls.first().args[0]; expect(navArgs[0]).withContext('nav to heroes detail URL').toContain('heroes'); expect(navArgs[1]).withContext('expected hero.id').toBe(expectedHer",
    "id": "testing-utility-apis-*-angular-65"
  },
  {
    "url": "https://angular.dev/guide/testing/utility-apis",
    "title": "Testing utility APIs • Angular",
    "chunk": "o.id); })); it('should find `HighlightDirective` with `By.directive', () => { // Can find DebugElement either by css selector or by directive const h2 = fixture.debugElement.query(By.css('h2')); const directive = fixture.debugElement.query(By.directive(HighlightDirective)); expect(h2).toBe(directive); }); it('should color header with `HighlightDirective`', () => { const h2 = page.highlightDe.nativeElement as HTMLElement; const bgColor = h2.style.backgroundColor; // different browsers report colo",
    "id": "testing-utility-apis-*-angular-66"
  },
  {
    "url": "https://angular.dev/guide/testing/utility-apis",
    "title": "Testing utility APIs • Angular",
    "chunk": "r values differently const isExpectedColor = bgColor === 'gold' || bgColor === 'rgb(255, 215, 0)'; expect(isExpectedColor).withContext('backgroundColor').toBe(true); }); it(\"the `HighlightDirective` is among the element's providers\", () => { expect(page.highlightDe.providerTokens) .withContext('HighlightDirective') .toContain(HighlightDirective); });});/////////// Helpers //////** Create the component and set the `page` test variables */function createComponent() { fixture = TestBed.createCompon",
    "id": "testing-utility-apis-*-angular-67"
  },
  {
    "url": "https://angular.dev/guide/testing/utility-apis",
    "title": "Testing utility APIs • Angular",
    "chunk": "ent(HeroListComponent); comp = fixture.componentInstance; // change detection triggers ngOnInit which gets a hero fixture.detectChanges(); return fixture.whenStable().then(() => { // got the heroes and updated component // change detection updates the view fixture.detectChanges(); page = new Page(); });}class Page { /** Hero line elements */ heroRows: HTMLLIElement[]; /** Highlighted DebugElement */ highlightDe: DebugElement; /** Spy on router navigate method */ navSpy: jasmine.Spy; constructor(",
    "id": "testing-utility-apis-*-angular-68"
  },
  {
    "url": "https://angular.dev/guide/testing/utility-apis",
    "title": "Testing utility APIs • Angular",
    "chunk": ") { const heroRowNodes = fixture.nativeElement.querySelectorAll('li'); this.heroRows = Array.from(heroRowNodes); // Find the first element with an attached HighlightDirective this.highlightDe = fixture.debugElement.query(By.directive(HighlightDirective)); // Get the component's injected router navigation spy const routerSpy = fixture.debugElement.injector.get(Router); this.navSpy = routerSpy.navigate as jasmine.Spy; }} Social MediaBlogX (formerly Twitter)BlueskyYouTube Discord GitHub Stack Overf",
    "id": "testing-utility-apis-*-angular-69"
  },
  {
    "url": "https://angular.dev/guide/testing/utility-apis",
    "title": "Testing utility APIs • Angular",
    "chunk": "low Community Contribute Code of Conduct Report Issues Google's DevLibrary Angular Google Developer Experts ResourcesPress KitRoadmapLanguages简体中文版正體中文版日本語版한국어 Ελληνικά Super-powered by Google ©2010-2025. Code licensed under an MIT-style License . Documentation licensed under CC BY 4.0 .",
    "id": "testing-utility-apis-*-angular-70"
  },
  {
    "url": "https://angular.dev/guide/testing/component-harnesses-overview",
    "title": "Component harnesses overview • Angular",
    "chunk": "In-depth GuidesTesting Component harnesses overview A component harness is a class that allows tests to interact with components the way an end user does via a supported API. You can create test harnesses for any component, ranging from small reusable widgets to full pages. Harnesses offer several benefits: They make tests less brittle by insulating themselves against implementation details of a component, such as its DOM structure They make tests become more readable and easier to maintain They",
    "id": "component-harnesses-overview-*-angular-0"
  },
  {
    "url": "https://angular.dev/guide/testing/component-harnesses-overview",
    "title": "Component harnesses overview • Angular",
    "chunk": " can be used across multiple testing environments // Example of test with a harness for a component called MyButtonComponentit('should load button with exact text', async () => { const button = await loader.getHarness(MyButtonComponentHarness); expect(await button.getText()).toBe('Confirm');}); Component harnesses are especially useful for shared UI widgets. Developers often write tests that depend on private implementation details of widgets, such as DOM structure and CSS classes. Those depende",
    "id": "component-harnesses-overview-*-angular-1"
  },
  {
    "url": "https://angular.dev/guide/testing/component-harnesses-overview",
    "title": "Component harnesses overview • Angular",
    "chunk": "ncies make tests brittle and hard to maintain. Harnesses offer an alternative— a supported API that interacts with the widget the same way an end-user does. Widget implementation changes now become less likely to break user tests. For example, Angular Material provides a test harness for each component in the library. Component harnesses support multiple testing environments. You can use the same harness implementation in both unit and end-to-end tests. Test authors only need to learn one API an",
    "id": "component-harnesses-overview-*-angular-2"
  },
  {
    "url": "https://angular.dev/guide/testing/component-harnesses-overview",
    "title": "Component harnesses overview • Angular",
    "chunk": "d component authors don't have to maintain separate unit and end-to-end test implementations. Many developers can be categorized by one of the following developer type categories: test authors, component harness authors, and harness environment authors. Use the table below to find the most relevant section in this guide based on these categories: Developer Type Description Relevant Section Test Authors Developers that use component harnesses written by someone else to test their application. For",
    "id": "component-harnesses-overview-*-angular-3"
  },
  {
    "url": "https://angular.dev/guide/testing/component-harnesses-overview",
    "title": "Component harnesses overview • Angular",
    "chunk": " example, this could be an app developer who uses a third-party menu component and needs to interact with the menu in a unit test. Using component harnesses in tests Component harness authors Developers who maintain some reusable Angular components and want to create a test harness for its users to use in their tests. For example, an author of a third party Angular component library or a developer who maintains a set of common components for a large Angular application. Creating component harnes",
    "id": "component-harnesses-overview-*-angular-4"
  },
  {
    "url": "https://angular.dev/guide/testing/component-harnesses-overview",
    "title": "Component harnesses overview • Angular",
    "chunk": "ses for your components Harness environment authors Developers who want to add support for using component harnesses in additional testing environments. For information on supported testing environments out-of-the-box, see the test harness environments and loaders. Adding support for additional testing environments For the full API reference, please see the Angular CDK's component harness API reference page. Social MediaBlogX (formerly Twitter)BlueskyYouTube Discord GitHub Stack Overflow Communi",
    "id": "component-harnesses-overview-*-angular-5"
  },
  {
    "url": "https://angular.dev/guide/testing/component-harnesses-overview",
    "title": "Component harnesses overview • Angular",
    "chunk": "ty Contribute Code of Conduct Report Issues Google's DevLibrary Angular Google Developer Experts ResourcesPress KitRoadmapLanguages简体中文版正體中文版日本語版한국어 Ελληνικά Super-powered by Google ©2010-2025. Code licensed under an MIT-style License . Documentation licensed under CC BY 4.0 .",
    "id": "component-harnesses-overview-*-angular-6"
  },
  {
    "url": "https://angular.dev/guide/testing/using-component-harnesses",
    "title": "Using component harnesses in tests • Angular",
    "chunk": "In-depth GuidesTesting Using component harnesses in tests On this pagearrow_upward_alt Back to the top Before you start TIP: This guide assumes you've already read the component harnesses overview guide. Read that first if you're new to using component harnesses. CDK Installation The Component Dev Kit (CDK) is a set of behavior primitives for building components. To use the component harnesses, first install @angular/cdk from npm. You can do this from your terminal using the Angular CLI: ng add ",
    "id": "using-component-harnesses-in-tests-*-angular-0"
  },
  {
    "url": "https://angular.dev/guide/testing/using-component-harnesses",
    "title": "Using component harnesses in tests • Angular",
    "chunk": "@angular/cdk Test harness environments and loaders You can use component test harnesses in different test environments. Angular CDK supports two built-in environments: Unit tests with Angular's TestBed End-to-end tests with WebDriver Each environment provides a harness loader. The loader creates the harness instances you use throughout your tests. See below for more specific guidance on supported testing environments. Additional testing environments require custom bindings. See the adding harnes",
    "id": "using-component-harnesses-in-tests-*-angular-1"
  },
  {
    "url": "https://angular.dev/guide/testing/using-component-harnesses",
    "title": "Using component harnesses in tests • Angular",
    "chunk": "s support for additional testing environments guide for more information. Using the loader from TestbedHarnessEnvironment for unit tests For unit tests you can create a harness loader from TestbedHarnessEnvironment. This environment uses a component fixture created by Angular's TestBed. To create a harness loader rooted at the fixture's root element, use the loader() method: const fixture = TestBed.createComponent(MyComponent);// Create a harness loader from the fixtureconst loader = TestbedHarn",
    "id": "using-component-harnesses-in-tests-*-angular-2"
  },
  {
    "url": "https://angular.dev/guide/testing/using-component-harnesses",
    "title": "Using component harnesses in tests • Angular",
    "chunk": "essEnvironment.loader(fixture);...// Use the loader to get harness instancesconst myComponentHarness = await loader.getHarness(MyComponent); To create a harness loader for harnesses for elements that fall outside the fixture, use the documentRootLoader() method. For example, code that displays a floating element or pop-up often attaches DOM elements directly to the document body, such as the Overlay service in Angular CDK. You can also create a harness loader directly with harnessForFixture() fo",
    "id": "using-component-harnesses-in-tests-*-angular-3"
  },
  {
    "url": "https://angular.dev/guide/testing/using-component-harnesses",
    "title": "Using component harnesses in tests • Angular",
    "chunk": "r a harness at that fixture's root element directly. Using the loader from SeleniumWebDriverHarnessEnvironment for end-to-end tests For WebDriver-based end-to-end tests you can create a harness loader with SeleniumWebDriverHarnessEnvironment. Use the loader() method to get the harness loader instance for the current HTML document, rooted at the document's root element. This environment uses a WebDriver client. let wd: webdriver.WebDriver = getMyWebDriverClient();const loader = SeleniumWebDriverH",
    "id": "using-component-harnesses-in-tests-*-angular-4"
  },
  {
    "url": "https://angular.dev/guide/testing/using-component-harnesses",
    "title": "Using component harnesses in tests • Angular",
    "chunk": "arnessEnvironment.loader(wd);...const myComponentHarness = await loader.getHarness(MyComponent); Using a harness loader Harness loader instances correspond to a specific DOM element and are used to create component harness instances for elements under that specific element. To get ComponentHarness for the first instance of the element, use the getHarness() method. To get all ComponentHarness instances, use the getAllHarnesses() method. // Get harness for first instance of the elementconst myComp",
    "id": "using-component-harnesses-in-tests-*-angular-5"
  },
  {
    "url": "https://angular.dev/guide/testing/using-component-harnesses",
    "title": "Using component harnesses in tests • Angular",
    "chunk": "onentHarness = await loader.getHarness(MyComponent);// Get harnesses for all instances of the elementconst myComponentHarnesses = await loader.getHarnesses(MyComponent); As an example, consider a reusable dialog-button component that opens a dialog on click. It contains the following components, each with a corresponding harness: MyDialogButton (composes the MyButton and MyDialog with a convenient API) MyButton (a standard button component) MyDialog (a dialog appended to document.body by MyDialo",
    "id": "using-component-harnesses-in-tests-*-angular-6"
  },
  {
    "url": "https://angular.dev/guide/testing/using-component-harnesses",
    "title": "Using component harnesses in tests • Angular",
    "chunk": "gButton upon click) The following test loads harnesses for each of these components: let fixture: ComponentFixture<MyDialogButton>;let loader: HarnessLoader;let rootLoader: HarnessLoader;beforeEach(() => { fixture = TestBed.createComponent(MyDialogButton); loader = TestbedHarnessEnvironment.loader(fixture); rootLoader = TestbedHarnessEnvironment.documentRootLoader(fixture);});it('loads harnesses', async () => { // Load a harness for the bootstrapped component with `harnessForFixture` dialogButto",
    "id": "using-component-harnesses-in-tests-*-angular-7"
  },
  {
    "url": "https://angular.dev/guide/testing/using-component-harnesses",
    "title": "Using component harnesses in tests • Angular",
    "chunk": "nHarness = await TestbedHarnessEnvironment.harnessForFixture(fixture, MyDialogButtonHarness); // The button element is inside the fixture's root element, so we use `loader`. const buttonHarness = await loader.getHarness(MyButtonHarness); // Click the button to open the dialog await buttonHarness.click(); // The dialog is appended to `document.body`, outside of the fixture's root element, // so we use `rootLoader` in this case. const dialogHarness = await rootLoader.getHarness(MyDialogHarness); /",
    "id": "using-component-harnesses-in-tests-*-angular-8"
  },
  {
    "url": "https://angular.dev/guide/testing/using-component-harnesses",
    "title": "Using component harnesses in tests • Angular",
    "chunk": "/ ... make some assertions}); Harness behavior in different environments Harnesses may not behave exactly the same in all environments. Some differences are unavoidable between the real user interaction versus the simulated events generated in unit tests. Angular CDK makes a best effort to normalize the behavior to the extent possible. Interacting with child elements To interact with elements below the root element of this harness loader, use the HarnessLoader instance of a child element. For th",
    "id": "using-component-harnesses-in-tests-*-angular-9"
  },
  {
    "url": "https://angular.dev/guide/testing/using-component-harnesses",
    "title": "Using component harnesses in tests • Angular",
    "chunk": "e first instance of the child element, use the getChildLoader() method. For all instances of the child element, use the getAllChildLoaders() method. const myComponentHarness = await loader.getHarness(MyComponent);// Get loader for first instance of child element with '.child' selectorconst childLoader = await myComponentHarness.getLoader('.child');// Get loaders for all instances of child elements with '.child' selectorconst allChildLoaders = await myComponentHarness.getAllChildLoaders('.child')",
    "id": "using-component-harnesses-in-tests-*-angular-10"
  },
  {
    "url": "https://angular.dev/guide/testing/using-component-harnesses",
    "title": "Using component harnesses in tests • Angular",
    "chunk": "; Filtering harnesses When a page contains multiple instances of a particular component, you may want to filter based on some property of the component to get a particular component instance. You can use a harness predicate, a class used to associate a ComponentHarness class with predicates functions that can be used to filter component instances, to do so. When you ask a HarnessLoader for a harness, you're actually providing a HarnessQuery. A query can be one of two things: A harness constructo",
    "id": "using-component-harnesses-in-tests-*-angular-11"
  },
  {
    "url": "https://angular.dev/guide/testing/using-component-harnesses",
    "title": "Using component harnesses in tests • Angular",
    "chunk": "r. This just gets that harness A HarnessPredicate, which gets harnesses that are filtered based on one or more conditions HarnessPredicate does support some base filters (selector, ancestor) that work on anything that extends ComponentHarness. // Example of loading a MyButtonComponentHarness with a harness predicateconst disabledButtonPredicate = new HarnessPredicate(MyButtonComponentHarness, {selector: '[disabled]'});const disabledButton = await loader.getHarness(disabledButtonPredicate); Howev",
    "id": "using-component-harnesses-in-tests-*-angular-12"
  },
  {
    "url": "https://angular.dev/guide/testing/using-component-harnesses",
    "title": "Using component harnesses in tests • Angular",
    "chunk": "er it's common for harnesses to implement a static with() method that accepts component-specific filtering options and returns a HarnessPredicate. // Example of loading a MyButtonComponentHarness with a specific selectorconst button = await loader.getHarness(MyButtonComponentHarness.with({selector: 'btn'})) For more details refer to the specific harness documentation since additional filtering options are specific to each harness implementation. Using test harness APIs While every harness define",
    "id": "using-component-harnesses-in-tests-*-angular-13"
  },
  {
    "url": "https://angular.dev/guide/testing/using-component-harnesses",
    "title": "Using component harnesses in tests • Angular",
    "chunk": "s an API specific to its corresponding component, they all share a common base class, ComponentHarness. This base class defines a static property, hostSelector, that matches the harness class to instances of the component in the DOM. Beyond that, the API of any given harness is specific to its corresponding component; refer to the component's documentation to learn how to use a specific harness. As an example, the following is a test for a component that uses the Angular Material slider componen",
    "id": "using-component-harnesses-in-tests-*-angular-14"
  },
  {
    "url": "https://angular.dev/guide/testing/using-component-harnesses",
    "title": "Using component harnesses in tests • Angular",
    "chunk": "t harness: it('should get value of slider thumb', async () => { const slider = await loader.getHarness(MatSliderHarness); const thumb = await slider.getEndThumb(); expect(await thumb.getValue()).toBe(50);}); Interop with Angular change detection By default, test harnesses runs Angular's change detection before reading the state of a DOM element and after interacting with a DOM element. There may be times that you need finer-grained control over change detection in your tests. such as checking th",
    "id": "using-component-harnesses-in-tests-*-angular-15"
  },
  {
    "url": "https://angular.dev/guide/testing/using-component-harnesses",
    "title": "Using component harnesses in tests • Angular",
    "chunk": "e state of a component while an async operation is pending. In these cases use the manualChangeDetection function to disable automatic handling of change detection for a block of code. it('checks state while async action is in progress', async () => { const buttonHarness = loader.getHarness(MyButtonHarness); await manualChangeDetection(async () => { await buttonHarness.click(); fixture.detectChanges(); // Check expectations while async click operation is in progress. expect(isProgressSpinnerVisi",
    "id": "using-component-harnesses-in-tests-*-angular-16"
  },
  {
    "url": "https://angular.dev/guide/testing/using-component-harnesses",
    "title": "Using component harnesses in tests • Angular",
    "chunk": "ble()).toBe(true); await fixture.whenStable(); // Check expectations after async click operation complete. expect(isProgressSpinnerVisible()).toBe(false); });}); Almost all harness methods are asynchronous and return a Promise to support the following: Support for unit tests Support for end-to-end tests Insulate tests against changes in asynchronous behavior The Angular team recommends using await to improve the test readability. Calling await blocks the execution of your test until the associat",
    "id": "using-component-harnesses-in-tests-*-angular-17"
  },
  {
    "url": "https://angular.dev/guide/testing/using-component-harnesses",
    "title": "Using component harnesses in tests • Angular",
    "chunk": "ed Promise resolves. Occasionally, you may want to perform multiple actions simultaneously and wait until they're all done rather than performing each action sequentially. For example, read multiple properties of a single component. In these situations use the parallel function to parallelize the operations. The parallel function works similarly to Promise.all, while also optimizing change detection checks. it('reads properties in parallel', async () => { const checkboxHarness = loader.getHarnes",
    "id": "using-component-harnesses-in-tests-*-angular-18"
  },
  {
    "url": "https://angular.dev/guide/testing/using-component-harnesses",
    "title": "Using component harnesses in tests • Angular",
    "chunk": "s(MyCheckboxHarness); // Read the checked and intermediate properties simultaneously. const [checked, indeterminate] = await parallel(() => [ checkboxHarness.isChecked(), checkboxHarness.isIndeterminate() ]); expect(checked).toBe(false); expect(indeterminate).toBe(true);}); Social MediaBlogX (formerly Twitter)BlueskyYouTube Discord GitHub Stack Overflow Community Contribute Code of Conduct Report Issues Google's DevLibrary Angular Google Developer Experts ResourcesPress KitRoadmapLanguages简体中文版正",
    "id": "using-component-harnesses-in-tests-*-angular-19"
  },
  {
    "url": "https://angular.dev/guide/testing/using-component-harnesses",
    "title": "Using component harnesses in tests • Angular",
    "chunk": "體中文版日本語版한국어 Ελληνικά Super-powered by Google ©2010-2025. Code licensed under an MIT-style License . Documentation licensed under CC BY 4.0 .",
    "id": "using-component-harnesses-in-tests-*-angular-20"
  },
  {
    "url": "https://angular.dev/guide/testing/creating-component-harnesses",
    "title": "Creating harnesses for your components • Angular",
    "chunk": "In-depth GuidesTesting Creating harnesses for your components On this pagearrow_upward_alt Back to the top Before you start TIP: This guide assumes you've already read the component harnesses overview guide. Read that first if you're new to using component harnesses. When does creating a test harness make sense? The Angular team recommends creating component test harnesses for shared components that are used in many places and have some user interactivity. This most commonly applies to widget li",
    "id": "creating-harnesses-for-your-components-*-angular-0"
  },
  {
    "url": "https://angular.dev/guide/testing/creating-component-harnesses",
    "title": "Creating harnesses for your components • Angular",
    "chunk": "braries and similar reusable components. Harnesses are valuable for these cases because they provide the consumers of these shared components a well- supported API for interacting with a component. Tests that use harnesses can avoid depending on unreliable implementation details of these shared components, such as DOM structure and specific event listeners. For components that appear in only one place, such as a page in an application, harnesses don't provide as much benefit. In these situations",
    "id": "creating-harnesses-for-your-components-*-angular-1"
  },
  {
    "url": "https://angular.dev/guide/testing/creating-component-harnesses",
    "title": "Creating harnesses for your components • Angular",
    "chunk": ", a component's tests can reasonably depend on the implementation details of this component, as the tests and components are updated at the same time. However, harnesses still provide some value if you would use the harness in both unit and end-to-end tests. CDK Installation The Component Dev Kit (CDK) is a set of behavior primitives for building components. To use the component harnesses, first install @angular/cdk from npm. You can do this from your terminal using the Angular CLI: ng add @angu",
    "id": "creating-harnesses-for-your-components-*-angular-2"
  },
  {
    "url": "https://angular.dev/guide/testing/creating-component-harnesses",
    "title": "Creating harnesses for your components • Angular",
    "chunk": "lar/cdk Extending ComponentHarness The abstract ComponentHarness class is the base class for all component harnesses. To create a custom component harness, extend ComponentHarness and implement the static property hostSelector. The hostSelector property identifies elements in the DOM that match this harness subclass. In most cases, the hostSelector should be the same as the selector of the corresponding Component or Directive. For example, consider a simple popup component: @Component({ selector",
    "id": "creating-harnesses-for-your-components-*-angular-3"
  },
  {
    "url": "https://angular.dev/guide/testing/creating-component-harnesses",
    "title": "Creating harnesses for your components • Angular",
    "chunk": ": 'my-popup', template: ` <button (click)=\"toggle()\">{{triggerText()}}</button> @if (isOpen()) { <div class=\"my-popup-content\"><ng-content></ng-content></div> } `})class MyPopup { triggerText = input(''); isOpen = signal(false); toggle() { this.isOpen.update((value) => !value); }} In this case, a minimal harness for the component would look like the following: class MyPopupHarness extends ComponentHarness { static hostSelector = 'my-popup';} While ComponentHarness subclasses require only the hos",
    "id": "creating-harnesses-for-your-components-*-angular-4"
  },
  {
    "url": "https://angular.dev/guide/testing/creating-component-harnesses",
    "title": "Creating harnesses for your components • Angular",
    "chunk": "tSelector property, most harnesses should also implement a static with method to generate HarnessPredicate instances. The filtering harnesses section covers this in more detail. Finding elements in the component's DOM Each instance of a ComponentHarness subclass represents a particular instance of the corresponding component. You can access the component's host element via the host() method from the ComponentHarness base class. ComponentHarness also offers several methods for locating elements w",
    "id": "creating-harnesses-for-your-components-*-angular-5"
  },
  {
    "url": "https://angular.dev/guide/testing/creating-component-harnesses",
    "title": "Creating harnesses for your components • Angular",
    "chunk": "ithin the component's DOM. These methods are locatorFor(), locatorForOptional(), and locatorForAll(). These methods create functions that find elements, they do not directly find elements. This approach safeguards against caching references to out-of-date elements. For example, when an @if block hides and then shows an element, the result is a new DOM element; using functions ensures that tests always reference the current state of the DOM. See the ComponentHarness API reference page for the ful",
    "id": "creating-harnesses-for-your-components-*-angular-6"
  },
  {
    "url": "https://angular.dev/guide/testing/creating-component-harnesses",
    "title": "Creating harnesses for your components • Angular",
    "chunk": "l list details of the different locatorFor methods. For example, the MyPopupHarness example discussed above could provide methods to get the trigger and content elements as follows: class MyPopupHarness extends ComponentHarness { static hostSelector = 'my-popup'; // Gets the trigger element getTriggerElement = this.locatorFor('button'); // Gets the content element. getContentElement = this.locatorForOptional('.my-popup-content');} Working with TestElement instances TestElement is an abstraction ",
    "id": "creating-harnesses-for-your-components-*-angular-7"
  },
  {
    "url": "https://angular.dev/guide/testing/creating-component-harnesses",
    "title": "Creating harnesses for your components • Angular",
    "chunk": "designed to work across different test environments (Unit tests, WebDriver, etc). When using harnesses, you should perform all DOM interaction via this interface. Other means of accessing DOM elements, such as document.querySelector(), do not work in all test environments. TestElement has a number of methods to interact with the underlying DOM, such as blur(), click(), getAttribute(), and more. See the TestElement API reference page for the full list of methods. Do not expose TestElement instanc",
    "id": "creating-harnesses-for-your-components-*-angular-8"
  },
  {
    "url": "https://angular.dev/guide/testing/creating-component-harnesses",
    "title": "Creating harnesses for your components • Angular",
    "chunk": "es to harness users unless it's an element the component consumer defines directly, such as the component's host element. Exposing TestElement instances for internal elements leads users to depend on a component's internal DOM structure. Instead, provide more narrow-focused methods for specific actions the end-user may take or particular state they may observe. For example, MyPopupHarness from previous sections could provide methods like toggle and isOpen: class MyPopupHarness extends ComponentH",
    "id": "creating-harnesses-for-your-components-*-angular-9"
  },
  {
    "url": "https://angular.dev/guide/testing/creating-component-harnesses",
    "title": "Creating harnesses for your components • Angular",
    "chunk": "arness { static hostSelector = 'my-popup'; protected getTriggerElement = this.locatorFor('button'); protected getContentElement = this.locatorForOptional('.my-popup-content'); /** Toggles the open state of the popup. */ async toggle() { const trigger = await this.getTriggerElement(); return trigger.click(); } /** Checks if the popup us open. */ async isOpen() { const content = await this.getContentElement(); return !!content; }} Loading harnesses for subcomponents Larger components often compose",
    "id": "creating-harnesses-for-your-components-*-angular-10"
  },
  {
    "url": "https://angular.dev/guide/testing/creating-component-harnesses",
    "title": "Creating harnesses for your components • Angular",
    "chunk": " sub-components. You can reflect this structure in a component's harness as well. Each of the locatorFor methods on ComponentHarness has an alternate signature that can be used for locating sub-harnesses rather than elements. See the ComponentHarness API reference page for the full list of the different locatorFor methods. For example, consider a menu build using the popup from above: @Directive({ selector: 'my-menu-item'})class MyMenuItem {}@Component({ selector: 'my-menu', template: ` <my-popu",
    "id": "creating-harnesses-for-your-components-*-angular-11"
  },
  {
    "url": "https://angular.dev/guide/testing/creating-component-harnesses",
    "title": "Creating harnesses for your components • Angular",
    "chunk": "p> <ng-content></ng-content> </my-popup> `})class MyMenu { triggerText = input(''); @ContentChildren(MyMenuItem) items: QueryList<MyMenuItem>;} The harness for MyMenu can then take advantage of other harnesses for MyPopup and MyMenuItem: class MyMenuHarness extends ComponentHarness { static hostSelector = 'my-menu'; protected getPopupHarness = this.locatorFor(MyPopupHarness); /** Gets the currently shown menu items (empty list if menu is closed). */ getItems = this.locatorForAll(MyMenuItemHarnes",
    "id": "creating-harnesses-for-your-components-*-angular-12"
  },
  {
    "url": "https://angular.dev/guide/testing/creating-component-harnesses",
    "title": "Creating harnesses for your components • Angular",
    "chunk": "s); /** Toggles open state of the menu. */ async toggle() { const popupHarness = await this.getPopupHarness(); return popupHarness.toggle(); }}class MyMenuItemHarness extends ComponentHarness { static hostSelector = 'my-menu-item';} Filtering harness instances with HarnessPredicate When a page contains multiple instances of a particular component, you may want to filter based on some property of the component to get a particular component instance. For example, you may want a button with some sp",
    "id": "creating-harnesses-for-your-components-*-angular-13"
  },
  {
    "url": "https://angular.dev/guide/testing/creating-component-harnesses",
    "title": "Creating harnesses for your components • Angular",
    "chunk": "ecific text, or a menu with a specific ID. The HarnessPredicate class can capture criteria like this for a ComponentHarness subclass. While the test author is able to construct HarnessPredicate instances manually, it's easier when the ComponentHarness subclass provides a helper method to construct predicates for common filters. You should create a static with() method on each ComponentHarness subclass that returns a HarnessPredicate for that class. This allows test authors to write easily unders",
    "id": "creating-harnesses-for-your-components-*-angular-14"
  },
  {
    "url": "https://angular.dev/guide/testing/creating-component-harnesses",
    "title": "Creating harnesses for your components • Angular",
    "chunk": "tandable code, e.g. loader.getHarness(MyMenuHarness.with({selector: '#menu1'})). In addition to the standard selector and ancestor options, the with method should add any other options that make sense for the particular subclass. Harnesses that need to add additional options should extend the BaseHarnessFilters interface and additional optional properties as needed. HarnessPredicate provides several convenience methods for adding options: stringMatches(), addOption(), and add(). See the HarnessP",
    "id": "creating-harnesses-for-your-components-*-angular-15"
  },
  {
    "url": "https://angular.dev/guide/testing/creating-component-harnesses",
    "title": "Creating harnesses for your components • Angular",
    "chunk": "redicate API page for the full description. For example, when working with a menu it is useful to filter based on trigger text and to filter menu items based on their text: interface MyMenuHarnessFilters extends BaseHarnessFilters { /** Filters based on the trigger text for the menu. */ triggerText?: string | RegExp;}interface MyMenuItemHarnessFilters extends BaseHarnessFilters { /** Filters based on the text of the menu item. */ text?: string | RegExp;}class MyMenuHarness extends ComponentHarne",
    "id": "creating-harnesses-for-your-components-*-angular-16"
  },
  {
    "url": "https://angular.dev/guide/testing/creating-component-harnesses",
    "title": "Creating harnesses for your components • Angular",
    "chunk": "ss { static hostSelector = 'my-menu'; /** Creates a `HarnessPredicate` used to locate a particular `MyMenuHarness`. */ static with(options: MyMenuHarnessFilters): HarnessPredicate<MyMenuHarness> { return new HarnessPredicate(MyMenuHarness, options) .addOption('trigger text', options.triggerText, (harness, text) => HarnessPredicate.stringMatches(harness.getTriggerText(), text)); } protected getPopupHarness = this.locatorFor(MyPopupHarness); /** Gets the text of the menu trigger. */ async getTrigg",
    "id": "creating-harnesses-for-your-components-*-angular-17"
  },
  {
    "url": "https://angular.dev/guide/testing/creating-component-harnesses",
    "title": "Creating harnesses for your components • Angular",
    "chunk": "erText(): Promise<string> { const popupHarness = await this.getPopupHarness(); return popupHarness.getTriggerText(); } ...}class MyMenuItemHarness extends ComponentHarness { static hostSelector = 'my-menu-item'; /** Creates a `HarnessPredicate` used to locate a particular `MyMenuItemHarness`. */ static with(options: MyMenuItemHarnessFilters): HarnessPredicate<MyMenuItemHarness> { return new HarnessPredicate(MyMenuItemHarness, options) .addOption('text', options.text, (harness, text) => HarnessPr",
    "id": "creating-harnesses-for-your-components-*-angular-18"
  },
  {
    "url": "https://angular.dev/guide/testing/creating-component-harnesses",
    "title": "Creating harnesses for your components • Angular",
    "chunk": "edicate.stringMatches(harness.getText(), text)); } /** Gets the text of the menu item. */ async getText(): Promise<string> { const host = await this.host(); return host.text(); }} You can pass a HarnessPredicate instead of a ComponentHarness class to any of the APIs on HarnessLoader, LocatorFactory, or ComponentHarness. This allows test authors to easily target a particular component instance when creating a harness instance. It also allows the harness author to leverage the same HarnessPredicat",
    "id": "creating-harnesses-for-your-components-*-angular-19"
  },
  {
    "url": "https://angular.dev/guide/testing/creating-component-harnesses",
    "title": "Creating harnesses for your components • Angular",
    "chunk": "e to enable more powerful APIs on their harness class. For example, consider the getItems method on the MyMenuHarness shown above. Adding a filtering API allows users of the harness to search for particular menu items: class MyMenuHarness extends ComponentHarness { static hostSelector = 'my-menu'; /** Gets a list of items in the menu, optionally filtered based on the given criteria. */ async getItems(filters: MyMenuItemHarnessFilters = {}): Promise<MyMenuItemHarness[]> { const getFilteredItems =",
    "id": "creating-harnesses-for-your-components-*-angular-20"
  },
  {
    "url": "https://angular.dev/guide/testing/creating-component-harnesses",
    "title": "Creating harnesses for your components • Angular",
    "chunk": " this.locatorForAll(MyMenuItemHarness.with(filters)); return getFilteredItems(); } ...} Creating HarnessLoader for elements that use content projection Some components project additional content into the component's template. See the content projection guide for more information. Add a HarnessLoader instance scoped to the element containing the <ng-content> when you create a harness for a component that uses content projection. This allows the user of the harness to load additional harnesses for",
    "id": "creating-harnesses-for-your-components-*-angular-21"
  },
  {
    "url": "https://angular.dev/guide/testing/creating-component-harnesses",
    "title": "Creating harnesses for your components • Angular",
    "chunk": " whatever components were passed in as content. ComponentHarness has several methods that can be used to create HarnessLoader instances for cases like this: harnessLoaderFor(), harnessLoaderForOptional(), harnessLoaderForAll(). See the HarnessLoader interface API reference page for more details. For example, the MyPopupHarness example from above can extend ContentContainerComponentHarness to add support to load harnesses within the <ng-content> of the component. class MyPopupHarness extends Cont",
    "id": "creating-harnesses-for-your-components-*-angular-22"
  },
  {
    "url": "https://angular.dev/guide/testing/creating-component-harnesses",
    "title": "Creating harnesses for your components • Angular",
    "chunk": "entContainerComponentHarness<string> { static hostSelector = 'my-popup';} Accessing elements outside of the component's host element There are times when a component harness might need to access elements outside of its corresponding component's host element. For example, code that displays a floating element or pop-up often attaches DOM elements directly to the document body, such as the Overlay service in Angular CDK. In this case, ComponentHarness provides a method that can be used to get a Lo",
    "id": "creating-harnesses-for-your-components-*-angular-23"
  },
  {
    "url": "https://angular.dev/guide/testing/creating-component-harnesses",
    "title": "Creating harnesses for your components • Angular",
    "chunk": "catorFactory for the root element of the document. The LocatorFactory supports most of the same APIs as the ComponentHarness base class, and can then be used to query relative to the document's root element. Consider if the MyPopup component above used the CDK overlay for the popup content, rather than an element in its own template. In this case, MyPopupHarness would have to access the content element via documentRootLocatorFactory() method that gets a locator factory rooted at the document roo",
    "id": "creating-harnesses-for-your-components-*-angular-24"
  },
  {
    "url": "https://angular.dev/guide/testing/creating-component-harnesses",
    "title": "Creating harnesses for your components • Angular",
    "chunk": "t. class MyPopupHarness extends ComponentHarness { static hostSelector = 'my-popup'; /** Gets a `HarnessLoader` whose root element is the popup's content element. */ async getHarnessLoaderForContent(): Promise<HarnessLoader> { const rootLocator = this.documentRootLocatorFactory(); return rootLocator.harnessLoaderFor('my-popup-content'); }} Waiting for asynchronous tasks The methods on TestElement automatically trigger Angular's change detection and wait for tasks inside the NgZone. In most cases",
    "id": "creating-harnesses-for-your-components-*-angular-25"
  },
  {
    "url": "https://angular.dev/guide/testing/creating-component-harnesses",
    "title": "Creating harnesses for your components • Angular",
    "chunk": " no special effort is required for harness authors to wait on asynchronous tasks. However, there are some edge cases where this may not be sufficient. Under some circumstances, Angular animations may require a second cycle of change detection and subsequent NgZone stabilization before animation events are fully flushed. In cases where this is needed, the ComponentHarness offers a forceStabilize() method that can be called to do the second round. You can use NgZone.runOutsideAngular() to schedule",
    "id": "creating-harnesses-for-your-components-*-angular-26"
  },
  {
    "url": "https://angular.dev/guide/testing/creating-component-harnesses",
    "title": "Creating harnesses for your components • Angular",
    "chunk": " tasks outside of NgZone. Call the waitForTasksOutsideAngular() method on the corresponding harness if you need to explicitly wait for tasks outside NgZone since this does not happen automatically. Social MediaBlogX (formerly Twitter)BlueskyYouTube Discord GitHub Stack Overflow Community Contribute Code of Conduct Report Issues Google's DevLibrary Angular Google Developer Experts ResourcesPress KitRoadmapLanguages简体中文版正體中文版日本語版한국어 Ελληνικά Super-powered by Google ©2010-2025. Code licensed under ",
    "id": "creating-harnesses-for-your-components-*-angular-27"
  },
  {
    "url": "https://angular.dev/guide/testing/creating-component-harnesses",
    "title": "Creating harnesses for your components • Angular",
    "chunk": "an MIT-style License . Documentation licensed under CC BY 4.0 .",
    "id": "creating-harnesses-for-your-components-*-angular-28"
  },
  {
    "url": "https://angular.dev/guide/animations/css",
    "title": "Animating your content • Angular",
    "chunk": "In-depth GuidesAnimations Animating your Application with CSS CSS offers a robust set of tools for you to create beautiful and engaging animations within your application. On this pagearrow_upward_alt Back to the top How to write animations in native CSS If you've never written any native CSS animations, there are a number of excellent guides to get you started. Here's a few of them:MDN's CSS Animations guideW3Schools CSS3 Animations guideThe Complete CSS Animations TutorialCSS Animation for Beg",
    "id": "animating-your-content-*-angular-0"
  },
  {
    "url": "https://angular.dev/guide/animations/css",
    "title": "Animating your content • Angular",
    "chunk": "inners and a couple of videos:Learn CSS Animation in 9 MinutesNet Ninja CSS Animation Tutorial Playlist Check some of these various guides and tutorials out, and then come back to this guide. Creating Reusable Animations You can create reusable animations that can be shared across your application using @keyframes. Define keyframe animations in a shared CSS file, and you'll be able to re-use those keyframe animations wherever you want within your application. src/app/animations.css @keyframes sh",
    "id": "animating-your-content-*-angular-1"
  },
  {
    "url": "https://angular.dev/guide/animations/css",
    "title": "Animating your content • Angular",
    "chunk": "aredAnimation { to { height: 0; opacity: 1; background-color: 'red'; }}.animated-class { animation: sharedAnimation 1s;}.open { height: '200px'; opacity: 1; background-color: 'yellow'; transition: all 1s;}.closed { height: '100px'; opacity: 0.8; background-color: 'blue'; transition: all 1s;}.example-element { animation-duration: 1s; animation-delay: 500ms; animation-timing-function: ease-in-out;}.example-shorthand { animation: exampleAnimation 1s ease-in-out 500ms;}.example-element { transition-",
    "id": "animating-your-content-*-angular-2"
  },
  {
    "url": "https://angular.dev/guide/animations/css",
    "title": "Animating your content • Angular",
    "chunk": "duration: 1s; transition-delay: 500ms; transition-timing-function: ease-in-out; transition-property: margin-right;}.example-shorthand { transition: margin-right 1s ease-in-out 500ms;} Adding the class animated-class to an element would trigger the animation on that element. Animating a Transition Animating State and Styles You may want to animate between two different states, for example when an element is opened or closed. You can accomplish this by using CSS classes either using a keyframe ani",
    "id": "animating-your-content-*-angular-3"
  },
  {
    "url": "https://angular.dev/guide/animations/css",
    "title": "Animating your content • Angular",
    "chunk": "mation or transition styling. src/app/animations.css @keyframes sharedAnimation { to { height: 0; opacity: 1; background-color: 'red'; }}.animated-class { animation: sharedAnimation 1s;}.open { height: '200px'; opacity: 1; background-color: 'yellow'; transition: all 1s;}.closed { height: '100px'; opacity: 0.8; background-color: 'blue'; transition: all 1s;}.example-element { animation-duration: 1s; animation-delay: 500ms; animation-timing-function: ease-in-out;}.example-shorthand { animation: exa",
    "id": "animating-your-content-*-angular-4"
  },
  {
    "url": "https://angular.dev/guide/animations/css",
    "title": "Animating your content • Angular",
    "chunk": "mpleAnimation 1s ease-in-out 500ms;}.example-element { transition-duration: 1s; transition-delay: 500ms; transition-timing-function: ease-in-out; transition-property: margin-right;}.example-shorthand { transition: margin-right 1s ease-in-out 500ms;} Triggering the open or closed state is done by toggling classes on the element in your component. You can find examples of how to do this in our template guide. You can see similar examples in the template guide for animating styles directly. Transit",
    "id": "animating-your-content-*-angular-5"
  },
  {
    "url": "https://angular.dev/guide/animations/css",
    "title": "Animating your content • Angular",
    "chunk": "ions, Timing, and Easing Animating often requires adjusting timing, delays and easeing behaviors. This can be done using several css properties or shorthand properties. Specify animation-duration, animation-delay, and animation-timing-function for a keyframe animation in CSS, or alternatively use the animation shorthand property. src/app/animations.css @keyframes sharedAnimation { to { height: 0; opacity: 1; background-color: 'red'; }}.animated-class { animation: sharedAnimation 1s;}.open { heig",
    "id": "animating-your-content-*-angular-6"
  },
  {
    "url": "https://angular.dev/guide/animations/css",
    "title": "Animating your content • Angular",
    "chunk": "ht: '200px'; opacity: 1; background-color: 'yellow'; transition: all 1s;}.closed { height: '100px'; opacity: 0.8; background-color: 'blue'; transition: all 1s;}.example-element { animation-duration: 1s; animation-delay: 500ms; animation-timing-function: ease-in-out;}.example-shorthand { animation: exampleAnimation 1s ease-in-out 500ms;}.example-element { transition-duration: 1s; transition-delay: 500ms; transition-timing-function: ease-in-out; transition-property: margin-right;}.example-shorthan",
    "id": "animating-your-content-*-angular-7"
  },
  {
    "url": "https://angular.dev/guide/animations/css",
    "title": "Animating your content • Angular",
    "chunk": "d { transition: margin-right 1s ease-in-out 500ms;} Similarly, you can use transition-duration, transition-delay, and transition-timing-function and the transition shorthand for animations that are not using @keyframes. src/app/animations.css @keyframes sharedAnimation { to { height: 0; opacity: 1; background-color: 'red'; }}.animated-class { animation: sharedAnimation 1s;}.open { height: '200px'; opacity: 1; background-color: 'yellow'; transition: all 1s;}.closed { height: '100px'; opacity: 0.8",
    "id": "animating-your-content-*-angular-8"
  },
  {
    "url": "https://angular.dev/guide/animations/css",
    "title": "Animating your content • Angular",
    "chunk": "; background-color: 'blue'; transition: all 1s;}.example-element { animation-duration: 1s; animation-delay: 500ms; animation-timing-function: ease-in-out;}.example-shorthand { animation: exampleAnimation 1s ease-in-out 500ms;}.example-element { transition-duration: 1s; transition-delay: 500ms; transition-timing-function: ease-in-out; transition-property: margin-right;}.example-shorthand { transition: margin-right 1s ease-in-out 500ms;} Triggering an Animation Animations can be triggered by toggl",
    "id": "animating-your-content-*-angular-9"
  },
  {
    "url": "https://angular.dev/guide/animations/css",
    "title": "Animating your content • Angular",
    "chunk": "ing CSS styles or classes. Once a class is present on an element, the animation will occur. Removing the class will revert the element back to whatever CSS is defined for that element. Here's an example: src/app/open-close.component.ts import {Component, signal} from '@angular/core';@Component({ selector: 'app-open-close', templateUrl: 'open-close.component.html', styleUrls: ['open-close.component.css'],})export class OpenCloseComponent { isOpen = signal(true); toggle() { this.isOpen.update((isO",
    "id": "animating-your-content-*-angular-10"
  },
  {
    "url": "https://angular.dev/guide/animations/css",
    "title": "Animating your content • Angular",
    "chunk": "pen) => !isOpen); }} src/app/open-close.component.html <h2>Open / Close Example</h2><button type=\"button\" (click)=\"toggle()\">Toggle Open/Close</button><div class=\"open-close-container\" [class.open]=\"isOpen()\"> <p>The box is now {{ isOpen() ? 'Open' : 'Closed' }}!</p></div> src/app/open-close.component.css :host { display: block; margin-top: 1rem;}.open-close-container { border: 1px solid #dddddd; margin-top: 1em; padding: 20px 20px 0px 20px; font-weight: bold; font-size: 20px; height: 100px; opa",
    "id": "animating-your-content-*-angular-11"
  },
  {
    "url": "https://angular.dev/guide/animations/css",
    "title": "Animating your content • Angular",
    "chunk": "city: 0.8; background-color: blue; color: #ebebeb; transition-property: height, opacity, background-color, color; transition-duration: 1s;}.open { transition-duration: 0.5s; height: 200px; opacity: 1; background-color: yellow; color: #000000;} Transition and Triggers Animating Auto Height You can use css-grid to animate to auto height. src/app/auto-height.component.ts import {Component, signal} from '@angular/core';@Component({ selector: 'app-auto-height', templateUrl: 'auto-height.component.htm",
    "id": "animating-your-content-*-angular-12"
  },
  {
    "url": "https://angular.dev/guide/animations/css",
    "title": "Animating your content • Angular",
    "chunk": "l', styleUrls: ['auto-height.component.css'],})export class AutoHeightComponent { isOpen = signal(true); toggle() { this.isOpen.update((isOpen) => !isOpen); }} src/app/auto-height.component.html <h2>Auto Height Example</h2><button type=\"button\" (click)=\"toggle()\">Toggle Open/Close</button><div class=\"container\" [class.open]=\"isOpen()\"> <div class=\"content\"> <p>The box is now {{ isOpen() ? 'Open' : 'Closed' }}!</p> </div></div> src/app/auto-height.component.css .container { display: grid; grid-te",
    "id": "animating-your-content-*-angular-13"
  },
  {
    "url": "https://angular.dev/guide/animations/css",
    "title": "Animating your content • Angular",
    "chunk": "mplate-rows: 0fr; overflow: hidden; transition: grid-template-rows 1s;}.container.open { grid-template-rows: 1fr;}.container .content { min-height: 0; transition: visibility 1s; padding: 0 20px; visibility: hidden; margin-top: 1em; font-weight: bold; font-size: 20px; background-color: blue; color: #ebebeb; overflow: hidden;}.container.open .content { visibility: visible;} If you don't have to worry about supporting all browsers, you can also check out calc-size(), which is the true solution to a",
    "id": "animating-your-content-*-angular-14"
  },
  {
    "url": "https://angular.dev/guide/animations/css",
    "title": "Animating your content • Angular",
    "chunk": "nimating auto height. See MDN's docs and (this tutorial)[https://frontendmasters.com/blog/one-of-the-boss-battles-of-css-is-almost-won-transitioning-to-auto/] for more information. Animate entering and leaving a view You can create animations for when an item enters a view or leaves a view. Let's start by looking at how to animate an element leaving a view. src/app/insert.component.ts import {Component, signal} from '@angular/core';@Component({ selector: 'app-insert', templateUrl: 'insert.compon",
    "id": "animating-your-content-*-angular-15"
  },
  {
    "url": "https://angular.dev/guide/animations/css",
    "title": "Animating your content • Angular",
    "chunk": "ent.html', styleUrls: ['insert.component.css'],})export class InsertComponent { isShown = signal(false); toggle() { this.isShown.update((isShown) => !isShown); }} src/app/insert.component.html <h2>Insert Element Example</h2><nav> <button type=\"button\" (click)=\"toggle()\">Toggle Element</button></nav>@if (isShown()) { <div class=\"insert-container\"> <p>The box is inserted</p> </div>} src/app/insert.component.css :host { display: block;}.insert-container { border: 1px solid #dddddd; margin-top: 1em;",
    "id": "animating-your-content-*-angular-16"
  },
  {
    "url": "https://angular.dev/guide/animations/css",
    "title": "Animating your content • Angular",
    "chunk": " padding: 20px 20px 0px 20px; color: #000000; font-weight: bold; font-size: 20px; opacity: 1; transition: opacity 1s ease-out, transform 1s ease-out; @starting-style { opacity: 0; transform: translateY(20px); }} Leaving a view is slightly more complex. The element removal needs to be delayed until the exit animation is complete. This requires a bit of extra code in your component class to accomplish. src/app/remove.component.ts import {Component, ElementRef, inject, signal} from '@angular/core';",
    "id": "animating-your-content-*-angular-17"
  },
  {
    "url": "https://angular.dev/guide/animations/css",
    "title": "Animating your content • Angular",
    "chunk": "@Component({ selector: 'app-remove', templateUrl: 'remove.component.html', styleUrls: ['remove.component.css'],})export class RemoveComponent { isShown = signal(false); deleting = signal(false); private el = inject(ElementRef); toggle() { if (this.isShown()) { const target = this.el.nativeElement.querySelector('.insert-container'); target.addEventListener('transitionend', () => this.hide()); this.deleting.set(true); } else { this.isShown.update((isShown) => !isShown); } } hide() { this.isShown.s",
    "id": "animating-your-content-*-angular-18"
  },
  {
    "url": "https://angular.dev/guide/animations/css",
    "title": "Animating your content • Angular",
    "chunk": "et(false); this.deleting.set(false); }} src/app/remove.component.html <h2>Remove Element Example</h2><nav> <button type=\"button\" (click)=\"toggle()\">Toggle Element</button></nav>@if (isShown()) { <div class=\"insert-container\" [class.deleting]=\"deleting()\"> <p>The box is inserted</p> </div>} src/app/remove.component.css :host { display: block;}.insert-container { border: 1px solid #dddddd; margin-top: 1em; padding: 20px 20px 0px 20px; color: #000000; font-weight: bold; font-size: 20px; opacity: 1;",
    "id": "animating-your-content-*-angular-19"
  },
  {
    "url": "https://angular.dev/guide/animations/css",
    "title": "Animating your content • Angular",
    "chunk": " transition: opacity 200ms ease-in; @starting-style { opacity: 0; }}.deleting { opacity: 0; transform: translateY(20px); transition: opacity 500ms ease-out, transform 500ms ease-out;} Animating increment and decrement Animating on increment and decrement is a common pattern in applications. Here's an example of how you can accomplish that behavior. src/app/increment-decrement.component.ts import {Component, ElementRef, OnInit, signal, viewChild} from '@angular/core';@Component({ selector: 'app-i",
    "id": "animating-your-content-*-angular-20"
  },
  {
    "url": "https://angular.dev/guide/animations/css",
    "title": "Animating your content • Angular",
    "chunk": "ncrement-decrement', templateUrl: 'increment-decrement.component.html', styleUrls: ['increment-decrement.component.css'],})export class IncrementDecrementComponent implements OnInit { num = signal(0); el = viewChild<ElementRef<HTMLParagraphElement>>('el'); ngOnInit() { this.el()?.nativeElement.addEventListener('animationend', (ev) => { if (ev.animationName.endsWith('decrement') || ev.animationName.endsWith('increment')) { this.animationFinished(); } }); } modify(n: number) { const targetClass = ",
    "id": "animating-your-content-*-angular-21"
  },
  {
    "url": "https://angular.dev/guide/animations/css",
    "title": "Animating your content • Angular",
    "chunk": "n > 0 ? 'increment' : 'decrement'; this.num.update((v) => (v += n)); this.el()?.nativeElement.classList.add(targetClass); } animationFinished() { this.el()?.nativeElement.classList.remove('increment', 'decrement'); } ngOnDestroy() { this.el()?.nativeElement.removeEventListener('animationend', this.animationFinished); }} src/app/increment-decrement.component.html <h3>Increment and Decrement Example</h3><section> <p #el>Number {{ num() }}</p> <div class=\"controls\"> <button type=\"button\" (click)=\"m",
    "id": "animating-your-content-*-angular-22"
  },
  {
    "url": "https://angular.dev/guide/animations/css",
    "title": "Animating your content • Angular",
    "chunk": "odify(1)\">+</button> <button type=\"button\" (click)=\"modify(-1)\">-</button> </div></section> src/app/increment-decrement.component.css :host { display: block; font-size: 32px; margin: 20px; text-align: center;}section { border: 1px solid lightgray; border-radius: 50px;}p { display: inline-block; margin: 2rem 0; text-transform: uppercase;}.increment { animation: increment 300ms;}.decrement { animation: decrement 300ms;}.controls { padding-bottom: 2rem;}button { font: inherit; border: 0; background",
    "id": "animating-your-content-*-angular-23"
  },
  {
    "url": "https://angular.dev/guide/animations/css",
    "title": "Animating your content • Angular",
    "chunk": ": lightgray; width: 50px; border-radius: 10px;}button + button { margin-left: 10px;}@keyframes increment { 33% { color: green; transform: scale(1.3, 1.2); } 66% { color: green; transform: scale(1.2, 1.2); } 100% { transform: scale(1, 1); }}@keyframes decrement { 33% { color: red; transform: scale(0.8, 0.9); } 66% { color: red; transform: scale(0.9, 0.9); } 100% { transform: scale(1, 1); }} Disabling an animation or all animations If you'd like to disable the animations that you've specified, you",
    "id": "animating-your-content-*-angular-24"
  },
  {
    "url": "https://angular.dev/guide/animations/css",
    "title": "Animating your content • Angular",
    "chunk": " have multiple options. Create a custom class that forces animation and transition to none. .no-animation { animation: none !important; transition: none !important;} Applying this class to an element prevents any animation from firing on that element. You could alternatively scope this to your entire DOM or section of your DOM to enforce this behavior. However, this prevents animation events from firing. If you are awaiting animation events for element removal, this solution won't work. A workar",
    "id": "animating-your-content-*-angular-25"
  },
  {
    "url": "https://angular.dev/guide/animations/css",
    "title": "Animating your content • Angular",
    "chunk": "ound is to set durations to 1 millisecond instead. Use the prefers-reduced-motion media query to ensure no animations play for users that prefer less animation. Prevent adding animation classes programatically Animation Callbacks If you have actions you would like to execute at certain points during animations, there are a number of available events you can listen to. Here's a few of them. OnAnimationStartOnAnimationEndOnAnimationIterationOnAnimationCancel OnTransitionStartOnTransitionRunOnTrans",
    "id": "animating-your-content-*-angular-26"
  },
  {
    "url": "https://angular.dev/guide/animations/css",
    "title": "Animating your content • Angular",
    "chunk": "itionEndOnTransitionCancel The Web Animations API has a lot of additional functionality. Take a look at the documentation to see all the available animation APIs. NOTE: Be aware of bubbling issues with these callbacks. If you are animating children and parents, the events bubble up from children to parents. Consider stopping propagation or looking at more details within the event to determine if you're responding to the desired event target rather than an event bubbling up from a child node. You",
    "id": "animating-your-content-*-angular-27"
  },
  {
    "url": "https://angular.dev/guide/animations/css",
    "title": "Animating your content • Angular",
    "chunk": " can examine the animationname property or the properties being transitioned to verify you have the right nodes. Complex Sequences Animations are often more complicated than just a simple fade in or fade out. You may have lots of complicated sequences of animations you may want to run. Let's take a look at some of those possible scenarios. Staggering animations in a list One common effect is to stagger the animations of each item in a list to create a cascade effect. This can be accomplished by ",
    "id": "animating-your-content-*-angular-28"
  },
  {
    "url": "https://angular.dev/guide/animations/css",
    "title": "Animating your content • Angular",
    "chunk": "utilizing animation-delay or transition-delay. Here is an example of what that CSS might look like. src/app/stagger.component.ts import {Component, signal} from '@angular/core';@Component({ selector: 'app-stagger', templateUrl: './stagger.component.html', styleUrls: ['stagger.component.css'],})export class StaggerComponent { show = signal(true); items = [1, 2, 3]; refresh() { this.show.set(false); setTimeout(() => { this.show.set(true); }, 10); }} src/app/stagger.component.html <h1>Stagger Examp",
    "id": "animating-your-content-*-angular-29"
  },
  {
    "url": "https://angular.dev/guide/animations/css",
    "title": "Animating your content • Angular",
    "chunk": "le</h1><button type=\"button\" (click)=\"refresh()\">Refresh</button>@if (show()) { <ul class=\"items\"> @for(item of items; track item) { <li class=\"item\" style=\"--index: {{ item }}\">{{item}}</li> } </ul>} src/app/stagger.component.css .items { list-style: none; padding: 0; margin: 0;}.items .item { transition-property: opacity, transform; transition-duration: 500ms; transition-delay: calc(200ms * var(--index)); @starting-style { opacity: 0; transform: translateX(-10px); }} Parallel Animations You ca",
    "id": "animating-your-content-*-angular-30"
  },
  {
    "url": "https://angular.dev/guide/animations/css",
    "title": "Animating your content • Angular",
    "chunk": "n apply multiple animations to an element at once using the animation shorthand property. Each can have their own durations and delays. This allows you to compose animations together and create complicated effects. .target-element { animation: rotate 3s, fade-in 2s;} In this example, the rotate and fade-in animations fire at the same time, but have different durations. Animating the items of a reordering list Items in a @for loop will be removed and re-added, which will fire off animations using",
    "id": "animating-your-content-*-angular-31"
  },
  {
    "url": "https://angular.dev/guide/animations/css",
    "title": "Animating your content • Angular",
    "chunk": " @starting-styles for entry animations. Removal animations will require additional code to add the event listener, as seen in the example above. src/app/reorder.component.ts import {Component, signal} from '@angular/core';@Component({ selector: 'app-reorder', templateUrl: './reorder.component.html', styleUrls: ['reorder.component.css'],})export class ReorderComponent { show = signal(true); items = ['stuff', 'things', 'cheese', 'paper', 'scissors', 'rock']; randomize() { const randItems = [...thi",
    "id": "animating-your-content-*-angular-32"
  },
  {
    "url": "https://angular.dev/guide/animations/css",
    "title": "Animating your content • Angular",
    "chunk": "s.items]; const newItems = []; for (let i of this.items) { const max: number = this.items.length - newItems.length; const randNum = Math.floor(Math.random() * max); newItems.push(...randItems.splice(randNum, 1)); } this.items = newItems; }} src/app/reorder.component.html <h1>Reordering List Example</h1><button type=\"button\" (click)=\"randomize()\">Randomize</button><ul class=\"items\"> @for(item of items; track item) { <li class=\"item\">{{ item }}</li> }</ul> src/app/reorder.component.css .items { li",
    "id": "animating-your-content-*-angular-33"
  },
  {
    "url": "https://angular.dev/guide/animations/css",
    "title": "Animating your content • Angular",
    "chunk": "st-style: none; padding: 0; margin: 0;}.items .item { transition-property: opacity, transform; transition-duration: 500ms; @starting-style { opacity: 0; transform: translateX(-10px); }} Programmatic control of animations You can retrieve animations off an element directly using Element.getAnimations(). This returns an array of every Animation on that element. You can use the Animation API to do much more than you could with what the AnimationPlayer from the animations package offered. From here ",
    "id": "animating-your-content-*-angular-34"
  },
  {
    "url": "https://angular.dev/guide/animations/css",
    "title": "Animating your content • Angular",
    "chunk": "you can cancel(), play(), pause(), reverse() and much more. This native API should provide everything you need to control your animations. Social MediaBlogX (formerly Twitter)BlueskyYouTube Discord GitHub Stack Overflow Community Contribute Code of Conduct Report Issues Google's DevLibrary Angular Google Developer Experts ResourcesPress KitRoadmapLanguages简体中文版正體中文版日本語版한국어 Ελληνικά Super-powered by Google ©2010-2025. Code licensed under an MIT-style License . Documentation licensed under CC BY 4",
    "id": "animating-your-content-*-angular-35"
  },
  {
    "url": "https://angular.dev/guide/animations/css",
    "title": "Animating your content • Angular",
    "chunk": ".0 .",
    "id": "animating-your-content-*-angular-36"
  },
  {
    "url": "https://angular.dev/guide/animations/route-animations",
    "title": "Route transition animations • Angular",
    "chunk": "In-depth GuidesAnimations Route transition animations When a user navigates from one route to another, the Angular Router maps the URL path to the relevant component and displays its view. Animating this route transition can greatly enhance the user experience. The Router has support for the View Transitions API when navigating between routes in Chrome/Chromium browsers. HELPFUL: The Router's native View Transitions integration is currently in developer preview. Native View Transitions are also ",
    "id": "route-transition-animations-*-angular-0"
  },
  {
    "url": "https://angular.dev/guide/animations/route-animations",
    "title": "Route transition animations • Angular",
    "chunk": "a relatively new feature so there may be limited support in some browsers. On this pagearrow_upward_alt Back to the top How View Transitions work The native browser method that’s used for view transitions is document.startViewTransition. When startViewTransition() is called, the browser captures the current state of the page which includes taking a screenshot. The method takes a callback that updates the DOM and this function can be asynchronous. The new state is captured and the transition begi",
    "id": "route-transition-animations-*-angular-1"
  },
  {
    "url": "https://angular.dev/guide/animations/route-animations",
    "title": "Route transition animations • Angular",
    "chunk": "ns in the next animation frame when the promise returned by the callback resolves. Here’s an example of the startViewTransition api: document.startViewTransition(async () => { await updateTheDOMSomehow();}); If you’re curious to read more about the details of the browser API, the Chrome Explainer is an invaluable resource. How the Router uses view transitions Several things happen after navigation starts in the router: route matching, loading lazy routes and components, executing guards and reso",
    "id": "route-transition-animations-*-angular-2"
  },
  {
    "url": "https://angular.dev/guide/animations/route-animations",
    "title": "Route transition animations • Angular",
    "chunk": "lvers to name a few. Once these have completed successfully, the new routes are ready to be activated. This route activation is the DOM update that we want to perform as part of the view transition. When the view transition feature is enabled, navigation “pauses” and a call is made to the browser’s startViewTransition method. Once the startViewTransition callback executes (this happens asynchronously, as outlined in the spec here), navigation “resumes”. The remaining steps for the router navigat",
    "id": "route-transition-animations-*-angular-3"
  },
  {
    "url": "https://angular.dev/guide/animations/route-animations",
    "title": "Route transition animations • Angular",
    "chunk": "ion include updating the browser URL and activating or deactivating the matched routes (the DOM update). Finally, the callback passed to startViewTransition returns a Promise that resolves once Angular has finished rendering. As described above, this indicates to the browser that the new DOM state should be captured and the transition should begin. View transitions are a progressive enhancement. If the browser does not support the API, the Router will perform the DOM updates without calling star",
    "id": "route-transition-animations-*-angular-4"
  },
  {
    "url": "https://angular.dev/guide/animations/route-animations",
    "title": "Route transition animations • Angular",
    "chunk": "tViewTransition and the navigation will not be animated. Enabling View Transitions in the Router To enable this feature, simply add withViewTransitions to the provideRouter or set enableViewTransitions: true in RouterModule.forRoot: // Standalone bootstrapbootstrapApplication(MyApp, {providers: [ provideRouter(ROUTES, withViewTransitions()),]});// NgModule bootstrap@NgModule({ imports: [RouterModule.forRoot(routes, {enableViewTransitions: true})]})export class AppRouting {} Try the “count” examp",
    "id": "route-transition-animations-*-angular-5"
  },
  {
    "url": "https://angular.dev/guide/animations/route-animations",
    "title": "Route transition animations • Angular",
    "chunk": "le on StackBlitz This example uses the counter application from the Chrome explainer and replaces the direct call to startViewTransition when the counter increments with a router navigation. Using CSS to customize transitions View transitions can be customized with CSS. We can also instruct the browser to create separate elements for the transition by setting a view-transition-name. We can expand the first example by adding view-transition-name: count to the .count style in the Counter component",
    "id": "route-transition-animations-*-angular-6"
  },
  {
    "url": "https://angular.dev/guide/animations/route-animations",
    "title": "Route transition animations • Angular",
    "chunk": ". Then, in the global styles, we can define a custom animation for this view transition: /* Custom transition */@keyframes rotate-out { to { transform: rotate(90deg); }}@keyframes rotate-in { from { transform: rotate(-90deg); }}::view-transition-old(count),::view-transition-new(count) { animation-duration: 200ms; animation-name: -ua-view-transition-fade-in, rotate-in;}::view-transition-old(count) { animation-name: -ua-view-transition-fade-out, rotate-out;} It is important that the view transitio",
    "id": "route-transition-animations-*-angular-7"
  },
  {
    "url": "https://angular.dev/guide/animations/route-animations",
    "title": "Route transition animations • Angular",
    "chunk": "n animations are defined in a global style file. They cannot be defined in the component styles because the default view encapsulation will scope the styles to the component. Try the updated “count” example on StackBlitz Controlling transitions with onViewTransitionCreated The withViewTransitions router feature can also be called with an options object that includes an onViewTransitionCreated callback. This callback is run in an injection context and receives a ViewTransitionInfo object that inc",
    "id": "route-transition-animations-*-angular-8"
  },
  {
    "url": "https://angular.dev/guide/animations/route-animations",
    "title": "Route transition animations • Angular",
    "chunk": "ludes the ViewTransition returned from startViewTransition, as well as the ActivatedRouteSnapshot that the navigation is transitioning from and the new one that it is transitioning to. This callback can be used for any number of customizations. For example, you might want to skip transitions under certain conditions. We use this on the new angular.dev docs site: withViewTransitions({ onViewTransitionCreated: ({transition}) => { const router = inject(Router); const targetUrl = router.getCurrentNa",
    "id": "route-transition-animations-*-angular-9"
  },
  {
    "url": "https://angular.dev/guide/animations/route-animations",
    "title": "Route transition animations • Angular",
    "chunk": "vigation()!.finalUrl!; // Skip the transition if the only thing // changing is the fragment and queryParams const config = { paths: 'exact', matrixParams: 'exact', fragment: 'ignored', queryParams: 'ignored', }; if (router.isActive(targetUrl, config)) { transition.skipTransition(); } },}), In this code snippet, we create a UrlTree from the ActivatedRouteSnapshot the navigation is going to. We then check with the Router to see if this UrlTree is already active, ignoring any differences in the fra",
    "id": "route-transition-animations-*-angular-10"
  },
  {
    "url": "https://angular.dev/guide/animations/route-animations",
    "title": "Route transition animations • Angular",
    "chunk": "gment or query parameters. If it is already active, we call skipTransition which will skip the animation portion of the view transition. This is the case when clicking on an anchor link that will only scroll to another location in the same document. Examples from the Chrome explainer adapted to Angular We’ve recreated some of the great examples from the Chrome Team in Angular for you to explore. Transitioning elements don’t need to be the same DOM element Chrome Explainer Angular Example on Stac",
    "id": "route-transition-animations-*-angular-11"
  },
  {
    "url": "https://angular.dev/guide/animations/route-animations",
    "title": "Route transition animations • Angular",
    "chunk": "kBlitz Custom entry and exit animations Chrome Explainer Angular Example on StackBlitz Async DOM updates and waiting for content Chrome Explainer During this time, the page is frozen, so delays here should be kept to a minimum…in some cases it’s better to avoid the delay altogether, and use the content you already have. The view transition feature in the Angular router does not provide a way to delay the animation. For the moment, our stance is that it’s always better to use the content you have",
    "id": "route-transition-animations-*-angular-12"
  },
  {
    "url": "https://angular.dev/guide/animations/route-animations",
    "title": "Route transition animations • Angular",
    "chunk": " rather than making the page non-interactive for any additional amount of time. Handle multiple view transition styles with view transition types Chrome Explainer Angular Example on StackBlitz Handle multiple view transition styles with a class name on the view transition root (deprecated) Chrome Explainer Angular Example on StackBlitz Transitioning without freezing other animations Chrome Explainer Angular Example on StackBlitz Animating with Javascript Chrome Explainer Angular Example on Stack",
    "id": "route-transition-animations-*-angular-13"
  },
  {
    "url": "https://angular.dev/guide/animations/route-animations",
    "title": "Route transition animations • Angular",
    "chunk": "Blitz Native View Transitions Alternative Animating the transition between routes can also be done with the @angular/animations package. The animation triggers and transitions can be derived from the router state, such as the current URL or ActivatedRoute. Social MediaBlogX (formerly Twitter)BlueskyYouTube Discord GitHub Stack Overflow Community Contribute Code of Conduct Report Issues Google's DevLibrary Angular Google Developer Experts ResourcesPress KitRoadmapLanguages简体中文版正體中文版日本語版한국어 Ελληνι",
    "id": "route-transition-animations-*-angular-14"
  },
  {
    "url": "https://angular.dev/guide/animations/route-animations",
    "title": "Route transition animations • Angular",
    "chunk": "κά Super-powered by Google ©2010-2025. Code licensed under an MIT-style License . Documentation licensed under CC BY 4.0 .",
    "id": "route-transition-animations-*-angular-15"
  },
  {
    "url": "https://angular.dev/api",
    "title": "API Reference • Overview • Angular",
    "chunk": "API Referencesearch Stable Developer Preview Experimental Deprecated Filter by Identifier typeBBlockCClassKConst@DecoratorDDirectiveElElementEEnumFFunctionIInterfacePPipeMModuleTType AliasIAInitializer API animations FanimateFanimateChildIAnimateChildOptionsTAnimateTimingsFanimationIAnimationAnimateChildMetadataIAnimationAnimateMetadataIAnimationAnimateRefMetadataCAnimationBuilderIAnimationEventCAnimationFactoryIAnimationGroupMetadataIAnimationKeyframesSequenceMetadataIAnimationMetadataEAnimatio",
    "id": "api-reference-*-overview-*-angular-0"
  },
  {
    "url": "https://angular.dev/api",
    "title": "API Reference • Overview • Angular",
    "chunk": "nMetadataTypeIAnimationOptionsIAnimationPlayerIAnimationQueryMetadataIAnimationQueryOptionsIAnimationReferenceMetadataIAnimationSequenceMetadataIAnimationStaggerMetadataIAnimationStateMetadataIAnimationStyleMetadataIAnimationTransitionMetadataIAnimationTriggerMetadataKAUTO_STYLEFgroupFkeyframesCNoopAnimationPlayerFqueryFsequenceFstaggerFstateFstyleFtransitionFtriggerFuseAnimation animations/browser CAnimationDriverCNoopAnimationDriver animations/browser/testing CMockAnimationDriverCMockAnimation",
    "id": "api-reference-*-overview-*-angular-1"
  },
  {
    "url": "https://angular.dev/api",
    "title": "API Reference • Overview • Angular",
    "chunk": "Player cdk/drag-drop KCDK_DRAG_CONFIGKCDK_DRAG_HANDLEKCDK_DRAG_PLACEHOLDERKCDK_DRAG_PREVIEWKCDK_DROP_LISTKCDK_DROP_LIST_GROUPCCdkDragICdkDragDropICdkDragEndICdkDragEnterICdkDragExitCCdkDragHandleICdkDragMoveDCdkDragPlaceholderCCdkDragPreviewICdkDragReleaseICdkDragSortEventICdkDragStartCCdkDropListCCdkDropListGroupFcopyArrayItemTDragAxisTDragConstrainPositionCDragDropIDragDropConfigCDragDropModuleCDragRefIDragRefConfigTDragStartDelayTDropListOrientationCDropListRefFmoveItemInArrayIPointTPreviewCo",
    "id": "api-reference-*-overview-*-angular-2"
  },
  {
    "url": "https://angular.dev/api",
    "title": "API Reference • Overview • Angular",
    "chunk": "ntainerFtransferArrayItem cdk/testing TAsyncOptionPredicateTAsyncPredicateIAutoChangeDetectionStatusIBaseHarnessFiltersCComponentHarnessIComponentHarnessConstructorCContentContainerComponentHarnessIElementDimensionsTEventDataFhandleAutoChangeDetectionStatusCHarnessEnvironmentIHarnessLoaderCHarnessPredicateTHarnessQueryILocatorFactoryTLocatorFnResultFmanualChangeDetectionIModifierKeysFparallelFstopHandlingAutoChangeDetectionStatusITestElementETestKeyITextOptions cdk/testing/selenium-webdriver CSe",
    "id": "api-reference-*-overview-*-angular-3"
  },
  {
    "url": "https://angular.dev/api",
    "title": "API Reference • Overview • Angular",
    "chunk": "leniumWebDriverElementCSeleniumWebDriverHarnessEnvironmentFwaitForAngularReadyIWebDriverHarnessEnvironmentOptions cdk/testing/testbed CTestbedHarnessEnvironmentITestbedHarnessEnvironmentOptionsCUnitTestElement common KAPP_BASE_HREFPAsyncPipeCBrowserPlatformLocationMCommonModulePCurrencyPipeKDATE_PIPE_DEFAULT_OPTIONSPDatePipeIDatePipeConfigPDecimalPipeKDOCUMENTFformatCurrencyFformatDateFformatNumberFformatPercentCHashLocationStrategyPI18nPluralPipePI18nSelectPipeKIMAGE_CONFIGKIMAGE_LOADERTImageCo",
    "id": "api-reference-*-overview-*-angular-4"
  },
  {
    "url": "https://angular.dev/api",
    "title": "API Reference • Overview • Angular",
    "chunk": "nfigTImageLoaderIImageLoaderConfigIImagePlaceholderConfigFisPlatformBrowserFisPlatformServerPJsonPipeIKeyValuePKeyValuePipeCLocationKLOCATION_INITIALIZEDILocationChangeEventILocationChangeListenerCLocationStrategyPLowerCasePipeDNgClassDNgComponentOutletCNgLocaleLocalizationCNgLocalizationDNgOptimizedImageDNgPluralDNgPluralCaseDNgStyleDNgTemplateOutletCPathLocationStrategyPPercentPipeCPlatformLocationIPopStateEventKPRECONNECT_CHECK_BLOCKLISTKprovideCloudflareLoaderKprovideCloudinaryLoaderKprovide",
    "id": "api-reference-*-overview-*-angular-5"
  },
  {
    "url": "https://angular.dev/api",
    "title": "API Reference • Overview • Angular",
    "chunk": "ImageKitLoaderKprovideImgixLoaderFprovideNetlifyLoaderFregisterLocaleDataPSlicePipePTitleCasePipePUpperCasePipeKVERSIONCViewportScrollerCXhrFactory common/http CFetchBackendKHTTP_INTERCEPTORSKHTTP_TRANSFER_CACHE_ORIGIN_MAPCHttpBackendCHttpClientCHttpContextCHttpContextTokenIHttpDownloadProgressEventCHttpErrorResponseTHttpEventEHttpEventTypeIHttpFeatureEHttpFeatureKindCHttpHandlerTHttpHandlerFnCHttpHeaderResponseCHttpHeadersIHttpInterceptorTHttpInterceptorFnIHttpParameterCodecCHttpParamsIHttpPara",
    "id": "api-reference-*-overview-*-angular-6"
  },
  {
    "url": "https://angular.dev/api",
    "title": "API Reference • Overview • Angular",
    "chunk": "msOptionsIHttpProgressEventCHttpRequestIAhttpResource 🧪 IHttpResourceFn 🧪 IHttpResourceOptions 🧪 IHttpResourceRef 🧪 IHttpResourceRequest 🧪 CHttpResponseCHttpResponseBaseIHttpSentEventEHttpStatusCodeTHttpTransferCacheOptionsIHttpUploadProgressEventCHttpUrlEncodingCodecIHttpUserEventCHttpXhrBackendCHttpXsrfTokenExtractorCJsonpClientBackendCJsonpInterceptorFprovideHttpClientFwithFetchFwithInterceptorsFwithInterceptorsFromDiFwithJsonpSupportFwithNoXsrfProtectionFwithRequestsMadeViaParentFwithXs",
    "id": "api-reference-*-overview-*-angular-7"
  },
  {
    "url": "https://angular.dev/api",
    "title": "API Reference • Overview • Angular",
    "chunk": "rfConfiguration common/http/testing CHttpTestingControllerFprovideHttpClientTestingIRequestMatchCTestRequest common/testing KMOCK_PLATFORM_LOCATION_CONFIGCMockLocationStrategyCMockPlatformLocationIMockPlatformLocationConfigFprovideLocationMocksCSpyLocation common/upgrade C$locationShimC$locationShimProviderCAngularJSUrlCodecKLOCATION_UPGRADE_CONFIGURATIONILocationUpgradeConfigMLocationUpgradeModuleCUrlCodec core B@deferB@forB@ifB@letB@switchIAbstractTypeIAfterContentCheckedIAfterContentInitFafte",
    "id": "api-reference-*-overview-*-angular-8"
  },
  {
    "url": "https://angular.dev/api",
    "title": "API Reference • Overview • Angular",
    "chunk": "rEveryRender 🚧 FafterNextRender 🚧 FafterRenderEffectIAfterRenderOptionsIAfterRenderRefIAfterViewCheckedIAfterViewInitKANIMATION_MODULE_TYPEKAPP_BOOTSTRAP_LISTENERKAPP_IDIApplicationConfigCApplicationInitStatusMApplicationModuleCApplicationRefFasNativeElementsFassertInInjectionContextFassertNotInReactiveContextFassertPlatform@AttributeIBaseResourceOptions 🧪 IBindingFbooleanAttributeIBootstrapOptionsEChangeDetectionStrategyCChangeDetectorRefIClassProviderIClassSansProviderKCOMPILER_OPTIONSTComp",
    "id": "api-reference-*-overview-*-angular-9"
  },
  {
    "url": "https://angular.dev/api",
    "title": "API Reference • Overview • Angular",
    "chunk": "ilerOptions@ComponentIComponentMirrorCComponentRefFcomputedIConstructorProviderIConstructorSansProviderIAcontentChild@ContentChildIAcontentChildren@ContentChildrenFcreateComponentICreateComputedOptionsICreateEffectOptionsFcreateEnvironmentInjectorFcreateNgModuleFcreatePlatformFcreatePlatformFactoryICreateSignalOptionsKCSP_NONCEKCUSTOM_ELEMENTS_SCHEMACDebugElementCDebugEventListenerCDebugNodeKDEFAULT_CURRENCY_CODEIDestroyableInjectorFdestroyPlatformCDestroyRef@DirectiveIDoBootstrapIDoCheckKDOCUME",
    "id": "api-reference-*-overview-*-angular-10"
  },
  {
    "url": "https://angular.dev/api",
    "title": "API Reference • Overview • Angular",
    "chunk": "NTFeffectTEffectCleanupFnTEffectCleanupRegisterFnIEffectRefCElementRefCEmbeddedViewRefFenableProdModeFenableProfiling 🧪 CEnvironmentInjectorTEnvironmentProvidersCErrorHandlerKEventEmitterIExistingProviderIExistingSansProviderIFactoryProviderIFactorySansProviderFforwardRefIForwardRefFnFgetDebugNodeFgetNgModuleByIdFgetPlatformIGetTestability@HostKHOST_TAG_NAMECHostAttributeToken@HostBinding@HostListenerFimportProvidersFromTImportProvidersSourceFinject@Inject@InjectableTInjectableProviderIInjectab",
    "id": "api-reference-*-overview-*-angular-11"
  },
  {
    "url": "https://angular.dev/api",
    "title": "API Reference • Overview • Angular",
    "chunk": "leTypeCInjectionTokenIInjectOptionsCInjectorKINJECTORIInjectorTypeIAinput@InputFinputBindingIInputOptionsTInputOptionsWithoutTransformTInputOptionsWithTransformIInputSignalIInputSignalWithTransformFisDevModeFisSignalFisStandaloneIIterableChangeRecordIIterableChangesIIterableDifferIIterableDifferFactoryCIterableDiffersIKeyValueChangeRecordIKeyValueChangesIKeyValueDifferIKeyValueDifferFactoryCKeyValueDiffersFlinkedSignalIListenerOptionsKLOCALE_IDFmakeEnvironmentProvidersFmakeStateKeyFmergeApplicat",
    "id": "api-reference-*-overview-*-angular-12"
  },
  {
    "url": "https://angular.dev/api",
    "title": "API Reference • Overview • Angular",
    "chunk": "ionConfigEMissingTranslationStrategyIAmodelIModelOptionsIModelSignalIModuleWithProvidersElng-containerElng-contentElng-templateTNgIterable@NgModuleCNgModuleRefCNgZoneINgZoneOptionsKNO_ERRORS_SCHEMAFnumberAttributeIOnChangesIOnDestroyIOnInit@OptionalIAoutput@OutputFoutputBindingCOutputEmitterRefIOutputOptionsIOutputRefIOutputRefSubscriptionCPendingTasks@PipeIPipeTransformKPLATFORM_IDKplatformCoreCPlatformRefTPredicateIPromiseResourceOptions 🧪 FprovideAppInitializerFprovideBrowserGlobalErrorListe",
    "id": "api-reference-*-overview-*-angular-13"
  },
  {
    "url": "https://angular.dev/api",
    "title": "API Reference • Overview • Angular",
    "chunk": "nersFprovideCheckNoChangesConfig 🚧 FprovideEnvironmentInitializerFprovideNgReflectAttributesFprovidePlatformInitializerTProviderTProviderTokenFprovideZoneChangeDetectionFprovideZonelessChangeDetection 🚧 CQueryCQueryListFreflectComponentTypeCRenderer2CRendererFactory2ERendererStyleFlags2IRendererType2KREQUESTKREQUEST_CONTEXTFresolveForwardRefFresource 🧪 IResource 🧪 TResourceLoader 🧪 IResourceLoaderParams 🧪 TResourceOptions 🧪 IResourceRef 🧪 TResourceStatus 🧪 TResourceStreamingLoader 🧪 TR",
    "id": "api-reference-*-overview-*-angular-14"
  },
  {
    "url": "https://angular.dev/api",
    "title": "API Reference • Overview • Angular",
    "chunk": "esourceStreamItem 🧪 KRESPONSE_INITFrunInInjectionContextCSanitizerISchemaMetadataESecurityContext@SelfFsetTestabilityGetterFsignalTSignalCSimpleChangeISimpleChanges@SkipSelfTStateKeyIStaticClassProviderIStaticClassSansProviderTStaticProviderIStreamingResourceOptions 🧪 CTemplateRefCTestabilityCTestabilityRegistryITrackByFunctionCTransferStateKTRANSLATIONSKTRANSLATIONS_FORMATFtwoWayBindingKTypeITypeProviderFuntrackedTValueEqualityFnIValueProviderIValueSansProviderCVersionKVERSIONIAviewChild@View",
    "id": "api-reference-*-overview-*-angular-15"
  },
  {
    "url": "https://angular.dev/api",
    "title": "API Reference • Overview • Angular",
    "chunk": "ChildIAviewChildren@ViewChildrenCViewContainerRefEViewEncapsulationCViewRefIWritableResource 🧪 IWritableSignal core/rxjs-interop FoutputFromObservableFoutputToObservableFpendingUntilEvent 🚧 FrxResource 🧪 IRxResourceOptions 🧪 FtakeUntilDestroyedFtoObservableIToObservableOptionsFtoSignalIToSignalOptions core/testing CComponentFixtureKComponentFixtureAutoDetectKComponentFixtureNoNgZoneEDeferBlockBehaviorCDeferBlockFixtureEDeferBlockStateFdiscardPeriodicTasksFfakeAsyncFflushFflushMicrotasksFgetT",
    "id": "api-reference-*-overview-*-angular-16"
  },
  {
    "url": "https://angular.dev/api",
    "title": "API Reference • Overview • Angular",
    "chunk": "estBedFinjectCInjectSetupWrapperTMetadataOverrideIModuleTeardownOptionsFresetFakeAsyncZoneKTestBedITestBedStaticCTestComponentRendererITestEnvironmentOptionsITestModuleMetadataFtickFwaitForAsyncFwithModule elements FcreateCustomElementCNgElementINgElementConfigINgElementConstructorINgElementStrategyINgElementStrategyEventINgElementStrategyFactoryKVERSIONTWithProperties forms CAbstractControlCAbstractControlDirectiveIAbstractControlOptionsDAbstractFormGroupDirectiveIAsyncValidatorIAsyncValidatorF",
    "id": "api-reference-*-overview-*-angular-17"
  },
  {
    "url": "https://angular.dev/api",
    "title": "API Reference • Overview • Angular",
    "chunk": "nDCheckboxControlValueAccessorDCheckboxRequiredValidatorKCOMPOSITION_BUFFER_MODETControlConfigCControlContainerCControlEventIControlValueAccessorDDefaultValueAccessorDEmailValidatorIFormCFormArrayDFormArrayNameCFormBuilderIFormControlDFormControlDirectiveDFormControlNameIFormControlOptionsIFormControlStateTFormControlStatusCFormGroupDFormGroupDirectiveDFormGroupNameCFormRecordCFormResetEventMFormsModuleCFormSubmittedEventKisFormArrayKisFormControlKisFormGroupKisFormRecordDMaxLengthValidatorDMaxV",
    "id": "api-reference-*-overview-*-angular-18"
  },
  {
    "url": "https://angular.dev/api",
    "title": "API Reference • Overview • Angular",
    "chunk": "alidatorDMinLengthValidatorDMinValidatorKNG_ASYNC_VALIDATORSKNG_VALIDATORSKNG_VALUE_ACCESSORCNgControlDNgControlStatusDNgControlStatusGroupDNgFormDNgModelDNgModelGroupDNgSelectOptionCNonNullableFormBuilderDNumberValueAccessorDPatternValidatorCPristineChangeEventDRadioControlValueAccessorDRangeValueAccessorMReactiveFormsModuleDRequiredValidatorDSelectControlValueAccessorDSelectMultipleControlValueAccessorTSetDisabledStateOptionCStatusChangeEventCTouchedChangeEventKUntypedFormArrayCUntypedFormBuil",
    "id": "api-reference-*-overview-*-angular-19"
  },
  {
    "url": "https://angular.dev/api",
    "title": "API Reference • Overview • Angular",
    "chunk": "derKUntypedFormControlKUntypedFormGroupTValidationErrorsIValidatorIValidatorFnCValidatorsCValueChangeEventKVERSION localize FclearTranslationsFloadTranslationsTMessageIdTTargetMessage localize/init K$localize platform-browser FbootstrapApplicationMBrowserModuleCByFcreateApplicationFdisableDebugToolsCDomSanitizerFenableDebugToolsKEVENT_MANAGER_PLUGINSCEventManagerCEventManagerPluginIHydrationFeatureEHydrationFeatureKindCMetaTMetaDefinitionKplatformBrowserFprovideClientHydrationFprovideProtractorT",
    "id": "api-reference-*-overview-*-angular-20"
  },
  {
    "url": "https://angular.dev/api",
    "title": "API Reference • Overview • Angular",
    "chunk": "estingSupportKREMOVE_STYLES_ON_COMPONENT_DESTROYISafeHtmlISafeResourceUrlISafeScriptISafeStyleISafeUrlISafeValueCTitleKVERSIONFwithEventReplayFwithHttpTransferCacheOptionsFwithI18nSupportFwithIncrementalHydrationFwithNoHttpTransferCache platform-browser-dynamic KVERSION platform-browser/animations KANIMATION_MODULE_TYPEMBrowserAnimationsModuleIBrowserAnimationsModuleConfigMNoopAnimationsModuleFprovideAnimationsFprovideNoopAnimations platform-browser/animations/async FprovideAnimationsAsync platf",
    "id": "api-reference-*-overview-*-angular-21"
  },
  {
    "url": "https://angular.dev/api",
    "title": "API Reference • Overview • Angular",
    "chunk": "orm-browser/testing MBrowserTestingModuleKplatformBrowserTesting platform-server KBEFORE_APP_SERIALIZEDKINITIAL_CONFIGIPlatformConfigFplatformServerCPlatformStateFprovideServerRenderingFrenderApplicationFrenderModuleMServerModuleKVERSION router CActivatedRouteCActivatedRouteSnapshotCActivationEndCActivationStartCBaseRouteReuseStrategyICanActivateICanActivateChildTCanActivateChildFnTCanActivateFnICanDeactivateTCanDeactivateFnICanMatchTCanMatchFnCChildActivationEndCChildActivationStartCChildrenOut",
    "id": "api-reference-*-overview-*-angular-22"
  },
  {
    "url": "https://angular.dev/api",
    "title": "API Reference • Overview • Angular",
    "chunk": "letContextsTComponentInputBindingFeatureFconvertToParamMapFcreateUrlTreeFromSnapshotTDataTDebugTracingFeatureIDefaultExportCDefaultTitleStrategyFdefaultUrlMatcherCDefaultUrlSerializerTDetachedRouteHandleTDisabledInitialNavigationFeatureTEnabledBlockingInitialNavigationFeatureTEventEEventTypeIExtraOptionsTGuardResultCGuardsCheckEndCGuardsCheckStartTInitialNavigationTInitialNavigationFeatureTInMemoryScrollingFeatureIInMemoryScrollingOptionsIIsActiveMatchOptionsTLoadChildrenTLoadChildrenCallbackFma",
    "id": "api-reference-*-overview-*-angular-23"
  },
  {
    "url": "https://angular.dev/api",
    "title": "API Reference • Overview • Angular",
    "chunk": "pToCanActivateFmapToCanActivateChildFmapToCanDeactivateFmapToCanMatchFmapToResolveTMaybeAsyncINavigationINavigationBehaviorOptionsCNavigationCancelENavigationCancellationCodeCNavigationEndCNavigationErrorTNavigationErrorHandlerFeatureINavigationExtrasCNavigationSkippedENavigationSkippedCodeCNavigationStartCNoPreloadingTOnSameUrlNavigationCOutletContextIParamMapTParamsCPreloadAllModulesTPreloadingFeatureCPreloadingStrategyKPRIMARY_OUTLETFprovideRouterTQueryParamsHandlingCRedirectCommandTRedirectF",
    "id": "api-reference-*-overview-*-angular-24"
  },
  {
    "url": "https://angular.dev/api",
    "title": "API Reference • Overview • Angular",
    "chunk": "unctionIResolveTResolveDataCResolveEndTResolveFnCResolveStartIRouteCRouteConfigLoadEndCRouteConfigLoadStartCRouterKROUTER_CONFIGURATIONKROUTER_INITIALIZERKROUTER_OUTLET_DATAIRouterConfigOptionsTRouterConfigurationFeatureCRouteReuseStrategyCRouterEventIRouterFeatureTRouterFeaturesTRouterHashLocationFeatureDRouterLinkDRouterLinkActiveDRouterLinkWithHrefMRouterModuleDRouterOutletIRouterOutletContractCRouterPreloaderCRouterStateCRouterStateSnapshotTRoutesKROUTESCRoutesRecognizedTRunGuardsAndResolver",
    "id": "api-reference-*-overview-*-angular-25"
  },
  {
    "url": "https://angular.dev/api",
    "title": "API Reference • Overview • Angular",
    "chunk": "sCScrollCTitleStrategyIUrlCreationOptionsCUrlHandlingStrategyTUrlMatcherTUrlMatchResultCUrlSegmentCUrlSegmentGroupCUrlSerializerCUrlTreeKVERSIONIViewTransitionInfo 🚧 TViewTransitionsFeatureIViewTransitionsFeatureOptions 🚧 FwithComponentInputBindingFwithDebugTracingFwithDisabledInitialNavigationFwithEnabledBlockingInitialNavigationFwithHashLocationFwithInMemoryScrollingFwithNavigationErrorHandlerFwithPreloadingFwithRouterConfigFwithViewTransitions 🚧 router/testing CRouterTestingHarness router/",
    "id": "api-reference-*-overview-*-angular-26"
  },
  {
    "url": "https://angular.dev/api",
    "title": "API Reference • Overview • Angular",
    "chunk": "upgrade FlocationSyncBootstrapListenerKRouterUpgradeInitializerFsetUpLocationSync service-worker INoNewVersionDetectedEventFprovideServiceWorkerMServiceWorkerModuleCSwPushCSwRegistrationOptionsCSwUpdateIUnrecoverableStateEventIVersionDetectedEventTVersionEventIVersionInstallationFailedEventIVersionReadyEvent ssr CAngularAppEngineFcreateRequestHandlerEPrerenderFallbackFprovideServerRenderingERenderModeTRequestHandlerFunctionTServerRouteIServerRouteClientIServerRouteCommonIServerRoutePrerenderISer",
    "id": "api-reference-*-overview-*-angular-27"
  },
  {
    "url": "https://angular.dev/api",
    "title": "API Reference • Overview • Angular",
    "chunk": "verRoutePrerenderWithParamsIServerRouteServerFwithAppShellFwithRoutes ssr/node CAngularNodeAppEngineCCommonEngineICommonEngineOptionsICommonEngineRenderOptionsFcreateNodeRequestHandlerFcreateWebRequestFromNodeRequestFisMainModuleTNodeRequestHandlerFunctionFwriteResponseToNodeResponse upgrade/static FdowngradeComponentFdowngradeInjectableFdowngradeModuleFgetAngularJSGlobalFsetAngularJSGlobalDUpgradeComponentMUpgradeModuleKVERSION upgrade/static/testing FcreateAngularJSTestingModuleFcreateAngularT",
    "id": "api-reference-*-overview-*-angular-28"
  },
  {
    "url": "https://angular.dev/api",
    "title": "API Reference • Overview • Angular",
    "chunk": "estingModule window.ng globals FapplyChangesTDirectiveDebugMetadataFenableProfiling 🧪 FgetComponentFgetContextFgetDirectiveMetadataFgetDirectivesFgetHostElementFgetInjectorFgetListenersFgetOwningComponentFgetRootComponentsIListenerSocial MediaBlogX (formerly Twitter)BlueskyYouTube Discord GitHub Stack Overflow Community Contribute Code of Conduct Report Issues Google's DevLibrary Angular Google Developer Experts ResourcesPress KitRoadmapLanguages简体中文版正體中文版日本語版한국어 Ελληνικά Super-powered by Googl",
    "id": "api-reference-*-overview-*-angular-29"
  },
  {
    "url": "https://angular.dev/api",
    "title": "API Reference • Overview • Angular",
    "chunk": "e ©2010-2025. Code licensed under an MIT-style License . Documentation licensed under CC BY 4.0 .",
    "id": "api-reference-*-overview-*-angular-30"
  },
  {
    "url": "https://angular.dev/cli",
    "title": "CLI Reference • Overview • Angular",
    "chunk": "CLI Reference CLI Reference Command Alias Description add Adds support for an external library to your project. analytics Configures the gathering of Angular CLI usage metrics. build b Compiles an Angular application or library into an output directory named dist/ at the given output path. cache Configure persistent disk cache and retrieve cache statistics. completion Set up Angular CLI autocompletion for your terminal. config Retrieves or sets Angular configuration values in the angular.json fi",
    "id": "cli-reference-*-overview-*-angular-0"
  },
  {
    "url": "https://angular.dev/cli",
    "title": "CLI Reference • Overview • Angular",
    "chunk": "le for the workspace. deploy Invokes the deploy builder for a specified project or for the default project in the workspace. e2e e Builds and serves an Angular application, then runs end-to-end tests. extract-i18n Extracts i18n messages from source code. generate g Generates and/or modifies files based on a schematic. lint Runs linting tools on Angular application code in a given project folder. new n Creates a new Angular workspace. run Runs an Architect target with an optional custom builder c",
    "id": "cli-reference-*-overview-*-angular-1"
  },
  {
    "url": "https://angular.dev/cli",
    "title": "CLI Reference • Overview • Angular",
    "chunk": "onfiguration defined in your project. serve s, dev Builds and serves your application, rebuilding on file changes. test t Runs unit tests in a project. update Updates your workspace and its dependencies. See https://angular.dev/update-guide/. version v Outputs Angular CLI version. Social MediaBlogX (formerly Twitter)BlueskyYouTube Discord GitHub Stack Overflow Community Contribute Code of Conduct Report Issues Google's DevLibrary Angular Google Developer Experts ResourcesPress KitRoadmapLanguage",
    "id": "cli-reference-*-overview-*-angular-2"
  },
  {
    "url": "https://angular.dev/cli",
    "title": "CLI Reference • Overview • Angular",
    "chunk": "s简体中文版正體中文版日本語版한국어 Ελληνικά Super-powered by Google ©2010-2025. Code licensed under an MIT-style License . Documentation licensed under CC BY 4.0 .",
    "id": "cli-reference-*-overview-*-angular-3"
  },
  {
    "url": "https://angular.dev/guide/zoneless",
    "title": "Zoneless • Angular",
    "chunk": "Best PracticesPerformance Angular without ZoneJS (Zoneless) On this pagearrow_upward_alt Back to the top Why use Zoneless? The main advantages to removing ZoneJS as a dependency are: Improved performance: ZoneJS uses DOM events and async tasks as indicators of when application state might have updated and subsequently triggers application synchronization to run change detection on the application's views. ZoneJS does not have any insight into whether application state actually changed and so thi",
    "id": "zoneless-*-angular-0"
  },
  {
    "url": "https://angular.dev/guide/zoneless",
    "title": "Zoneless • Angular",
    "chunk": "s synchronization is triggered more frequently than necessary. Improved Core Web Vitals: ZoneJS brings a fair amount of overhead, both in payload size and in startup time cost. Improved debugging experience: ZoneJS makes debugging code more difficult. Stack traces are harder to understand with ZoneJS. It's also difficult to understand when code breaks as a result of being outside the Angular Zone. Better ecosystem compatibility: ZoneJS works by patching browser APIs but does not automatically ha",
    "id": "zoneless-*-angular-1"
  },
  {
    "url": "https://angular.dev/guide/zoneless",
    "title": "Zoneless • Angular",
    "chunk": "ve patches for every new browser API. Some APIs cannot be patched effectively, such as async/await, and have to be downleveled to work with ZoneJS. Sometimes libraries in the ecosystem are also incompatible with the way ZoneJS patches the native APIs. Removing ZoneJS as a dependency ensures better long-term compatibility by removing a source of complexity, monkey patching, and ongoing maintenance. Enabling Zoneless in an application The API for enabling Zoneless is currently in developer preview",
    "id": "zoneless-*-angular-2"
  },
  {
    "url": "https://angular.dev/guide/zoneless",
    "title": "Zoneless • Angular",
    "chunk": ". The shape of the API and underlying behavior can change in patch versions. // standalone bootstrapbootstrapApplication(MyApp, {providers: [ provideZonelessChangeDetection(),]});// NgModule bootstrapplatformBrowser().bootstrapModule(AppModule);@NgModule({ providers: [provideZonelessChangeDetection()]})export class AppModule {} Removing ZoneJS Zoneless applications should remove ZoneJS entirely from the build to reduce bundle size. ZoneJS is typically loaded via the polyfills option in angular.j",
    "id": "zoneless-*-angular-3"
  },
  {
    "url": "https://angular.dev/guide/zoneless",
    "title": "Zoneless • Angular",
    "chunk": "son, both in the build and test targets. Remove zone.js and zone.js/testing from both to remove it from the build. Projects which use an explicit polyfills.ts file should remove import 'zone.js'; and import 'zone.js/testing'; from the file. After removing ZoneJS from the build, there is no longer a need for a zone.js dependency either and the package can be removed entirely: npm uninstall zone.js Requirements for Zoneless compatibility Angular relies on notifications from core APIs in order to d",
    "id": "zoneless-*-angular-4"
  },
  {
    "url": "https://angular.dev/guide/zoneless",
    "title": "Zoneless • Angular",
    "chunk": "etermine when to run change detection and on which views. These notifications include: ChangeDetectorRef.markForCheck (called automatically by AsyncPipe) ComponentRef.setInput Updating a signal that's read in a template Bound host or template listeners callbacks Attaching a view that was marked dirty by one of the above OnPush-compatible components One way to ensure that a component is using the correct notification mechanisms from above is to use ChangeDetectionStrategy.OnPush. The OnPush chang",
    "id": "zoneless-*-angular-5"
  },
  {
    "url": "https://angular.dev/guide/zoneless",
    "title": "Zoneless • Angular",
    "chunk": "e detection strategy is not required, but it is a recommended step towards zoneless compatibility for application components. It is not always possible for library components to use ChangeDetectionStrategy.OnPush. When a library component is a host for user-components which might use ChangeDetectionStrategy.Default, it cannot use OnPush because that would prevent the child component from being refreshed if it is not OnPush compatible and relies on ZoneJS to trigger change detection. Components c",
    "id": "zoneless-*-angular-6"
  },
  {
    "url": "https://angular.dev/guide/zoneless",
    "title": "Zoneless • Angular",
    "chunk": "an use the Default strategy as long as they notify Angular when change detection needs to run (calling markForCheck, using signals, AsyncPipe, etc.). Being a host for a user component means using an API such as ViewContainerRef.createComponent and not just hosting a portion of a template from a user component (i.e. content projection or a using a template ref input). Remove NgZone.onMicrotaskEmpty, NgZone.onUnstable, NgZone.isStable, or NgZone.onStable Applications and libraries need to remove u",
    "id": "zoneless-*-angular-7"
  },
  {
    "url": "https://angular.dev/guide/zoneless",
    "title": "Zoneless • Angular",
    "chunk": "ses of NgZone.onMicrotaskEmpty, NgZone.onUnstable and NgZone.onStable. These observables will never emit when an Application enables zoneless change detection. Similarly, NgZone.isStable will always be true and should not be used as a condition for code execution. The NgZone.onMicrotaskEmpty and NgZone.onStable observables are most often used to wait for Angular to complete change detection before performing a task. Instead, these can be replaced by afterNextRender if they need to wait for a sin",
    "id": "zoneless-*-angular-8"
  },
  {
    "url": "https://angular.dev/guide/zoneless",
    "title": "Zoneless • Angular",
    "chunk": "gle change detection or afterEveryRender if there is some condition that might span several change detection rounds. In other cases, these observables were used because they happened to be familiar and have similar timing to what was needed. More straightforward or direct DOM APIs can be used instead, such as MutationObserver when code needs to wait for certain DOM state (rather than waiting for it indirectly through Angular's render hooks). NgZone.run and NgZone.runOutsideAngular are compatible",
    "id": "zoneless-*-angular-9"
  },
  {
    "url": "https://angular.dev/guide/zoneless",
    "title": "Zoneless • Angular",
    "chunk": " with Zoneless NgZone.run and NgZone.runOutsideAngular do not need to be removed in order for code to be compatible with Zoneless applications. In fact, removing these calls can lead to performance regressions for libraries that are used in applications that still rely on ZoneJS. PendingTasks for Server Side Rendering (SSR) If you are using SSR with Angular, you may know that it relies on ZoneJS to help determine when the application is \"stable\" and can be serialized. If there are asynchronous t",
    "id": "zoneless-*-angular-10"
  },
  {
    "url": "https://angular.dev/guide/zoneless",
    "title": "Zoneless • Angular",
    "chunk": "asks that should prevent serialization, an application not using ZoneJS must make Angular aware of these with the PendingTasks service. Serialization will wait for the first moment that all pending tasks have been removed. The two most straightforward uses of pending tasks are the run method: const taskService = inject(PendingTasks);taskService.run(async () => { const someResult = await doSomeWorkThatNeedsToBeRendered(); this.someState.set(someResult);}); For more complicated use-cases, you can ",
    "id": "zoneless-*-angular-11"
  },
  {
    "url": "https://angular.dev/guide/zoneless",
    "title": "Zoneless • Angular",
    "chunk": "manuall add and remove a pending tasks: const taskService = inject(PendingTasks);const taskCleanup = taskService.add();try { await doSomeWorkThatNeedsToBeRendered();} catch { // handle error} finally { taskCleanup();} In addition, the pendingUntilEvent helper in rxjs-interop ensures the application remains unstable until the observable emits, complets, errors, or is unsubscribed. readonly myObservableState = someObservable.pipe(pendingUntilEvent()); The framework uses this service internally as ",
    "id": "zoneless-*-angular-12"
  },
  {
    "url": "https://angular.dev/guide/zoneless",
    "title": "Zoneless • Angular",
    "chunk": "well to prevent serialization until asynchronous tasks are complete. These include, but are not limited to, an ongoing Router navigation and an incomplete HttpClient request. Testing and Debugging Using Zoneless in TestBed The zoneless provider function can also be used with TestBed to help ensure the components under test are compatible with a Zoneless Angular application. TestBed.configureTestingModule({ providers: [provideZonelessChangeDetection()]});const fixture = TestBed.createComponent(My",
    "id": "zoneless-*-angular-13"
  },
  {
    "url": "https://angular.dev/guide/zoneless",
    "title": "Zoneless • Angular",
    "chunk": "Component);await fixture.whenStable(); To ensure tests have the most similar behavior to production code, avoid using fixture.detectChanges() when possible. This forces change detection to run when Angular might otherwise have not scheduled change detection. Tests should ensure these notifications are happening and allow Angular to handle when to synchronize state rather than manually forcing it to happen in the test. For existing test suites, using fixture.detectChanges() is a common pattern an",
    "id": "zoneless-*-angular-14"
  },
  {
    "url": "https://angular.dev/guide/zoneless",
    "title": "Zoneless • Angular",
    "chunk": "d it is likely not worth the effort of converting these to await fixture.whenStable(). TestBed will still enforce that the fixture's component is OnPush compatible and throws ExpressionChangedAfterItHasBeenCheckedError if it finds that template values were updated without a change notification (i.e. fixture.componentInstance.someValue = 'newValue';). If the component is used in production, this issue should be addressed by updating the component to use signals for state or call ChangeDetectorRef",
    "id": "zoneless-*-angular-15"
  },
  {
    "url": "https://angular.dev/guide/zoneless",
    "title": "Zoneless • Angular",
    "chunk": ".markForCheck(). If the component is only used as a test wrapper and never used in an application, it is acceptable to use fixture.changeDetectorRef.markForCheck(). Debug-mode check to ensure updates are detected Angular also provides an additional tool to help verify that an application is making updates to state in a zoneless-compatible way. provideCheckNoChangesConfig({exhaustive: true, interval: <milliseconds>}) can be used to periodically check to ensure that no bindings have been updated w",
    "id": "zoneless-*-angular-16"
  },
  {
    "url": "https://angular.dev/guide/zoneless",
    "title": "Zoneless • Angular",
    "chunk": "ithout a notification. Angular throws ExpressionChangedAfterItHasBeenCheckedError if there is an updated binding that would not have refreshed by the zoneless change detection. Social MediaBlogX (formerly Twitter)BlueskyYouTube Discord GitHub Stack Overflow Community Contribute Code of Conduct Report Issues Google's DevLibrary Angular Google Developer Experts ResourcesPress KitRoadmapLanguages简体中文版正體中文版日本語版한국어 Ελληνικά Super-powered by Google ©2010-2025. Code licensed under an MIT-style License ",
    "id": "zoneless-*-angular-17"
  },
  {
    "url": "https://angular.dev/guide/zoneless",
    "title": "Zoneless • Angular",
    "chunk": ". Documentation licensed under CC BY 4.0 .",
    "id": "zoneless-*-angular-18"
  },
  {
    "url": "https://angular.dev/errors",
    "title": "Error Encyclopedia • Overview • Angular",
    "chunk": "Error Encyclopedia Error Encyclopedia On this pagearrow_upward_alt Back to the top Runtime errors Code Name NG0100 Expression Changed After Checked NG0200 Circular Dependency in DI NG0201 No Provider Found NG0203 inject() must be called from an injection context NG0209 Invalid multi provider NG0300 Selector Collision NG0301 Export Not Found NG0302 Pipe Not Found NG0403 Bootstrapped NgModule doesn't specify which component to initialize NG0500 Hydration Node Mismatch NG0501 Hydration Missing Sibl",
    "id": "error-encyclopedia-*-overview-*-angular-0"
  },
  {
    "url": "https://angular.dev/errors",
    "title": "Error Encyclopedia • Overview • Angular",
    "chunk": "ings NG0502 Hydration Missing Node NG0503 Hydration Unsupported Projection of DOM Nodes NG0504 Skip hydration flag is applied to an invalid node NG0505 No hydration info in server response NG0506 NgZone remains unstable NG0507 HTML content was altered after SSR NG0750 @defer dependencies failed to load NG0910 Unsafe bindings on an iframe element NG0912 Component ID generation collision NG0955 Track expression resulted in duplicated keys for a given collection NG0956 Tracking expression caused re",
    "id": "error-encyclopedia-*-overview-*-angular-1"
  },
  {
    "url": "https://angular.dev/errors",
    "title": "Error Encyclopedia • Overview • Angular",
    "chunk": "-creation of the DOM structure NG01101 Wrong Async Validator Return Type NG01203 Missing value accessor NG02200 Missing Iterable Differ NG02800 JSONP support in HttpClient configuration NG05000 Hydration with unsupported Zone.js instance. NG05104 Root element was not found. Compiler errors Code Name NG1001 Argument Not Literal NG2003 Missing Token NG2009 Invalid Shadow DOM selector NG3003 Import Cycle Detected NG6100 NgModule.id Set to module.id anti-pattern NG8001 Invalid Element NG8002 Invalid",
    "id": "error-encyclopedia-*-overview-*-angular-2"
  },
  {
    "url": "https://angular.dev/errors",
    "title": "Error Encyclopedia • Overview • Angular",
    "chunk": " Attribute NG8003 Missing Reference Target Social MediaBlogX (formerly Twitter)BlueskyYouTube Discord GitHub Stack Overflow Community Contribute Code of Conduct Report Issues Google's DevLibrary Angular Google Developer Experts ResourcesPress KitRoadmapLanguages简体中文版正體中文版日本語版한국어 Ελληνικά Super-powered by Google ©2010-2025. Code licensed under an MIT-style License . Documentation licensed under CC BY 4.0 .",
    "id": "error-encyclopedia-*-overview-*-angular-3"
  },
  {
    "url": "https://angular.dev/extended-diagnostics",
    "title": "Extended Diagnostics • Overview • Angular",
    "chunk": "Extended Diagnostics Extended Diagnostics There are many coding patterns that are technically valid to the compiler or runtime, but which may have complex nuances or caveats. These patterns may not have the intended effect expected by a developer, which often leads to bugs. The Angular compiler includes \"extended diagnostics\" which identify many of these patterns, in order to warn developers about the potential issues and enforce common best practices within a codebase. On this pagearrow_upward_",
    "id": "extended-diagnostics-*-overview-*-angular-0"
  },
  {
    "url": "https://angular.dev/extended-diagnostics",
    "title": "Extended Diagnostics • Overview • Angular",
    "chunk": "alt Back to the top Diagnostics Currently, Angular supports the following extended diagnostics: Code Name NG8101 invalidBananaInBox NG8102 nullishCoalescingNotNullable NG8103 missingControlFlowDirective NG8104 textAttributeNotBinding NG8105 missingNgForOfLet NG8106 suffixNotSupported NG8107 optionalChainNotNullable NG8108 skipHydrationNotStatic NG8109 interpolatedSignalNotInvoked NG8111 uninvokedFunctionInEventBinding NG8113 unusedStandaloneImports NG8114 unparenthesizedNullishCoalescing NG8116 ",
    "id": "extended-diagnostics-*-overview-*-angular-1"
  },
  {
    "url": "https://angular.dev/extended-diagnostics",
    "title": "Extended Diagnostics • Overview • Angular",
    "chunk": "missingStructuralDirective Configuration Extended diagnostics are warnings by default and do not block compilation. Each diagnostic can be configured as either: Error category Effect warning Default - The compiler emits the diagnostic as a warning but does not block compilation. The compiler will still exist with status code 0, even if warnings are emitted. error The compiler emits the diagnostic as an error and fails the compilation. The compiler will exit with a non-zero status code if one or ",
    "id": "extended-diagnostics-*-overview-*-angular-2"
  },
  {
    "url": "https://angular.dev/extended-diagnostics",
    "title": "Extended Diagnostics • Overview • Angular",
    "chunk": "more errors are emitted. suppress The compiler does not emit the diagnostic at all. Check severity can be configured as an Angular compiler option: { \"angularCompilerOptions\": { \"extendedDiagnostics\": { // The categories to use for specific diagnostics. \"checks\": { // Maps check name to its category. \"invalidBananaInBox\": \"suppress\" }, // The category to use for any diagnostics not listed in `checks` above. \"defaultCategory\": \"error\" }}} The checks field maps the name of individual diagnostics t",
    "id": "extended-diagnostics-*-overview-*-angular-3"
  },
  {
    "url": "https://angular.dev/extended-diagnostics",
    "title": "Extended Diagnostics • Overview • Angular",
    "chunk": "o their associated category. See Diagnostics for a complete list of extended diagnostics and the name to use for configuring them. The defaultCategory field is used for any diagnostics that are not explicitly listed under checks. If not set, such diagnostics will be treated as warning. Extended diagnostics will emit when strictTemplates is enabled. This is required to allow the compiler to better understand Angular template types and provide accurate and meaningful diagnostics. Semantic Versioni",
    "id": "extended-diagnostics-*-overview-*-angular-4"
  },
  {
    "url": "https://angular.dev/extended-diagnostics",
    "title": "Extended Diagnostics • Overview • Angular",
    "chunk": "ng The Angular team intends to add or enable new extended diagnostics in minor versions of Angular (see semver). This means that upgrading Angular may show new warnings in your existing codebase. This enables the team to deliver features more quickly and to make extended diagnostics more accessible to developers. However, setting \"defaultCategory\": \"error\" will promote such warnings to hard errors. This can cause a minor version upgrade to introduce compilation errors, which may be seen as a sem",
    "id": "extended-diagnostics-*-overview-*-angular-5"
  },
  {
    "url": "https://angular.dev/extended-diagnostics",
    "title": "Extended Diagnostics • Overview • Angular",
    "chunk": "ver non-compliant breaking change. Any new diagnostics can be suppressed or demoted to warnings via the above configuration, so the impact of a new diagnostic should be minimal to projects that treat extended diagnostics as errors by default. Defaulting to error is a very powerful tool; just be aware of this semver caveat when deciding if error is the right default for your project. New Diagnostics The Angular team is always open to suggestions about new diagnostics that could be added. Extended",
    "id": "extended-diagnostics-*-overview-*-angular-6"
  },
  {
    "url": "https://angular.dev/extended-diagnostics",
    "title": "Extended Diagnostics • Overview • Angular",
    "chunk": " diagnostics should generally: Detect a common, non-obvious developer mistake with Angular templates Clearly articulate why this pattern can lead to bugs or unintended behavior Suggest one or more clear solutions Have a low, preferably zero, false-positive rate Apply to the vast majority of Angular applications (not specific to an unofficial library) Improve program correctness or performance (not style, that responsibility falls to a linter) If you have an idea for an extended diagnostic which ",
    "id": "extended-diagnostics-*-overview-*-angular-7"
  },
  {
    "url": "https://angular.dev/extended-diagnostics",
    "title": "Extended Diagnostics • Overview • Angular",
    "chunk": "fits these criteria, consider filing a feature request. Social MediaBlogX (formerly Twitter)BlueskyYouTube Discord GitHub Stack Overflow Community Contribute Code of Conduct Report Issues Google's DevLibrary Angular Google Developer Experts ResourcesPress KitRoadmapLanguages简体中文版正體中文版日本語版한국어 Ελληνικά Super-powered by Google ©2010-2025. Code licensed under an MIT-style License . Documentation licensed under CC BY 4.0 .",
    "id": "extended-diagnostics-*-overview-*-angular-8"
  },
  {
    "url": "https://angular.dev/update-guide",
    "title": "Angular",
    "chunk": "Update GuideSelect the options that match your updateAngular versions From v. 19.0expand_more To v. 20.0expand_moreApplication complexityBasicMediumAdvancedShows information for all Angular developers.Other dependenciesI use ngUpgrade to combine AngularJS & AngularI use Angular Material I use Windows Show me how to update! Social MediaBlogX (formerly Twitter)BlueskyYouTube Discord GitHub Stack Overflow Community Contribute Code of Conduct Report Issues Google's DevLibrary Angular Google Develope",
    "id": "angular-0"
  },
  {
    "url": "https://angular.dev/update-guide",
    "title": "Angular",
    "chunk": "r Experts ResourcesPress KitRoadmapLanguages简体中文版正體中文版日本語版한국어 Ελληνικά Super-powered by Google ©2010-2025. Code licensed under an MIT-style License . Documentation licensed under CC BY 4.0 . BasicMediumAdvanced",
    "id": "angular-1"
  },
  {
    "url": "https://angular.dev/roadmap",
    "title": "Roadmap • Angular",
    "chunk": "Angular Roadmap Learn how the Angular team is building momentum on the web. As an open source project, Angular’s daily commits, PRs and momentum is all trackable on GitHub. To increase transparency into how this daily work connects to the framework’s future, our roadmap brings together the team’s current and future planned vision. The following projects are not associated with a particular Angular version. We will release them on completion, and they will be part of a specific version based on o",
    "id": "roadmap-*-angular-0"
  },
  {
    "url": "https://angular.dev/roadmap",
    "title": "Roadmap • Angular",
    "chunk": "ur release schedule, following semantic versioning. For example, we release features in the next minor after completion or the next major if they include breaking changes. Currently, Angular has two goals for the framework: Improve the Angular developer experience and Improve the framework’s performance. Continue reading to learn how we plan to deliver these objectives with specific project work. On this pagearrow_upward_alt Back to the top Explore modern Angular Start developing with the latest",
    "id": "roadmap-*-angular-1"
  },
  {
    "url": "https://angular.dev/roadmap",
    "title": "Roadmap • Angular",
    "chunk": " Angular features from our roadmap. This list represents the current status of new features from our roadmap: Available to experiment with Zoneless change detection Resource API httpResource Production ready Linked Signal API Incremental hydration Effect API Event replay with SSR Route-level render mode Improving the Angular developer experience Developer velocity Selectorless To reduce boilerplate and improve the ergonomics of standalone components we are now designing a solution that will make",
    "id": "roadmap-*-angular-2"
  },
  {
    "url": "https://angular.dev/roadmap",
    "title": "Roadmap • Angular",
    "chunk": " selectors optional. To use a component or directive you'll be able to import it and directly use it in a component's template. We kicked off early prototyping of selectorless and we're still in early stages of planning. We'll share a request for comments when we have a design and we're ready for next steps. Signal Forms We plan to analyze existing feedback about Angular forms and design a solution which addresses developers' requirements and uses Signals for management of reactive state. Asynch",
    "id": "roadmap-*-angular-3"
  },
  {
    "url": "https://angular.dev/roadmap",
    "title": "Roadmap • Angular",
    "chunk": "ronous reactivity To enable developers to handle asynchronous data flow with signals we developed the resource async primitive. Building on top of it, we introduced httpResource which allows you to send HTTP requests and receive your response as a signal. We're still actively collecting feedback for these new experimental APIs. Please give them a try and share your feedback with us on GitHub! Learn more Zoneless Angular In v18 we shipped experimental zoneless support in Angular. It enables devel",
    "id": "roadmap-*-angular-4"
  },
  {
    "url": "https://angular.dev/roadmap",
    "title": "Roadmap • Angular",
    "chunk": "opers to use the framework without including zone.js in their bundle, which improves performance, debugging experience, and interoperability. As part of the initial release we also introduced zoneless support to the Angular CDK and Angular Material. In v19 we introduced zoneless support in server-side rendering, addressed some edge cases, and created a schematic to scaffold zoneless projects. We transitioned Google Fonts to zoneless which improved performance, developer experience, and allowed u",
    "id": "roadmap-*-angular-5"
  },
  {
    "url": "https://angular.dev/roadmap",
    "title": "Roadmap • Angular",
    "chunk": "s to identify gaps that we need to address before moving this feature to developer preview. As of Angular v20, Zoneless Angular is now in developer preview and includes improvements in error handling and server-side rendering. Signal integrations We're working towards improving the integration of fundamental Angular packages, such as forms, HTTP, and router, with Signals. As part of this project, we'll seek opportunities to introduce convenient signal-based APIs or wrappers to improve the holist",
    "id": "roadmap-*-angular-6"
  },
  {
    "url": "https://angular.dev/roadmap",
    "title": "Roadmap • Angular",
    "chunk": "ic developer experience. Improve HMR (Hot Module Reload) We're working towards faster edit/refresh cycle by enabling hot module replacement. In Angular v19 we shipped initial support for CSS and template HMR and in v20 we graduated template HMR to stable. We'll continue collecting feedback to make sure we're addressing developers' needs before we mark this project as complete. Learn more Improve Angular Material and the CDK New CDK primitives We are working on new CDK primitives to facilitate cr",
    "id": "roadmap-*-angular-7"
  },
  {
    "url": "https://angular.dev/roadmap",
    "title": "Roadmap • Angular",
    "chunk": "eating custom components based on the WAI-ARIA design patterns for Combobox. Angular v14 introduced stable menu and dialog primitives as part of this project, and in v15 Listbox. Angular component accessibility We are evaluating components in Angular Material against accessibility standards such as WCAG and working to fix any issues that arise from this process. Improve tooling Modernize unit testing tooling with ng test In v12, we revisited the Angular end-to-end testing experience by replacing",
    "id": "roadmap-*-angular-8"
  },
  {
    "url": "https://angular.dev/roadmap",
    "title": "Roadmap • Angular",
    "chunk": " Protractor with modern alternatives such as Cypress, Nightwatch, Puppeteer, Playwright, and Webdriver.io. Next, we'd like to tackle ng test to modernize Angular's unit testing experience. In Angular v20 we introduced experimental support for vitest. Make sure you give it a try and share your feedback with us! Evaluating Nitro support in the Angular CLI We're excited about the set of features that Nitro offers such as more deployment options, improved compatibility of server-side rendering with ",
    "id": "roadmap-*-angular-9"
  },
  {
    "url": "https://angular.dev/roadmap",
    "title": "Roadmap • Angular",
    "chunk": "different runtimes and file-based routing. In 2025 we'll evaluate how it fits in the Angular server-side rendering model. We'll share updates as we make progress in this investigation. Learn more Signal debugging in Angular DevTools With the evolution of Signals in Angular, we are working on a better tooling for debugging them. High on the priority list is a UI for inspecting and debugging signals. Future work, explorations, and prototyping This section represents explorations and prototyping of",
    "id": "roadmap-*-angular-10"
  },
  {
    "url": "https://angular.dev/roadmap",
    "title": "Roadmap • Angular",
    "chunk": " potential future projects. A reasonable outcome is to decide that our current solutions are the best options. Other projects may result in RFCs, graduating to in-progress projects, or being deprioritized as the web continues to innovate along with our framework. Exploration of streamed server-side rendering Over the past few releases we've been working on making Angular's server-side rendering story more robust. On our priority list is to explore streamed server-side rendering for zoneless appl",
    "id": "roadmap-*-angular-11"
  },
  {
    "url": "https://angular.dev/roadmap",
    "title": "Roadmap • Angular",
    "chunk": "ication. Investigation for authoring format improvements Based on our developer surveys' results we saw there are opportunities for improving the ergonomics of the component authoring format. The first step of the process will be to gather requirements and understand the problem space in advanced to an RFC. We'll share updates as we make progress. High priority in the future work will be backward compatibility and interoperability. Improve TestBed Based on feedback over the years and the recent ",
    "id": "roadmap-*-angular-12"
  },
  {
    "url": "https://angular.dev/roadmap",
    "title": "Roadmap • Angular",
    "chunk": "updates in Angular's runtime, we'll evaluate TestBed to identify opportunities to improve developer experience and reduce boilerplate when developing unit tests. Incremental adoption Angular has been lacking the tools and the flexibility to add interactivity to a multi-page app or embed an Angular component inside of an existing app built with a different framework. As part of this project, we'll explore the requirement space of cross framework interop and our build tooling offering to make this",
    "id": "roadmap-*-angular-13"
  },
  {
    "url": "https://angular.dev/roadmap",
    "title": "Roadmap • Angular",
    "chunk": " use case possible. Completed projects Server route configuration We're working towards enabling a more ergonomic route configuration on the server. We want to make it trivial to declare which routes should be server-side rendered, prerendered or client-side rendered. In Angular v19 we shipped developer preview of route-level render mode which allows you to granularly configure which routes you want Angular to prerender, server-side render or client-side render. In Angular v20 we graduated it to",
    "id": "roadmap-*-angular-14"
  },
  {
    "url": "https://angular.dev/roadmap",
    "title": "Roadmap • Angular",
    "chunk": " stable. Completed in Q2 2025 Enable incremental hydration In v17 we graduated hydration from developer preview and we've been consistently observing 40-50% improvements in LCP. Since then we started prototyping incremental hydration and shared a demo on stage at ng-conf. In v19 we shipped the incremental hydration in developer preview mode, powered by @defer blocks. In Angular v20 we graduated it to stable! Completed in Q2 2025 Deliver Angular Signals This project rethinks the Angular reactivit",
    "id": "roadmap-*-angular-15"
  },
  {
    "url": "https://angular.dev/roadmap",
    "title": "Roadmap • Angular",
    "chunk": "y model by introducing Signals as a reactivity primitive. The initial planning resulted in hundreds of discussions, conversations with developers, feedback sessions, user experience studies, and a series of RFCs, which received over 1,000 comments. In Angular v20 we graduated all the fundamental reactivity primitives to stable including signal, effect, linkedSignal, signal-based queries, and inputs. Completed in Q2 2025 Support two-dimensional drag-and-drop As part of this project, we implemente",
    "id": "roadmap-*-angular-16"
  },
  {
    "url": "https://angular.dev/roadmap",
    "title": "Roadmap • Angular",
    "chunk": "d mixed orientation support for the Angular CDK drag and drop. This is one of the repository's most highly requested features. Completed in Q2 2024 Event replay with SSR and prerendering In v18 we introduced an event replay functionality when using server-side rendering or prerendering. For this feature we depend on the event dispatch primitive (previously known as jsaction) that is running on Google.com. In Angular v19 we graduated event replay to stable and enabled it by default for all new pr",
    "id": "roadmap-*-angular-17"
  },
  {
    "url": "https://angular.dev/roadmap",
    "title": "Roadmap • Angular",
    "chunk": "ojects. Completed in Q4 2024 Integrate Angular Language Service with Schematics To make it easier for developers to use modern Angular APIs, we enabled integration between the Angular language service and schematics which allows you to refactor your app with a single click. Completed in Q4 2024 Streamline standalone imports with Language Service As part of this initiative, the language service automatically imports components and pipes in standalone and NgModule-based apps. Additionally, we've a",
    "id": "roadmap-*-angular-18"
  },
  {
    "url": "https://angular.dev/roadmap",
    "title": "Roadmap • Angular",
    "chunk": "dded a template diagnostic to highlight unused imports in standalone components, which should help make application bundles smaller. Completed in Q4 2024 Local template variables We've released the support for local template variables in Angular, see @let docs for additional information. Completed in Q3 2024 Expand the customizability of Angular Material To provide better customization of our Angular Material components and enable Material 3 capabilities, we'll be collaborating with Google's Mat",
    "id": "roadmap-*-angular-19"
  },
  {
    "url": "https://angular.dev/roadmap",
    "title": "Roadmap • Angular",
    "chunk": "erial Design team on defining token-based theming APIs. In v17.2 we shared experimental support for Angular Material 3 and in v18 we graduated it to stable. Completed in Q2 2024 Introduce deferred loading In v17 we shipped deferrable views in developer preview, which provide an ergonomic API for deferred code loading. In v18 we enabled deferrable views for library developers and graduated the API to stable. Completed in Q2 2024 iframe support in Angular DevTools We enabled debugging and profilin",
    "id": "roadmap-*-angular-20"
  },
  {
    "url": "https://angular.dev/roadmap",
    "title": "Roadmap • Angular",
    "chunk": "g of Angular apps embedded within an iframe on the page. Completed in Q2 2024 Automation for transition of existing hybrid rendering projects to esbuild and vite In v17 we shipped a vite and esbuild-based application builder and enabled it for new projects by default. It improves build time for projects using hybrid rendering with up to 87%. As part of v18 we shipped schematics and a guide that migrate existing projects using hybrid rendering to the new build pipeline. Completed in Q2 2024 Make ",
    "id": "roadmap-*-angular-21"
  },
  {
    "url": "https://angular.dev/roadmap",
    "title": "Roadmap • Angular",
    "chunk": "Angular.dev the official home for Angular developers Angular.dev is the new site, domain and home for Angular development. The new site contains updated documentation, tutorials and guidance that will help developers build with Angular’s latest features. Completed in Q2 2024 Introduce built-in control flow In v17 we shipped a developer preview version of a new control flow. It brings significant performance improvements and better ergonomics for template authoring. We also provided a migration o",
    "id": "roadmap-*-angular-22"
  },
  {
    "url": "https://angular.dev/roadmap",
    "title": "Roadmap • Angular",
    "chunk": "f existing *ngIf, *ngFor, and *ngSwitch which you can run to move your project to the new implementation. As of v18 the built-in control flow is now stable. Completed in Q2 2024 Modernize getting started tutorial Over the past two quarters, we developed a new video and textual tutorial based on standalone components. Completed Q4 2023 Investigate modern bundlers In Angular v16, we released a developer preview of an esbuild-based builder with support for ng build and ng serve. The ng serve develo",
    "id": "roadmap-*-angular-23"
  },
  {
    "url": "https://angular.dev/roadmap",
    "title": "Roadmap • Angular",
    "chunk": "pment server uses Vite and a multi-file compilation by esbuild and the Angular compiler. In v17 we graduated the build tooling from developer preview and enabled it by default for new projects. Completed Q4 2023 Introduce dependency injection debugging APIs To improve the debugging utilities of Angular and Angular DevTools, we'll work on APIs that provide access to the dependency injection runtime. As part of the project, we'll expose debugging methods that allow us to explore the injector hiera",
    "id": "roadmap-*-angular-24"
  },
  {
    "url": "https://angular.dev/roadmap",
    "title": "Roadmap • Angular",
    "chunk": "rchy and the dependencies across their associated providers. As of v17, we shipped a feature that enables us to plug into the dependency injection life-cycle. We also launched a visualization of the injector tree and inspection of the providers declared inside each individual node, Completed Q4 2023 Improve documentation and schematics for standalone components We released a developer preview of the ng new --standalone schematics collection, allowing you to create apps free of NgModules. In v17 ",
    "id": "roadmap-*-angular-25"
  },
  {
    "url": "https://angular.dev/roadmap",
    "title": "Roadmap • Angular",
    "chunk": "we switched the new application authoring format to standalone APIs and changed the documentation to reflect the recommendation. Additionally, we shipped schematics which support updating existing applications to standalone components, directives, and pipes. Even though NgModules will stick around for foreseeable future, we recommend you to explore the benefits of the new APIs to improve developer experience and benefit from the new features we build for them. Completed Q4 2023 Explore hydration",
    "id": "roadmap-*-angular-26"
  },
  {
    "url": "https://angular.dev/roadmap",
    "title": "Roadmap • Angular",
    "chunk": " and server-side rendering improvements In v16, we released a developer preview of non-destructive full hydration, see the hydration guide and the blog post for additional information. We're already seeing significant improvements to Core Web Vitals, including LCP and CLS. In lab tests, we consistently observed 45% better LCP of a real-world app. In v17 we launched hydration outside developer preview and did a series of improvements in the server-side rendering story, including: route discovery ",
    "id": "roadmap-*-angular-27"
  },
  {
    "url": "https://angular.dev/roadmap",
    "title": "Roadmap • Angular",
    "chunk": "at runtime for SSG, up to 87% faster build times for hybrid rendered applications, prompt that enables hybrid rendering for new projects. Completed Q4 2023 Non-destructive full app hydration In v16, we released a developer preview of non-destructive full hydration, which allows Angular to reuse existing DOM nodes on a server-side rendered page, instead of re-creating an app from scratch. See additional information in the hydration guide. Completed Q1 2023 Improvements in the image directive We r",
    "id": "roadmap-*-angular-28"
  },
  {
    "url": "https://angular.dev/roadmap",
    "title": "Roadmap • Angular",
    "chunk": "eleased the Angular image directive as stable in v15. We introduced a new fill mode feature that enables images to fit within their parent container rather than having explicit dimensions. Over the past two months, the Chrome Aurora team backported the directive to v12 and newer. Completed Q1 2023 Documentation refactoring Ensure all existing documentation fits into a consistent set of content types. Update excessive use of tutorial-style documentation into independent topics. We want to ensure ",
    "id": "roadmap-*-angular-29"
  },
  {
    "url": "https://angular.dev/roadmap",
    "title": "Roadmap • Angular",
    "chunk": "the content outside the main tutorials is self-sufficient without being tightly coupled to a series of guides. In Q2 2022, we refactored the template content and dependency injection. In Q1 2023, we improved the HTTP guides, and with this, we're putting the documentation refactoring project on hold. Completed Q1 2023 Improve image performance The Aurora and the Angular teams are working on the implementation of an image directive that aims to improve Core Web Vitals. We shipped a stable version ",
    "id": "roadmap-*-angular-30"
  },
  {
    "url": "https://angular.dev/roadmap",
    "title": "Roadmap • Angular",
    "chunk": "of the image directive in v15. Completed Q4 2022 Modern CSS The Web ecosystem evolves constantly and we want to reflect the latest modern standards in Angular. In this project we aim to provide guidelines on using modern CSS features in Angular to ensure developers follow best practices for layout, styling, etc. We shared official guidelines for layout and as part of the initiative stopped publishing flex layout. Completed Q4 2022 Support adding directives to host elements A long-standing featur",
    "id": "roadmap-*-angular-31"
  },
  {
    "url": "https://angular.dev/roadmap",
    "title": "Roadmap • Angular",
    "chunk": "e request is to add the ability to add directives to host elements. The feature lets developers augment their own components with additional behaviors without using inheritance. In v15 we shipped our directive composition API, which enables enhancing host elements with directives. Completed Q4 2022 Better stack traces The Angular and the Chrome DevTools are working together to enable more readable stack traces for error messages. In v15 we released improved relevant and linked stack traces. As a",
    "id": "roadmap-*-angular-32"
  },
  {
    "url": "https://angular.dev/roadmap",
    "title": "Roadmap • Angular",
    "chunk": " lower priority initiative, we'll be exploring how to make the stack traces friendlier by providing more accurate call frame names for templates. Completed Q4 2022 Enhanced Angular Material components by integrating MDC Web MDC Web is a library created by the Google Material Design team that provides reusable primitives for building Material Design components. The Angular team is incorporating these primitives into Angular Material. Using MDC Web aligns Angular Material more closely with the Mat",
    "id": "roadmap-*-angular-33"
  },
  {
    "url": "https://angular.dev/roadmap",
    "title": "Roadmap • Angular",
    "chunk": "erial Design specification, expands accessibility, improves component quality, and improves the velocity of our team. Completed Q4 2022 Implement APIs for optional NgModules In the process of making Angular simpler, we are working on introducing APIs that allow developers to initialize apps, instantiate components, and use the router without NgModules. Angular v14 introduces developer preview of the APIs for standalone components, directives, and pipes. In the next few quarters we'll collect fee",
    "id": "roadmap-*-angular-34"
  },
  {
    "url": "https://angular.dev/roadmap",
    "title": "Roadmap • Angular",
    "chunk": "dback from developers and finalize the project making the APIs stable. As the next step we will work on improving use cases such as TestBed, Angular elements, etc. Completed Q4 2022 Allow binding to protected fields in templates To improve the encapsulation of Angular components we enabled binding to protected members of the component instance. This way you'll no longer have to expose a field or a method as public to use it inside your templates. Completed Q2 2022 Publish guides on advanced conc",
    "id": "roadmap-*-angular-35"
  },
  {
    "url": "https://angular.dev/roadmap",
    "title": "Roadmap • Angular",
    "chunk": "epts Develop and publish an in-depth guide on change detection. Develop content for performance profiling of Angular apps. Cover how change detection interacts with Zone.js and explain when it gets triggered, how to profile its duration, as well as common practices for performance optimization. Completed Q2 2022 Rollout strict typings for @angular/forms In Q4 2021 we designed a solution for introducing strict typings for forms and in Q1 2022 we concluded the corresponding request for comments. C",
    "id": "roadmap-*-angular-36"
  },
  {
    "url": "https://angular.dev/roadmap",
    "title": "Roadmap • Angular",
    "chunk": "urrently, we are implementing a rollout strategy with an automated migration step that will enable the improvements for existing projects. We are first testing the solution with more than 2,500 projects at Google to ensure a smooth migration path for the external community. Completed Q2 2022 Remove legacy View Engine After the transition of all our internal tooling to Ivy is completed, we will remove the legacy View Engine for reduced Angular conceptual overhead, smaller package size, lower main",
    "id": "roadmap-*-angular-37"
  },
  {
    "url": "https://angular.dev/roadmap",
    "title": "Roadmap • Angular",
    "chunk": "tenance cost, and lower codebase complexity. Completed Q1 2022 Simplified Angular mental model with optional NgModules To simplify the Angular mental model and learning journey, we will be working on making NgModules optional. This work lets developers develop standalone components and implement an alternative API for declaring the compilation scope of the component. We kicked this project off with high-level design discussions that we captured in an RFC. Completed Q1 2022 Design strict typing f",
    "id": "roadmap-*-angular-38"
  },
  {
    "url": "https://angular.dev/roadmap",
    "title": "Roadmap • Angular",
    "chunk": "or @angular/forms We will work on finding a way to implement stricter type checking for reactive forms with minimal backward incompatible implications. This way, we let developers catch more issues during development time, enable better text editor and IDE support, and improve the type checking for reactive forms. Completed Q1 2022 Improve integration of Angular DevTools with framework To improve the integration of Angular DevTools with the framework, we are working on moving the codebase to the",
    "id": "roadmap-*-angular-39"
  },
  {
    "url": "https://angular.dev/roadmap",
    "title": "Roadmap • Angular",
    "chunk": " angular/angular monorepository. This includes transitioning Angular DevTools to Bazel and integrating it into the existing processes and CI pipeline. Completed Q1 2022 Launch advanced compiler diagnostics Extend the diagnostics of the Angular compiler outside type checking. Introduce other correctness and conformance checks to further guarantee correctness and best practices. Completed Q1 2022 Update our e2e testing strategy To ensure we provide a future-proof e2e testing strategy, we want to e",
    "id": "roadmap-*-angular-40"
  },
  {
    "url": "https://angular.dev/roadmap",
    "title": "Roadmap • Angular",
    "chunk": "valuate the state of Protractor, community innovations, e2e best practices, and explore novel opportunities. As first steps of the effort, we shared an RFC and worked with partners to ensure smooth integration between the Angular CLI and state-of-the-art tooling for e2e testing. As the next step, we need to finalize the recommendations and compile a list of resources for the transition. Completed Q3 2021 Angular libraries use Ivy Earlier in 2020, we shared an RFC for Ivy library distribution. Af",
    "id": "roadmap-*-angular-41"
  },
  {
    "url": "https://angular.dev/roadmap",
    "title": "Roadmap • Angular",
    "chunk": "ter invaluable feedback from the community, we developed a design of the project. We are now investing in the development of Ivy library distribution, including an update of the library package format to use Ivy compilation, unblock the deprecation of the View Engine library format, and ngcc. Completed Q3 2021 Improve test times and debugging with automatic test environment tear down To improve test time and create better isolation across tests, we want to change TestBed to automatically clean u",
    "id": "roadmap-*-angular-42"
  },
  {
    "url": "https://angular.dev/roadmap",
    "title": "Roadmap • Angular",
    "chunk": "p and tear down the test environment after each test run. Completed Q3 2021 Deprecate and remove IE11 support Internet Explorer 11 (IE11) has been preventing Angular from taking advantage of some of the modern features of the Web platform. As part of this project we are going to deprecate and remove IE11 support to open the path for modern features that evergreen browsers provide. We ran an RFC to collect feedback from the community and decide on next steps to move forward. Completed Q3 2021 Lev",
    "id": "roadmap-*-angular-43"
  },
  {
    "url": "https://angular.dev/roadmap",
    "title": "Roadmap • Angular",
    "chunk": "erage ES2017+ as the default output language Supporting modern browsers lets us take advantage of the more compact, expressive, and performant new syntax of JavaScript. As part of this project we will investigate what the blockers are to moving forward with this effort, and take the steps to enable it. Completed Q3 2021 Accelerated debugging and performance profiling with Angular DevTools We are working on development tooling for Angular that provides utilities for debugging and performance prof",
    "id": "roadmap-*-angular-44"
  },
  {
    "url": "https://angular.dev/roadmap",
    "title": "Roadmap • Angular",
    "chunk": "iling. This project aims to help developers understand the component structure and the change detection in an Angular app. Completed Q2 2021 Streamline releases with consolidated Angular versioning & branching We want to consolidate release management tooling between the multiple GitHub repositories for Angular (angular/angular, angular/angular-cli, and angular/components). This effort lets us reuse infrastructure, unify and simplify processes, and improve the reliability of our release process.",
    "id": "roadmap-*-angular-45"
  },
  {
    "url": "https://angular.dev/roadmap",
    "title": "Roadmap • Angular",
    "chunk": " Completed Q2 2021 Higher developer consistency with commit message standardization We want to unify commit message requirements and conformance across Angular repositories (angular/angular, angular/components, and angular/angular-cli) to bring consistency to our development process and reuse infrastructure tooling. Completed Q2 2021 Transition the Angular language service to Ivy The goal of this project is to improve the experience and remove legacy dependency by transitioning the language serv",
    "id": "roadmap-*-angular-46"
  },
  {
    "url": "https://angular.dev/roadmap",
    "title": "Roadmap • Angular",
    "chunk": "ice to Ivy. Today the language service still uses the View Engine compiler and type checking, even for Ivy apps. We want to use the Ivy template parser and improved type checking for the Angular Language service to match app behavior. This migration is also a step towards unblocking the removal of View Engine, which will simplify Angular, reduce the npm package size, and improve the maintainability of the framework. Completed Q2 2021 Increased security with native Trusted Types in Angular In col",
    "id": "roadmap-*-angular-47"
  },
  {
    "url": "https://angular.dev/roadmap",
    "title": "Roadmap • Angular",
    "chunk": "laboration with the Google security team, we are adding support for the new Trusted Types API. This web platform API helps developers build more secure web apps. Completed Q2 2021 Optimized build speed and bundle sizes with Angular CLI webpack 5 As part of the v11 release, we introduced an opt-in preview of webpack 5 in the Angular CLI. To ensure stability, we will continue iterating on the implementation to enable build speed and bundle size improvements. Completed Q2 2021 Faster apps by inlini",
    "id": "roadmap-*-angular-48"
  },
  {
    "url": "https://angular.dev/roadmap",
    "title": "Roadmap • Angular",
    "chunk": "ng critical styles in Universal apps Loading external stylesheets is a blocking operation, which means that the browser cannot start rendering your app until it loads all the referenced CSS. Having render-blocking resources in the header of a page can significantly impact its load performance, for example, its first contentful paint. To make apps faster, we have been collaborating with the Google Chrome team on inlining critical CSS and loading the rest of the styles asynchronously. Completed Q1",
    "id": "roadmap-*-angular-49"
  },
  {
    "url": "https://angular.dev/roadmap",
    "title": "Roadmap • Angular",
    "chunk": " 2021 Improve debugging with better Angular error messages Error messages often bring limited actionable information to help developers resolve them. We have been working on making error messages more discoverable by adding associated codes, developing guides, and other materials to ensure a smoother debugging experience. Completed Q1 2021 Improved developer onboarding with refreshed introductory documentation We will redefine the user learning journeys and refresh the introductory documentation",
    "id": "roadmap-*-angular-50"
  },
  {
    "url": "https://angular.dev/roadmap",
    "title": "Roadmap • Angular",
    "chunk": ". We will clearly state the benefits of Angular, how to explore its capabilities and provide guidance so developers can become proficient with the framework in as little time as possible. Completed Q1 2021 Expand component harnesses best practices Angular CDK introduced the concept of component test harnesses to Angular in version 9. Test harnesses let component authors create supported APIs for testing component interactions. We are continuing to improve this harness infrastructure and clarifyi",
    "id": "roadmap-*-angular-51"
  },
  {
    "url": "https://angular.dev/roadmap",
    "title": "Roadmap • Angular",
    "chunk": "ng the best practices around using harnesses. We are also working to drive more harness adoption inside of Google. Completed Q1 2021 Author a guide for content projection Content projection is a core Angular concept that does not have the presence it deserves in the documentation. As part of this project we want to identify the core use cases and concepts for content projection and document them. Completed Q2 2021 Migrate to ESLint With the deprecation of TSLint we will be moving to ESLint. As p",
    "id": "roadmap-*-angular-52"
  },
  {
    "url": "https://angular.dev/roadmap",
    "title": "Roadmap • Angular",
    "chunk": "art of the process, we will work on ensuring backward compatibility with our current recommended TSLint configuration, implement a migration strategy for existing Angular apps and introduce new tooling to the Angular CLI toolchain. Completed Q4 2020 Operation Bye Bye Backlog (also known as Operation Byelog) We are actively investing up to 50% of our engineering capacity on triaging issues and PRs until we have a clear understanding of broader community needs. After that, we will commit up to 20%",
    "id": "roadmap-*-angular-53"
  },
  {
    "url": "https://angular.dev/roadmap",
    "title": "Roadmap • Angular",
    "chunk": " of our engineering capacity to keep up with new submissions promptly. Completed Q4 2020 Social MediaBlogX (formerly Twitter)BlueskyYouTube Discord GitHub Stack Overflow Community Contribute Code of Conduct Report Issues Google's DevLibrary Angular Google Developer Experts ResourcesPress KitRoadmapLanguages简体中文版正體中文版日本語版한국어 Ελληνικά Super-powered by Google ©2010-2025. Code licensed under an MIT-style License . Documentation licensed under CC BY 4.0 . Angular Roadmap Learn how the Angular team is",
    "id": "roadmap-*-angular-54"
  },
  {
    "url": "https://angular.dev/roadmap",
    "title": "Roadmap • Angular",
    "chunk": " building momentum on the web.",
    "id": "roadmap-*-angular-55"
  },
  {
    "url": "https://angular.dev/update",
    "title": "Keeping up-to-date • Angular",
    "chunk": "Best Practices Keeping your Angular projects up-to-date Just like Web and the entire web ecosystem, Angular is continuously improving. Angular balances continuous improvement with a strong focus on stability and making updates straightforward. Keeping your Angular application up-to-date enables you to take advantage of leading-edge new features, as well as optimizations and bug fixes. This document contains information and resources to help you keep your Angular applications and libraries up-to-",
    "id": "keeping-up-to-date-*-angular-0"
  },
  {
    "url": "https://angular.dev/update",
    "title": "Keeping up-to-date • Angular",
    "chunk": "date. For information about our versioning policy and practices —including support and deprecation practices, as well as the release schedule— see Angular versioning and releases. HELPFUL: If you are currently using AngularJS, see Upgrading from AngularJS. AngularJS is the name for all v1.x versions of Angular. On this pagearrow_upward_alt Back to the top Getting notified of new releases To be notified when new releases are available, follow @angular on X (formerly Twitter) or subscribe to the A",
    "id": "keeping-up-to-date-*-angular-1"
  },
  {
    "url": "https://angular.dev/update",
    "title": "Keeping up-to-date • Angular",
    "chunk": "ngular blog. Learning about new features What's new? What's changed? We share the most important things you need to know on the Angular blog in release announcements. To review a complete list of changes, organized by version, see the Angular change log. Checking your version of Angular To check your application's version of Angular use the ng version command from within your project directory. Finding the current version of Angular The most recent stable released version of Angular appears on n",
    "id": "keeping-up-to-date-*-angular-2"
  },
  {
    "url": "https://angular.dev/update",
    "title": "Keeping up-to-date • Angular",
    "chunk": "pm under \"Version.\" For example, 16.2.4. You can also find the most current version of Angular by using the CLI command ng update. By default, ng update(without additional arguments) lists the updates that are available to you. Updating your environment and apps To make updating uncomplicated, we provide complete instructions in the interactive Angular Update Guide. The Angular Update Guide provides customized update instructions, based on the current and target versions that you specify. It inc",
    "id": "keeping-up-to-date-*-angular-3"
  },
  {
    "url": "https://angular.dev/update",
    "title": "Keeping up-to-date • Angular",
    "chunk": "ludes basic and advanced update paths, to match the complexity of your applications. It also includes troubleshooting information and any recommended manual changes to help you get the most out of the new release. For simple updates, the CLI command ng update is all you need. Without additional arguments, ng update lists the updates that are available to you and provides recommended steps to update your application to the most current version. Angular Versioning and Releases describes the level ",
    "id": "keeping-up-to-date-*-angular-4"
  },
  {
    "url": "https://angular.dev/update",
    "title": "Keeping up-to-date • Angular",
    "chunk": "of change that you can expect based on a release's version number. It also describes supported update paths. Resource summary Release announcements: Angular blog - release announcements Release details: Angular change log Update instructions: Angular Update Guide Update command reference: Angular CLI ng update command reference Versioning, release, support, and deprecation practices: Angular versioning and releases Social MediaBlogX (formerly Twitter)BlueskyYouTube Discord GitHub Stack Overflow ",
    "id": "keeping-up-to-date-*-angular-5"
  },
  {
    "url": "https://angular.dev/update",
    "title": "Keeping up-to-date • Angular",
    "chunk": "Community Contribute Code of Conduct Report Issues Google's DevLibrary Angular Google Developer Experts ResourcesPress KitRoadmapLanguages简体中文版正體中文版日本語版한국어 Ελληνικά Super-powered by Google ©2010-2025. Code licensed under an MIT-style License . Documentation licensed under CC BY 4.0 .",
    "id": "keeping-up-to-date-*-angular-6"
  },
  {
    "url": "https://angular.dev/best-practices/security",
    "title": "Security • Angular",
    "chunk": "Best Practices Security This topic describes Angular's built-in protections against common web application vulnerabilities and attacks such as cross-site scripting attacks. It doesn't cover application-level security, such as authentication and authorization. For more information about the attacks and mitigations described below, see the Open Web Application Security Project (OWASP) Guide. Reporting vulnerabilities Angular is part of Google Open Source Software Vulnerability Reward Program. For ",
    "id": "security-*-angular-0"
  },
  {
    "url": "https://angular.dev/best-practices/security",
    "title": "Security • Angular",
    "chunk": "vulnerabilities in Angular, please submit your report at https://bughunters.google.com. For more information about how Google handles security issues, see Google's security philosophy. On this pagearrow_upward_alt Back to the top Best practices These are some best practices to ensure that your Angular application is secure. Keep current with the latest Angular library releases - The Angular libraries get regular updates, and these updates might fix security defects discovered in previous version",
    "id": "security-*-angular-1"
  },
  {
    "url": "https://angular.dev/best-practices/security",
    "title": "Security • Angular",
    "chunk": "s. Check the Angular change log for security-related updates. Don't alter your copy of Angular - Private, customized versions of Angular tend to fall behind the current version and might not include important security fixes and enhancements. Instead, share your Angular improvements with the community and make a pull request. Avoid Angular APIs marked in the documentation as \"Security Risk\" - For more information, see the Trusting safe values section of this page. Preventing cross-site scripting ",
    "id": "security-*-angular-2"
  },
  {
    "url": "https://angular.dev/best-practices/security",
    "title": "Security • Angular",
    "chunk": "(XSS) Cross-site scripting (XSS) enables attackers to inject malicious code into web pages. Such code can then, for example, steal user and login data, or perform actions that impersonate the user. This is one of the most common attacks on the web. To block XSS attacks, you must prevent malicious code from entering the Document Object Model (DOM). For example, if attackers can trick you into inserting a <script> tag in the DOM, they can run arbitrary code on your website. The attack isn't limite",
    "id": "security-*-angular-3"
  },
  {
    "url": "https://angular.dev/best-practices/security",
    "title": "Security • Angular",
    "chunk": "d to <script> tags —many elements and properties in the DOM allow code execution, for example, <img alt=\"\" onerror=\"...\"> and <a href=\"javascript:...\">. If attacker-controlled data enters the DOM, expect security vulnerabilities. Angular's cross-site scripting security model To systematically block XSS bugs, Angular treats all values as untrusted by default. When a value is inserted into the DOM from a template binding, or interpolation, Angular sanitizes and escapes untrusted values. If a value",
    "id": "security-*-angular-4"
  },
  {
    "url": "https://angular.dev/best-practices/security",
    "title": "Security • Angular",
    "chunk": " was already sanitized outside of Angular and is considered safe, communicate this to Angular by marking the value as trusted. Unlike values to be used for rendering, Angular templates are considered trusted by default, and should be treated as executable code. Never create templates by concatenating user input and template syntax. Doing this would enable attackers to inject arbitrary code into your application. To prevent these vulnerabilities, always use the default Ahead-Of-Time (AOT) templat",
    "id": "security-*-angular-5"
  },
  {
    "url": "https://angular.dev/best-practices/security",
    "title": "Security • Angular",
    "chunk": "e compiler in production deployments. An extra layer of protection can be provided through the use of Content security policy and Trusted Types. These web platform features operate at the DOM level which is the most effective place to prevent XSS issues. Here they can't be bypassed using other, lower-level APIs. For this reason, it is strongly encouraged to take advantage of these features. To do this, configure the content security policy for the application and enable trusted types enforcement",
    "id": "security-*-angular-6"
  },
  {
    "url": "https://angular.dev/best-practices/security",
    "title": "Security • Angular",
    "chunk": ". Sanitization and security contexts Sanitization is the inspection of an untrusted value, turning it into a value that's safe to insert into the DOM. In many cases, sanitization doesn't change a value at all. Sanitization depends on a context. For example, a value that's harmless in CSS is potentially dangerous in a URL. Angular defines the following security contexts: Security contexts Details HTML Used when interpreting a value as HTML, for example, when binding to innerHtml. Style Used when ",
    "id": "security-*-angular-7"
  },
  {
    "url": "https://angular.dev/best-practices/security",
    "title": "Security • Angular",
    "chunk": "binding CSS into the style property. URL Used for URL properties, such as <a href>. Resource URL A URL that is loaded and executed as code, for example, in <script src>. Angular sanitizes untrusted values for HTML and URLs. Sanitizing resource URLs isn't possible because they contain arbitrary code. In development mode, Angular prints a console warning when it has to change a value during sanitization. Sanitization example The following template binds the value of htmlSnippet. Once by interpolat",
    "id": "security-*-angular-8"
  },
  {
    "url": "https://angular.dev/best-practices/security",
    "title": "Security • Angular",
    "chunk": "ing it into an element's content, and once by binding it to the innerHTML property of an element: src/app/inner-html-binding.component.html <h3>Binding innerHTML</h3><p>Bound value:</p><p class=\"e2e-inner-html-interpolated\">{{ htmlSnippet }}</p><p>Result of binding to innerHTML:</p><p class=\"e2e-inner-html-bound\" [innerHTML]=\"htmlSnippet\"></p> Interpolated content is always escaped —the HTML isn't interpreted and the browser displays angle brackets in the element's text content. For the HTML to ",
    "id": "security-*-angular-9"
  },
  {
    "url": "https://angular.dev/best-practices/security",
    "title": "Security • Angular",
    "chunk": "be interpreted, bind it to an HTML property such as innerHTML. Be aware that binding a value that an attacker might control into innerHTML normally causes an XSS vulnerability. For example, one could run JavaScript in a following way: src/app/inner-html-binding.component.ts (class) import {Component} from '@angular/core';@Component({ selector: 'app-inner-html-binding', templateUrl: './inner-html-binding.component.html',})export class InnerHtmlBindingComponent { // For example, a user/attacker-co",
    "id": "security-*-angular-10"
  },
  {
    "url": "https://angular.dev/best-practices/security",
    "title": "Security • Angular",
    "chunk": "ntrolled value from a URL. htmlSnippet = 'Template <script>alert(\"0wned\")</script> <b>Syntax</b>';} Angular recognizes the value as unsafe and automatically sanitizes it, which removes the script element but keeps safe content such as the <b> element. Direct use of the DOM APIs and explicit sanitization calls Unless you enforce Trusted Types, the built-in browser DOM APIs don't automatically protect you from security vulnerabilities. For example, document, the node available through ElementRef, ",
    "id": "security-*-angular-11"
  },
  {
    "url": "https://angular.dev/best-practices/security",
    "title": "Security • Angular",
    "chunk": "and many third-party APIs contain unsafe methods. Likewise, if you interact with other libraries that manipulate the DOM, you likely won't have the same automatic sanitization as with Angular interpolations. Avoid directly interacting with the DOM and instead use Angular templates where possible. For cases where this is unavoidable, use the built-in Angular sanitization functions. Sanitize untrusted values with the DomSanitizer.sanitize method and the appropriate SecurityContext. That function a",
    "id": "security-*-angular-12"
  },
  {
    "url": "https://angular.dev/best-practices/security",
    "title": "Security • Angular",
    "chunk": "lso accepts values that were marked as trusted using the bypassSecurityTrust functions, and does not sanitize them, as described below. Trusting safe values Sometimes applications genuinely need to include executable code, display an <iframe> from some URL, or construct potentially dangerous URLs. To prevent automatic sanitization in these situations, tell Angular that you inspected a value, checked how it was created, and made sure it is secure. Do be careful. If you trust a value that might be",
    "id": "security-*-angular-13"
  },
  {
    "url": "https://angular.dev/best-practices/security",
    "title": "Security • Angular",
    "chunk": " malicious, you are introducing a security vulnerability into your application. If in doubt, find a professional security reviewer. To mark a value as trusted, inject DomSanitizer and call one of the following methods: bypassSecurityTrustHtml bypassSecurityTrustScript bypassSecurityTrustStyle bypassSecurityTrustUrl bypassSecurityTrustResourceUrl Remember, whether a value is safe depends on context, so choose the right context for your intended use of the value. Imagine that the following templat",
    "id": "security-*-angular-14"
  },
  {
    "url": "https://angular.dev/best-practices/security",
    "title": "Security • Angular",
    "chunk": "e needs to bind a URL to a javascript:alert(...) call: src/app/bypass-security.component.html (URL) <h3>Bypass Security Component</h3><h4>An untrusted URL:</h4><p><a class=\"e2e-dangerous-url\" [href]=\"dangerousUrl\">Click me</a></p><h4>A trusted URL:</h4><p><a class=\"e2e-trusted-url\" [href]=\"trustedUrl\">Click me</a></p><h4>Resource URL:</h4><p>Showing: {{ dangerousVideoUrl }}</p><p>Trusted:</p><iframe class=\"e2e-iframe-trusted-src\" width=\"640\" height=\"390\" [src]=\"videoUrl\" title=\"trusted video url",
    "id": "security-*-angular-15"
  },
  {
    "url": "https://angular.dev/best-practices/security",
    "title": "Security • Angular",
    "chunk": "\"></iframe><p>Untrusted:</p><iframe class=\"e2e-iframe-untrusted-src\" width=\"640\" height=\"390\" [src]=\"dangerousVideoUrl\" title=\"unTrusted video url\"></iframe> Normally, Angular automatically sanitizes the URL, disables the dangerous code, and in development mode, logs this action to the console. To prevent this, mark the URL value as a trusted URL using the bypassSecurityTrustUrl call: src/app/bypass-security.component.ts (trust-url) import {Component, inject} from '@angular/core';import {DomSani",
    "id": "security-*-angular-16"
  },
  {
    "url": "https://angular.dev/best-practices/security",
    "title": "Security • Angular",
    "chunk": "tizer, SafeResourceUrl, SafeUrl} from '@angular/platform-browser';@Component({ selector: 'app-bypass-security', templateUrl: './bypass-security.component.html',})export class BypassSecurityComponent { dangerousUrl: string; trustedUrl: SafeUrl; dangerousVideoUrl!: string; videoUrl!: SafeResourceUrl; private sanitizer = inject(DomSanitizer); constructor() { // javascript: URLs are dangerous if attacker controlled. // Angular sanitizes them in data binding, but you can // explicitly tell Angular to",
    "id": "security-*-angular-17"
  },
  {
    "url": "https://angular.dev/best-practices/security",
    "title": "Security • Angular",
    "chunk": " trust this value: this.dangerousUrl = 'javascript:alert(\"Hi there\")'; this.trustedUrl = this.sanitizer.bypassSecurityTrustUrl(this.dangerousUrl); this.updateVideoUrl('PUBnlbjZFAI'); } updateVideoUrl(id: string) { // Appending an ID to a YouTube URL is safe. // Always make sure to construct SafeValue objects as // close as possible to the input data so // that it's easier to check if the value is safe. this.dangerousVideoUrl = 'https://www.youtube.com/embed/' + id; this.videoUrl = this.sanitizer",
    "id": "security-*-angular-18"
  },
  {
    "url": "https://angular.dev/best-practices/security",
    "title": "Security • Angular",
    "chunk": ".bypassSecurityTrustResourceUrl(this.dangerousVideoUrl); }} If you need to convert user input into a trusted value, use a component method. The following template lets users enter a YouTube video ID and load the corresponding video in an <iframe>. The <iframe src> attribute is a resource URL security context, because an untrusted source can, for example, smuggle in file downloads that unsuspecting users could run. To prevent this, call a method on the component to construct a trusted video URL, ",
    "id": "security-*-angular-19"
  },
  {
    "url": "https://angular.dev/best-practices/security",
    "title": "Security • Angular",
    "chunk": "which causes Angular to let binding into <iframe src>: src/app/bypass-security.component.html (iframe) <h3>Bypass Security Component</h3><h4>An untrusted URL:</h4><p><a class=\"e2e-dangerous-url\" [href]=\"dangerousUrl\">Click me</a></p><h4>A trusted URL:</h4><p><a class=\"e2e-trusted-url\" [href]=\"trustedUrl\">Click me</a></p><h4>Resource URL:</h4><p>Showing: {{ dangerousVideoUrl }}</p><p>Trusted:</p><iframe class=\"e2e-iframe-trusted-src\" width=\"640\" height=\"390\" [src]=\"videoUrl\" title=\"trusted video ",
    "id": "security-*-angular-20"
  },
  {
    "url": "https://angular.dev/best-practices/security",
    "title": "Security • Angular",
    "chunk": "url\"></iframe><p>Untrusted:</p><iframe class=\"e2e-iframe-untrusted-src\" width=\"640\" height=\"390\" [src]=\"dangerousVideoUrl\" title=\"unTrusted video url\"></iframe> src/app/bypass-security.component.ts (trust-video-url) import {Component, inject} from '@angular/core';import {DomSanitizer, SafeResourceUrl, SafeUrl} from '@angular/platform-browser';@Component({ selector: 'app-bypass-security', templateUrl: './bypass-security.component.html',})export class BypassSecurityComponent { dangerousUrl: string",
    "id": "security-*-angular-21"
  },
  {
    "url": "https://angular.dev/best-practices/security",
    "title": "Security • Angular",
    "chunk": "; trustedUrl: SafeUrl; dangerousVideoUrl!: string; videoUrl!: SafeResourceUrl; private sanitizer = inject(DomSanitizer); constructor() { // javascript: URLs are dangerous if attacker controlled. // Angular sanitizes them in data binding, but you can // explicitly tell Angular to trust this value: this.dangerousUrl = 'javascript:alert(\"Hi there\")'; this.trustedUrl = this.sanitizer.bypassSecurityTrustUrl(this.dangerousUrl); this.updateVideoUrl('PUBnlbjZFAI'); } updateVideoUrl(id: string) { // Appe",
    "id": "security-*-angular-22"
  },
  {
    "url": "https://angular.dev/best-practices/security",
    "title": "Security • Angular",
    "chunk": "nding an ID to a YouTube URL is safe. // Always make sure to construct SafeValue objects as // close as possible to the input data so // that it's easier to check if the value is safe. this.dangerousVideoUrl = 'https://www.youtube.com/embed/' + id; this.videoUrl = this.sanitizer.bypassSecurityTrustResourceUrl(this.dangerousVideoUrl); }} Content security policy Content Security Policy (CSP) is a defense-in-depth technique to prevent XSS. To enable CSP, configure your web server to return an appro",
    "id": "security-*-angular-23"
  },
  {
    "url": "https://angular.dev/best-practices/security",
    "title": "Security • Angular",
    "chunk": "priate Content-Security-Policy HTTP header. Read more about content security policy at the Web Fundamentals guide on the Google Developers website. The minimal policy required for a brand-new Angular application is: default-src 'self'; style-src 'self' 'nonce-randomNonceGoesHere'; script-src 'self' 'nonce-randomNonceGoesHere'; When serving your Angular application, the server should include a randomly-generated nonce in the HTTP header for each request. You must provide this nonce to Angular so ",
    "id": "security-*-angular-24"
  },
  {
    "url": "https://angular.dev/best-practices/security",
    "title": "Security • Angular",
    "chunk": "that the framework can render <style> elements. You can set the nonce for Angular in one of two ways: Set the ngCspNonce attribute on the root application element as <app ngCspNonce=\"randomNonceGoesHere\"></app>. Use this approach if you have access to server-side templating that can add the nonce both to the header and the index.html when constructing the response. Provide the nonce using the CSP_NONCE injection token. Use this approach if you have access to the nonce at runtime and you want to ",
    "id": "security-*-angular-25"
  },
  {
    "url": "https://angular.dev/best-practices/security",
    "title": "Security • Angular",
    "chunk": "be able to cache the index.html. import {bootstrapApplication, CSP_NONCE} from '@angular/core';import {AppComponent} from './app/app.component';bootstrapApplication(AppComponent, { providers: [{ provide: CSP_NONCE, useValue: globalThis.myRandomNonceValue }]}); Unique nonces Always ensure that the nonces you provide are unique per request and that they are not predictable or guessable. If an attacker can predict future nonces, they can circumvent the protections offered by CSP. If you cannot gene",
    "id": "security-*-angular-26"
  },
  {
    "url": "https://angular.dev/best-practices/security",
    "title": "Security • Angular",
    "chunk": "rate nonces in your project, you can allow inline styles by adding 'unsafe-inline' to the style-src section of the CSP header. Sections Details default-src 'self'; Allows the page to load all its required resources from the same origin. style-src 'self' 'nonce-randomNonceGoesHere'; Allows the page to load global styles from the same origin ('self') and styles inserted by Angular with the nonce-randomNonceGoesHere. script-src 'self' 'nonce-randomNonceGoesHere'; Allows the page to load JavaScript ",
    "id": "security-*-angular-27"
  },
  {
    "url": "https://angular.dev/best-practices/security",
    "title": "Security • Angular",
    "chunk": "from the same origin ('self') and scripts inserted by the Angular CLI with the nonce-randomNonceGoesHere. This is only required if you're using critical CSS inlining. Angular itself requires only these settings to function correctly. As your project grows, you may need to expand your CSP settings to accommodate extra features specific to your application. Enforcing Trusted Types It is recommended that you use Trusted Types as a way to help secure your applications from cross-site scripting attac",
    "id": "security-*-angular-28"
  },
  {
    "url": "https://angular.dev/best-practices/security",
    "title": "Security • Angular",
    "chunk": "ks. Trusted Types is a web platform feature that can help you prevent cross-site scripting attacks by enforcing safer coding practices. Trusted Types can also help simplify the auditing of application code. Trusted types Trusted Types might not yet be available in all browsers your application targets. In the case your Trusted-Types-enabled application runs in a browser that doesn't support Trusted Types, the features of the application are preserved. Your application is guarded against XSS by w",
    "id": "security-*-angular-29"
  },
  {
    "url": "https://angular.dev/best-practices/security",
    "title": "Security • Angular",
    "chunk": "ay of Angular's DomSanitizer. See caniuse.com/trusted-types for the current browser support. To enforce Trusted Types for your application, you must configure your application's web server to emit HTTP headers with one of the following Angular policies: Policies Detail angular This policy is used in security-reviewed code that is internal to Angular, and is required for Angular to function when Trusted Types are enforced. Any inline template values or content sanitized by Angular is treated as s",
    "id": "security-*-angular-30"
  },
  {
    "url": "https://angular.dev/best-practices/security",
    "title": "Security • Angular",
    "chunk": "afe by this policy. angular#bundler This policy is used by the Angular CLI bundler when creating lazy chunk files. angular#unsafe-bypass This policy is used for applications that use any of the methods in Angular's DomSanitizer that bypass security, such as bypassSecurityTrustHtml. Any application that uses these methods must enable this policy. angular#unsafe-jit This policy is used by the Just-In-Time (JIT) compiler. You must enable this policy if your application interacts directly with the J",
    "id": "security-*-angular-31"
  },
  {
    "url": "https://angular.dev/best-practices/security",
    "title": "Security • Angular",
    "chunk": "IT compiler or is running in JIT mode using the platform browser dynamic. angular#unsafe-upgrade This policy is used by the @angular/upgrade package. You must enable this policy if your application is an AngularJS hybrid. You should configure the HTTP headers for Trusted Types in the following locations: Production serving infrastructure Angular CLI (ng serve), using the headers property in the angular.json file, for local development and end-to-end testing Karma (ng test), using the customHeade",
    "id": "security-*-angular-32"
  },
  {
    "url": "https://angular.dev/best-practices/security",
    "title": "Security • Angular",
    "chunk": "rs property in the karma.config.js file, for unit testing The following is an example of a header specifically configured for Trusted Types and Angular: Content-Security-Policy: trusted-types angular; require-trusted-types-for 'script'; An example of a header specifically configured for Trusted Types and Angular applications that use any of Angular's methods in DomSanitizer that bypasses security: Content-Security-Policy: trusted-types angular angular#unsafe-bypass; require-trusted-types-for 'sc",
    "id": "security-*-angular-33"
  },
  {
    "url": "https://angular.dev/best-practices/security",
    "title": "Security • Angular",
    "chunk": "ript'; The following is an example of a header specifically configured for Trusted Types and Angular applications using JIT: Content-Security-Policy: trusted-types angular angular#unsafe-jit; require-trusted-types-for 'script'; The following is an example of a header specifically configured for Trusted Types and Angular applications that use lazy loading of modules: Content-Security-Policy: trusted-types angular angular#bundler; require-trusted-types-for 'script'; Community contributions To lear",
    "id": "security-*-angular-34"
  },
  {
    "url": "https://angular.dev/best-practices/security",
    "title": "Security • Angular",
    "chunk": "n more about troubleshooting Trusted Type configurations, the following resource might be helpful: Prevent DOM-based cross-site scripting vulnerabilities with Trusted Types Use the AOT template compiler The AOT template compiler prevents a whole class of vulnerabilities called template injection, and greatly improves application performance. The AOT template compiler is the default compiler used by Angular CLI applications, and you should use it in all production deployments. An alternative to t",
    "id": "security-*-angular-35"
  },
  {
    "url": "https://angular.dev/best-practices/security",
    "title": "Security • Angular",
    "chunk": "he AOT compiler is the JIT compiler which compiles templates to executable template code within the browser at runtime. Angular trusts template code, so dynamically generating templates and compiling them, in particular templates containing user data, circumvents Angular's built-in protections. This is a security anti-pattern. For information about dynamically constructing forms in a safe way, see the Dynamic Forms guide. Server-side XSS protection HTML constructed on the server is vulnerable to",
    "id": "security-*-angular-36"
  },
  {
    "url": "https://angular.dev/best-practices/security",
    "title": "Security • Angular",
    "chunk": " injection attacks. Injecting template code into an Angular application is the same as injecting executable code into the application: It gives the attacker full control over the application. To prevent this, use a templating language that automatically escapes values to prevent XSS vulnerabilities on the server. Don't create Angular templates on the server side using a templating language. This carries a high risk of introducing template-injection vulnerabilities. HTTP-level vulnerabilities Ang",
    "id": "security-*-angular-37"
  },
  {
    "url": "https://angular.dev/best-practices/security",
    "title": "Security • Angular",
    "chunk": "ular has built-in support to help prevent two common HTTP vulnerabilities, cross-site request forgery (CSRF or XSRF) and cross-site script inclusion (XSSI). Both of these must be mitigated primarily on the server side, but Angular provides helpers to make integration on the client side easier. Cross-site request forgery In a cross-site request forgery (CSRF or XSRF), an attacker tricks the user into visiting a different web page (such as evil.com) with malignant code. This web page secretly send",
    "id": "security-*-angular-38"
  },
  {
    "url": "https://angular.dev/best-practices/security",
    "title": "Security • Angular",
    "chunk": "s a malicious request to the application's web server (such as example-bank.com). Assume the user is logged into the application at example-bank.com. The user opens an email and clicks a link to evil.com, which opens in a new tab. The evil.com page immediately sends a malicious request to example-bank.com. Perhaps it's a request to transfer money from the user's account to the attacker's account. The browser automatically sends the example-bank.com cookies, including the authentication cookie, w",
    "id": "security-*-angular-39"
  },
  {
    "url": "https://angular.dev/best-practices/security",
    "title": "Security • Angular",
    "chunk": "ith this request. If the example-bank.com server lacks XSRF protection, it can't tell the difference between a legitimate request from the application and the forged request from evil.com. To prevent this, the application must ensure that a user request originates from the real application, not from a different site. The server and client must cooperate to thwart this attack. In a common anti-XSRF technique, the application server sends a randomly created authentication token in a cookie. The cl",
    "id": "security-*-angular-40"
  },
  {
    "url": "https://angular.dev/best-practices/security",
    "title": "Security • Angular",
    "chunk": "ient code reads the cookie and adds a custom request header with the token in all following requests. The server compares the received cookie value to the request header value and rejects the request if the values are missing or don't match. This technique is effective because all browsers implement the same origin policy. Only code from the website on which cookies are set can read the cookies from that site and set custom headers on requests to that site. That means only your application can r",
    "id": "security-*-angular-41"
  },
  {
    "url": "https://angular.dev/best-practices/security",
    "title": "Security • Angular",
    "chunk": "ead this cookie token and set the custom header. The malicious code on evil.com can't. HttpClient XSRF/CSRF security HttpClient supports a common mechanism used to prevent XSRF attacks. When performing HTTP requests, an interceptor reads a token from a cookie, by default XSRF-TOKEN, and sets it as an HTTP header, X-XSRF-TOKEN. Because only code that runs on your domain could read the cookie, the backend can be certain that the HTTP request came from your client application and not an attacker. B",
    "id": "security-*-angular-42"
  },
  {
    "url": "https://angular.dev/best-practices/security",
    "title": "Security • Angular",
    "chunk": "y default, an interceptor sends this header on all mutating requests (such as POST) to relative URLs, but not on GET/HEAD requests or on requests with an absolute URL. Why not protect GET requests? CSRF protection is only needed for requests that can change state on the backend. By their nature, CSRF attacks cross domain boundaries, and the web's same-origin policy will prevent an attacking page from retrieving the results of authenticated GET requests. To take advantage of this, your server nee",
    "id": "security-*-angular-43"
  },
  {
    "url": "https://angular.dev/best-practices/security",
    "title": "Security • Angular",
    "chunk": "ds to set a token in a JavaScript readable session cookie called XSRF-TOKEN on either the page load or the first GET request. On subsequent requests the server can verify that the cookie matches the X-XSRF-TOKEN HTTP header, and therefore be sure that only code running on your domain could have sent the request. The token must be unique for each user and must be verifiable by the server; this prevents the client from making up its own tokens. Set the token to a digest of your site's authenticati",
    "id": "security-*-angular-44"
  },
  {
    "url": "https://angular.dev/best-practices/security",
    "title": "Security • Angular",
    "chunk": "on cookie with a salt for added security. To prevent collisions in environments where multiple Angular apps share the same domain or subdomain, give each application a unique cookie name. HttpClient supports only the client half of the XSRF protection scheme Your backend service must be configured to set the cookie for your page, and to verify that the header is present on all eligible requests. Failing to do so renders Angular's default protection ineffective. Configure custom cookie/header nam",
    "id": "security-*-angular-45"
  },
  {
    "url": "https://angular.dev/best-practices/security",
    "title": "Security • Angular",
    "chunk": "es If your backend service uses different names for the XSRF token cookie or header, use withXsrfConfiguration to override the defaults. Add it to the provideHttpClient call as follows: export const appConfig: ApplicationConfig = { providers: [ provideHttpClient( withXsrfConfiguration({ cookieName: 'CUSTOM_XSRF_TOKEN', headerName: 'X-Custom-Xsrf-Header', }), ), ]}; Disabling XSRF protection If the built-in XSRF protection mechanism doesn't work for your application, you can disable it using the ",
    "id": "security-*-angular-46"
  },
  {
    "url": "https://angular.dev/best-practices/security",
    "title": "Security • Angular",
    "chunk": "withNoXsrfProtection feature: export const appConfig: ApplicationConfig = { providers: [ provideHttpClient( withNoXsrfProtection(), ), ]}; For information about CSRF at the Open Web Application Security Project (OWASP), see Cross-Site Request Forgery (CSRF) and Cross-Site Request Forgery (CSRF) Prevention Cheat Sheet. The Stanford University paper Robust Defenses for Cross-Site Request Forgery is a rich source of detail. See also Dave Smith's talk on XSRF at AngularConnect 2016. Cross-site scrip",
    "id": "security-*-angular-47"
  },
  {
    "url": "https://angular.dev/best-practices/security",
    "title": "Security • Angular",
    "chunk": "t inclusion (XSSI) Cross-site script inclusion, also known as JSON vulnerability, can allow an attacker's website to read data from a JSON API. The attack works on older browsers by overriding built-in JavaScript object constructors, and then including an API URL using a <script> tag. This attack is only successful if the returned JSON is executable as JavaScript. Servers can prevent an attack by prefixing all JSON responses to make them non-executable, by convention, using the well-known string",
    "id": "security-*-angular-48"
  },
  {
    "url": "https://angular.dev/best-practices/security",
    "title": "Security • Angular",
    "chunk": " \")]}',\\n\". Angular's HttpClient library recognizes this convention and automatically strips the string \")]}',\\n\" from all responses before further parsing. For more information, see the XSSI section of this Google web security blog post. Auditing Angular applications Angular applications must follow the same security principles as regular web applications, and must be audited as such. Angular-specific APIs that should be audited in a security review, such as the bypassSecurityTrust methods, are",
    "id": "security-*-angular-49"
  },
  {
    "url": "https://angular.dev/best-practices/security",
    "title": "Security • Angular",
    "chunk": " marked in the documentation as security sensitive. Social MediaBlogX (formerly Twitter)BlueskyYouTube Discord GitHub Stack Overflow Community Contribute Code of Conduct Report Issues Google's DevLibrary Angular Google Developer Experts ResourcesPress KitRoadmapLanguages简体中文版正體中文版日本語版한국어 Ελληνικά Super-powered by Google ©2010-2025. Code licensed under an MIT-style License . Documentation licensed under CC BY 4.0 .",
    "id": "security-*-angular-50"
  },
  {
    "url": "https://angular.dev/guide/i18n",
    "title": "Internationalization • Overview • Angular",
    "chunk": "In-depth GuidesInternationalization Angular Internationalization Internationalization, sometimes referenced as i18n, is the process of designing and preparing your project for use in different locales around the world. Localization is the process of building versions of your project for different locales. The localization process includes the following actions. Extract text for translation into different languages Format data for a specific locale A locale identifies a region in which people spe",
    "id": "internationalization-*-overview-*-angular-0"
  },
  {
    "url": "https://angular.dev/guide/i18n",
    "title": "Internationalization • Overview • Angular",
    "chunk": "ak a particular language or language variant. Possible regions include countries and geographical regions. A locale determines the formatting and parsing of the following details. Measurement units including date and time, numbers, and currencies Translated names including time zones, languages, and countries For a quick introduction to localization and internationalization watch this video: On this pagearrow_upward_alt Back to the top Learn about Angular internationalization Add the localize pa",
    "id": "internationalization-*-overview-*-angular-1"
  },
  {
    "url": "https://angular.dev/guide/i18n",
    "title": "Internationalization • Overview • Angular",
    "chunk": "ckage Learn how to add the Angular Localize package to your project Learn more Refer to locales by ID Learn how to identify and specify a locale identifier for your project Learn more Format data based on locale Learn how to implement localized data pipes and override the locale for your project Learn more Prepare component for translation Learn how to specify source text for translation Learn more Work with translation files Learn how to review and process translation text Learn more Merge tran",
    "id": "internationalization-*-overview-*-angular-2"
  },
  {
    "url": "https://angular.dev/guide/i18n",
    "title": "Internationalization • Overview • Angular",
    "chunk": "slations into the application Learn how to merge translations and build your translated application Learn more Deploy multiple locales Learn how to deploy multiple locales for your application Learn more Import global variants of the locale data Learn how to import locale data for language variants Learn more Manage marked text with custom IDs Learn how to implement custom IDs to help you manage your marked text Learn more Internationalization example Review an example of Angular internationaliz",
    "id": "internationalization-*-overview-*-angular-3"
  },
  {
    "url": "https://angular.dev/guide/i18n",
    "title": "Internationalization • Overview • Angular",
    "chunk": "ation. Learn more Social MediaBlogX (formerly Twitter)BlueskyYouTube Discord GitHub Stack Overflow Community Contribute Code of Conduct Report Issues Google's DevLibrary Angular Google Developer Experts ResourcesPress KitRoadmapLanguages简体中文版正體中文版日本語版한국어 Ελληνικά Super-powered by Google ©2010-2025. Code licensed under an MIT-style License . Documentation licensed under CC BY 4.0 .",
    "id": "internationalization-*-overview-*-angular-4"
  }
]
